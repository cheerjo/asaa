/**
 * @fileoverview
 * eXria
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */

/**
 * eXria package
 */
eXria = {};

/**
 * @fileoverview
 * eXria.lang package
 */

/**
 * eXria.lang package
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */
eXria.lang = {};

/**
 * @fileoverview
 * 현재 사용자의 Browser를 구분하는 클래스
 * @license YAHOO UI 2.4.1 (BSD)
 */

/**
 * 현재 사용자의 Browser를 구분하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 */
eXria.lang.Browser = function(poPage) {
  /**
   * 현재 Browser에 포함된 Page Obejct
   */
  this.page = poPage;
  /**
   * 사용자 Browser가 IE일 경우 IE 버전 정보를 저장.
   * @type Number
   */
  this.ie = 0;
  /**
   * 사용자 Browser가 Opera일 경우 Opera 버전 정보를 저장.
   * @type Number
   */
  this.opera = 0;
  /**
   * 사용자 Browser가 FirFox일 경우 FireFox 버전 정보를 저장.
   * @type Number
   */
  this.gecko = 0;
  /**
   * 사용자 Browser가 Safari일 경우 Safari 버전 정보를 저장.
   * @type Number
   */
  this.webkit = 0;
  /**
   * 사용자 Browser가 chrome 경우 chrome 버전 정보를 저장.
   * @type Number
   */
  this.chrome = 0;
  /**
   * 사용자 Browser가 Mobile Browser일 경우 Mobile Browser 버전 정보를 저장.
   * @type Number
   */
  this.mobile = null;
  /**
   * @private
   */
  var vsAgent = this.page.window.navigator.userAgent;
  /**
   * @private
   */
  var voInfo = null;

  // chrome
  voInfo = vsAgent.match(/Chrome\/([^\s]*)/);
  if (voInfo && voInfo [1]) {
    this.chrome = voInfo [1];
  }

  if (! this.chrome) { // not chrome
    // Modern KHTML browsers should qualify as Safari X-Grade
    if ((/KHTML/).test(vsAgent)) {
      this.webkit = 1;
    }

    // Modern WebKit browsers are at least X-Grade
    voInfo = vsAgent.match(/AppleWebKit\/([^\s]*)/);
    if (voInfo && voInfo [1]) {
      this.webkit = parseFloat(voInfo [1]);

      // Mobile browser check
      if (/ Mobile\//.test(vsAgent)) {
        this.mobile = "Apple"; // iPhone or iPod Touch
      } else {
        voInfo = vsAgent.match(/NokiaN[^\/]*/);
        if (voInfo) {
          this.mobile = voInfo [0]; // Nokia N-series, ex: NokiaN95
        }
      }
    }

    if (! this.webkit) {// not webkit
      // @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
      voInfo = vsAgent.match(/Opera[\s\/]([^\s]*)/);
      if (voInfo && voInfo [1]) {
        this.opera = parseFloat(voInfo [1]);
        voInfo = vsAgent.match(/Opera Mini[^;]*/);
        if (voInfo) {
          this.mobile = voInfo [0]; // ex: Opera Mini/2.0.4509/1316
        }
      } else {
        // not opera or webkit
        voInfo = vsAgent.match(/MSIE\s([^;]*)/);
        if (voInfo && voInfo [1]) {
          this.ie = parseFloat(voInfo [1]);
        } else {
          // not opera, webkit, or ie
          voInfo = vsAgent.match(/Gecko([^\s]*)/);
          if (voInfo) {
            this.gecko = 1; // Gecko detected, look for revision
            voInfo = vsAgent.match(/rv:([^\s\)]*)/);
            if (voInfo && voInfo [1]) {
              this.gecko = parseFloat(voInfo [1]);
            }
          }
        }
      }
    }
  }

};
/**
 * @fileoverview
 * StringBuilder
 * 문자열 편집을 용이하게 하기 위한 클래스
 */

/**
 * StringBuilder
 * 문자열 편집을 용이하게 하기 위한 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.lang.StringBuilder = function() {

  /**
   * 스트링 버퍼 역할의 멤버 변수
   */
  this.buffer = "";

  /**
   * isEmpty();
   */
  this.isEmpty = function() { return (this.buffer == ""); };

  /**
   * clear
   */
  this.clear = function() {
    this.buffer = "";
    return this;
  };

  /**
   * 문자열 버퍼에 문자열을 추가하는 메소드.
   * 파라미터로 주어진 모든 객체의 문자열 표현
   * 값을 문자열 버퍼에 추가한다.
   * @param {String} poValue 문자열 표현 값으로 문자열 버퍼에 추가될 오브젝트
   * @return 클래스 오브젝트 접근자
   */
  this.append = function(poValue) {
      this.buffer += eXria.util.StringUtil.fixNull(poValue);
      return this;
  };

  /**
   * append()메소드와 기능이 유사하며 append()와는 달리 추가되는 문자열에
   * 줄바꿈 문자가 덧붙여진다.
   * @param {String} poValue 문자열 표현 값으로 뒤에 줄바꿈 문자가 덧붙여져 문자열 버퍼에 추가될 오브젝트
   * @return 클래스 오브젝트 접근자
   */
  this.appendln = function(poValue) {
      return voBuilder.append(poValue).append("\n");
  };

  /**
   * append()메소드와 기능이 유사하며 append()와는 달리 추가되는 문자열에
   * 줄바꿈 문자가 덧붙여진다.
   * @param {String} poValue 문자열 표현 값으로 뒤에 줄바꿈 문자가 덧붙여져 문자열 버퍼에 추가될 오브젝트
   * @return 클래스 오브젝트 접근자
   */
  this.indexOf = function(psValue) {
      return this.buffer.indexOf(psValue);
  };

  /**
   * append()메소드와 기능이 유사하며 append()와는 달리 추가되는 문자열에
   * 줄바꿈 문자가 덧붙여진다.
   * @param {String} poValue 문자열 표현 값으로 뒤에 줄바꿈 문자가 덧붙여져 문자열 버퍼에 추가될 오브젝트
   * @return 클래스 오브젝트 접근자
   */
  this.lastIndexOf = function(psValue) {
      return this.buffer.lastIndexOf(psValue);
  };

  /**
   * toString();
   */
  this.toString = function() { return this.buffer; };

};

/**
 * @fileoverview
 * eXria.util
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */

/**
 * eXria.util
 */
eXria.util = {}; 
/**
 * @fileoverview
 * BooleanUtil
 */
 
/**
 * BooleanUtil
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.util.BooleanUtil = {

  /**
   * fix</br>
   * default : null, undefined, NaN -> false</br>
   * boolean, Boolean -> boolean</br>
   * null, undefined, NaN -> default</br>
   * Math.NEGATIVE_INFINITY -> false</br>
   * Math.POSITIVE_INFINITY -> true</br>
   * string, String -> equals true ?</br>
   * number, Number -> > 0 ?</br>
   * @return 변경된 Boolean 데이터
   * @type Boolean
   */
  fix : function(puValue, pbDefault) {
    var vbDefault = pbDefault || false;

    // boolean, Boolean
    var vsType = typeof(puValue);
    if (vsType == "boolean" || (vsType == "Object" && puValue instanceof Boolean)) {
      return puValue == true;

    // null, undefined, NaN
    } else if (puValue == null || puValue == undefined || puValue == NaN) {
      return vbDefault;

    // NEGATIVE_INFINITY
    } else if (puValue == Math.NEGATIVE_INFINITY) {
      return false;

    // POSITIVE_INFINITY
    } else if (puValue == Math.POSITIVE_INFINITY) {
      return true;
    }

    // string, String
    var vsValue = new String(puValue);
    if (eXria.util.StringUtil.equals(vsValue, "true")) {
      return true;

    // number, Number
    } else if (new Number(vsValue) > 0) {
      return true;
    } 

    return vbDefault;
  },

  /**
   * 파라미터로 넘어온 2개의 데이터가 같은 데이터인지 비교한다.
   * @return 같다면 true, 틀리다면 false
   * @type Boolean
   */
  equals : function(puValue1, puValue2) {
    return this.fix(puValue1, false) == this.fix(puValue2, false);
  }

};

/**
 * @fileoverview
 * DomUtil
 */

/**
 * DomUtil
 * 
 * @version 1.0
 * @constructor
 */
eXria.util.DomUtil = {
  /**
   * 파라미터로 넘어온 XMLNode를 기존의 Dom에 추가
   * @param {XMLNode} poDom 넘어온 XMLNode를 추가할 Dom
   * @param {XMLNode} poXML 기존의 Dom에 추가시킬 XMLNode
   * @param {Boolean} pbMode 넘어온 XMLNode를 기존의 Dom에 추가시 false,</br>기존의 Dom을 초기화 후 추가시 true.
   * @return void
   * @type void
   */
  load : function(poDom, poXML, pbMode) {
    var voOriNode = new eXria.data.xhtml.CollectionNode(poDom);

    if (pbMode) { //replace 
      voOriNode.clear();
    }

    //    var voNodes = poXML.childNodes;
    // var vnLength = voNodes.length;
    var voNodes = poXML.getChildNodes();
    var vnLength = voNodes.getLength();

    for ( var i = 0; i < vnLength; i++) {
      voOriNode.add(voNodes.item(i).cloneNode(true));
    }
  },

  /**
   * 넘겨 받은 parentNode에 append 될 Node를 생성 후 추가(IE8과 관련하여 Document가 틀린 Node가 붙지 않는 문제)
   * @param {XMLNode} poParentNode 넘어온 node를 추가할 Node
   * @param {XMLNode} poAppendNode 추가 될 Node
   * @return void
   * @type void
   * @private
   */
  appendNodeElement : function(poParentNode, poAppendNode, poDocument) {
    var voWhiteSpace = /\S/;
    var voNode = null;
    var voCreateNode = null;

    if (poAppendNode.nodeType == 1) {
      var voFirstChild = poAppendNode.firstChild;

      if (voFirstChild == null) {
        voCreateNode = poDocument.createNode(poAppendNode.nodeName);
        poParentNode.appendChild(voCreateNode);
      } else {
        if (!voWhiteSpace.test(voFirstChild.nodeValue)) {
          voFirstChild = voFirstChild.nextSibling;
        }

        if (voFirstChild.nodeType == 1) {
          voCreateNode = poDocument.createNode(poAppendNode.nodeName);
          poParentNode.appendChild(voCreateNode);
          poParentNode = voCreateNode;
        }
      }
    }

    var voChilds = poAppendNode.childNodes;
    var vnChildLen = voChilds.length;

    if (vnChildLen == 0)
      return null;

    for ( var i = 0; i < vnChildLen; i++) {
      if (!voWhiteSpace.test(voChilds[i].nodeValue))
        continue;

      if (!voChilds[i].firstChild) {
        voCreateNode = poDocument.createNode(voChilds[i].nodeName);

        poParentNode.appendChild(voCreateNode);
      } else if (voChilds[i].firstChild.nodeType == 3
          || voChilds[i].firstChild.nodeType == 4) {
        voCreateNode = poDocument.createNode(voChilds[i].nodeName);

        var voValue = voCreateNode.firstChild;
        if (voValue != null) {
          voValue.nodeValue = voChilds[i].firstChild.nodeValue;
        } else {
          voCreateNode.appendChild(voCreateNode.ownerDocument
              .createTextNode(voChilds[i].firstChild.nodeValue));
        }
        poParentNode.appendChild(voCreateNode);
      } else {
        if (voChilds[i].nodeType == 1) {
          if (voChilds[i].firstChild.nodeType == 1) {
            eXria.util.DomUtil.appendNodeElement(poParentNode, voChilds[i],
                poDocument);
          }
        }
      }
    }
  }
};
/**
 * @fileoverview
 * RequestUtil
 */
 
/**
 * RequestUtil
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.util.RequestUtil = {
    APP_NAME_MSIE : "MSIE",
    APP_NAME_FIREFOX : "Firefox",
    APP_NAME_SAFARI : "Safari",
    APP_NAME_OPERA : "Opera",
    vaToResponse : null,

    /**
     *
     * @param {Object} object
     */
    forInView : function( object, poPage ) {
		var voDocument = poPage.window.document;
        var viewData = "";
        var i = 0;
        for( num in object ) {
            viewData += i+" # ["+num + " : \n" + object[num] + "\n]\n<br>";
            i++;
        }
        voDocument.write(viewData);
    },
    forInViews : function( object ) {
        var viewData = "";
        var i = 0;
        for( num in object ) {
            viewData += i+" # ["+num + " : \n" + object[num] + "\n]\n";
            i++;
        }
        alert( viewData );
    },
    httpMessage : function( data ) {
        switch( eXria.lang.Browser.name ) {
            case eXria.util.RequestUtil.APP_NAME_MSIE :
                alert( data.xml );
                break;
            case eXria.util.RequestUtil.APP_NAME_FIREFOX :
                alert( data.documentElement.textContent );
                break;
            case eXria.util.RequestUtil.APP_NAME_SAFARI :
                break;
        }
    },
    /**
     * DOM 객체를 QueryString으로 변환
     * @param {Object} poDOM
     * @param {Object} psXPath
     */
    toResponse : function( poDOM, psXPath ) {
        var voToResponse = "";
        eXria.util.RequestUtil.vaToResponse = new Array();
        try {
            eXria.util.RequestUtil.doRecursive( poDOM.selectNodes(psXPath), "" );
            var vSeparator = "";
            for( var i=0; i < eXria.util.RequestUtil.vaToResponse.length; i++ ) {
                var voQueryString = eXria.util.RequestUtil.vaToResponse[i]+"";
                if( voQueryString != "undefined" ) {
                    voToResponse += vSeparator+voQueryString;
                }
                vSeparator = "&";
            }
        } catch( e ) {
            throw new Error( "eXria.data.Instance#toResponse \n[ERROR : " + e.message + "]");
        }
        return voToResponse;
    },
    /**
     *
     * @param {Object} poDOM
     * @param {Object} pResponse
     */
    doRecursive : function( poDOM, pResponse ) {
        try {
            for( var i=0; i<poDOM.length; i++ ) {
                var voItem = poDOM.item(i);
                var voNodeList = voItem.childNodes;
                switch( voItem.nodeType ) {
                    case eXria.data.transform.dom.Node.NODE_ELEMENT :
                        if( voItem.tagName != "undefined"
                                && voItem.text != ""
                                && voNodeList.item(0).lastChild == null) {
                            var voQueryString = voItem.tagName +"="+ voItem.text;
                            eXria.util.RequestUtil.vaToResponse[eXria.util.RequestUtil.vaToResponse.length+1] = voQueryString;
                        }
                        break;
                    default :
                        break;
                }
                if( voNodeList.length > 0 ) {
                    eXria.util.RequestUtil.doRecursive( voNodeList, pResponse );
                }
            }
        } catch( e ) {
            throw new Error( "eXria.data.Instance#doRecursive() : \n"+e.message );
        }
    }
};
/**
 * @fileoverview
 * StringUtil
 */
 
/**
 * StringUtil
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.util.StringUtil = {
  /**
   * 파라미터로 넘어온 문자열의 null처리
   * @param {Object} puValue null 처리 되어야 할 문자열
   * @param {String} psDefault 첫번째 파라미터가 null일 경우 대체될 문자열
   * @return 첫번째 파라미터가 null이 아니라면 해당문자열 리턴, null이라면 두번째 파라미터로 넘어온 대체 문자열 리턴.
   * @type String
   */
  fix : function(puValue, psDefault) {
    var vsDefault = psDefault || null;
    //return puValue == null || puValue == undefined ? vsFix -> vsDefault(090420 수정 최현종) : new String(puValue).valueOf();
    return puValue == null || puValue == undefined ? vsDefault : new String(puValue).valueOf();
  },
  /**
   * 파라미터로 넘어온 문자열의 null처리
   * @param {String} psValue null 처리 할 문자열
   * @return 파라미터로 넘어온 데이터가 null일 경우 공백 아니라면 파라미터 데이터 리턴
   * @type String
   */
  fixNull : function(psValue) {
    return psValue == null ? "" : psValue;
  },
  /**
   * 파라미터로 넘어온 2개의 문자열이 같은 문자열인지 비교
   * @param {Object} puValue1 비교문자열
   * @param {Object} puValue2 비교문자열
   * @return 같다면 true, 틀리면 false
   * @type Boolean
   */
  equals : function(puValue1, puValue2) {
    return this.fix(puValue1, "").toLowercase() == this.fix(puValue2, "").toLowercase();
  },
  /**
   * 파라미터로 넘어온 문자열 앞 뒤의 공백 삭제
   * @param {Object} puValue 공백을 지울 문자열
   * @return 공백이 지워진 문자열
   * @type String
   */
  trim : function( puValue ) {
    return puValue.replace(/(^\s*)|(\s*$)/g, "");
  },
  /**
   * 첫번째 파라미터의 문자열의 시작이 두번째 파라미터와 일치하는지 검사
   * @param {String} psStr 비교될 문자열
   * @param {String} psWith 비교할 문자열
   * @return 문자열의 시작이 일치한다면 true, 불일치하다면 false
   * @type Boolean
   */
  startsWith : function(psStr, psWith) {
    return (psStr.indexOf(psWith) == 0);
  },
  /**
   * 첫번째 파라미터의 문자열의 끝이 두번째 파라미터와 일치하는지 검사
   * @param {String} psStr 비교될 문자열
   * @paran {String} psWith 비교할 문자열
   * @return 문자열의 끝이 일치한다면 true, 불일치한다면 false
   * @type Boolean
   */
  endsWith : function(psStr, psWith) {
    var vnIdx = psStr.lastIndexOf(psWith);
    return vnIdx != -1 && vnIdx == (psStr.length - psWith.length);
  },
  /**
   * 한글/영어에 맞게 넘어온 문자열의 Byte 길이를 반환합니다.
   * @param {String} psStr
   * @type Number
   * @return 문자열의 길이
   * @author Choe, Hyeon jong.
   */
  getStringLength : function(psStr) {
    for(var i = 0, pnStrLen = 0, pnChCode = null, vsCh = null ; i < psStr.length ; i++) {
      pnChCode = psStr.charCodeAt(i)
      vsCh = psStr.substr(i,1).toUpperCase()
      pnChCode = parseInt(pnChCode)
      if ((vsCh < "0" || vsCh > "9") && (vsCh < "A" || vsCh > "Z") && ((pnChCode > 255) || (pnChCode < 0)))
        pnStrLen = pnStrLen + 2;
      else
        pnStrLen = pnStrLen + 1;
    }
    return pnStrLen;
  },
   
   /**
    * 문자열의 바이트를 수를 구한다.
    * @param {String} pstr 대상 문자열
    * @type Number
    * @return 문자열 바이트 수
    */
   getByteLength : function(psText) {
     var vnByteLength = 0;
     if (psText.valueOf() == null || psText.length == 0) {
       return 0;
     }
     var vsTemp;
     for ( var i = 0; i < psText.length; i++) {
       vsTemp = escape(psText.charAt(i));
       if (vsTemp.length == 1) {
         vnByteLength++;
       } else if (vsTemp.indexOf("%u") != -1) {
         vnByteLength += 2;
       } else if (vsTemp.indexOf("%") != -1) {
         vnByteLength += vsTemp.length / 3;
       }
     }
     return vnByteLength;
   }
};

/**
 * 지정한 문자열로 시작하는지 판단.
 * @param {String} psWith 지정 문자열.
 * @return 지정 문자열로 시작하는지 여부.
 * @type Boolean
 */
String.prototype.startsWith = function(psWith) {
    return (this.indexOf(psWith) == 0);
};
/**
 * 지정한 문자열로 끝나는지 판단.
 * @param {String} psWith 지정 문자열.
 * @return 지정 문자열로 끝나는지 여부.
 * @type Boolean
 */
String.prototype.endsWith = function(psWith) {
    var vnIdx = this.lastIndexOf(psWith);
    return vnIdx != -1 && vnIdx == (this.length - psWith.length);
};

/**
 * @fileoverview
 * UrlUtil
 */
 
/**
 * UrlUtil
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.util.UrlUtil = {
  parse : function(puValue, psDefault) {
    //TODO
  },
  /**
   * 파라미터로 넘어온 url을 절대 주소로 변경하여 리턴하는 메소드
   * @param {String} psUrl
   * @type String
   * @return 절대주소로 변경된 String
   */
  getAbsoluteUrl : function(psUrl) {
	var vsUrl = null;
	if(psUrl.toUpperCase().indexOf("HTTP") == 0) {
		vsUrl = psUrl;
	} else if(psUrl.indexOf("../") == 0 || psUrl.indexOf("./") == 0) {
	  var vsUrl = page.metadata.url;
	  var vsDocPath = vsUrl.substring(0, vsUrl.lastIndexOf("/") + 1);
	  vsUrl = vsDocPath + psUrl;
	} else if(psUrl.indexOf("/") == 0) {
	  var voLocation = page.window.location;
	  vsUrl = voLocation.protocol + "//" + voLocation.host + page.metadata.resourceBaseUrl + psUrl.substring(1, psUrl.length);
	} else if(psUrl.indexOf("/") == -1) {
	  var vsUrl = page.metadata.url;
	  vsUrl = vsUrl.substring(0, vsUrl.lastIndexOf("/")) + "/" + psUrl;
	} else if(psUrl.indexOf("/") > 0) {
	  var voLocation = page.window.location;
	  vsUrl = voLocation.protocol + "//" + voLocation.host + page.metadata.resourceBaseUrl + psUrl;
	}
	return vsUrl;
  }
}; 
/**
 * @fileoverview
 * ValueUtil
 * Value 체크 및 형 변환
 */
 
/**
 * ValueUtil
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.util.ValueUtil = {
    /**
     * Null 여부 체크
     * @param {Object} puValue null 체크를 할 객체
     * @return null 이라면 true, 아니라면 false
     * @type Boolean
     */
    isNull : function (puValue) {
        return (eXria.util.StringUtil.fixNull(puValue) == "");
    },
    /**
     * Number형 value인지 체크 : ex) ValueUtil.isNumber("1234.56") == true
     * @param {String} psValue 체크할 문자열
     * @return 숫자라면 true, 아니라면 false
     * @type Boolean
     */
    isNumber : function (psValue) {
        var vnNum = Number(psValue);
        return isNaN(vnNum) == false;
    },

    /**
     * null이거나 정의되지 않은경우 ""로 반환
     * @param {Object} puValue 체크할 객체
     * @return null이라면 공백, null이 아니라면 해당 문자열 리턴
     * @type String
     */
    fixNull : function (puValue) {
        var vsType = typeof(puValue);
        if(vsType == "string" || (vsType == "object" && puValue instanceof String)) {
        	puValue = eXria.util.StringUtil.trim(puValue);
        }
        return (puValue == null || puValue == "null" || puValue == "undefined") ? "" : String(puValue);
    },

    /**
     * Boolean형으로 반환
     * @param {Object} puValue Boolean으로 반환할 객체
     * @return 파라미터가 boolean 데이터일 경우 그대로 리턴.</br>Number일 경우 0이 아니면 true, 0이면 false.</br>String일경우 TRUE면 true, 아니면 false리턴
     * @type Boolean
     */
    fixBoolean : function (puValue) {
        if (typeof(puValue) == "boolean" || puValue instanceof Boolean) {
            return puValue;
        }
        if (typeof(puValue) == "number" || puValue instanceof Number) {
            return puValue != 0;
        }
        return (eXria.util.StringUtil.fixNull(puValue).toUpperCase() == "TRUE");
    },

    /**
     * Number형으로 반환
     * @param {Object} puValue Number형으로 반환할 객체
     * @return 파라미터가 Number일 경우 그대로 리턴.</br>아닐 경우 파라미터를 숫자로 변경 후 리턴</br>파라미터가 null 혹은 정의되지 않았을 경우 0 리턴
     * @type Number
     */
    fixNumber : function (puValue) {
        if (typeof(puValue) == "number" || puValue instanceof Number) {
            return puValue;
        }
        var vnNum = Number(eXria.util.StringUtil.fixNull(puValue));
        return isNaN(vnNum) ? 0 : vnNum;
    }

};
/**
 * @fileoverview
 * eXria.util.NumberUtil
 */
/**
 * eXria.util.NumberUtil
 * @author Choe, hyeon jong.
 * @constructor
 */
eXria.util.NumberUtil = {
  /**
   * Number 속성 데이터에 대한 null값 체크를 한다.</br>
   * @param {Object} puValue null체크를 할 데이터
   * @param {Number} pnFix 첫번째 파라미터가 null일 경우 대체할 데이터
   * @return 첫번째로 넘어온 데이터가 Number 혹은 String 타입의 Number일 경우</br>해당 값을 리턴하며,</br>null이거나 undefined일 경우 두번째로 넘어온</br>데이터가 리턴된다.
   * @type Number 
   */
  fixNull : function(puValue, pnFix) {
	if(typeof(pnFix) != "number" || pnFix instanceof Number)
	  throw new Error("Parameter is not a number.");
	
	if(!puValue) {
		return pnFix;
	} else if(typeof(puValue) == "number" || puValue instanceof Number) {
        return puValue;
    } else {
		var vnNum =  Number(puValue);
		return isNaN(vnNum) ? pnFix : vnNum;
	}
  }
};
/**
 * @fileoverview
 * FileDownLoadUtil
 */
/**
 * FileDownLoadUtil
 * 파일 다운로드를 위한 유틸
 * @constructor
 */
eXria.util.FileDownloadUtil = function(poPage) {
  /**
   * page
   * @type {eXria.form.Page} poPage
   * @see eXria.form.Page
   * @ignore
   */
  this.page = poPage;
  /**
   * downLoadForm
   * @ignore
   */
  this.downLoadForm = null;
  /**
   *  파라미터 추가
   *  @param {eXria.form.Page} poPage page 객체
   *  @param {String} psKey 파라미터의 Id
   *  @param {String} psValue 파라미터의 value
   *  @return void
   *  @type void
   */
  this.addParam = function(poPage, psKey, psValue) {
	var voInputElement = poPage.window.document.createElement("input");
	voInputElement.setAttribute("type", "hidden");
	voInputElement.setAttribute("id", psKey);
	voInputElement.setAttribute("name", psKey);
	voInputElement.setAttribute("value", psValue);
	this.downLoadForm.appendChild(voInputElement);
  };
  /**
   *  action URL 설정
   *  @param {String} psAction action url
   *  @return void
   *  @type void
   */
  this.setURL = function(psAction) {
	var vsRegAction;
	var vsTmpAction = psAction;
	var vsRegAction = null;

	if(this.page.metadata.submitBaseUrl == null || this.page.metadata.submitBaseUrl == "") {
	  if(eXria.util.StringUtil.startsWith(vsTmpAction, "/")) {
		vsRegAction = "." + psAction;
	  } else {
		vsRegAction = psAction;
	  }
	} else if(vsTmpAction.length > 4 && eXria.util.StringUtil.startsWith(vsTmpAction.toUpperCase(), "HTTP")) {
	  vsRegAction = psAction;
	} else {
	  if(eXria.util.StringUtil.startsWith(vsTmpAction, "/")) {
		if(eXria.util.StringUtil.endsWith(this.page.metadata.submitBaseUrl, "/")) {
		  vsTmpAction = psAction.substring(1);
		}
		vsRegAction = this.page.metadata.submitBaseUrl + vsTmpAction;
	  } else {
		if(eXria.util.StringUtil.endsWith(this.page.metadata.submitBaseUrl, "/")) {
		  vsRegAction = this.page.metadata.submitBaseUrl + psAction;
		} else {
		  vsRegAction = this.page.metadata.submitBaseUrl + "/" + psAction;
		}
	  }
	}
	this.downLoadForm.setAttribute("action", vsRegAction);
  };
  /**
   * 파일을 다운로드 하는 메서드
   * @return void
   * @type void
   */
  this.fileDown = function() {
    this.bindErrMsg();
    
    this.downLoadForm.submit();
    this.downLoadForm.reset();
    this.downLoadForm.parentNode.removeChild(this.downLoadForm);
    this.downLoadForm = null;
  };
  /**
   *  initialize, iFrame은 MultipartBuilder의 것을 사용
   *  @param {eXria.form.Page} poPage
   *  @return void
   *  @type void
   *  @ignore
   */
  this.init = function(poPage) {
	var voPageDocument = poPage.window.document;
  var vnBrowserVer = poPage.metadata.browser.ie;
  
	// IE
	if(vnBrowserVer > 0) {
	  var voDiv = voPageDocument.getElementById("hiddenFormDiv");

	  if(voDiv == null || voDiv == undefined) {
  		var voFrameDiv = voPageDocument.createElement("DIV");
  		voFrameDiv.setAttribute("id", "hiddenFormDiv");
  		voFrameDiv.setAttribute("name", "hiddenFormDiv");
          		
  		voFrameDiv.innerHTML = "<iframe id='fileUpHiddenFrm' name='fileUpHiddenFrm' style='display:none'></iframe>";
      
      if(vnBrowserVer >= 8) {
        voPageDocument.body.appendChild(voFrameDiv);
      } else {
        voPageDocument.appendChild(voFrameDiv); 
      }
	  }
	} else {	// non IE
	  var voHiddenFrm = voPageDocument.getElementById("fileUpHiddenFrm");

	  if(voHiddenFrm == null || voHiddenFrm == undefined) {
		var voHiddenFrame = voPageDocument.createElement("iframe");
		voHiddenFrame.setAttribute("id", "fileUpHiddenFrm");
		voHiddenFrame.setAttribute("name", "fileUpHiddenFrm");
		voHiddenFrame.style.display = "none";
		voPageDocument.body.appendChild(voHiddenFrame);	
	  }
	}
	this.downLoadForm = voPageDocument.createElement("form");
	this.downLoadForm.setAttribute("method", "POST");
	this.downLoadForm.setAttribute("target", "fileUpHiddenFrm");
	voPageDocument.body.appendChild(this.downLoadForm);
  };
  /**
   *  iframe body의 에러메세지 처리
   *  @return void
   *  @type void
   *  @ignore
   */
  this.bindErrMsg = function(){
    var voPage = this.page;
    var voPageDocument = voPage.window.document;
    
    var fileDownLoadComplete = function() {
      var vsResult = null;
      var voReadyState = voPageDocument.getElementById("fileUpHiddenFrm").readyState;

      // iframe body의 error msg 가져오기
      if(voReadyState && voReadyState == "complete") { //IE
        vsResult = voPageDocument.frames["fileUpHiddenFrm"].document.body;
        if(vsResult != null) vsResult = vsResult.innerText;
      } else { // IE외
        try {
          vsResult = voPageDocument.getElementById("fileUpHiddenFrm").contentWindow.document.body.firstChild.firstChild.nodeValue;
        } catch(e) {
        }
      }
      
      // error msg를 instance에 bind
      if(vsResult != null) {
        try {
          vsResult =eval("(" + vsResult + ")");
          var voDefInst = voPage.model.getInstance(voPage.model.defaultInstanceId);
          var voErr = voDefInst.selectSingleNode("/root/EXRIAERRMSG");
          if(voErr.hasChildNodes()) {
            voErr.parentNode["EXRIAERRMSG"] = "";
          }
          if(!vsResult) return;
          if(!vsResult.root.EXRIAERRMSG) return;
      
          var voResErr = null;
          voResErr = new eXria.data.json.Node(vsResult.root.EXRIAERRMSG);
          var voResErrNode = voResErr.getChildNodes();
          var vnErrLen = voResErrNode.getLength();
          for(var i = 0 ; i < vnErrLen ; i++) {  
            voErr.appendChild((voResErrNode.item(i)).cloneNode(true));
          }
        } catch(err) {
        }
      }
    };

    if (voPage.metadata.browser.ie > 0) {
      voPageDocument.getElementById("fileUpHiddenFrm").onreadystatechange = function() {
        fileDownLoadComplete();
      };
    } else {
      voPageDocument.getElementById("fileUpHiddenFrm").onload = function() {
        fileDownLoadComplete();
      };
    }
  };
  /**
   * @ignore
   */
  this.init(poPage);
};
/**
 * @fileoverview
 * eXria.data package
 */
/**
 * eXria.data package
 * @author Kim, Min Seok
 * @version 1.0
 */
eXria.data = {};

/**
 * @fileoverview
 * XML Node를 Array Collection 형태로 wrapping 하거나 새로운 Array Collection을 생성하는 클래스
 */
/**
 * XML Node를 Array Collection 형태로 wrapping 하거나 새로운 Array Collection을 생성하는 클래스
 * @author Kim, Min Seok
 * @version 1.0
 * @param {eXria.data.Collection} poCollection Collection Object
 * @constructor
 * @base eXria.data.Collection
 */

eXria.data.ArrayCollection = function(poCollection) {
  /**
   * inherit
   */
  eXria.data.Collection.call(this);

  if(poCollection != null) {
    this.elements = poCollection.elements;
    this.cnt = poCollection.elements.length;
  }
  /**
   * Parameter로 넘어온 Array의 Index에 Value를 대입한다. 만약 해당 Index에 기존의 데이터가 있을 기존의 데이터는 삭제 된다.
   * @param {Number} pnIndex item index
   * @param {Object} poValue item value
   * @return 넘어온 index에 이전에 들어있던 데이터 Object
   * @type Object
   */
  this.set = function(pnIndex, poValue) {
    this.rangeCheck(pnIndex);
    var voOld = this.elements[pnIndex];
    this.elements[pnIndex] = poValue;
    if(!voOld) this.cnt++;
    return voOld;
  };
  /**
   * Parameter로 넘어온 Index에 해당되는 Item이 존재할 경우 삭제한다.
   * @param {Number} pnIndex 삭제할 Item Index
   * @return 삭제될 요소
   * @type Object
   */
  this.remove = function(pnIndex) {
    this.rangeCheck(pnIndex);
    var voElement = this.elements.splice(pnIndex, 1);
    if(voElement) {
      voElement = voElement[0];
      this.cnt--;
    }
    return voElement;
  };
  /**
   * 현재 Array Collection의 모든 데이터를 삭제하고 Array를 초기화 시킨다.
   * @return void
   * @type void
   */
  this.clear = function() {
    this.elements = new Array();
    this.cnt = 0;
  };
  /**
   * Array Collection에 Item의 존재 유무를 리턴한다.
   * @return Element가 없을 경우 TRUE, 있다면 FALSE
   * @type Boolean
   */
  this.isEmpty = function() {
  return (this.cnt == 0);
  };
  /**
   * 현재 Array Collection의 데이터를 Array Iterator 객체로 변환하여 리턴한다.
   * @return Collection Iterator
   * @type eXria.data.ArrayIterator
   * @see eXria.data.ArrayIterator
   */
  this.iterator = function() {
    return new eXria.data.ArrayIterator(this);
  };
  /**
   * 현재 Array Collection의 모든 데이터를 "," 구분자를 사용하여 문자열로 리턴한다.
   * @return Item List String in Collection
   * @type String
   */
  this.toString = function() {
    return "[" + this.elements.join(", ") + "]";
  };
};

/**
 * @fileoverview
 * XML Node를 Array Iterator 형태로 wrapping 하는 클래스
 */
/**
 * XML Node를 Array Iterator 형태로 wrapping 하는 클래스
 * @author Kim, Min Seok
 * @version 1.0
 * @param {eXria.data.Collection} poCollection Collection Object
 * @constructor
 * @base eXria.data.Iterator
 */

eXria.data.ArrayIterator = function(poCollection) {
  /**
   * inherit
   */
  eXria.data.Iterator.call(this, poCollection);
  /**
   * Iterator의 현재 포인트가 Iterator의 첫번째인지 아닌지를 확인하여 리턴한다.
   * @return 첫번째 포인트이면 true 아니면 false
   * @type Boolean
   */
  this.isFirst = function() {
      return (this.cursor == 0);
  };
  /**
   * Iterator의 현재 포인트가 Iterator의 마지막인지 아닌지를 확인하여 리턴한다.
   * @return 마지막이면 true 아니면 false
   * @type Boolean
   */
  this.isLast = function() {
  return (this.cursor == this.collection.cnt);
  };
};

/**
 * @fileoverview
 * Map으로 생성되어있는 XML Node를 Array Map 형태로 wrapping 하거나 새로운 Array Map을 생성하는 클래스
 */
/**
 * Map으로 생성되어있는 XML Node를 Array Map 형태로 wrapping 하거나 새로운 Array Map을 생성하는 클래스
 * @author Kim, Min Seok
 * @version 1.0
 * @param {eXria.data.Map} poMap Map Object
 * @constructor
 * @base eXria.data.Map
 */
eXria.data.ArrayMap = function(poMap) {
  /**
   * inherit
   */
  eXria.data.Map.call(this);
  /**
   * key에 순번을 정렬하기 위해 사용되는 배열 객체
   * @type Array(Number)
   * @private
   */
  var maSeq = [];
  /**
   * 순번 저장 배열을 오름차순 정렬하기 위한 메소드
   * 지정된 두 값의 순서를 결정하기 위한 두 값의 차
   * @type Number
   * @private
   */
  var sortNumber = function(a, b) {
    return a - b;
  };
  /**
   * getKeyCollection 메소드에 의해 반환될 key저장 Collection 객체
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.keyCollection = new eXria.data.ArrayCollection();
  /**
   * getValueCollection 메소드에 의해 반환될 key저장 Collection 객체
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.valueCollection = new eXria.data.ArrayCollection();

  if (poMap != null) {
    this.entries = poMap.entries;
    this.keyEntries = poMap.keyEntries;
    this.seqEntries = poMap.seqEntries;
    this.seq = poMap.seq;
  }
  /**
   * Map에 저장된 Item의 갯수를 리턴한다.
   * @return Map에 저장된 데이타 크기[개수]
   * @type Number
   */
  this.size = function() {
    this.syncEntries();
    return this.cnt;
  };
  /**
   * Map에 저장된 데이터 중 Parameter로 넘어온 Key에 해당되는 데이터가 있을 경우 해당 데이터를 삭제한다.
   * @param {String} psKey 삭제하고자 하는 데이타의 키 값
   * @return psKey에 해당되는 데이터
   * @type Object
   */
  this.remove = function(psKey) {
    this.isChanged = true;
    var voRet = this.entries[psKey];
    delete this.entries[psKey];
    return voRet;
  };
  /**
   * 현재 Map 객체의 모든 데이터를 삭제하고 Map을 초기화 한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    this.isChanged = true;
    this.seq = 0;
    this.entries = new Object();
    this.seqEntries = {};
    this.keyEntries = {};
    this.cnt = 0;
  };
  /**
   * 현재 Map에 저장된 Item이 없는지 체크하여 리턴한다.
   * @return Map 내부에 데이터가 없을 경우 TRUE, 있다면 FALSE
   * @type Boolean
   */
  this.isEmpty = function() {
    this.syncEntries();
    return (this.cnt == 0);
  };
  /**
   * Map에 저장된 모든 Key를 ArrayCollection 형태로 변환하여 리턴한다.
   * @return Map에 저장된 데이타들의 키 값을 저장한 컬렉션
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getKeyCollection = function() {
    this.syncEntries();
    return this.keyCollection;
  };
  /**
   * Map에 저장된 모든 Value를 ArrayCollection 형태로 변환하여 리턴한다.
   * @return Map에 저장된 데이타들의 value 값을 저장한 컬렉션
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getValueCollection = function() {
    this.syncEntries();
    return this.valueCollection;
  };

  /**
   * Map 변경에 의해 동기화 되어야될 속성들 처리를 수행하는 메소드
   */
  this.syncEntries = function() {

    if(this.isChanged) {
      var vnCnt = 0;
      maSeq = [];
      var voEntries = this.entries;
      var voSeqEntries = this.seqEntries;

      for(var member in voEntries) {
        maSeq.push(voSeqEntries[member]);
        vnCnt++;
      }
      maSeq.sort(sortNumber);

      var vnSize = maSeq.length;
      var vnSeq = 0;
      var voKeyEntries = this.keyEntries;

      var voKeyCollection = this.keyCollection;
      var voValueCollection = this.valueCollection;
      voKeyCollection.clear();
      voValueCollection.clear();

      for(var i = 0; i < vnSize; i++) {
        vnSeq = maSeq[i];
        voKeyCollection.add(voKeyEntries[vnSeq]);
        voValueCollection.add(voEntries[voKeyEntries[vnSeq]]);
      }
      if(vnCnt == 0) {
        this.seq = 0;
        this.seqEntries = {};
        this.keyEntries = {};
      }
      this.cnt = vnCnt;
      this.isChanged = false;
     }
  };

  /**
   * Map에 저장된 모든 데이터를 "," 구분자를 사용하여 문자열 형태로 리턴한다.
   * @return Map에 저장된 데이타들의 문자열 형태 표현 값
   * @type String
   */
  this.toString = function() {
    var voBuilder = new eXria.lang.StringBuilder();
    voBuilder.append("{");
    var voIterator = this.getKeyCollection().iterator();
    var vsKey = null;
    while (voIterator.hasNext()) {
      vsKey = voIterator.next();
      voBuilder.append(vsKey).append("=").append(this.get(vsKey));
      if (voIterator.isLast() == false) { voBuilder.append(", "); }
    }
    voBuilder.append("}");
    return voBuilder.toString();
  };
};

/**
 * @fileoverview
 * XML Node를 Collection 형태로 관리할 수 있도록 하는 클래스
 */
/**
 * XML Node를 Collection 형태로 관리할 수 있도록 하는 클래스
 * @author Kim, Min Seok
 * @version 1.0
 * @constructor
 */
eXria.data.Collection = function() {
  /**
   * elements
   * @type Object
   * @private
   */
  this.elements = new Array();
  /**
   * 컬렉션 구성 요소 크기를 저장하기 위한 속성
   * @type Number
   * @private
   */
  this.cnt = 0;
  /**
   * Collection에 Parameter로 넘어온 데이터를 추가한다.
   * @param {Object} poValue 컬렉션에 추가될 Value
   * @return void
   * @type void
   */
  this.add = function(poValue) {
    this.elements.push(poValue);
    this.cnt++;
  };
  /**
   * Collection에 현재 존재하는 Item의 갯수를 리턴한다.
   * @return 컬렉션 구성 요소들의 크기[개수]
   * @type Number
   */
  this.size = function() {
    return this.cnt;
  };
  /**
   * Parameter로 넘어온 Index에 해당하는 Collection의 Item을 리턴한다.
   * @param {Number} pnIndex 요소의 인덱스 번호
   * @return 해당 Index를 Index로 하는 요소
   * @type Object
   */
  this.get = function(pnIndex) {
    this.rangeCheck(pnIndex);
    return this.elements[pnIndex];
  };
  /**
   * 주어진 값이 현재 컬렉션 구성 요소의 인덱스 번호로서 적합한 지 여부를 검사하는 메소드
   * @param {Number} pnIndex 검사할 값
   * @return void
   * @type void
   * @private
   */
  this.rangeCheck = function(pnIndex) {
    if (pnIndex < 0 || pnIndex > this.cnt) {
      throw new Error("Index out of range : " + pnIndex);
    }
  };
};

/**
 * @fileoverview
 * XML Node를 Collection 형태로 wrapping 하는 클래스의 Interface
 */
/**
 * XML Node를 Collection 형태로 wrapping 하는 클래스의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.Node
 */
eXria.data.CollectionNode = function(poNode) {
  /**
   * inherit
   */
  eXria.data.Node.call(this, poNode);
  /**
   * Collection에 파라미터로 넘어온 Node를 추가한다.
   * @param {XMLNode} poNode 추가할 Node
   * @return void
   * @type void
   */
  this.add = null;
  /**
   * 현재 Collection의 Item 갯수를 리턴한다.
   * @return 하위 ElementNode의 갯수
   * @type Number
   */
  this.size = null;
  /**
   * Parameter로 넘어온 Index에 해당하는 위치의 Node를 리턴한다.
   * @param {Number} pnIndex 리턴받은 Node의 Index
   * @return 해당 Index의 Node. Index가 Node의 범위 밖인 경우 null을 리턴한다.
   * @type Node
   */
  this.get = null;
  /**
   * Collection에서 Parameter로 넘어온 Index에 해당되는 위치에 두번째 Parameter로 넘어온 Node를 추가한다. 만약 해당 Index에 기존 Node가 존재할 경우 기존 Node는 삭제 된다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type Node
   */
  this.set = null;
  /**
   * 넘겨 받은 Index에 Node를 추가 한다. 해당 Index에 기존에 Node가 존재 할 경우 해당 Node 및 이후 Index의 Node들의 Index가 하나씩 밀린다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type Node
   */
  this.insert = null;
  /**
   * Parameter로 넘어온 Index에 해당하는 Node를 삭제한다.
   * @param {Number} pnIndex 삭제할 Node Index
   * @return 삭제된 Node 참조값
   * @type Node
   */
  this.remove = null;
  /**
   * Collection의 모든 Node를 삭제 하고 Collection을 초기화 한다.
   * @return void
   * @type void
   */
  this.clear = null;
  /**
   * 현재 Collection이 비어 있는지 체크하여 리턴한다.
   * @return 비어있는 노드일 경우 TRUE, 아닐 경우 FALSE
   * @type Boolean
   */
  this.isEmpty = null;
  /**
   * 현재 Collection의 모든 Node를 Iterator로 변환하여 리턴한다.
   * @return 내부객체를 조회하는 Iterator
   * @type eXria.data.ArrayIterator
   * @see eXRia.data.ArrayIterator
   */
  this.iterator = null;
  /**
   * 현재 메소드 이름을 리턴한다.
   * @return 현재 메소드명
   * @type String
   */
  this.toString = null;
};

/**
 * @fileoverview
 * Document 클래스의 Interface
 */
/**
 * Document 클래스의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.data.Document = function() {
  /**
   * XMLDocument
   * @type XMLDocument
   * @private
   */
  this.dom = null;
  /**
   * 파라미터로 넘겨받은 URL에 존재하는 XML을 로딩한다.
   * @param {String} psUrl 로딩할 XML이 존재하는 URL
   * @return void
   * @type void
   */
  this.loadURL = null;
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   */
  this.loadXML = null;
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   */
  this.loadTXT = null;
  /**
   * 넘겨받은 Tag Name의 Element Node를 생성하여 리턴한다.
   * @param {String} psName 생성할 Element Tag Name
   * @return 생성된 XML Element Node
   * @type Node|Element
   */
  this.createNode = null;
  /**
   * 넘겨받은 XPath의 Node를 삭제한다.
   * @param {String} psXpath 삭제할 XPath
   * @return void
   * @type void
   */
  this.removeNode = null;
  /**
   * 넘겨받은 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 XML Element
   * @type Node
   */
  this.selectSingleNode = null;
  /**
   * 넘겨받은 XPath에 해당하는 Node들을 조회하여 NodeList로 리턴한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 NodeList를 Wrapping한 NodeList 객체
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = null;
};

/**
 * @fileoverview
 * msxml 버전에 맞춰 ActiveXObject를 생성하여 리턴하는 팩토리 클래스
 */

/**
 * msxml 버전에 맞춰 ActiveXObject를 생성하여 리턴하는 팩토리 클래스
 * @version 1.0
 * @author Choe, hyeon jong
 * @constructor
 * @private
 */

eXria.data.DomDocumentFactory = {
  msxmlNames :
  [
    "MSXML2.DOMDocument.6.0",
    "MSXML2.DOMDocument.5.0",
    "MSXML2.DOMDocument.4.0",
    "MSXML2.DOMDocument.3.0"
  ]
  ,
  /**
   * msxml 버전에 맞춰 ActiveXObject를 생성
   * @private
   */
  getDomDocument : function(poPage, psId) {
  if(window.ActiveXObject !== undefined) {
    var msxmlNamesLen = this.msxmlNames.length;
    for(var i = 0 ; i < msxmlNamesLen ; i++) {
      try {
      this.voDomObj = new ActiveXObject(this.msxmlNames[i]);
      } catch (e) {}
    if(this.voDomObj != null) {
        if(this.voDocumentDom == null) {
        this.voDocumentDom = this.voDomObj;
        } else {
        if(this.voInstanceDom == null) {
          this.voInstanceDom = new eXria.data.Map();
        }
        this.voInstanceDom.put(psId, this.voDomObj);
        }
        break;
      }
    }
  } else {
    this.voDomObj = poPage.window.document.implementation.createDocument("", "", null);
    if(this.voDocumentDom == null) {
    this.voDocumentDom = this.voDomObj;
    } else {
    if(this.voInstanceDom == null) {
      this.voInstanceDom = new eXria.data.Map();
    }
      this.voInstanceDom.put(psId, this.voDomObj);
    }
  }
  return this.voDomObj;
  },
  /**
   * DomDocument return
   * @type eXria.data.Map
   * @return DOM Document Map
   * @private
   */
  getDomDocObj : function() {
  return this.voInstanceDom;
  }
};
/**
 * @fileoverview
 * DOM Parser의 Interface
 */
/**
 * DOM Parser의 Interface
 * @version 1.0
 * @implements eXria.data.xhtml.GeckoDOMParser
 * @implements eXria.data.xhtml.MsieDOMParser
 * @constructor
 * @private
 */
eXria.data.DOMParser = function() {
  /**
   * DOM parser
   * @type Object
   * @private
   */
  this.parser = null;
  /**
   * XML Text 값을 XMLDocument로 Parsing한다.
   * @param {String} psData XML Test
   * @return Parsing된 XMLDocument
   * @type XMLDocument
   */
  this.parse = null;
  /**
   * Parser Clear
   * @return void
   * @type void
   */
  this.clear = function() {
    delete this.parser;
  };
};
/**
 * @fileoverview
 * Browser Type에 맞게 Parser를 리턴해주는 클래스
 */
/**
 * Browser Type에 맞게 Parser를 리턴해주는 클래스
 * @version 1.0
 * @see eXria.data.DOMParser
 * @constructor
 * @private
 */
eXria.data.DOMParserFactory = {
  /**
   * DOM을 Browser 타입에 맞춰 생성 후 리턴
   * @private
   */
  getParser : function(poPage) {
    if(window.ActiveXObject !== undefined) {
      return new eXria.data.xhtml.MsieDOMParser(poPage);
    } else if(window.DOMParser) {
      return new eXria.data.xhtml.GeckoDOMParser(poPage);
    } else {
      return null;
    }
  }
};
/**
 * @fileoverview
 * Instance 클래스의 Interface
 */
/**
 * Instance 클래스의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} Instance Id
 * @param {eXria.form.Model} eXria Model Object
 * @constructor
 */
eXria.data.Instance = function(psId, poModel) {
  /**
   * Instance Id
   * @type String
   */
  this.id = psId;
  /**
   * Model Object
   * @type eXria.form.Model
   */
  this.model = poModel;
  /**
   * document
   * @private
   */
  this.document = null;
  /**
   * loadXML, loadURL, loadTXT 메소드 사용시 이전의 DOM 삭제 후 새로운 데이터를 로딩
   * <br/>Plugin에서만 사용 가능한 플래그
   * @type Number
   */
  this.LOADREPLACE = null;
  /**
   * loadXML, loadURL, loadTXT 메소드 사용시 이전의 DOM 유지 후 새로운 데이터 로딩
   * <br/>Plugin에서만 사용 가능한 플래그
   * @type Number
   */
  this.LOADAPPEND = null;
  /**
   * Parameter로 넘어온 URL의 타겟에 해당하는 XML을 인스턴스에 바인딩 한다.
   * @param {String} psUrl 바인딩할 XML의 URL
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정(Plugin에서만 지정가능)
   * @return void
   * @type void
   */
  this.loadURL = null;
  /**
   * Parameter로 넘어온 XML Element를 인스턴스에 바인딩한다.
   * @param {XMLElement} poXML 바인딩할 XMLElement
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정(Plugin에서만 지정가능)
   * @return void
   * @type void
   */
  this.loadXML = null;
  /**
   * Parameter로 넘어온 XML Text를 파싱하여 인스턴스에 바인딩한다.
   * @param {String} psTxt 파싱할 XML Text
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정(Plugin에서만 지정가능)
   * @return void
   * @type void
   */
  this.loadTXT = null;
  /**
   * Node를 주어진 타입에 따라 생성하여 그 객체를 리턴한다. Type이 없을 경우 Default로 Element Node가 리턴 된다.
   * @param {String} psNodeName 두번째 파라미터로 넘어오는 Type에 따라 Node명 또는 그 Node의 Value가 된다.
   * @param {Number} pnType Type [eXria.data.NodeType]
   * @type eXria.data.Node
   * @return 생성된 XML Node
   */
  this.createNode = null;
  /**
   * 파라미터로 넘어온 이름의 Element를 생성하여 리턴한다.
   * @param {String} psElementName 생성될 엘리먼트 이름
   * @return 생성된 Element Node
   * @type eXria.data.Node
   * @see eXria.data.Node
   */
  this.createElement = null;
  /**
   * Parameter로 넘어온 Tag Name을 가지는 ElementNode를 Value Node 형태로 생성하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 value node
   * @type eXria.data.ValueNode
   * @see eXria.data.ValueNode
   */
  this.createValueNode = null;
  /**
   * Parameter로 넘어온 Tag Name을 가지는 ElementNode를 Map Node 형태로 생성하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 Map node
   * @type eXria.data.MapNode
   * @see eXria.data.MapNode
   */
  this.createMapNode = null;
  /**
   * Parameter로 넘어온 Tag Name을 가지는 ElementNode를 CollectionNode 형태로 생성하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 Collection Node
   * @type eXria.data.CollectionNode
   * @see eXria.data.CollectionNode
   */
  this.createCollectionNode = null;
  /**
   * Parameter로 넘어온 XPath에 해당 Node를 추가한다.
   * @param {String} psPath 추가할 위치에 해당하는 XPath
   * @param {XMLNode} poNode 추가할 XMLNode
   * @return void
   * @type void
   */
  this.appendNode = null;
  /**
   * 넘겨받은 XPath를 단순 Value형태로 처리하기 위한 ValueNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 value node
   * @type eXria.data.ValueNode
   * @see eXria.data.ValueNode
   */
  this.getValueNode = null;
  /**
   * 파라미터로 넘어온 XPath의 Node Value를 리턴한다.
   * @param {String} psXpath 조회대상의 XPath 경로
   * @type String
   * @return 조회된 Value
   */
  this.getValue = null;
  /**
   * Instance의 dom객체의 XML 내용을 XPath를 이용하여 해당 위치에 데이터를 문자열로 얻는다.
   * @return dom 객체의 XML 문자열
   * @param {String} psXPath XPath 문자열
   * @type String
   */
  this.getXML = null;
  /**
   * Instnace의 주어진 XPath 경로에 Value를 설정한다.
   * @param {String} psXpath Value를 설정하기 위한 XPath 경로
   * @param {String} psValue 설정하고자 하는 Value
   * @return void
   * @type void
   */
  this.setValue = null;
  /**
   * 넘겨받은 XPath를 Map형태로 처리하기 위한 MapNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 Map node
   * @type eXria.data.MapNode
   * @see eXria.data.MapNode
   */
  this.getMapNode = null;
  /**
   * 넘겨받은 XPath를 Collection형태로 처리하기 위한 CollectionNode를 생성하여 리턴한다.
   * @param {String} psXpath 처리할 기준 Node XPath
   * @return 생성된 Collection node
   * @type eXria.data.CollectionNode
   * @see eXria.data.CollectionNode
   */
  this.getCollectionNode = null;
  /**
   * 넘겨받은 Xpath의 Node를 삭제한다.
   * @param {String} psXpath 삭제할 Node의 XPath
   * @return 삭제된 노드
   * @type eXria.data.Node
   */
  this.removeNode = null;
  /**
   * 해당 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 node
   * @type eXria.data.Node
   */
  this.selectSingleNode = null;
  /**
   * Instance의 하위Node를 넘겨받은 XPath로 조회하여 리턴한다.
   * @param {String} psXpath 조회할 Xpath
   * @return 조회된 node list
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = null;
  /**
   * Instance의 하위 Node를 Collection 형태로 리턴하며, <br/>
   * 해당 Node에 자식 Node가 있을 경우 nodeName과 nodeValue가 각각 Key, Value로 셋팅된 Map으로 Wrapping 하여 Collection에 Set
   * @param {String} psXpath Collection으로 리턴 받고자 하는 Node의 부모의 XPath
   * @return Collection으로 Wrapping 된 Node
   * @type eXria.data.Collection
   */
  this.getCollection = null;
  /**
   * 모든 하위노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = null;
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 alert으로 출력
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return void
   * @type void
   */
  this.print = null;
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = null;
  /**
   * 넘겨 받은 XPath의 Node를 복사하여 리턴한다.
   * @param {String} psXPath 복사할 Node의 XPath
   * @param {String} pbDeep 깊은복사 유무 ( True : Deep Copy )
   * @return 복사된 노드
   * @type eXria.data.Node
   */
  this.cloneNode = null;
  /**
   * 해당 XPath 하위에 두번째 파라미터로 넘어온 XML Text Node구조를 생성한다.
   * @param {String} psXpath 생성할 Node의 Parent Node가 될 Node의 XPath
   * @param {String} psTxt 생성할 Node XML Text
   * @return void
   * @type void
   */
  this.appendNodeByTxt = null;
};

/**
 * @fileoverview
 * Collection으로 wrapping 되어 있는 클래스에 대해 Iterator로 warpping 하는 클래스
 */
/**
 * Collection으로 wrapping 되어 있는 클래스에 대해 Iterator로 warpping 하는 클래스
 * @constructor
 * @param {eXria.data.Collection} poCollection Iterator로 변환할 Collection 오브젝트
 */
eXria.data.Iterator = function(poCollection) {
  /**
   * Iterator로 변환할 Collecton Object
   * @type eXria.data.Collection
   * @private
   */
  this.collection = poCollection.elements;
  /**
   * cursor
   * 현재 참조하고 있는 Iterator 요소의 위치 값 저장
   */
  this.cursor = -1;
  /**
   * 다음에 참조할 Iterator의 요소의 존재여부를 반환하는 메소드.
   * 함수 호출 후 커서(Iterator 요소의 위치) 값이 하나 증가 됨.
   * @return 다음에 참조할 Iterator의 요소가 있다면 TRUE, 없다면 FALSE
   * @type Boolean
   */
  this.hasNext = function() {
    //if(this.cursor < this.collection.length - 1) {
  if(this.cursor < this.collection.length - 1) {
      this.cursor++;
      return true;
    }
    return false;
  };
  /**
   * 현재 커서 값의 Iterator 요소를 반환하는 메소드
   * @throws 현재 커서 값이 유효하지 않을 경우 IndexOutOfBoundsException이 발생됨
   * @return 현재 커서 값의 Iterator 요소
   * @type Object
   */
  this.next = function() {
    //if (this.cursor >= this.collection.length) {
  if(this.cursor >= this.collection.length) {
      throw new Error("No such element.");
    }
    return this.collection[this.cursor];
  };
};

/**
 * @fileoverview
 * DOM Document Load시 기존 Document의 DOM을 대체할지 추가할지를 결정하는 상수 클래스</br>
 * enum list</br>
 * - REPLACE : 기존의 DOM 삭제 후 생성
 * - APPEND : 기존의 DOM 에 추가
 */
/**
 * DOM Document Load시 기존 Document의 DOM을 대체할지 추가할지를 결정하는 상수 클래스
 * enum(eXria.data.LoadMode.REPLACE, eXria.data.LoadMode.APPEND)
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.data.LoadMode = {
  REPLACE : 1,
  APPEND  : 2
};
/**
 * @fileoverview
 * Map 객체를 생성하기 위한 클래스
 */
/**
 * Map 객체를 생성하기 위한 클래스
 * @author Kim, Min Seok
 * @version 1.0
 * eXria.data.Map
 * @constructor
 */
eXria.data.Map = function() {
  /**
   * Map의 변경 상태를 체크하기 위한 플래그 변수
   * @type Boolean
   * @private
   */
  this.isChanged = true;
  /**
   * Key의 생성 순서를 체크하기 위한 넘버링 변수
   * @type Number
   * @private
   */
  this.seq = 0;
  /**
   * Map 내부의 Element 갯수를 저장하는 변수
   * @private
   */
  this.cnt = 0;
  /**
   * Map에 저장될 데이터를 가지고 있을 Object 객체
   * @private
   */
  this.entries = new Object();
  /**
   * key의 순번 데이터를 가지고 있을 Object 객체
   * @private
   */
  this.seqEntries = {};
  /**
   * 순번을 key로 하여 Map key를 데이터로 가지고 있을 Object 객체
   * @private
   */
  this.keyEntries = {};
  /**
   * 넘어온 Key와 매핑되는 Value를 리턴, 메핑되는 데이터가 없다면 null 리턴
   * @param {String} psKey 찾아올 Value의 Key
   * @return Key와 매핑되어 있는 Value
   * @type Object
   */
  this.get = function(psKey) {
    var voEntry = this.entries[psKey];
    return voEntry == undefined ? null : voEntry;
  };
  /**
   * 넘어온 Key, Value를 map에 저장
   * @param {String} psKey Key
   * @param {Object} psValue value
   * @return void
   * @type void
   */
  this.put = function(psKey, poValue) {
    this.isChanged = true;
    if(this.entries[psKey] === undefined) {
      this.keyEntries[this.seq] = psKey;
      this.seqEntries[psKey] = this.seq++;
    }
    this.entries[psKey] = poValue;
  };
  /**
   * Map의 데이터를 가진 엔트리 객체를 리턴
   * @return Map에 저장되어 있는 모든 데이터를 가진 객체
   * @type Object
   */
  this.getEntries = function() {
    return this.entries;
  };
};
/**
 * @fileoverview
 * Node에 대해 Map으로 wrapping 하기 위한 Interface
 */
/**
 * Node에 대해 Map으로 wrapping 하기 위한 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.Node
 */
eXria.data.MapNode = function(poNode) {
  /**
   * inherit
   */
  eXria.data.Node.call(this, poNode);
  /**
   * ChildNode의 Element 갯수를 리턴한다.
   * @return ChildNode중 Element 갯수
   * @type Number
   */
  this.size = null;
  /**
   * ChildNode중 넘겨받은 Tag명인 첫번째 노드의 TextNode값을 리턴한다.
   * @param {String} psKey 조회할 ElementNode의 Tag명
   * @return 조회된 TextNode의 값
   * @type String
   */
  this.get = null;
  /**
   * ChildNode에 넘겨받은 Key값이 존재할 경우 존재하는 ChildNode의 하위 TextNode로 값을 설정하고,
   * 존재하지 않는 경우 ChileNode에 Append한다.
   * @param {String} psKey 설정할 Element Tag Name
   * @param {String} psValue 설정할 Value
   * @return void
   * @type void
   */
  this.put = null;
  /**
   * 넘겨받은 값을 Tag Name으로 가지는 첫번째 Node를 삭제한다.
   * @param {String} psKey 삭제할 Tag명
   * @return void
   * @type void
   */
  this.remove = null;
  /**
   * 모든 하위 노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = null;
  /**
   * 하위 Element의 존재 유무 리턴
   * @return 하위 ElementNode가 없을 경우 true, 아니라면 false
   * @type Boolean
   */
  this.isEmpty = null;
  /**
   * ChildNode의 Tag명 만으로 구성된 Collection 객체를 리턴한다.
   * @return Tag Name으로 구성된 Collection
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getKeyCollection = null;
  // deprecated ?
  /**
   * ChildNode의 Element 하위 TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @return TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getValueCollection = null;
  /**
   * ChildNode의 Element, TextNode 및 CDataNode로 구성된 Object Collection 객체를 리턴한다.
   * @return Element, TextNode 및 CDataNode로 구성된 Collection 객체
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getEntryCollection = null;
  /**
   * JSON Format String 값으로 리턴한다.
   * @return JSON Format의 xml data
   * @type String
   */
  this.toString = null;
};

/**
 * @fileoverview
 * Node Object를 관리하기 위한 Interface
 */
/**
 * Node Object를 관리하기 위한 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {Node} poNode XML Node
 * @constructor
 */
eXria.data.Node = function(poNode) {
  /**
   * Node Object
   * @type Node
   * @see Node
   */
  this.node = null;
  /**
   * Node Name
   * @type String
   */
  this.name = null;
  /**
   * 파라미터로 넘어온 Node를 자식 Node의 마지막에 추가한다.
   * @param {eXria.data.Node} poNode 추가할 Node Object
   * @type void
   * @return void
   */
  this.appendChild = null;
  /**
   * 현재 Node와 동일한 Node를 복사하여 리턴한다.
   * @param {Boolean} pbDeep deep copy 유무를 지정한다. (true | false)
   * @return 복사된 Node Object
   * @type eXria.data.Node
   */
  this.cloneNode = null;
  /**
   * 현재 Node의 자식 Node들을 NodeList 형식으로 리턴한다.
   * @type eXria.data.NodeList
   * @return 생성된 자식 Node List
   */
  this.getChildNodes = null;
  /**
   * 현재 Node의 첫번째 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 첫번째 자식 Node
   */
  this.getFirstChild = null;
  /**
   * 현재 Node의 마지막 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 마지막 자식 Node
   */
  this.getLastChild = null;
  /**
   * 현재 Node의 바로 다음 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 다음 Node
   */
  this.getNextSibling = null;
  /**
   * 현재 Node의 이름을 리턴한다.
   * @type String
   * @return 현재 Node의 이름
   */
  this.getNodeName = null;
  /**
   * 현재 Node의 value를 리턴한다.
   * @type String
   * @return 현재 Node의 Value
   */
  this.getNodeValue = null;
  /**
   * 현재 Node의 부모 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 부모 Node
   */
  this.getParentNode = null;
  /**
   * 현재 Node의 바로 전 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 바로 전 Node
   */
  this.getPreviousSibling = null;
  /**
   * Element를 생성하여 리턴한다.
   * @param {String} psTagName 생성할 Element의 Tag Name
   * @param {String} psValue 생성할 Element의 Value [ null을 넘길 경우 TextNode가 생성되지 않은 Element 리턴 ]
   * @type eXria.data.Node
   * @return 생성된 Element
   */
  this.createElement = null;
  /**
   * TextNode를 생성하여 리턴
   * @param {String} psValue 생성할 Node의 Value값
   * @type eXria.data.Node
   * @return 생성된 TextNode
   */
  this.createTextNode = null;
  /**
   * 현재 Node의 자식 Node 유무를 리턴한다.
   * @type Boolean
   * @return 자식 Node의 존재 유무
   */
  this.hasChildNodes = null;
  /**
   * 현재 Node의 자식 Node 중 파라미터로 넘어온 Node와 일치하는 Node를 삭제한다.
   * @param {eXria.data.Node} poNode 삭제할 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.removeChild = null;
  /**
   * 현재 Node의 Value 파라미터로 넘어온 데이터로 변경한다.
   * @param {String} psValue 변경할 데이터
   * @type void
   * @return void
   */
  this.setNodeValue = null;
  /**
   * 두번째 파라미터로 넘어온 Node와 동일한 Node가 있을 경우 해당 위치에 첫번째 파라미터로 넘어온 Node를 셋팅.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poOldNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.replaceChild = null;
  /**
   * 두번째 파라미터로 넘어온 Node의 앞에 첫번째로 넘어온 파라미터 Node를 추가한다.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poRefNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return insert 되기 전 Node
   */
  this.insertBefore = null;
  /**
   * node type을 리턴한다.
   * @type Number
   * @return 해당 Node의 node Type
   */
  this.getNodeType = null;
  /**
   * 현재 클래스의 이름을 반환 한다.
   * @type String
   * @return Class Name
   */
  this.toString = null;
  /**
   * 노드의 특정 속성 반환한다.
   * @param {String} psAttr 속성 명
   * @type String
   * @return 노드의 해당 속성 값
   */
  this.getAttribute = null;
  /**
   * 노드의 특정 속성 값을 설정한다.
   * @param {String} psAttr 속성 명
   * @param {String} psValue 속성 값
   */
  this.setAttribute = null;
  /**
   * 파라미터로 넘어온 Node와 현재 Node가 같은 Node인지 비교한다.
   * @param {eXria.data.Node} poNode 비교할 Node
   * @return 두개의 Node가 같은 Node인지 유무
   * @type Boolean
   */
  this.equal = null;
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return Node Object
   */
  this.getElementByTagName = null;
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.NodeList
   * @return NodeList Object
   */
  this.getElementsByTagName = null;
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return Node Object
   */
  this.getElementByTagNameFromChildNodes = null;
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Collection
   * @return eXria.data.Collection Object
   */
  this.getElementsByTagNameFromChildNodes = null;
  /**
   * 현재 Node의 XML 스트링을 리턴.
   * @type String
   * @return XML String
   */
  this.getXML = null;
};

/**
 * @fileoverview
 * Node Type을 상수정의 한 클래스</br>
 * enum list</br>
 * - eXria.data.NodeType.ELEMENT</br>
 * - eXria.data.NodeType.ATTRIBUTE</br>
 * - eXria.data.NodeType.TEXT</br>
 * - eXria.data.NodeType.CDATA_SECTION</br>
 * - eXria.data.NodeType.COMMENT</br>
 * - eXria.data.NodeType.DOCUMENT
 */
/**
 * Node Type을 상수정의 한 클래스
 * @author Choe, Hyeon Jong
 * @version 1.0
 * @constructor
 */
eXria.data.NodeType = {
  ELEMENT     : 0X0000,
  ATTRIBUTE   : 0X0001,
  TEXT      : 0X0002,
  CDATA_SECTION : 0X0004,
  COMMENT     : 0X0008,
  DOCUMENT    : 0X0010
};
/**
 * @fileoverview
 * Node를 List로 관리하기 위한 Interface
 */
/**
 * Node를 List로 관리하기 위한 Interface
 * @version 1.0
 * @constructor
 */
eXria.data.NodeList = function() {
  /**
   * NodeList의 Item 갯수를 리턴한다.
   * @return item count number
   * @type Number
   */
  this.getLength = null;
  /**
   * 해당 index의 Node를 리턴한다.
   * @param {Number} pnIdx index
   * @return Node Object
   * @type eXria.data.Node
   */
  this.item = null;
};
/**
 * @fileoverview
 * Node의 Value를 관리하기 위한 클래스의 Interface
 */
/**
 * Node의 Value를 관리하기 위한 클래스의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.Node
 */
eXria.data.ValueNode = function(poNode) {
  /**
   * inherit
   */
  eXria.data.Node.call(this, poNode);
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.
   * @return TextNode 값
   * @type String
   */
  this.getValue = null;
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * @param {String} psValue value
   * @return void
   * @type void
   */
  this.setValue = null;
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {String} psFix default value
   * @return TextNode의 값 또는 argument의 값
   * @type String
   */
  this.getString = null;
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.<br/>
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {String} psValue value
   * @param {String} psFix alternate value
   * @return void
   * @type void
   */
  this.setString = null;
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {Number} pnFix alternate value
   * @return Number로 치환된 TextNode 값
   * @type Number
   */
  this.getNumber = null;
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.<br/>
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {Number} pnValue value
   * @param {Number} pnFix alternate value
   * @return void
   * @type void
   */
  this.setNumber = null;
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {Boolean} pbFix alternate value
   * @return boolean으로 치환된 TextNode 값
   * @type Boolean
   */
  this.getBoolean = null;
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {Boolean} puValue value
   * @param {Boolean} pbFix alternate value
   * @return void
   * @type void
   */
  this.setBoolean = null;
};

/**
 * @fileoverview
 * Curd 사용시 타입을 결정하는 상수 클래스</br>
 * enum list</br>
 * - eXria.data.CrudType.UNCHANGEDFLAG : 데이터셋의 로우가 변경이 되지 않은 상태</br>
 * - eXria.data.CrudType.ADDEDFLAG : 추가된 로우일 경우</br>
 * - eXria.data.CrudType.DELETEDFLAG : 삭제된 로우일 경우</br>
 * - eXria.data.CrudType.MODIFIEDFLAG : 자료가 수정된 경우</br>
 * - eXria.data.CrudType.CRUDALLTYPE : Create, Read, Update, Delete 모든 변경 상태일 경우</br>
 * - eXria.data.CrudType.EXCEPDELETEALLTYPE : 삭제상태를 제외한 상태일 경우
 */
/**
 * Curd 사용시 타입을 결정하는 상수 클래스
 * @author Choe, Hyeon Jong
 * @version 1.0
 * @constructor
 */
eXria.data.CrudType = {
  UNCHANGEDFLAG     : 0X0001,
  ADDEDFLAG       : 0X0002,
  DELETEDFLAG     : 0X0004,
  MODIFIEDFLAG      : 0X0008,
  EMPTYEDFLAG       : 0X0010,
  CRUDALLTYPE     : 0X000E,
  EXCEPDELETEALLTYPE  : 0X000C
};
/**
 * @fileoverview
 * DataSet 사용시 내부의 메서드를 래핑해주는 클래스의 Interface
 */
/**
 * DataSet 사용시 내부의 메서드를 래핑해주는 클래스의 Interface
 * @author Choe, hyeon jong.
 * @version 1.0
 * @param {Object} poDataSet dataset
 * @constructor
 */
eXria.data.DataSetCmd = function(psId, poModel) {
  /**
   * DataSet Id
   * @type String
   */
  this.id = psId;
  /**
   * model
   * @private
   */
  this.model = poModel;
  /**
   * dataset Object
   * @private
   */
  this.dataSet = this.model.plugin.getDataSet(this.id);
  /**
   * Primary key 정보를 설정한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 설정할 primary key
   * @return void
   * @type void
   */
  this.addPrimaryKey = null;
  /**
   * column 정보를 update 한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName update 할 값
   * @return void
   * @type void
   */
  this.addUpdateColumn = null;
  /**
   * source와 target의 index를 설정한다.
   * @param {Number} pnSourceIndex 대상 src index
   * @param {Number} pnTargetIndex 대상 target index
   * @return void
   * @type void
   */
  this.changeRowIndex = null;
  /**
   * 해당 테이블에서 primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 테이블 이름
   * @return void
   * @type void
   */
  this.clearPrimaryKeys = null;
  /**
   * sort parameter를 clear 한다.
   * @return void
   * @type void
   */
  this.clearSortItem = null;
  /**
   * column 정보를 clear 한다.
   * @param {String} psTableName 대상 table name
   * @return void
   * @type void
   */
  this.clearUpdateColumns = null;
  /**
   * 현재 DataSet에 특정 컬럼을 다른 DataSet으로 복사한다.
   * @param {String} psScrCol 원본 컬럼명
   * @param {String} psDataSetId 복사할 데이터셋 Id명
   * @return 복사 성공 여부 성공시 True
   * @type Boolean
   */
  this.cloneCol = null;
  /**
   * XPath filter 설정
   * @param {String} psXPath 적용대상 경로
   * @param {Boolean} pbApply 적용 유무
   * @param {Boolean} pbViewDelFlagRow delete flag row를 보이고자 할 경우 true 보이지 말고자 할 경우 false
   * @return -1
   * @type Number
   */
  this.compositeFilter = null;
  /**
   * xpath를 이용하여 필터링된 자료의 DataSet RowID를 알아낸다.
   * @param {String} psXPath 해당 DataSet에서 추출 하고자 하는 컬럼의 연산식
   * @return 해당 연산으로 필터링 된 RowIndex를 문자열로 ','로 구분하여 리턴한다.
   * 결과 값이 없을 경우 ""을 리턴한다.
   * @type String
   */
  this.compositeIdx = null;
  /**
   * 찾고자 하는 Column:Value 쌍을 복수로 입력하여 값에 해당하는 RowID를 "," 구분하여 리턴한다.
   * 인자 값은 컬럼명과 그 컬럼에서 찾을 Value를 ":"로 구분하여 넣어주고 복수개일 경우 Column:Value쌍을 ","로 구분하여
   * 다수개의 조건을 넣어 줄 수 있다.
   * @param {String} psKeyArray 찾고자 하는 DataSet의 Column명
   * @return ","로 구분되어진 문자열
   * @type String
   */
  this.find = null;
  /**
   * 주어진 index의 row를 delete 한다.
   * @param {Number} pnIndex 삭제 대상 row의 index
   * @return index가 범위를 넘으면 -1 리턴
   * @type Number
   */
  this.deleteRow = null;
  /**
   * 주어진 row의 fieldname을 통한 value 질의
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @return 조회 결과 리턴
   * @type String
   */
  this.get = null;
  /**
   * 컬럼의 수를 리턴
   * @return 컬럼의 수
   * @type Number
   */
  this.getColCnt = null;
  /**
   * 주어진 컬럼 인덱스에 해당하는 컬럼 명을 반환하는 메소드
   * @return 주어진 컬럼 인덱스에 해당하는 컬럼 명
   * @param {Number} pnIndex 컬럼 인덱스
   * @type String
   */
  this.getColName = null;
  /**
   * DataSet의 CRUD Node의 속성을 리턴한다.
   * @param {String} psAttrName 해당 속성 명
   * @return 해당 속성명에 속성값을 리턴한다.
   * @type String
   */
  this.getCRUDAttr = null;
  /**
   * index 값을 얻는다
   * @return index값 리턴
   * @type Number
   */
  this.getIndex = null;
  /**
   * Row에 설정한 특정 속성을 가져온다.
   * @param {Number} pnIndex 조회할 Row 번호
   * @param {String} psAttrName 질의 할 속성 명
   * @return 속성 값
   * @type String
   */
  this.getRowAttr = null;
  /**
   * Row 갯수를 얻는다
   * @return Row Count 값
   * @type Number
   */
  this.getRowCnt = null;
  /**
   * DataSet에 설정한 Sort 정보를 Node Path 별로 질의하여 결과를 리턴한다.
   * @param {String} psRef 컬럼 Node Path
   * @return 질의한 소트 정보
   * @type String
   */
  this.getSortItem = null;
  /**
   * DataSet에 설정한 Sort Item의 Column 정보를 리턴한다.<br/>
   * 여러개의 Column 정보가 있을 경우 "," 딜리미터를 이용하여 분리하여 리턴
   * @return Sort Item에 존재하는 Column 명
   * @type String
   */
  this.getSortItemColumNames = null;
  /**
   * crud type을 얻는다
   * @param {Number} pnIndex 조회대상 index
   * @return CrudType Number
   * @type Number
   */
  this.getStatus = null;
  /**
   * 모든 Row 상태 중 입력한 상태를 가지고 있는 Row에 index 값을 구분자로 연결하여 리턴한다.
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.getStatusIndex(eXria.data.CrudType.ADDEDFLAG, ";");
   * @param {Number} pnType 조회대상 CRUDTYPE (eXria.data.CrudType)
   * @param {String} psDelimeter 연결할 구분자, 생략할 경우 ',' 기본 설정
   * @return 입력 상태를 가진 Row의 index값
   * @type String
   */
  this.getStatusIndex = null;
  /**
   * 주어진 index에 새로운 row를 insert 한다
   * @param {Number} pnIndex Insert 대상 Index
   * @param {Boolean} pbAfter pnIndex 뒤에 추가 유무
   * @return insert 후 row 갯수
   * @type Number
   */
  this.insertRow = null;
  /**
   * DataSet을 Rebuild 한다.
   * @param {Boolean} pbAdd Add 유무 설정
   * @return Row Count
   * @type Number
   */
  this.rebuild = null;
  /**
   * primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 삭제할 primary key 값
   * @return void
   * @type void
   */
  this.removePrimaryKey = null;
  /**
   * column 정보를 remove 한다
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName remove 할 값
   * @return void
   * @type void
   */
  this.removeUpdateColumn = null;
  /**
   * instance를 reset 한다
   * @param {Boolean} pbResetInstance 연결된 Instance와 동기화 여부를 결정한다. false시에 동기화 된다.
   * @return void
   * @type void
   */
  this.reset = null;
  /**
   * 원본값으로 restore 한다
   * @param {Boolean} pbAll all 유무
   * @return void
   * @type void
   */
  this.restoreOriginVal = null;
  /**
   * 주어진 row의 fieldname에 value를 설정한다
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @param {String} psValue 설정할 값
   * @return 성공 : 1, 실패 : 0
   * @type Number
   */
  this.set = null;
  /**
   * Data 동기화 설정을 한다
   * @param {Boolean} pbSync 동기화 여부 설정
   * @return void
   * @type void
   */
  this.setDataSync = null;
  /**
   * index를 설정한다
   * @param {Number} pnIndex 설정할 index 값
   * @return void
   * @type void
   */
  this.setIndex = null;
  /**
   * table에 prefix를 설정한다
   * @param {String} psTableName 설정 대상
   * @param {String} psPrefix 설정할 값
   * @return void
   * @type void
   */
  this.setPrefix = null;
  /**
   * 해당 Row에 속성을 설정한다
   * @param {Number} pnIndex Row Number
   * @param {String} psAttrName 속성 명
   * @param {String} psAttrVal 속성 값
   * @return void
   * @type void
   */
  this.setRowAttr = null;
  /**
   * sort item을 설정한다
   * @param {String} psNodeName 대상 Node 설정
   * @param {Number} pnType 1 : text, 0 : not text
   * @param {Boolean} pbAscending true : 오름차순, false : 내림차순
   * @return void
   * @type void
   */
  this.setSortItem = null;
  /**
   * 원하는 index에 CRUD type을 설정한다
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.setStatus(1, eXria.data.CrudType.MODIFIEDFLAG);
   * @param {Number} pnIndex 설정할 index
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatus = null;
  /**
   * CRUD type을 설정한다
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.setStatusAll(eXria.data.CrudType.MODIFIEDFLAG);
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusAll = null;
  /**
   * 범위로 입력한 Row에 CRUD Type으로 설정한다.
   *  ex) page.getDataSet("dataset1").setStatusRange(1, 2, eXria.data.CrudType.ADDEDFLAG);
   * @param {Number} pnStart 시작 Row 번호
   * @param {Number} pnEnd 종료 Row 번호
   * @param {Number} pnType CRUDTYPE (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusRange = null;
  /**
   * set은 값을 변경 하면서 동시에 그 Row에 상태값을 수정된 상태로 변경 하지만
   * 이 메서드는 status를 변경하지 않고 단지 value만을 변경 한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName Field Name
   * @param {String} psValue 설정할 값
   * @return 성공하면 1, 실패하면 0
   * @type Number
   */
  this.simpleSet = null;
  /**
   * sort를 수행한다
   * @return void
   * @type void
   */
  this.sort = null;
  /**
   * 현재 DataSet에 설정 되어 있는 PrimaryKey들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명. ""일 경우 모든 테이블의 primary key를 반환
   * @type String
   * @return Primary Key 값들
   */
  this.getPrimaryKeys = null;
  /**
   * 현재 DataSet에 설정 되어 있는 update column들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명.
   * @type String
   * @return 현재 DataSet에서 입력한 table에 설정 되어 있는 UpdateColumn들을 "," 구분자로 하여 문자열로 리턴한다.
   */
  this.getUpdateCols = null;
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블명들을 "," 구분자로 하여 문자열로 리턴한다.
   * @type String
   * @return  DataSet에 등록 되어져 있는 AutoCRUD처리 테이블들의 이름을 리턴한다. 복수개일 경우 "," 구분자로 구분하여 리턴한다.
   */
  this.getCRUDTableNames = null;
  /**
   * DataSet에서 삭제된 로우의 전체 count를 리턴한다.
   * @type Number
   * @return delete된 row의 전체 수.
   */
  this.getDelTableRowCnt = null;
  /**
   * DataSet에서 삭제된 로우 중 해당 인덱스와 컬럼명의 값을 리턴한다.
   * @param {Number} pnIdx Row Index
   * @param {String} psFieldName 컬럼 명
   * @return index 조건으로 검색된 삭제 row의 해당 컬럼의 값.
   * @type String
   */
  this.getDelTableValue = null;
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블을 등록하는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return void
   * @type void
   */
  this.addCRUDTable = null;
  /**
   * DataSet에 CRUD 테이블에서 해당 테이블 명을 가지고 있는 테이블을 삭제한다.
   * @param {String} psTableName 삭제할 테이블 명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeCRUDTable = null;
  /**
   * 현재 DataSet에 등록된 request 테이블의 prefix를 얻어오는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return 첫 인자로 입력한 아이디를 가지는 테이블의 Prefix 값을 문자열로 리턴하여 준다.
   * @type String
   */
  this.getPrefix = null;
  /**
   * submission에 추가할 수 있는 CRUD 문자열 정보를 반환해주는 메소드.
   * @param {Boolean} pbGetUnchanged Unchanged Status의 row데이타 정보도 가져올지 여부
   * @type String
   * @return submission에 추가할 수 있는 CRUD 문자열 정보를 반환
   */
  this.getAutoCRUDString = null;
  /**
   * 해당 Row에서 필드명과 일치하는 곳에 수정 바로 이전 값을 리턴한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @type String
   * @return 수정되기 이전 값을 리턴한다. 이 기능을 쓰기 위해서는 Keep the Original Data 속성이 설정 되어 있어야 한다.
   */
  this.getOrigin = null;
  /**
   * DataSet과 원본 데이터와의 Sync 상태를 리턴한다.
   * @return Sync 상태시 True 리턴
   * @type Boolean
   */
  this.isDataSync = null;
  /**
   * DataSet의 Keep Original Value 상태 리턴
   * @return Keep 상태시 True 리턴
   * @type Boolean
   */
  this.isKeepOriginalValue = null;
  /**
   * CRUD에 관계된 데이타셋 속성 값을 설정하기 위한 메소드.
   * - submission에서 데이타셋으로 부터 unchanged status의 row정보를 하져올 때 setCRUDAttr("alltype", "true")를 호출함.
   *   해제시에는 setCRUDAttr("alltype", "false")를 호출함.
   * @param {String} psName 속성명
   * @param {String} psValue 속성값
   * @return void
   * @type void
   */
  this.setCRUDAttr = null;
  /**
   * 현재 DataSet을 초기화 시킨다.
   * @type void
   * @return void
   */
  this.refresh = null;
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 추가한다.
   * @param {Array} paCol 추가할 컬럼 Array
   * @type void
   * @return void
   */
  this.addSkipSCList = null;
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트 중 파라미터로 넘어온 컬럼들을 삭제한다.
   * @param {Array} paCol 삭제할 컬럼 Array
   * @type void
   * @return void
   */
  this.removeSkipSCList = null;
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 전부 삭제한다.
   * @type void
   * @return void
   */
  this.clearSkipSCList = null;
  /**
   * DataSet에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {Number} pnIndex 컬럼을 삽입시킬 위치 값
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.addColumn = null;
  /**
   * DataSet의 마지막에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.appendColumn = null;
  /**
   * DataSet에 해당 컬럼명을 가지고 있는 컬럼을 삭제한다.
   * @param {String} psColName 삭제할 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeColumn = null;
  /**
   * dataset의 Source Type을 리턴한다.
   * @return dataset의 Source Type
   * @type {Number}
   */
  this.getSrcType = null;
  /**
   * dataset의 Connection Info를 리턴한다.
   * @return dataset의 Connection Info
   * @type {String}
   */
  this.getConnectionInfo = null;
  /**
   * dataset의 Source Query를 리턴한다.
   * @return dataset의 Source Query
   * @type {String}
   */
  this.getSourceQuery = null;
  /**
   * DataSet의 특정 Row에 해당하는 실제 Instance의 Row를 반환한다.
   * @param {Number} pnIdx 실제 리턴 받기를 원하는 DataSet Row Number
   * @return Instance Row 번호
   * @type {Number}
   */
  this.getInstanceRowIndex = null;
};
/**
 * @fileoverview
 * eXria.data.xhtml Package
 */
/**
 * eXria.data.xhtml package
 * @author Choe, hyeon jong.
 */
eXria.data.xhtml = {};
/**
 * @fileoverview
 * XHTML Mode 사용시 Document Node를 Collection으로 wrapping 해주는 클래스
 */
/**
 * XHTML Mode 사용시 Document Node를 Collection으로 wrapping 해주는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.xhtml.Node
 */
eXria.data.xhtml.CollectionNode = function(poNode) {
  if(page.metadata.useJsonInstance) {
    eXria.data.json.CollectionNode.call(this, poNode);
    return;
  }
  /**
   * inherit
   */
//  if(page.metadata.modelType == eXria.form.ModelType.PLUGIN) {
//    eXria.data.plugin.Node.call(this, poNode.node);
//  } else {
//  eXria.data.xhtml.Node.call(this, poNode.node);
//  }
  this.node = poNode;
  /**
   * 노드의 리스트 저장 속성
   * @private
   */
  this.nodeList = null;
  /**
   * Collection에 파라미터로 넘어온 Node를 추가한다.
   * @param {XMLNode} poNode 추가할 Node
   * @return void
   * @type void
   */
  this.add = function(poNode) {
    try {
      this.node.appendChild(poNode);
      this.nodeList[this.cnt] = poNode;
      this.cnt++;
    } catch(err) {
      throw err;
    }
  };
  /**
   * 현재 Collection의 Item 갯수를 리턴한다.
   * @return 하위 ElementNode의 갯수
   * @type Number
   */
  this.size = function() {
    return this.cnt;
  };
  /**
   * Parameter로 넘어온 Index에 해당하는 위치의 Node를 리턴한다.
   * @param {Number} pnIndex 리턴받은 Node의 Index
   * @return 해당 Index의 Node. Index가 Node의 범위 밖인 경우 null을 리턴한다.
   * @type  XMLNode
   */
  this.get = function(pnIndex) {
    var voNodeList = this.nodeList;
    return voNodeList[pnIndex];
  };
  /**
   * 주어진 값이 현재 Node 구성 요소의 인덱스 번호로서 적합한 지 여부를 검사하는 메소드
   * Collection의 Range안에 없을 경우 Error Throw.
   * @param {Number} pnIndex 체크할 Index
   * @return void
   * @type void
   * @private
   */
  this.rangeCheck = function(pnIndex) {
    if (pnIndex < 0 || pnIndex > this.cnt) {
      throw new Error("Index out of range : " + pnIndex);
    }
  };
  /**
   * Collection에서 Parameter로 넘어온 Index에 해당되는 위치에 두번째 Parameter로 넘어온 Node를 추가한다. 만약 해당 Index에 기존 Node가 존재할 경우 기존 Node는 삭제 된다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type XMLNode
   */
  this.set = function(pnIndex, poNode) {
    var vnSize = this.cnt;
    if (vnSize < pnIndex) {
      throw new Error("Index out of range : " + pnIndex);
    } else if (vnSize == pnIndex) {
      this.add(poNode);
      return null;
    } else {
      var voOldNode = null;
//      voOldNode = this.node.replaceChild(poNode, this.get(pnIndex));
    voOldNode = this.node.replaceChild(poNode, this.get(pnIndex));
      if(voOldNode) this.nodeList[pnIndex] = poNode;
      return poNode;
    }
  };
  /**
   * 넘겨 받은 Index에 Node를 추가 한다. 해당 Index에 기존에 Node가 존재 할 경우 해당 Node 및 이후 Index의 Node들의 Index가 하나씩 밀린다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type XMLNode
   */
  this.insert = function(pnIndex, poNode) {
    var vnSize = this.cnt;
    if(vnSize < pnIndex - 1) { // over
      throw new Error("Index out of range : " + pnIndex);
    } else if(vnSize == pnIndex - 1) { // last
      this.add(poNode);
      return null;
    } else {
//      poNode = this.node.insertBefore(poNode, this.get(pnIndex));
    poNode = this.node.insertBefore(poNode, this.get(pnIndex));
      this.nodeList.splice(pnIndex, 0, poNode);
      this.cnt++;
      return poNode;
    }
  };
  /**
   * Parameter로 넘어온 Index에 해당하는 Node를 삭제한다.
   * @param {Number} pnIndex 삭제할 Node Index
   * @return 삭제된 Node 참조값
   * @type XMLNode
   */
  this.remove = function(pnIndex) {
//    var voNode = this.node.removeChild(this.get(pnIndex));
  var voNode = this.node.removeChild(this.get(pnIndex));
    if(voNode) {
      this.nodeList.splice(pnIndex, 1);
      this.cnt--;
    }
    return voNode;
  };
  /**
   * Collection의 모든 Node를 삭제 하고 Collection을 초기화 한다.
   * @return void
   * @type void
   */
  this.clear = function() {
//    var voNode = this.node;
//    var voNodes = voNode.childNodes;
  var voNodes = this.node.getChildNodes();
//    var vnLength = voNodes.length;
  var vnLength = voNodes.getLength();
    var voItem = null;
    for (var i = 0; i < vnLength; i++) {
      voItem = voNodes.item(0);
      this.node.removeChild(voItem);
    }
    this.nodeList = [];
    this.cnt = 0;
  };
  /**
   * 현재 Collection이 비어 있는지 체크하여 리턴한다.
   * @return 비어있는 노드일 경우 TRUE, 아닐 경우 FALSE
   * @type Boolean
   */
  this.isEmpty = function() {
    return (this.size() == 0);
  };
  /**
   * 현재 Collection의 모든 Node를 Iterator로 변환하여 리턴한다.
   * @return 내부객체를 조회하는 Iterator
   * @type eXria.data.ArrayIterator
   * @see eXria.data.ArrayIterator
   */
  this.iterator = function() {
  this.elements = this.nodeList;
    return new eXria.data.ArrayIterator(this);
  };
  /**
   * 현재 메소드 이름을 리턴한다.
   * @return 내부요소를 파싱한 String 값
   * @type String
   */
  this.toString = function() {
    return "CollectionNode";
  };
  /**
   * 반복되는 하위 노드의 tagName 저장 속성
   * @return void
   * @type void
   * @private
   */
  this.reset = function() {
    var vnSize = 0;
    var vaNodeList = [];
    var voNodes = this.node.getChildNodes();
    if(voNodes == null) {
      this.nodeList = [];
      this.cnt = vnSize;
      return ;
    }
    var vnLength = voNodes.getLength();
    var voItem = null;
    for(var i = 0; i < vnLength; i++) {
      voItem = voNodes.item(i);
      if (voItem.getNodeType() == 1) { // Element
        vaNodeList.push(voItem);
      }
    }
    vnSize = vaNodeList.length;
    this.nodeList = vaNodeList;
    this.cnt = vnSize;
  };
  /**
   * 생성시 reset 메소드 호출
   * @private
   */
  this.reset();
};

/**
 * @fileoverview
 * XHTML Mode 사용시 Document를 관리하는 클래스
 */
/**
 * XHTML Mode 사용시 Document를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {eXria.data.Instance} poInstance Model Instance
 * @constructor
 * @base eXria.data.Document
 */
eXria.data.xhtml.Document = function(poInstance) {
  /**
   * inherit
   */
  eXria.data.Document.call(this);
  /**
   * XMLDocument
   * @type XMLDocument
   * @private
   */
  this.dom = null;
  /**
   * 파라미터로 넘겨받은 URL에 존재하는 XML을 로드하여 바인딩
   * @param {String} psUrl 로딩할 XML이 존재하는 URL
   * @return void
   * @type void
   * @private
   */
  this.loadURL = function(psUrl) {
    var voRequest = eXria.form.xhtml.HttpRequestFactory.create();

    voRequest.open("GET", psUrl, false);
    voRequest.send(null);

    if(voRequest.status == 200) {
      delete this.dom;
      this.dom = voRequest.responseXML;
    }
  };
  /**
   * 넘겨받은 Tag Name의 Element Node를 생성하여 리턴한다.
   * @param {String} psName 생성할 Element Tag Name
   * @return 생성된 XML Element Node
   * @type XMLElementNode
   */
  this.createNode = function(psName) {
    return this.dom.createElement(psName);
  };
  /**
   * 넘겨받은 XPath의 Node를 삭제한다.
   * @param {String} 삭제할 XPath
   * @return void
   * @type void
   */
  this.removeNode = function(psXpath) {
    var voNode = this.selectSingleNode(psXpath);
//    if (voNode == null) { throw new Error("Can not find the node : " + psXpath); }
    if (voNode == null) return null;
    return voNode.parentNode.removeChild(voNode);
  };
};



/**
 * @fileoverview
 * Document를 Browser Type에 맞도록 생성하여 리턴하는 클래스
 */
/**
 * Document를 Browser Type에 맞도록 생성하여 리턴하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @constructor
 * @private
 */
eXria.data.xhtml.DocumentFactory = {
  /**
   * 사용자 Browser Type에 맞는 XMLDocument를 생성하여 리턴한다.
   * @return eXria.data.Document
   * @private
   */
  createDocument : function(poPage, psId) {
    var voDocument = null;
    if(window.ActiveXObject !== undefined) {
    voDocument = new eXria.data.xhtml.MsieDocument(poPage, psId);
    } else if(window.document.implementation && window.document.implementation.createDocument) {
    voDocument = new eXria.data.xhtml.GeckoDocument(poPage, psId);
    }
    return voDocument;
  }
};

/**
 * @fileoverview
 * 사용자의 Browser Type에 따라 DOM을 생성하는 클래스
 */
/**
 * 사용자의 Browser Type에 따라 DOM을 생성하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @constructor
 * @private
 */
eXria.data.xhtml.DomFactory = {
  /**
   * 사용자의 Browser에 따라 XMLDocument를 생성한다.
   * @return 생성한 브라우저 종속적인 Document
   * @type XMLDocument
   * @private
   */
  createDom : function() {
    var voDom = null;
    if (window.ActiveXObject !== undefined) {
      try {
        voDom = new ActiveXObject("Microsoft.XMLDOM");
      } catch (e) {}
      voDom.setProperty("SelectionLanguage", "XPath");
    } else if (window.document.implementation && window.document.implementation.createDocument) {
      try {
        voDom = window.document.implementation.createDocument("", "", null);
      } catch (e) {}
    }
    if (voDom == null) { throw new Error("Can not create Document."); }
    return voDom;
  }
};

/**
 * @fileoverview
 * FireFox, Safari, Chrome, Opera 등의 Document를 생성하는 클래스
 * @private
 */
/**
 * FireFox, Safari, Chrome, Opera 등의 Document를 생성하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @base eXria.data.xhtml.Document
 * @constructor
 * @private
 */
eXria.data.xhtml.GeckoDocument = function(poPage) {
  /**
   * inherit
   */
  eXria.data.xhtml.Document.call(this);
  /**
   * page Object
   * @type Object
   */
  this.page = poPage;
  /**
   * dom Object
   * @type Object
   * @private
   */
  this.dom = this.page.window.document.implementation.createDocument("", "", null);
  if (this.dom == null) { throw new Error("Can not create Document."); }
  /**
   * 넘겨받은 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 XML Element
   * @type XMLElementNode
   * @private
   */
  this.selectSingleNode = function(psXpath) {
  try {
      var voXPathResult = this.dom.evaluate(psXpath, this.dom, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
      return voXPathResult.singleNodeValue;
  } catch(e) {
      return null;
  }
  };
  /**
   * 넘겨받은 XPath에 해당하는 Node들을 조회하여 NodeList로 리턴한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 NodeList를 Wrapping한 NodeList 객체
   * @type eXria.data.NodeList
   * @private
   */
  this.selectNodes = function(psXpath) {
    try {
      var voXPathResult = this.dom.evaluate(psXpath, this.dom, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      return new eXria.data.xhtml.GeckoNodeList(voXPathResult);
    } catch(e) {
        return null;
    }
  };
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   * @private
   */
  this.loadXML = function(poXML) {
    if(this.dom.documentElement) {
      this.dom.replaceChild(poXML, this.dom.documentElement);
    } else {
      this.dom.appendChild(poXML.cloneNode(true));
    }
  };
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   * @private
   */
  this.loadTXT = function(psTXT) {
    var voParser = new eXria.data.xhtml.GeckoDOMParser();
    var voDom = voParser.parse(psTXT);
    delete this.dom;
    this.dom = voDom;
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 alert으로 출력
   * @param {String} poNode print 하고자 하는 XML Node
   * @return void
   * @type void
   * @private
   */
  this.print = function(poNode) {
  if(poNode == null && poNode == undefined) {
    throw new Error("Node is null.");
  } else {
    var vSerializer = new XMLSerializer();
    alert(vSerializer.serializeToString(poNode));
  }
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = function(poNode) {
  if(poNode == null && poNode == undefined) {
    throw new Error("Node is null.");
  } else {
    var vSerializer = new XMLSerializer();
    return vSerializer.serializeToString(poNode);
  }
  };
};

/**
 * @fileoverview
 * FireFox, Safari, Chrome, Opera Browser의 Dom Parser 클래스
 */
/**
 * FireFox, Safari, Chrome, Opera Browser의 Dom Parser 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @base eXria.data.DOMParser
 * @constructor
 * @private
 */
eXria.data.xhtml.GeckoDOMParser = function() {
  eXria.data.DOMParser.call(this);
  /**
   * Gecko DOM Parser
   * @type DOMParser
   * @private
   */
  this.parser = new DOMParser();
  /**
   * XML Text 값을 XMLDocument로 Parsing한다.
   * @param {String} psData XML Test
   * @return Parsing된 XMLDocument
   * @type XMLDocument
   */
  this.parse = function(psData) {
    return this.parser.parseFromString(psData, "text/xml");
  };
};
/**
 * @fileoverview
 * FireFox, Safari, Chrome, Opera의 XML Node를 List로 wrapping 하는 클래스
 */
/**
 * FireFox, Safari, Chrome, Opera의 XML Node를 List로 wrapping 하는 클래스
 * @version 2.0
 * @param {XPathResult} Gecko XPath Result Object
 * @base eXria.data.NodeList
 * @constructor
 * @private
 */
eXria.data.xhtml.GeckoNodeList = function(poResult) {
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);
  /**
   * Gecko XMLResult
   * @type XMLPathResult
   * @private
   */
  this.xpathResult = poResult;
  /**
   * return Item count in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
    if(this.xpathResult == null) {
      return 0;
    } else {
      return this.xpathResult.snapshotLength;
    }
  };
  /**
   * return NodeItem of parameter index
   * @param {Number} pnIdx index
   * @return node
   * @type XMLNode
   */
  this.item = function(pnIdx) {
    return this.xpathResult.snapshotItem(pnIdx);
  };
};
/**
 * @fileoverview
 * XHTML Mode에서의 Instance 객체를 관리하는 클래스
 */
/**
 * XHTML Mode에서의 Instance 객체를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {String} psId Instance Id
 * @param {eXria.form.Model} poModel eXria Model Objecct
 * @constructor
 * @base eXria.data.Instance
 */
eXria.data.xhtml.Instance = function(psId, poModel) {
  if(page.metadata.useJsonInstance) {
    eXria.data.json.Instance.call(this, psId, poModel);
    return;
  }
  /**
   * inherit
   */
  eXria.data.Instance.call(this, psId, poModel);
  /**
   * document
   * @type Object
   */
  this.document = eXria.data.xhtml.DocumentFactory.createDocument(
      this.model.page, psId);
  /**
   * 특정 URL의 XML Document를 인스턴스에 바인딩한다.
   * @param {String} psUrl 바인딩할 XML의 URL
   * @return void
   * @type void
   */
  this.loadURL = function(psUrl) {
    this.document.loadURL(psUrl);
  };
  /**
   * XML Element를 인스턴스에 바인딩한다.
   * @param {XMLElement} poXML 바인딩할 XMLElement
   * @return void
   * @type void
   */
  this.loadXML = function(poXML) {
    this.document.loadXML(poXML);
  };
  /**
   * XML Text를 파싱하여 인스턴스에 바인딩한다.
   * @param {String} psTxt 파싱할 XML Text
   * @return void
   * @type void
   */
  this.loadTXT = function(psTxt) {
    this.document.loadTXT(psTxt);
  };
  /**
   * Node를 주어진 타입에 따라 생성하여 그 객체를 리턴한다.
   * @param {String} psNodeName 생성할 node Name
   * @param {String}  psValue 생성할 Node의 Value
   * @type XMLNode
   * @return 생성된 XML Node
   */
  this.createNode = function(psNodeName, psValue) {
    var voNewNode = null;
    try {
      voNewNode = this.document.createNode(psNodeName);
      if (psValue) {
        voNewNode.appendChild(voNewNode.ownerDocument.createTextNode(psValue));
      }
    } catch (e) {
      return null;
    }
    return new eXria.data.xhtml.Node(voNewNode);
  };
  /**
   * 파라미터로 넘어온 이름의 Element를 생성하여 리턴한다.
   * @param {String} psElementName 생성될 엘리먼트 이름
   * @return 생성된 Element Node
   * @type eXria.data.Node
   * @see eXria.data.Node
   */
  this.createElement = function(psElementName) {
    if(!psElementName) { return null; }
    return this.createNode(psElementName, null);
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 ValueNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 ValueNode
   * @type eXria.data.xhtml.ValueNode
   * @see eXria.data.xhtml.ValueNode
   */
  this.createValueNode = function(psName) {
    var voNode = this.document.createNode(psName);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.ValueNode(new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 MapNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 MapNode
   * @type eXria.data.xhtml.MapNode
   * @see eXria.data.xhtml.MapNode
   */
  this.createMapNode = function(psName) {
    var voNode = this.document.createNode(psName);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.MapNode(new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 CollectionNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 CollectionNode
   * @type eXria.data.xhtml.CollectionNode
   * @see eXria.data.xhtml.CollectionNode
   */
  this.createCollectionNode = function(psName) {
    var voNode = this.document.createNode(psName)
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.CollectionNode(
        new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨 받은 XPath의 하위에 Node를 추가한다.
   * @param {String} psPath 추가할 위치에 해당하는 XPath
   * @param {XMLNode} poNode 추가할 XMLNode
   * @return void
   * @type void
   */
  this.appendNode = function(psPath, poNode) {
    var voNode = null;
    voNode = this.document.selectSingleNode(psPath);
    if (voNode == null) {
      throw new Error("Can not find the node : " + psPath);
    }

    voNode = new eXria.data.xhtml.Node(voNode);
    voNode.appendChild(poNode);
  };
  /**
   * 넘겨받은 XPath를 단순 Value형태로 처리하기 위한 ValueNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 ValueNode
   * @type eXria.data.xhtml.ValueNode
   * @see eXria.data.xhtml.ValueNode
   */
  this.getValueNode = function(psXpath) {
    var voNode = this.document.selectSingleNode(psXpath);
    if (voNode == null) {
      return null;
    }
    return new eXria.data.xhtml.ValueNode(new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 파라미터로 넘어온 XPath의 Node Value를 리턴한다.
   * @param {String} psXpath 조회대상의 XPath 경로
   * @type String
   * @return 조회된 Value
   */
  this.getValue = function(psXpath) {
    try {
      var voNode = new eXria.data.xhtml.Node(this.document.selectSingleNode(psXpath));
      return voNode != null ? voNode.getNodeValue() : null;
    } catch (e) {
      return null;
    }
  };
  /**
   * Instance의 dom객체의 XML 내용을 XPath를 이용하여 해당 위치에 데이터를 문자열로 얻는다.
   * @return dom 객체의 XML 문자열
   * @param {String} psXPath XPath 문자열
   * @type String
   */
  this.getXML = function(psXPath) {
    if (!psXPath) {
      return;
    }

    var voNode = this.document.selectSingleNode(psXPath);
    if (voNode == null && voNode == undefined) {
      throw new Error("Cannot find XPath node.");
    } else {
      if (this.model.page.metadata.browser.ie > 0) {
        return voNode.xml;
      } else {
        var vSerializer = new XMLSerializer();
        return vSerializer.serializeToString(voNode);
      }
    }
  };
  /**
   * Instnace의 주어진 XPath 경로에 Value를 설정한다.
   * @param {String} psXpath Value를 설정하기 위한 XPath 경로
   * @param {String} psValue 설정하고자 하는 Value
   * @return void
   * @type void
   */
  this.setValue = function(psXpath, psValue) {
    var voNode = this.document.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    voNode = new eXria.data.xhtml.Node(voNode);
    psValue = (psValue ? psValue : "");
    var vsValue = voNode.setNodeValue(psValue);
  };
  /**
   * 넘겨받은 XPath를 Map형태로 처리하기 위한 MapNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 MapNode
   * @type eXria.data.xhtml.MapNode
   * @see eXria.data.xhtml.MapNode
   */
  this.getMapNode = function(psXpath) {
    var voNode = this.document.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.MapNode(new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨받은 XPath를 Collection형태로 처리하기 위한 CollectionNode를 생성하여 리턴한다.
   * @param {String} psXpath 처리할 기준 Node XPath
   * @return 생성된 CollectionNode
   * @type eXria.data.xhtml.CollectionNode
   * @see eXria.data.xhtml.CollectionNode
   */
  this.getCollectionNode = function(psXpath) {
    var voNode = this.document.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.CollectionNode(
        new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨받은 Xpath의 Node를 삭제한다.
   * @param {String} psXpath 삭제할 Node의 XPath
   * @return 삭제된 노드
   * @type eXria.data.Node
   */
  this.removeNode = function(psXpath) {
  var voNodeObj = null;
  if(typeof(psXpath) == "string") {
      voNodeObj = new eXria.data.xhtml.Node(this.document.removeNode(psXpath));
  } else {
    voNodeObj = psXpath;
    voParentNode = voNodeObj.getParentNode();
    voParentNode.removeChild(voNodeObj);
  }
    return voNodeObj;
  };
  /**
   * 해당 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 Node
   * @type XMLNode
   */
  this.selectSingleNode = function(psXpath) {
    var voNode = this.document.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.Node(voNode);
  };
  /**
   * Instance의 하위Node를 넘겨받은 XPath로 조회하여 리턴한다.
   * @param {String} psXpath 조회할 Xpath
   * @return 생성된 NodeList
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = function(psXpath) {
    var voNodes = this.document.selectNodes(psXpath);
    if (!voNodes) {
      return null;
    }
    return new eXria.data.xhtml.NodeList(voNodes);
  };
  /**
   * Instance의 하위Node들을 넘겨받은 XPath로 조회하여 배열 객체로 반환하는 메소드.
   * plugin 버전은 데이타 호환성 때문에 문자열을 반환받으나 여기서는 배열 객체를 바로 반환함.
   * 일반적으로 이후에 응용코드에서 반환값을 eval하여 사용하게 되는데 이럴경우에만 이 메소드 사용이 가능하고
   * 메소드의 반환값을 문자열로만 취급할 경우에는 사용불가.
   * @param {String} psXpath 조회할 Xpath
   * @return 생성된 NodeList
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodesStr = function(psXpath) {
    var voNodes = this.document.selectNodes(psXpath);
    if (!voNodes) {
      return null;
    }
    var vnCnt = voNodes.getLength();
    var vaNode = [];
    for(var i = 0; i < vnCnt; i++) {
      vaNode.push(voNodes.item(i));
    }
    return vaNode;
  };
  /**
   * 모든 하위노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    delete this.document;
    this.model = null;
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 alert으로 출력
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return void
   * @type void
   */
  this.print = function(psXpath) {
    alert(this.getXML(psXpath));
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = function(psXpath) {
    if (psXpath == null || psXpath == undefined) {
      return;
    }
    return this.getXML(psXpath);
  };
  /**
   * 넘겨 받은 XPath의 Node를 복사하여 리턴한다.
   * @param {String} psXPath 복사할 Node의 XPath
   * @param {String} pbDeep 깊은복사 유무 ( True : Deep Copy )
   * @return 복사된 노드
   * @type XMLNode
   */
  this.cloneNode = function(psXPath, pbDeep) {
    try {
      return new eXria.data.xhtml.Node(this.document.selectSingleNode(psXPath)
          .cloneNode(pbDeep));
    } catch (e) {
      return null;
    }
  };
  /**
   * 해당 XPath 하위에 두번째 파라미터로 넘어온 XML Text Node구조를 생성한다.
   * @param {String} psXpath 생성할 Node의 Parent Node가 될 Node의 XPath
   * @param {String} psTxt 생성할 Node XML Text
   * @return void
   * @type void
   */
  this.appendNodeByTxt = function(psXPath, psTxt) {
    var vsTmpName = "tmp" + new Date().getTime();
    var vsTxt = "<" + vsTmpName + ">" + psTxt + "</" + vsTmpName + ">";
    var vsOrgNodeStr = this.getXML("/root");

    this.loadTXT(vsTxt);
    var voNewNode = this.selectSingleNode("/" + vsTmpName).cloneNode(true);

    this.removeNode("/" + vsTmpName);

    this.loadTXT(vsOrgNodeStr);

    var voNewChild = voNewNode.getChildNodes();
    var vnLen = voNewChild.getLength();

    var voParentNode = this.selectSingleNode(psXPath);

    for(var i = 0 ; i < vnLen ; i++) {
      voParentNode.appendChild(voNewChild.item(i).cloneNode(true));
    }
  };
};

/**
 * @fileoverview
 * XHTML Mode 사용시 Document Node를 Map으로 wrapping 해주는 클래스
 */
/**
 * XHTML Mode 사용시 Document Node를 Map으로 wrapping 해주는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.xhtml.Node
 */
eXria.data.xhtml.MapNode = function(poNode) {
  if(page.metadata.useJsonInstance) {
    eXria.data.json.MapNode.call(this, poNode);
    return;
  }/**
   * inherit
   */
  this.node = poNode;

  /**
   * ChildNode의 Element 갯수를 리턴한다.
   * @return ChildNode중 Element 갯수
   * @type Number
   */
  this.size = function() {
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    var vnSize = 0;
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        // Element
        vnSize++;
      }
    }
    return vnSize;
  };
  /**
   * ChildNode중 넘겨받은 Tag명인 첫번째 노드를 리턴한다.
   * @param {String} psName Tag Name
   * @return 조회된 XMLElementNode
   * @type XMLElementNode
   */
  this.getNode = function(psName) {
    var node = this.node.getElementByTagNameFromChildNodes(psName);
    return node;
  };
  /**
   * ChildNode중 넘겨받은 Tag명인 첫번째 노드의 TextNode값을 리턴한다.
   * @param {String} psKey 조회할 ElementNode의 Tag명
   * @return 조회된 TextNode의 값
   * @type String
   */
  this.get = function(psKey) {
    if (!psKey || psKey == "") {
      return null;
    }
    var voNode = this.getNode(psKey);
    try {
      var vsRet = String(voNode.getNodeValue());
    } catch (e) {
      return null;
    }
    return vsRet;
  };
  /**
   * ChildNode에 넘겨받은 Key값이 존재할 경우 존재하는 ChildNode의 하위 TextNode로 값을 설정하고,</br>
   * 존재하지 않는 경우 ChileNode에 Append한다.
   * @param {String} psKey 설정할 Element Tag Name
   * @param {String} psValue 설정할 Value
   * @return void
   * @type void
   */
  this.put = function(psKey, psValue) {
    var voNode = this.getNode(psKey);
    if (psValue == null || psValue == undefined) psValue = "";
    if (voNode != null) {
      var voValue = voNode.getFirstChild();
      if (voValue != null && (voValue.getNodeType() == 3 || voValue.getNodeType() == 4)) {
        // TextNode, CDataNode
        voNode.replaceChild(this.node.createTextNode(psValue), voValue);

      } else {
        voNode.appendChild(this.node.createTextNode(psValue));
      }
    } else {
      voNode = this.node.createElement(psKey, psValue);
      this.node.appendChild(voNode);
    }
  };
  /**
   * 넘겨받은 값을 Tag Name으로 가지는 첫번째 Node를 삭제한다.
   * @param {String} psKey 삭제할 Tag명
   * @return void
   * @type void
   */
  this.remove = function(psKey) {
    var voNode = this.getNode(psKey);
    if (voNode != null) {
      this.node.removeChild(voNode);
    }
  };
  /**
   * 모든 하위 노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(0);
      if (voNode.getNodeType() == 1) {
        this.node.removeChild(voNode);
      }
    }
  };
  /**
   * 하위 Element의 존재 유무 리턴
   * @return 하위 ElementNode가 없을 경우 true, 아니라면 false
   * @type Boolean
   */
  this.isEmpty = function() {
    return (this.size() == 0);
  };
  /**
   * ChildNode의 Tag명 만으로 구성된 Collection 객체를 리턴한다.
   * @return Tag Name으로 구성된 Collection
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getKeyCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        // Element
        voCollection.add(voNode.getNodeName());
      }
    }
    return voCollection;
  };
  /**
   * ChildNode의 Element 하위 TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @return TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getValueCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        // Element
        voCollection.add(String(voNode.getNodeValue()));
      }
    }
    return voCollection;
  };
  /**
   * ChildNode의 Element, TextNode 및 CDataNode로 구성된 Object Collection 객체를 리턴한다.
   * @return Element, TextNode 및 CDataNode로 구성된 Collection 객체
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getEntryCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    var vsKey = null, voValue = null, vsValue = null;

    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        voValue = voNode.getFirstChild();
        vsValue = String(voNode.getNodeValue())
        vsKey = voNode.getNodeName();

        if (voValue != null && voValue.getNodeType() == 1) {
          voCollection.add({
            key : vsKey, value : voValue.cloneNode(true)
          });
        } else if (vsValue != null) {
          voCollection.add({
            key : vsKey, value : vsValue
          });
        } else {
          voCollection.add({
            key : vsKey, value : null
          });
        }
      }
    }
    return voCollection;
  };
  /**
   * JSON Format String 값으로 리턴한다.
   * @return JSON Format의 xml data
   * @type String
   */
  this.toString = function() {
    var voBuilder = new eXria.lang.StringBuilder();
    voBuilder.append("{");
    voIterator = this.getKeyCollection().iterator();
    while (voIterator.hasNext()) {
      var vsKey = voIterator.next();
      voBuilder.append(vsKey).append("=").append(this.get(vsKey));
      if (voIterator.isLast() == false) {
        voBuilder.append(", ");
      }
    }
    voBuilder.append("}");
    return voBuilder.toString();
  };
};

/**
 * @fileoverview
 * IE Document를 생성하는 클래스
 */
/**
 * IE Document를 생성하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @base eXria.data.xhtml.Document
 * @constructor
 * @private
 */
eXria.data.xhtml.MsieDocument = function(poPage, psId) {
  /**
   * inherit
   */
  eXria.data.xhtml.Document.call(this);
  /**
   * dom Object
   * @type Object
   * @private
   */
  this.dom = eXria.data.DomDocumentFactory.getDomDocument(poPage, psId);

  if (this.dom == null) { throw new Error("Can not create Document."); }
  this.dom.setProperty("SelectionLanguage", "XPath");

  /**
   * 넘겨받은 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 XML Element
   * @type XMLElementNode
   */
  this.selectSingleNode = function(psXpath) {
  try {
    return this.dom.selectSingleNode(psXpath);
  } catch(e) {
    return null;
  }
  };
  /**
   * 넘겨받은 XPath에 해당하는 Node들을 조회하여 NodeList로 리턴한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 NodeList를 Wrapping한 NodeList 객체
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = function(psXpath) {
  try {
    var voNodeList = this.dom.selectNodes(psXpath);
    return new eXria.data.xhtml.MsieNodeList(voNodeList);
  } catch(e) {
    return null;
  }
  };
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   */
  this.loadXML = function(poXML) {
    if(this.dom.documentElement) {
      this.dom.replaceChild(poXML, this.dom.documentElement);
    } else {
//      this.dom.appendChild(poXML);
    eXria.util.DomUtil.appendNodeElement(this.dom, poXML, this);
    }
  };
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   */
  this.loadTXT = function(psTXT) {
    this.dom.loadXML(psTXT);
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 alert으로 출력
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return void
   * @type void
   */
  this.print = function(poNode) {
  if(poNode == null && poNode == undefined) {
    throw new Error("Node is null.");
  } else {
    alert(poNode.xml);
  }
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = function(poNode) {
  if(poNode == null && poNode == undefined) {
    throw new Error("Node is null.");
  } else {
    return poNode.xml;
  }
  };
};

/**
 * @fileoverview
 * IE의 Dom Parser 클래스
 */
/**
 * IE의 Dom Parser 클래스
 * use Microsoft.XMLDOM
 * @version 2.0
 * @base eXria.data.DOMParser
 * @constructor
 * @private
 */
eXria.data.xhtml.MsieDOMParser = function(poPage) {
  eXria.data.DOMParser.call(this);
  /**
   * IE DOM Parser
   * @type DOMParser
   * @private
   */
  this.parser = eXria.data.DomDocumentFactory.getDomDocument(poPage);
  /**
   * String 형태의 XML을 파싱하여 DOM으로 리턴한다.
   * @param {String} psData XML Text
   * @return Parsing된 XMLDocument
   * @type XMLDocument
   */
  this.parse = function(psData) {
    this.parser.loadXML(psData);
    return this.parser;
  };
};
/**
 * @fileoverview
 * IE의 XML Node를 List로 wrapping 하는 클래스
 */
/**
 * IE의 XML Node를 List로 wrapping 하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {NodeList} XML NodeList Object
 * @base eXria.data.NodeList
 * @constructor
 * @private
 */
eXria.data.xhtml.MsieNodeList = function(poResult) {
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);
  /**
   * XMLNodeList
   * @type XMLNodeList
   * @private
   */
  this.nodeList = poResult;
  /**
   * return item count in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
    return this.nodeList.length;
  };
  /**
   * return NodeItem of parameter index
   * @param pnIdx index
   * @return node
   * @type XMLNode
   */
  this.item = function(pnIdx) {
    return this.nodeList.item(pnIdx);
  };
};
/**
 * @fileoverview
 * Document Node Object Class
 */
/**
 * xhtml.Node
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.Node
 */
eXria.data.xhtml.Node = function(poNode, pbDom) {
  if(page.metadata.useJsonInstance && !pbDom) {
    eXria.data.json.Node.call(this, poNode);
    return;
  }
  if (poNode == null) {
    throw new Error("Node is null.");
  }
  /**
   * inherit
   */
//  eXria.data.Node.call(this, poNode);
  /**
   * XMLNode
   * @type XMLElementNode
   * @private
   */
  this.node = poNode;
  /**
   * XMLNode Tag Name
   * @type String
   * @private
   */
  this.name = this.node.nodeName;
};

eXria.data.xhtml.Node.prototype = {
  /**
   * 파라미터로 넘어온 Node를 자식 Node의 마지막에 추가한다.
   * @param {eXria.data.Node} poNode 추가할 Node Object
   * @type void
   * @return void
   */
appendChild : function(poNode) {
  if(!poNode) return;
  this.node.appendChild(poNode.node);
  },
  /**
   * 현재 Node와 동일한 Node를 복사하여 리턴한다.
   * @param {Boolean} pbDeep deep copy 유무를 지정한다. (true | false)
   * @return 복사된 Node Object
   * @type eXria.data.Node
   */
  cloneNode : function(pbDeep) {
  if(pbDeep != true) pbDeep = false;
  return new eXria.data.xhtml.Node(this.node.cloneNode(pbDeep));
  },
  /**
   * 현재 Node의 자식 Node들을 NodeList 형식으로 리턴한다.
   * @type eXria.data.NodeList
   * @return 생성된 자식 Node List
   */
  getChildNodes : function() {
  var voChildNodes = this.node.childNodes;
  if(!voChildNodes) { return null; }
  return new eXria.data.xhtml.NodeList(voChildNodes);
  },
  /**
   * 현재 Node의 첫번째 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 첫번째 자식 Node
   */
  getFirstChild : function() {
  var voNode = this.node.firstChild;
  if(!voNode) { return null; }
  return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * 현재 Node의 마지막 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 마지막 자식 Node
   */
  getLastChild : function() {
  var voNode = this.node.lastChild;
  if(!voNode) { return null; }
  return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * 현재 Node의 바로 다음 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 다음 Node
   */
  getNextSibling : function() {
  var voNode = this.node.nextSibling;
  if(!voNode) { return null; }
  return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * 현재 Node의 이름을 리턴한다.
   * @type String
   * @return 현재 Node의 이름
   */
  getNodeName : function() {
    return this.name;
  },
  /**
   * 현재 Node의 value를 리턴한다.
   * @type String
   * @return 현재 Node의 Value
   */
  getNodeValue : function() {
  var vsValue = null;
  var vnNodeType = this.node.nodeType;
  if(vnNodeType == 1) {
    var voChildNode = this.node.firstChild;
    if(!voChildNode) {
    vsValue = "";
    } else {
      vsValue = voChildNode.nodeValue;
    }
  } else if(vnNodeType == 3 || vnNodeType == 4) {
    vsValue = this.node.nodeValue;
  } else {
    vsValue = null;
  }
  return vsValue;
  },
  /**
   * 현재 Node의 부모 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 부모 Node
   */
  getParentNode : function() {
  var voNode = this.node.parentNode;
  if(!voNode) { return null; }
    return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * 현재 Node의 바로 전 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 바로 전 Node
   */
  getPreviousSibling : function() {
  var voNode = this.node.previousSibling;
  if(!voNode) { return null; }
    return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * Element를 생성하여 리턴한다.
   * @param {String} psTagName 생성할 Element의 Tag Name
   * @param {String} psValue 생성할 Element의 Value [ null을 넘길 경우 TextNode가 생성되지 않은 Element 리턴 ]
   * @type {eXria.data.Node}
   * @return 생성된 Element
   */
  createElement : function(psTagName, psValue) {
  var voNode = null;
  try {
    var voOwnerDocument = this.node.ownerDocument;
    voNode = new eXria.data.xhtml.Node(voOwnerDocument.createElement(psTagName));
    if(psValue != null) {
    voNode.appendChild(new eXria.data.xhtml.Node(voOwnerDocument.createTextNode(psValue)));
    }
  } catch(e) { voNode = null; }
  return voNode;
  },
  /**
   * TextNode를 생성하여 리턴
   * @param {String} psValue 생성할 Node의 Value값
   * @type {eXria.data.Node}
   * @return 생성된 TextNode
   */
  createTextNode : function(psValue) {
  var voNode = null;
  try {
    voNode = this.node.ownerDocument.createTextNode(psValue)
  } catch(e) { return null; }
  return new eXria.data.xhtml.Node(voNode);
  },
  /**
   * 현재 Node의 자식 Node 유무를 리턴한다.
   * @type Boolean
   * @return 자식 Node의 존재 유무
   */
  hasChildNodes : function() {
    return this.node.hasChildNodes();
  },
  /**
   * 현재 Node의 자식 Node 중 파라미터로 넘어온 Node와 일치하는 Node를 삭제한다.
   * @param {eXria.data.Node} poNode 삭제할 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  removeChild : function(poNode) {
  if(!poNode) return;
  var voRemoveNode = this.node.removeChild(poNode.node);
  if(voRemoveNode) {
    return poNode;
  } else {
    return null;
  }
  },
  /**
   * 현재 Node의 Value 파라미터로 넘어온 데이터로 변경한다.
   * @param {String} psValue 변경할 데이터
   * @type void
   * @return void
   */
  setNodeValue : function(psValue) {
  try {
    psValue = (psValue ? psValue : "");
      var voValue = this.node.firstChild;
      if(voValue != null) {
    voValue.nodeValue = psValue;
    } else {
    this.node.appendChild(this.node.ownerDocument.createTextNode(psValue));
    }
  } catch(e) { return null; }
  },
  /**
   * 두번째 파라미터로 넘어온 Node와 동일한 Node가 있을 경우 해당 위치에 첫번째 파라미터로 넘어온 Node를 셋팅.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poOldNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  replaceChild : function(poNewNode, poOldNode) {
  var voRepChild = this.node.replaceChild(poNewNode.node, poOldNode.node);
  if(voRepChild) {
    return poOldNode;
  } else {
    return null;
  }
  },
  /**
   * 두번째 파라미터로 넘어온 Node의 앞에 첫번째로 넘어온 파라미터 Node를 추가한다.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poRefNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return insert 되기 전 Node
   */
  insertBefore : function(poNewNode, poRefNode) {
  var voOldNode = this.node.insertBefore(poNewNode.node, poRefNode.node);
  if(voOldNode) {
    return poRefNode;
  } else {
    return null;
  }
  },
  /**
   * node type을 리턴한다.
   * @type Number
   * @return 해당 Node의 node Type
   */
  getNodeType : function() {
  return this.node.nodeType;
  },
  /**
   * 현재 클래스의 이름을 반환 한다.
   * @type String
   * @return 현재 클래스 이름
   */
  toString : function() {
  return "eXria.data.xhtml.Node";
  },
  /**
   * 파라미터로 넘어온 Node와 현재 Node가 같은 Node인지 비교한다.
   * @param {eXria.data.Node} poNode 비교할 Node
   * @return 두개의 Node가 같은 Node인지 유무
   * @type Boolean
   */
  equal : function(poNode) {
  return this.node == poNode.node;
  },
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return Node Object
   */
  getElementByTagName : function(psTagName) {
    var voNodes = this.getElementsByTagName(psTagName);
    if(voNodes.getLength() == 0) {
      return null;
    } else {
      return voNodes.item(0);
    }
  },
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.NodeList
   * @return NodeList Object
   */
  getElementsByTagName : function(psTagName) {
  var voNodes = this.node.getElementsByTagName(psTagName);
  if(!voNodes) return null;
  return new eXria.data.xhtml.NodeList(voNodes);
  },
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return NodeList Object
   */
  getElementByTagNameFromChildNodes : function(psTagName) {
    var voNodes = this.getChildNodes();
    var voNode = null;
    var voTmpNode = null;
    for(var i = 0, vnLen = voNodes.getLength() ; i < vnLen ; i++) {
      voNode = voNodes.item(i);
      if(voNode.getNodeName() == psTagName) {
        voTmpNode = voNode;
        break;
      }
    }
    return voTmpNode;
  },
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Collection
   * @return eXria.data.Collection Object
   */
  getElementsByTagNameFromChildNodes : function(psTagName) {
    var voNodes = this.node.childNodes;
    var voNodeArr = new eXria.data.ArrayCollection();

    for(var i = 0, vnLen = voNodes.length ; i < vnLen ; i++) {
      var voNode = voNodes.item(i);
      if(voNode.nodeName == psTagName) {
        voNodeArr.add(new eXria.data.xhtml.Node(voNode));
      }
    }
    return voNodeArr;
  },
  /**
   * 현재 Node의 XML 스트링을 리턴.
   * @type String
   * @return XML String
   */
  getXML : function() {
    if (window.page.metadata.browser.ie > 0) {
      return this.node.xml;
    } else {
      var vSerializer = new XMLSerializer();
      return vSerializer.serializeToString(this.node);
    }
  },
  /**
   * 노드의 특정 속성 반환한다.
   * @param {String} psAttr 속성 명
   * @type String
   * @return 노드의 해당 속성 값
   */
  getAttribute : function(psAttr) {
    return this.node.getAttribute(psAttr);
  },
  /**
   * 노드의 특정 비표준 속성을 반환한다.
   * @param {String} psAttr 비표준 속성 명
   * @type String
   * @return 노드의 해당 속성 값
   */
  getUserAttribute : function(psAttr) {
    var voRet = this.node[psAttr];
    if(voRet == null) voRet = this.node.getAttribute(psAttr);
    return voRet;
  },
  /**
   * 노드의 특정 속성 값을 설정한다.
   * @param {String} psAttr 속성 명
   * @param {String} psValue 속성 값
   */
  setAttribute : function(psAttr, psValue) {
    this.node.setAttribute(psAttr, psValue);
  },
  /**
   * 노드의 특정 비표준 속성 값을 설정한다.
   * @param {String} psAttr 비표준 속성 명
   * @param {String} psValue 속성 값
   */
  setUserAttribute : function(psAttr, psValue) {
    try {
      this.node[psAttr] = psValue;
    } catch(err) {
      this.node.setAttribute(psAttr, psValue);
    }
  },

  getAttributes : function() {
  	var attrs = this.node.attributes;
  	var attrList = new eXria.data.xhtml.NodeList(attrs);
  	return attrList;
  }
};
/**
 * @fileoverview
 * XHTML Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 */
/**
 * XHTML Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 * @author Choe, hyeon jong.
 * @version 2.0
 * @param {NodeList} XHTML NodeList Object
 * @constructor
 * @base eXria.data.NodeList
 */
eXria.data.xhtml.NodeList = function(poResult) {
  if(page.metadata.useJsonInstance) {
    eXria.data.json.NodeList.call(this, poResult);
    return;
  }
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);

  /**
   * PLUGINNodeList
   * @type PLUGINNodeList
   * @private
   */
  this.nodeList = poResult;
  /**
   * return item cound in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
//    var voNodeList = this.nodeList;
//    var vnLength = 0;
//  var voTmp = null;
//  var vnLen = (voNodeList.length != null) ? voNodeList.length : voNodeList.getLength();
//  for(var i = 0 ; i < vnLen ; i++) {
//    voTmp = voNodeList.item(i)
//    if(voTmp.nodeType == 1) { vnLength++; }
//  }
//    return vnLength;
  return (this.nodeList.length != null) ? this.nodeList.length : this.nodeList.getLength();
  };
  /**
   * return NodeItem of parameter index
   * @param {Number} pnIdx
   * @return Node
   * @type Node
   */
  this.item = function(pnIdx) {
//  var voNode = null;
//  var vnLen = (this.nodeList.length != null) ? this.nodeList.length : this.nodeList.getLength();
//  for(var i = 0, vnIdx = 0 ; i < vnLen ; i++) {
//    voNode = this.nodeList.item(i);
//    if(voNode.nodeType == 1 && vnIdx == pnIdx) {
//    break;
//    } else {
//    if(voNode.nodeType == 1) { vnIdx++; }
//    }
//  }
//  if(voNode == null) return null;
    var voNode = this.nodeList.item(pnIdx);
    if(voNode == null) return null;
    else return new eXria.data.xhtml.Node(voNode);
  };
  /**
   * 현재 클래스의 이름을 반환 한다.
   * @type String
   * @return 현재 클래스 이름
   */
  this.toString = function() {
    return "eXria.data.xhtml.NodeList";
  };
};
/**
 * @fileoverview
 * XHTML Mode 사용시 XML Node의 Data에 대한 관리를 담당하는 클래스
 */
/**
 * XHTML Mode 사용시 XML Node의 Data에 대한 관리를 담당하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.xhtml.Node
 */
eXria.data.xhtml.ValueNode = function(poNode) {
  /**
   * inherit
   */
//  if(page.metadata.modelType == eXria.form.ModelType.PLUGIN) {
//    eXria.data.plugin.Node.call(this, poNode);
//  } else {
//  eXria.data.xhtml.Node.call(this, poNode);
//  }
  this.node = poNode;
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.
   * @return extNode 값
   * @type String
   */
  this.getValue = function() {
//    var voValue = this.node.firstChild;
//    return voValue != null ? voValue.nodeValue : null;
  return String(this.node.getNodeValue());
  };
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * @param {String} psValue value
   * @return void
   * @type void
   */
  this.setValue = function(psValue) {
  psValue = (psValue ? psValue : "");
//    var voValue = this.node.firstChild;
//    if(voValue != null) {
//      voValue.nodeValue = psValue;
//    } else {
//      this.node.appendChild(this.node.ownerDocument.createTextNode(psValue));
//    }
//  if(!psValue) {
//    return;
//  }
  this.node.setNodeValue(psValue);
  };
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {String} psFix default value
   * @return TextNode의 값 또는 argument의 값
   * @type String
   */
  this.getString = function(psFix) {
    return eXria.util.StringUtil.fixNull(this.getValue(), psFix);
  };
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {String} psValue value
   * @param {String} psFix alternate value
   * @return void
   * @type void
   */
  this.setString = function(psValue, psFix) {
    this.setValue(eXria.util.StringUtil.fixNull(psValue, psFix));
  };
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {Number} pnFix alternate value
   * @return Number로 치환된 TextNode 값
   * @type Number
   */
  this.getNumber = function(pnFix) {
    return eXria.util.NumberUtil.fixNull(this.getValue(), pnFix);
  };
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {Number} pnValue value
   * @param {Number} pnFix alternate value
   * @return void
   * @type void
   */
  this.setNumber = function(pnValue, pnFix) {
    this.setValue(eXria.util.NumberUtil.fixNull(pnValue), pnFix);
  };
  /**
   * ValueNode가 참조하고 있는 XML Node의 TextNode 값을 리턴한다.<br/>
   * 만약 값이 없을경우 argument의 값을 대신 리턴한다.
   * @param {Boolean} pbFix alternate value
   * @return boolean으로 치환된 TextNode 값
   * @type Boolean
   */
  this.getBoolean = function(pbFix) {
  //return eXria.util.BooleanUtil.fixNull(this.getValue(), pbFix); fixNull -> fix(20090420 최현종)
    return eXria.util.BooleanUtil.fix(this.getValue(), pbFix);
  };
  /**
   * ValueNode가 참조하고 있는 XML Node에 TextNode 값을 설정한다.
   * 설정 값이 Null 일경우 두번째 argument의 값을 설정한다.
   * @param {Boolean} puValue value
   * @param {Boolean} pbFix alternate value
   * @return void
   * @type void
   */
  this.setBoolean = function(puValue, pbFix) {
    //this.setValue(eXria.util.BooleanUtil.fixNull(puValue), pbFix); 20090420 최현종 수정
  this.setValue(eXria.util.BooleanUtil.fix(puValue, pbFix));
  };
};

eXria.data.xhtml.Sort = function(poDataSet) {
  this.dataSet = poDataSet;
  this.originRow = this.dataSet.originData;
  this.viewData = this.dataSet.viewData;
  this.sortItems = [];
};

eXria.data.xhtml.Sort.prototype = {
  SORT_COL_NM : 0,
  SORT_TYPE : 1,
  SORT_ASC : 2,
  SORT_ROW_IDX : "rowIdx",
  SORT_ROW_STAUTS : "status",
  /**
   * clear
   * @return void
   * @type void
   */
  clear : function() {
    this.sortItems = null;
    this.sortItems = [];
  },
  /**
   * add sort item
   * @param {String} psNodeName node name
   * @param {Number} pnType sort type
   * @param {Boolean} pbAsc is asc
   * @return void
   * @type void
   */
  addSortItem : function(psNodeName, pnType, pbAsc) {
    var voItem = [ psNodeName, Number(pnType), pbAsc ];
    this.sortItems[this.sortItems.length] = voItem;
  },
  /**
   * return sort item
   * @param {String} psNodeName
   * @return sort item
   * @type Array
   */
  get : function(psNodeName) {
    var voItem;
    for ( var i = 0, len = this.sortItems.length; i < len; i++) {
      voItem = this.sortItems[i];
      if (voItem[0] == psNodeName) {
        return voItem;
      }
    }
    return null;
  },
  /**
   * return sort column names
   * @return sort column names
   * @type Array
   */
  getColumnNames : function() {
    var len = this.sortItems.length;
    var voNames = [];
    for ( var i = 0; i < len; i++) {
      voNames[i] = this.sortItems[i][this.SORT_COL_NM];
    }
    return voNames;
  },
  /**
   * sort
   * @return void
   * @type void
   */
  doSort : function() {
    var voInst = this.dataSet.model.getInstance(this.dataSet
        .getConnectionInfo());
    var vsXPath = this.dataSet.getSourceQuery() + "/";

    var voNodeList = [];
    var vnSortLen = this.sortItems.length;
    var voSortItem;
    var voNode, vnNodeLen, vnRowLen;
    var i, j;
    var voSortValues = [];

    var vnRowCnt = this.viewData.getRowCnt();
    var vsColName, voColNode;
    var voViewRow, voOrgRow, vnStatus;

    var vnStatusIdx = this.dataSet.STATUSIDX;
    var vnOrgIdx = this.dataSet.ORIGINIDX;
    var vsSortColNm = this.SORT_COL_NM;
    var vsSortRowIdx = this.SORT_ROW_IDX;
    var vsSortRowStatus = this.SORT_ROW_STAUTS;
    var vsAttrName = this.dataSet.DATA_ROW_ATTR_NAME;
    for (i = 0; i < vnRowCnt; i++) {
      var voCol = [];
      voViewRow = this.viewData.getRow(i);
      vnStatus = voViewRow[vnStatusIdx];
      voOrgRow = this.originRow.getRowElement(voViewRow[vnOrgIdx]);
      for (j = 0; j < vnSortLen; j++) {
        vsColName = this.sortItems[j][vsSortColNm];
        voColNode = voOrgRow.getElementByTagNameFromChildNodes(vsColName);
        voCol[j] = voColNode.getNodeValue();
      }

      voCol[j] = {};
      voCol[j][vsSortRowIdx] = voColNode.getParentNode().getAttribute(vsAttrName);
      voCol[j][vsSortRowStatus] = vnStatus;

      voSortValues[i] = voCol;
    }

    voSortValues.sort(this
        .sorter(this.sortItems, this.SORT_TYPE, this.SORT_ASC));

    var vnLen = voSortValues.length;
    var vnLast = voSortValues[0].length - 1;
    var voList = [];
    var voData;

    for ( var i = 0; i < vnLen; i++) {
      voData = voSortValues[i][vnLast];
      voList[i] = [ voData[vsSortRowIdx], voData[vsSortRowStatus] ];
    }
    this.viewData.restoreRows(voList);
  },
  
  sorter : function(poSortItems, pnType, pnIsAsc) {
    return function(a, b) {
      var len = a.length - 1;
      var d1, d2;
      var vnSrcType, vbIsAsc;
      var result;
      for ( var i = 0; i < len; i++) {
        vnSrcType = poSortItems[i][pnType];
        vbIsAsc = poSortItems[i][pnIsAsc];

        d1 = a[i];
        d2 = b[i];

        if (vnSrcType != 1) {
          d1 = Number(d1);
          d2 = Number(d2);
        }

        if (d1 < d2) {
          result = -1;
        } else if (d1 > d2) {
          result = 1
        } else if (d1 == d2) {
          continue;
        }

        if (vbIsAsc == false) {
          result = result * -1;
        }
        return result;
      }
      return 0;
    }
  }
};
eXria.data.xhtml.Header = function(poDataSet) {
  //header names
  this.header = [];
};

eXria.data.xhtml.Header.prototype = {
  /**
   * add header name
   * @param {Number} pnIdx insert index
   * @param {String} psHeader header name
   * @return insert index
   * @type Number
   */
  addHeaderColumn : function(pnIdx, psHeader) {
    if (pnIdx == null) {
      pnIdx = this.header.length;
    }
    this.header.splice(pnIdx, 0, psHeader)

    return pnIdx;
  },
  /**
   * remove column
   * @param {Number} pnIdx remove index
   * @return void
   * @type void
   */
  removeColumn : function(pnIdx) {
    this.header.splice(pnIdx, 1);
  },
  /**
   * clear header names
   * @return void
   * @type void
   */
  clear : function() {
    this.header = null;
    this.header = [];
  },
  /**
   * exist header
   * @param {String} psHeader header name
   * @return is exist header name
   * @type Boolean
   */
  contains : function(psHeader) {
    var i, len = this.header.length;
    for (i = 0; i < len; i++) {
      if (this.header[i] == psHeader) {
        return true;
      }
    }
    return false;
  },
  /**
   * return parameter index header name
   * @param {Number} pnIdx header index
   * @return header name
   * @type String
   */
  getHeaderColumn : function(pnIdx) {
    return this.header[pnIdx];
  },
  /**
   * return parameter header name index
   * @param {String} psHeader header name
   * @return header index
   * @type Number
   */
  getHeaderIndex : function(psHeader) {
    var len = this.getHeaderCnt(), cnt = -1;

    while (++cnt < len) {
      if (this.header[cnt] == psHeader) {
        return cnt;
      }
    }
    return -1;
  },
  /**
   * return header count
   * @return header count
   * @type Number
   */
  getHeaderCnt : function() {
    return this.header.length;
  },
  /**
   * return header name list
   * @return header name list
   * @type Array
   */
  getHeaderColumns : function() {
    return this.header;
  }
};
eXria.data.xhtml.ViewData = function(poDataSet) {
  this.dataSet = poDataSet;
  // 그리드에 보여질 데이터 리스트 [[orgIdx, status, view idx], [] ...]
  this.viewData = [];
  this.index = 0;
};

eXria.data.xhtml.ViewData.prototype = {
  /**
   * row 추가
   * @param {Number} pnRowIdx row index
   * @param {Number} pnOrgIdx original data index
   * @param {Number} pnStatus status
   * @return void
   * @type void
   */
  addRow : function(pnRowIdx, pnOrgIdx, pnStatus) {
    var row = [ pnOrgIdx, pnStatus, this.viewData.length ];
    if (pnRowIdx != null) {
      this.viewData.splice(pnRowIdx, 0, row);
    } else {
      this.viewData[this.viewData.length] = row;
    }
  },
  /**
   * row 삭제
   * @param {Number} pnIdx row index
   * @return void
   * @type void
   */
  deleteRow : function(pnIdx) {
    this.viewData.splice(pnIdx, 1)
  },
  /**
   * 파라미터로 넘어온 인덱스의 실제 로우 인덱스를 리턴
   * @param {Number} pnIdx row index
   * @return original data row index
   * @type Number
   */
  getOriginalIndex : function(pnIdx) {
    var row = this.viewData[pnIdx];
    if (row == null)
      return null;

    return row[this.dataSet.ORIGINIDX];
  },
  /**
   * original data의 row 인덱스를 셋팅
   * @param {Number} pnIdx row index
   * @param {Number} pnOriIdx original row index
   * @return void
   * @type void
   */
  setOriginalIndex : function(pnIdx, pnOriIdx) {
    var row = this.viewData[pnIdx];
    if (row != null) {
      row[this.dataSet.ORIGINIDX] = pnOriIdx;
    }
  },
  /**
   * return row status
   * @param {Number} pnIdx row index
   * @return row status
   * @type Number
   */
  getStatus : function(pnIdx) {
    var row = this.viewData[pnIdx];
    if (row == null)
      return null;

    return row[this.dataSet.STATUSIDX];
  },
  /**
   * set row status
   * @param {Number} pnIdx row index
   * @param {Number} pnStatus row status
   * @return void
   * @type void
   */
  setStatus : function(pnIdx, pnStatus) {
    var row = this.viewData[pnIdx];
    if (row != null) {
      row[this.dataSet.STATUSIDX] = pnStatus;
    }
  },
  /**
   * view data의 row count 리턴
   * @return row count
   * @type Number
   */
  getRowCnt : function() {
    return this.viewData.length;
  },
  /**
   * clear
   * @return void
   * @type void
   */
  clear : function() {
    this.viewData = null;
    this.viewData = [];
    this.index = 0;
  },
  /**
   * set index
   * @param {Number} pnIdx index
   * @return void
   * @type void
   */
  setIndex : function(pnIdx) {
    var len = this.viewData.length;
    if (len <= pnIdx) {
      pnIdx = len - 1;
    }
    pnIdx = pnIdx < 0 ? 0 : pnIdx;
    this.index = pnIdx;
  },
  /**
   * get index
   * @return index
   * @type Number
   */
  getIndex : function() {
    var row = this.viewData[this.index];
    if (row == null)
      return null;

    return row[this.dataSet.ORIGINIDX];
  },
  /**
   * 파라미터로 받은 인덱스가 정상적인 인덱스인지 리턴
   * @param {Number} pnIdx row index
   * @return 인덱스의 정상 유무
   * @type Boolean
   */
  rangeCheck : function(pnIdx) {
    if (pnIdx < 0 || pnIdx > (this.viewData.length - 1)) {
      return false;
    } else {
      return true;
    }
  },
  /**
   * view Data를 새로 구성
   * @param {Array} poList data list
   * @return void
   * @type void
   */
  restoreRows : function(poList) {
    this.clear();
    var len = poList.length;

    for ( var i = 0; i < len; i++) {
      this.addRow(null, poList[i][0], poList[i][1]);
    }
  },
  /**
   * return row
   * @param {Number} pnIdx row index
   * @return row
   * @type Array
   */
  getRow : function(pnIdx) {
    return this.viewData[pnIdx];
  },
  /**
   * get view index
   * @param {Number} pnIdx row index
   * @return view index
   * @type Number
   */
  getViewIdx : function(pnIdx) {
    if (!this.rangeCheck(pnIdx))
      return null;
    return this.viewData[pnIdx][this.dataSet.VIEWIDX];
  }
};
eXria.data.xhtml.DelData = function(poDataSet) {
  //delete row index list
  this.delData = [];
};

eXria.data.xhtml.DelData.prototype = {
  /**
   * add delete row index
   * @param {Number} pnIdx delete row index
   * @return void
   * @type void
   */
  addRow : function(pnIdx) {
    this.delData[this.delData.length] = pnIdx;
  },
  /**
   * clear
   * @return void
   * @type void
   */
  clear : function() {
    this.delData = null;
    this.delData = [];
  },
  /**
   * return delete row count;
   * @return delete row count
   * @type Number
   */
  getRowCnt : function() {
    return this.delData.length;
  }
};
eXria.data.xhtml.OriginalData = function(poDataSet) {
  this.dataSet = poDataSet;
  // 로우 노드 리스트 [[row object, attribute, status, hidestatus], ......]
  this.row = [];
  // 실제 current, origin value 관리 리스트 [["original value", "current value"],[]...]
  // valueRow의 경우 dataset의 특정 컬럼에 get/set이 일어날 경우 동적 생성(해당 컬럼이 존재하는 row 일괄 생성)
  this.dataRow = [];
  this.header = this.dataSet.getHeader(); // 헤더

  var voInst = this.dataSet.model.getInstance(this.dataSet.getConnectionInfo());
  this.parentNode = (voInst) ? this.dataSet.model.getInstance(this.dataSet.getConnectionInfo()).selectSingleNode(this.dataSet.getSourceQuery().substr(0, this.dataSet.getSourceQuery().lastIndexOf("/"))) : null;
};

eXria.data.xhtml.OriginalData.prototype = {
  COL_ORIGIN_VAL : 0, //org
  COL_CURRENT_VAL : 1, //current
  /**
   * 헤더 오브젝트 리턴
   * @return header array
   * @type Array
   */
  getHeader : function() {
    return this.header;
  },
  /**
   * 컬럼 추가
   * @param {Number} pnIdx insert column index
   * @param {String} psColName insert column name
   * @return inserted header index
   */
  addColumn : function(pnIdx, psColName) {
    var vnHeaderIdx = this.header.addHeaderColumn(pnIdx, psColName);
    var i, len = this.row.length;
    var voRowNode, voRowEntry;
    var vsRowNode = this.dataSet.ROW_NODE;
    var voDataRow = null;

    for (i = 0; i < len; i++) {
      voRowEntry = this.getDataRow(i);
      var voNew = [ "", "" ];
      voRowEntry.splice(vnHeaderIdx, 0, voNew);

      voRowNode = this.row[i][vsRowNode];
      var voNode = voRowNode.getElementByTagNameFromChildNodes(psColName);

      if (voNode == null) {
        voNode = this.parentNode.createElement(psColName, "");
        voRowNode.appendChild(voNode);
      } else {
        var voTxt = voNode.getNodeValue();
        if (voTxt == null) {
          voTxt = this.parentNode.createTextNode("");
          voNode.appendChild(voTxt);
        }
      }
    }
    return vnHeaderIdx;
  },
  /**
   * 컬럼 삭제
   * @param {Number} pnIdx remove header index
   * @return void
   * @type void
   */
  removeColumn : function(pnIdx) {
    var vsHeaderNm = this.header.getHeaderColumn(pnIdx);
    this.header.removeColumn(pnIdx);
    var len = this.dataRow.length;
    var voRow;
    for ( var i = 0; i < len; i++) {
      voRow = this.dataRow[i];
      voRow.splice(pnIdx, 1);
    }

    var vsRowNode = this.dataSet.ROW_NODE;
    if (this.dataSet.isDataSync()) {
      var len = this.row.length, delCol;
      for ( var i = 0; i < len; i++) {
        voRow = this.row[i][vsRowNode];
        delCol = voRow.getElementByTagNameFromChildNodes(vsHeaderNm);
        if (delCol != null) {
          voRow.removeChild(delCol);
        }
      }
    }
  },
  /**
   * 인스턴스 데이터를 실제 orgin data와 current data로 분리하여 필요시에만 생성</br>
   * 생성 시점은 dataset에 set 혹은 get 메소드가 실행될 때 row 단위로 생성 되며 이미 생성된 row의 경우 해당 데이터 리턴</br>
   * 이 부분의 경우 프로그램상 부하가 많이 걸리며 인스턴스 데이터를 list 형식으로 새로 저장하기 때문에 데이터의 양에 따라 메모리가 소비됨.</br>
   * 때문에 다량의 데이터를 한번에 로드(Grid에서 Paging을 쓰지 않거나 auto의 경우) 할 경우</br>
   * 처리 시간 및 메모리 사용이 증가 할 수 있음.</br>
   * 또한 메모리 낭비를 줄이기 위하여 original data의 경우 현 시점에 셋팅 되지 않으며,
   * data row 생성 후 실제 데이터에 변경이 일어날때 (dataset.set) original data를 셋팅함.
   * @param {Number} pnIdx row index
   * @param {Number} pnColIdx column index
   * @return array 형식의 데이터 ["original data index", "current data index"]
   * @type Array
   * @ignore
   */
  getDataRow : function(pnIdx, pnColIdx) {
    var voDataRow = this.dataRow[pnIdx];
    if (voDataRow == null) {
      voDataRow = [];
      this.dataRow[pnIdx] = voDataRow;
    } else {
      return voDataRow;
    }

    if (pnColIdx == null)
      return voDataRow;

    var voCol = voDataRow[pnColIdx];
    if (voCol == null) {
      var voRow = this.row[pnIdx][this.dataSet.ROW_NODE];

      var vnType, vsNodeName, vnIdx, vsValue;
      var vnColCur = this.COL_CURRENT_VAL;
      var vnColOri = this.COL_ORIGIN_VAL;
      var i;
      var voChilds = voRow.getChildNodes();
      var vnLen = voChilds.getLength();

      for (i = 0; i < vnLen; i++) {
        voChild = voChilds.item(i);
        vnType = voChild.getNodeType();
        if (vnType != 1) {
          continue;
        }
        var voColNode = [];
        vsNodeName = voChild.getNodeName();
        vnIdx = this.header.getHeaderIndex(vsNodeName);
        if (vnIdx == -1) {
          continue;
        }

        vsValue = voChild.getNodeValue();
        voColNode[vnColCur] = vsValue;
        if(voColNode[vnColOri] === undefined){
          voColNode[vnColOri] = voColNode[vnColCur];
        }
        voDataRow[vnIdx] = voColNode;
      }

      var vnHeaderLen = this.header.getHeaderCnt();
      for (i = 0; i < vnHeaderLen; i++) {
        if (voDataRow[i] == null) {
          voDataRow[i] = [ "", "" ];
        }
      }
    }
    return voDataRow;
  },
  /**
   * data row에 데이터 셋팅, status 변경
   * @param {Number} pnIdx row index
   * @param {Number} pnColIdx column index
   * @param {String} psVal value
   * @return void
   * @type void
   */
  setValue : function(pnIdx, pnColIdx, psVal) {
    psVal = psVal == null ? "" : psVal;

    var voRow = this.row[pnIdx];
    if (voRow == null)
      return;

    var voDataRow = this.getDataRow(pnIdx, pnColIdx);

    var voCol = voDataRow[pnColIdx];
    if (voCol[this.COL_ORIGIN_VAL] === undefined) {
      voCol[this.COL_ORIGIN_VAL] = voCol[this.COL_CURRENT_VAL];
    }

    if (voCol[this.COL_CURRENT_VAL] === psVal) {
      return;
    }

    var vsStatus = this.dataSet.ROW_STATUS;
    var rowStatus = voRow[vsStatus];
    if (rowStatus == this.dataSet.ETBEMPTYEDFLAG) {
      voRow[vsStatus] = this.dataSet.ETBADDEDFLAG;
    } else if (rowStatus == this.dataSet.ETBUNCHANGEDFLAG) {
      voRow[vsStatus] = this.dataSet.ETBMODIFIEDFLAG;
    }

    this.setValueOnly(pnIdx, pnColIdx, psVal, voRow, voCol);
  },

  /**
   * data row에 데이터 셋팅, status 없음
   * @param {Number} pnIdx row index
   * @param {Number} pnColIdx column index
   * @param {String} psVal value
   * @param {Object} poRow row object
   * @param {Object} poCol column object
   * @return void
   * @type void
   */
  setValueOnly : function(pnIdx, pnColIdx, psVal, poRow, poCol) {
    if (poRow == null || poCol == null) {
      poRow = this.row[pnIdx];
      var voDataRow = this.getDataRow(pnIdx, pnColIdx);
      poCol = voDataRow[pnColIdx];
    }

    if (poCol[this.COL_ORIGIN_VAL] === undefined) {
      poCol[this.COL_ORIGIN_VAL] = poCol[this.COL_CURRENT_VAL];
    }

    poCol[this.COL_CURRENT_VAL] = psVal;

    var vsStatus = this.dataSet.HIDE_ROW_STATUS;
    var rowStatus = poRow[vsStatus];
    if (rowStatus == this.dataSet.ETBEMPTYEDFLAG) {
      poRow[vsStatus] = this.dataSet.ETBADDEDFLAG;
    } else if (rowStatus == this.dataSet.ETBUNCHANGEDFLAG) {
      poRow[vsStatus] = this.dataSet.ETBMODIFIEDFLAG;
    }

    if (this.dataSet.isDataSync()) {
      var vsColName = this.header.getHeaderColumn(pnColIdx);
      var voRow = poRow[this.dataSet.ROW_NODE];
      var voNode = voRow.getElementByTagName(vsColName);
      if(voNode == null) {
        voRow.appendChild(voRow.createElement(vsColName));
        voNode = voRow.getElementByTagName(vsColName);
      }
      voNode.setNodeValue(psVal);
    }
  },
  /**
   * 현재 dataset column의 값
   * @param {Number} pnRowIdx row index
   * @param {Number} pnColIdx column index
   * @return 해당 컬럼의 데이터
   * @type String
   */
  getValue : function(pnRowIdx, pnColIdx) {
    var voDataRow = this.getDataRow(pnRowIdx, pnColIdx);
    return voDataRow[pnColIdx][this.COL_CURRENT_VAL];
  },
  /**
   * dataset column의 초기 셋팅 데이터
   * @param {Number} pnRowIdx row index
   * @param {Number} pnColIdx column index
   * @return 해당 컬럼의 데이터
   * @type String
   */
  getOriginalValue : function(pnRowIdx, pnColIdx) {
    var voRow = this.row[pnRowIdx];
    if (voRow == null)
      return "";

    var voDataRow = this.getDataRow(pnRowIdx, pnColIdx);
    if (voDataRow[pnColIdx][this.COL_ORIGIN_VAL] === undefined) {
      return voDataRow[pnColIdx][this.COL_CURRENT_VAL];
    }
    return voDataRow[pnColIdx][this.COL_ORIGIN_VAL];
  },
  /**
   * row 추가
   * @param {Array} poRow row object
   * @return 로우 추가 후 row count
   * @type Number
   */
  addRow : function(poRow) {
    if (poRow == null) {
      poRow = [];
      var vnEmpty = this.dataSet.ETBEMPTYEDFLAG;
      poRow[this.dataSet.ROW_STATUS] = vnEmpty;
      poRow[this.dataSet.HIDE_ROW_STATUS] = vnEmpty;

      var voRow = this.parentNode.createElement(this.dataSet.getRowTagName());
      voRow.setAttribute(this.dataSet.DATA_ROW_ATTR_NAME, this.row.length);

      var vnHeaderCnt = this.header.getHeaderCnt();
      var vsHeader;
      for ( var i = 0; i < vnHeaderCnt; i++) {
        vsHeader = this.header.getHeaderColumn(i);
        var voCol = this.parentNode.createElement(vsHeader, "");
        voRow.appendChild(voCol);
      }
      
      this.parentNode.node = this.parentNode.parentNode[this.parentNode.name];
      this.parentNode.appendChild(voRow, this.dataSet.getRowTagName());

      poRow[this.dataSet.ROW_ATTR] = {};
      poRow[this.dataSet.ROW_NODE] = voRow;
    }

    this.row[this.row.length] = poRow;
    return this.row.length - 1;
  },
  /**
   * 실제 로우 node 를 리턴
   * @param {Number} pnIdx row index
   * @return row node
   * @type eXria.data.Node
   */
  getRowElement : function(pnIdx) {
    return this.row[pnIdx][this.dataSet.ROW_NODE];
  },
  /**
   * row object 리턴
   * @param {Number} pnIdx row index
   * @return row object 
   * @type Array
   */
  getRow : function(pnIdx) {
    return this.row[pnIdx];
  },
  /**
   * 로우 카운트 리턴
   * @return row 갯수
   * @type Number
   */
  getRowCnt : function() {
    return this.row.length;
  },
  /**
   * clear
   * @return void
   * @type void
   */
  clear : function() {
    this.row = null;
    this.row = [];
    this.dataRow = null;
    this.dataRow = [];
  },
  /**
   * row attribute 추가
   * @param {Number} pnIdx row index
   * @param {String} psKey attribute key
   * @param {String} psVal attribute value
   * @return void
   * @type void
   */
  setRowAttr : function(pnIdx, psKey, psVal) {
    if(this.row[pnIdx][this.dataSet.ROW_ATTR] == null){
      this.row[pnIdx][this.dataSet.ROW_ATTR] = {};
    }
    var voAttr = this.row[pnIdx][this.dataSet.ROW_ATTR];
    voAttr[psKey] = psVal;
  },
  /**
   * row attribute 리턴
   * @param {Number} pnIdx row index
   * @param {String} psKey attribute key
   * @return attribute value
   * @type String
   */
  getRowAttr : function(pnIdx, psKey) {
    var voAttr = this.row[pnIdx][this.dataSet.ROW_ATTR];
    if(voAttr == null) return null;
    return voAttr[psKey];
  },
  /**
   * status 설정
   * @param {Number} pnIdx row index
   * @param {Number} pnStatus status
   * @return void
   * @type void
   */
  setStatus : function(pnIdx, pnStatus) {
    this.row[pnIdx][this.dataSet.ROW_STATUS] = pnStatus;
    this.row[pnIdx][this.dataSet.HIDE_ROW_STATUS] = pnStatus;

    if (pnStatus == this.dataSet.REAL_DELETE_FLAG) {
      var voRow = this.row[pnIdx][this.dataSet.ROW_NODE];
      voRow.getParentNode().removeChild(voRow);
    }
  },
  /**
   * status 리턴
   * @param {Number} pnIdx row index
   * @return row status
   * @type Number
   */
  getStatus : function(pnIdx) {
    return this.row[pnIdx][this.dataSet.ROW_STATUS];
  },
  /**
   * setValueOnly를 사용하여 status 변경을 하지 않아도 암묵적으로 저장된 row status를 리턴 
   * @param {Number} pnIdx row index
   * @return row status
   * @type Number
   * @ignore
   */
  getHideStatus : function(pnIdx) {
    return this.row[pnIdx][this.dataSet.HIDE_ROW_STATUS];
  },
  /**
   * 실제 instance node를 삭제
   * @return void
   * @type void
   */
  clearInstance : function() {
    if (this.parentNode != null) {
      var voNodes = this.parentNode.getChildNodes();
      if(voNodes == null) return ;
      var vnLen = voNodes.getLength();
      var voNode;
      for ( var i = 0; i < vnLen; i++) {
        voNode = voNodes.item(i);
        this.parentNode.removeChild(voNode);
      }
    }
  },
  /**
   * 컬럼 복사
   * @param {Number} pnColIdx column index
   * @param {String} psColName column name
   * @param {Object} poOrgData original data
   * @return void
   * @type void
   */
  cloneColumn : function(pnColIdx, psColName, poOrgData) {
    var vnTargetIdx = this.header.getHeaderIndex(psColName);
    var vnCnt = poOrgData.getRowCnt();

    if (this.getRowCnt() < vnCnt) {
      while (this.getRowCnt() < cnt) {
        this.addRow(null);
      }
    }

    var voSrcRow;
    var vsColVal, vsColOrgVal;
    for ( var i = 0; i < cnt; i++) {
      vsColVal = poOrgData.getValue(i, pnColIdx);
      vsColOrgVal = poOrgData.getOriginalValue(i, pnColIdx);
      this.setValue(i, vnTargetIdx, vsColOrgVal);
      this.setValue(i, vnTargetIdx, vsColVal);
    }
  },
  /**
   * dataset originData 수정
   * @param {Number} pnRowIdx row index
   * @param {Number} pnColIdx column index
   * @param {Number} psVal value
   * @return void
   * @type void
   */
  setOriginalData : function(pnRowIdx, pnColIdx, psVal){
    var voDataRow = this.getDataRow(pnRowIdx, pnColIdx);
    voDataRow[pnColIdx][this.COL_ORIGIN_VAL] = psVal;
  }
};
eXria.data.xhtml.Filter = function(poDataSet) {
  this.dataSet = poDataSet;
  this.viewData = poDataSet.viewData;
  this.originData = poDataSet.originData;
  this.isViewDeleteFlag;
};

eXria.data.xhtml.Filter.prototype = {
  /**
   * filtering 
   * @param {String} psXPath xpath
   * @return void
   * @type void
   */
  doFilter : function(psXPath) {
    var voOrgIdxs = this.retrieveIndex(psXPath);
    this.viewData.clear();

    var vnRowStatus, vnOrgIdx, voRow;
    var vnLen = voOrgIdxs.length;
    var vnDeleteFlag = this.dataSet.ETBDELETEDFLAG;
    for ( var i = 0; i < vnLen; i++) {
      vnOrgIdx = voOrgIdxs[i];
      voRow = this.originData.getRowElement(vnOrgIdx);
      vnRowStatus = this.originData.getStatus(vnOrgIdx);
      if (vnRowStatus == vnDeleteFlag && !this.isViewDeleteFlag) {
        continue;
      } else {
        this.viewData.addRow(null, vnOrgIdx, vnRowStatus);
      }
    }
  },
  /**
   * retrive index
   * @param {String} psXPath
   * @return filtered index list
   * @type Array
   * @ignore
   */
  retrieveIndex : function(psXPath) {
    var vsXPath = this.dataSet.getSourceQuery() + "[" + psXPath + "]";
    var voNodeList = this.dataSet.model.getInstance(this.dataSet.getConnectionInfo()).selectNodes(vsXPath);
    if (voNodeList == null) return [];
    var vnLen = voNodeList.getLength();
    var voResult = [];
    var vsAttrName = this.dataSet.DATA_ROW_ATTR_NAME;
    for ( var i = 0; i < vnLen; i++) {
      voResult[i] = voNodeList.item(i).getAttribute(vsAttrName);
    }
    return voResult;
  },
  /**
   * clear filter
   * @return void
   * @type void
   */
  clear : function() {
    this.viewData.clear();

    var vnRowCnt = this.originData.getRowCnt();
    var voRow, vnStatus;
    for ( var i = 0; i < vnRowCnt; i++) {
      voRow = this.originData.getRowElement(i);
      vnStatus = this.originData.getStatus(i);
      this.viewData.addRow(null, i, vnStatus);
    }
  },
  /**
   * set is view delete row
   * @param {Boolean} pbFlag delete row view flag
   * @return void
   * @type void
   */
  setIsViewDeleteFlag : function(pbFlag) {
    this.isViewDeleteFlag = pbFlag;
  }
};
eXria.data.xhtml.AutoCUDTableInfo = function() {
  //table id
  this.id = null;
  //update col names
  this.updateCols = {};
  //pk names
  this.pks = {};
  //prefix
  this.prefix = null;
  //user str
  this.usrStr = "";
};

eXria.data.xhtml.AutoCUDTableInfo.prototype = {
  /**
   * set id
   * @param {String} id id
   * @return void
   * @type void
   */
  setId : function(id) {
    this.id = id;
  },
  /**
   * get id
   * @return id
   * @type String
   */
  getId : function() {
    return this.id;
  },
  /**
   * add update column
   * @param {String} dbId db id
   * @param {String} id id
   * @return void
   * @type void
   */
  addUpdateColumn : function(dbId, id) {
    this.updateCols[dbId] = id;
  },
  /**
   * remove update column
   * @param {String} dbId db id
   * @return void
   * @type void
   */
  removeUpdateColumn : function(dbId) {
    delete this.updateCols[dbId];
  },
  /**
   * clear update column
   * @return void
   * @type void
   */
  clearUpdateCololumn : function() {
    this.updateCols = null;
    this.updateCols = {};
  },
  /**
   * get update column names
   * @return update column names
   * @type Object
   */
  getUpdateCols : function() {
    return this.updateCols;
  },
  /**
   * add primary key
   * @param {String} dbId db id
   * @param {String} id id
   * @return void
   * @type void
   */
  addPrimaryKey : function(dbId, id) {
    this.pks[dbId] = id;
  },
  /**
   * get primary key
   * @param {String} pk primary key
   * @return primary key
   * @type String
   */
  getPrimaryKey : function(pk) {
    return this.pks[pk];
  },
  /**
   * get primary key object
   * @return pk id
   * @type String
   */
  getPrimaryKeys : function() {
    return this.pks;
  },
  /**
   * remove primay key
   * @param {String} dbId db id
   * @return void
   * @type void
   */
  removePrimaryKey : function(dbId) {
    delete this.pks[dbId];
  },
  /**
   * clear primary key
   * @return void
   * @type void
   */
  clearPrimaryKey : function() {
    this.pks = null;
    this.pks = {};
  },
  /**
   * set prefix
   * @param {String} p prefix name
   * @return void
   * @type void
   */
  setPrefix : function(p) {
    this.prefix = p;
  },
  /**
   * get prefix
   * @return prefix name
   * @type String
   */
  getPrefix : function() {
    return this.prefix;
  },
  /**
   * set user string
   * @param {String} s user string
   * @return void
   * @type void
   */
  setUsrStr : function(s) {
    if (!s)
      s = "";
    this.usrStr = s;
  },
  /**
   * get user string
   * @return user string
   * @type String
   */
  getUsrStr : function() {
    return this.usrStr;
  },
  /**
   * reset user string
   * @return void
   * @type void
   */
  resetUsrStr : function() {
    this.usrStr = "";
  },
  /**
   * return parameter name is update target
   * @param {String} s column name
   * @return is update target
   * @type Boolean
   */
  isUpdateSource : function(s) {
    var voUpdateCols = this.updateCols;
    for(var vsKey in voUpdateCols) {
      if(voUpdateCols[vsKey] == s) {
        return true;
      }
    }
    return false;
  },
  /**
   * return parameter name is primary key
   * @param {String} psSourceName source name
   * @return is primary key
   * @type Boolean
   */
  isPrimaryKeySource : function(psSourceName) {
    var voPk = this.pks[psSourceName];
    if (voPk == null) {
      return false;
    } else {
      return true;
    }
  },
  /**
   * reset table
   * @return void
   * @type void
   */
  resetTable : function() {
    this.id = null;
    this.pks = null;
    this.pks = {};
    this.updateCols = null;
    this.updateCols = {};
    this.prefix = null;
  }
};
eXria.data.xhtml.AutoCUD = function(poDataSet) {
  this.dataSet = poDataSet;
  this.original = poDataSet.originData;
  this.autoCudTables = {};
  this.attr = {};
  this.useOriginalValue;
};

eXria.data.xhtml.AutoCUD.prototype = {
  TABLE_PK : "PRIMARYKEYS",
  UPDATECOLS : "UPDATECOLUMNS",
  CUDTABLE : "XRAUTOCUD",
  ORIGINAL_APPENDIX : "__origin",
  CUD_TYPE : "CRUDTYPE",
  CUD_TYPE_INSERT : "I",
  CUD_TYPE_UPDATE : "U",
  CUD_TYPE_DELETE : "D",
  CUD_TYPE_UNCHANGED : "R",

  /**
   * cud data에 original value 사용 유무 지정
   * @param {Boolean} pbOrigin
   * @return void
   * @type void
   */
  setUseOriginVal : function(pbOrigin) {
    this.useOriginalValue = pbOrigin;
  },
  /**
   * cud data에 original value 사용 유무 리턴
   * @return use origin val
   * @type Boolean
   */
  isUseOriginalValue : function() {
    return this.useOriginalValue;
  },
  /**
   * add attribute
   * @param {String} psKey key
   * @param {String} psValue value
   * @return void
   * @type void
   */
  setAttr : function(psKey, psValue) {
    this.attr[psKey] = psValue;
  },
  /**
   * return attribute value
   * @param {String} psKey key
   * @return attribute 값
   * @type String
   */
  getAttr : function(psKey) {
    return this.attr[psKey];
  },
  /**
   * create table info object 
   * @param {String} psTableName table name
   * @return void
   * @type void
   */
  createTableInfo : function(psTableName) {
    if (this.autoCudTables[psTableName] != null) {
      if(window.console) window.console.warn("AutoCUD Table is already created : " + psTableName);
    } else {
      var voTable = new eXria.data.xhtml.AutoCUDTableInfo();
      voTable.setId(psTableName);
      this.autoCudTables[psTableName] = voTable;
    }
  },
  /**
   * add table infomation
   * @param {eXria.data.xhtml.AutoCUDTableInfo} poAutoCUDTableInfo table info object
   * @return void
   * @type void
   */
  addTableInfo : function(poAutoCUDTableInfo) {
    var tableName = poAutoCUDTableInfo.getId();
    this.autoCudTables[tableName] = poAutoCUDTableInfo;
  },
  /**
   * return table info
   * @param {String} psTableName tablename
   * @return table info object
   * @type eXria.data.xhtml.AutoCUDTableInfo
   */
  getTableInfo : function(psTableName) {
    return this.autoCudTables[psTableName];
  },
  /**
   * remove table info
   * @param {String} psTableName table name
   * @return void
   * @type void
   */
  removeTableInfo : function(psTableName) {
    delete this.autoCudTables[psTableName];
  },
  /**
   * table name list
   * @return table name list
   * @type Array
   */
  getTableNames : function() {
    var voTableNames = [];
    var cnt = 0;
    for ( var m in this.autoCudTables) {
      voTableNames[cnt++] = m;
    }
    return voTableNames;
  },
  /**
   * parse meta data
   * @return parsed meta data
   * @type String
   * @private
   */
  parseMetaData : function() {
    var s = "";
    var voTable;
    var vsXr = "";
    var vsPrefix;

    for ( var m in this.autoCudTables) {
      voTable = this.autoCudTables[m];
      vsPrefix = voTable.getPrefix();

      vsXr = vsXr + encodeURIComponent(vsPrefix) + ":" + encodeURIComponent(voTable.getId()) + ",";
      // primary keys
      s = s + encodeURIComponent(vsPrefix + this.TABLE_PK) + "=";
      var pks = voTable.getPrimaryKeys();
      for ( var pk in pks) {
        s = s + encodeURIComponent(pks[pk] + ":" + pk + ",");
      }
      s = s + "&";

      // columns
      s = s + encodeURIComponent(voTable.getPrefix() + this.UPDATECOLS) + "=";
      var uCols = voTable.getUpdateCols();
      for ( var cols in uCols) {
        s = s + encodeURIComponent(uCols[cols] + ":" + cols + ",");
      }
      s = s + "&";
    }
    if (s != "") {
      s = s + this.CUDTABLE + "=" + vsXr.substr(0, vsXr.length - 1) + "&";
    }
    return s;
  },
  /**
   * parse auto cud data
   * @return parsed autocud data
   * @type String
   * @private
   */
  parseData : function() {
    var header = this.original.getHeader();
    var colNames = header.getHeaderColumns();
    var rowSize = this.original.getRowCnt();

    var row;
    var rowStatus;
    var rowStatusStr;
    var tableInfoIter;
    var tableInfo;
    var rowWrited;
    var prefix;
    var column;
    var len, j;
    var vnDeleteFlag = this.dataSet.REAL_DELETE_FLAG;
    var vnEmptyFlag = this.dataSet.ETBEMPTYEDFLAG;
    var vnUnChangeFlag = this.dataSet.ETBUNCHANGEDFLAG;
    var vsAllTypeWrite = this.dataSet.getCRUDAttr("alltype");

    var result = "";
    var cnt = 0;

    for ( var i = 0; i < rowSize; i++) {
      rowWrited = false;
      rowStatus = this.original.getStatus(i);

      if ((this.useOriginalValue == true) && (rowStatus == vnDeleteFlag)) {
        continue;
      }
      
      if(rowStatus == vnUnChangeFlag){
        cnt++;
      }

      if (vsAllTypeWrite != "true" && (rowStatus == vnEmptyFlag || rowStatus == vnUnChangeFlag)) {
        continue;
      }

      for ( var m in this.autoCudTables) {
        tableInfo = this.autoCudTables[m];
        prefix = tableInfo.getPrefix();

        len = colNames.length;

        for (j = 0; j < len; j++) { // column loop
          if (tableInfo.isUpdateSource(colNames[j]) || tableInfo.isPrimaryKeySource(colNames[j])) { // update column
            rowWrited = true;
            result = result + encodeURIComponent(prefix + colNames[j]) + "=" + encodeURIComponent(this.original.getValue(i, j)) + "&";
            if (this.useOriginalValue == true || tableInfo.isPrimaryKeySource(colNames[j])) {
              result = result + encodeURIComponent(prefix + colNames[j] + this.ORIGINAL_APPENDIX) + "=" + encodeURIComponent(this.original.getOriginalValue(i, j)) + "&";
            }
          }
        }

        if (rowWrited) {
          rowStatusStr = this.getRowStatusString(rowStatus);
          result = result + encodeURIComponent(prefix + this.CUD_TYPE) + "=" + encodeURIComponent(rowStatusStr) + "&";
        }
      }
    }
    
    
//      if(vsAllTypeWrite != "true" &&  (cnt == rowSize)) {
//        for ( var m in this.autoCudTables) {
//          tableInfo = this.autoCudTables[m];
//          prefix = tableInfo.getPrefix();
//          rowStatusStr = this.getRowStatusString(vnUnChangeFlag);
//          result = result + encodeURIComponent(prefix + this.CUD_TYPE) + "=" + encodeURIComponent(rowStatusStr) + "&";
//        }
//      }
    
    return result;
  },
  /**
   * return cud type
   * @param {Number} pnStatus status
   * @return cud type character
   * @type String
   * @private
   */
  getRowStatusString : function(pnStatus) {
    var status = "";
    switch (pnStatus) {
      case this.dataSet.ETBADDEDFLAG:
        status = this.CUD_TYPE_INSERT;
        break;
      case this.dataSet.ETBDELETEDFLAG:
        status = this.CUD_TYPE_DELETE;
        break;
      case this.dataSet.ETBEMPTYEDFLAG:
        status = this.CUD_TYPE_UNCHANGED;
        break;
      case this.dataSet.ETBMODIFIEDFLAG:
        status = this.CUD_TYPE_UPDATE;
        break;
      case this.dataSet.REAL_DELETE_FLAG:
        status = this.CUD_TYPE_DELETE;
        break;
      case this.dataSet.ETBUNCHANGEDFLAG:
        status = this.CUD_TYPE_UNCHANGED;
        break;
    }
    return status;
  },
  /**
   * return auto cud string
   * @return parsed auto cud data string
   * @type String
   */
  getAutoCRUDString : function() {
    var result = this.parseMetaData();
    if (result == "") return "";
    result = result + this.parseData();
    return result;
  }
};

eXria.data.xhtml.DataSetCmd = function(psId, pnTypeSource, psConnectionInfo, psSourceQuery, pbSourceSync, pbKeepOriginValue, poModel) {
	this.id = psId;
	this.srcType = pnTypeSource;
	this.conInfo = (psConnectionInfo == null) ? "" : psConnectionInfo;
	this.srcQuery = (psSourceQuery == null) ? "" : psSourceQuery;
	this.srcSync = pbSourceSync;
	this.isKeepOrgin = pbKeepOriginValue;
	this.model = poModel;

  this.rowTagName;

  var vnSlash = this.srcQuery.lastIndexOf("/");
	if (vnSlash > 0) {
		this.rowTagName = this.srcQuery.substr(vnSlash + 1);
	} else {
		this.rowTagName = "list";
	}
	
	this.ETBUNCHANGEDFLAG = 1;
	this.ETBADDEDFLAG = 2;
	this.ETBDELETEDFLAG = 4;
	this.ETBMODIFIEDFLAG = 8;
	this.REAL_DELETE_FLAG = 9;
	this.ETBEMPTYEDFLAG = 16;
	
	this.ROW_STATUS = "status"; //dataset, org
	this.HIDE_ROW_STATUS = "hide_status"; //dataset, org
	this.ROW_ATTR = "attribute"; //filter, dataset, org, sort
	this.ROW_NODE = "row"; //dataset, org
	this.DATA_ROW_ATTR_NAME = "DataSetRowIdx"; //dataset, filter, sort
	this.ORIGINIDX = 0; //dataset, sort, view
	this.STATUSIDX = 1; //sort, viewData
	this.VIEWIDX = 2; //dataset, view

	this.dataSet = this;
	
  this.header = null;
  this.viewData = null;
  this.originData = null;
  this.delData = null;
  this.sorter = null;
  this.filter = null;
  
  this.init = function() {
	  this.header = new eXria.data.xhtml.Header(this);
	  this.delData = new eXria.data.xhtml.DelData(this);
	  this.originData = new eXria.data.xhtml.OriginalData(this);
	  this.viewData = new eXria.data.xhtml.ViewData(this);
	  this.sorter = new eXria.data.xhtml.Sort(this);
	  this.filter = new eXria.data.xhtml.Filter(this);
	  this.autoCUD = new eXria.data.xhtml.AutoCUD(this);
	  this.autoCUD.setUseOriginVal(this.isKeepOrgin);
  };
  
  this.getHeader = function() {
  	return this.header;
  };
  /**
   * Primary key 정보를 설정한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 설정할 primary key
   * @return void
   * @type void
   */
  this.addPrimaryKey = function(psTableName, psName, psSourceName) {
  	var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			voTable.addPrimaryKey(psSourceName, psName);
		} else {
			throw new Error(psTableName + " not register.");
		}
  };
  /**
   * column 정보를 update 한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName update 할 값
   * @return void
   * @type void
   */
  this.addUpdateColumn = function(psTableName, psName, psSourceName) {
  	var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			voTable.addUpdateColumn(psSourceName, psName);
		} else {
			throw new Error(psTableName + " not register.");
		}
  };
  /**
   * source와 target의 index를 설정한다.
   * @param {Number} pnSourceIndex 대상 src index
   * @param {Number} pnTargetIndex 대상 target index
   * @return void
   * @type void
   */
  this.changeRowIndex = function(pnSrcIdx, pnTgIdx) {
  	var vnViewIdx = this.toArrayIndex(pnSrcIdx);
		var vnTargetIdx = this.toArrayIndex(pnTgIdx);

		var vnSwap1 = this.viewData.getOriginalIndex(vnViewIdx);
		var vnSwap2 = this.viewData.getOriginalIndex(vnTargetIdx);

		this.viewData.setOriginalIndex(vnViewIdx, vnSwap2);
		this.viewData.setOriginalIndex(vnTargetIdx, vnSwap1);
  };
  /**
   * 해당 테이블에서 primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 테이블 이름
   * @return void
   * @type void
   */
  this.clearPrimaryKeys = function(psTableName) {
  	var voTable = this.autoCUD.getTableInfo(psTableName);
		if (voTable != null) {
			voTable.clearPrimaryKey();
		} else {
			throw new Error(psTableName + " not register.");
		}
  };
  /**
   * sort parameter를 clear 한다.
   * @return void
   * @type voiddnd
   
   */
  this.clearSortItem = function() {
  	this.sorter.clear();
  };
  /**
   * column 정보를 clear 한다.
   * @param {String} psTableName 대상 table name
   * @return void
   * @type void
   */
  this.clearUpdateColumns = function(psTableName) {
  	var voTable = this.autoCUD.getTableInfo(psTableName);
		if (voTable != null) {
			voTable.clearUpdateCololumn();
		} else {
			throw new Error(psTableName + " not register.");
		}
  };
  /**
   * 현재 DataSet에 특정 컬럼을 다른 DataSet으로 복사한다.
   * @param {String} psScrCol 원본 컬럼명
   * @param {String} psDataSetId 복사할 데이터셋 Id명
   * @return 복사 성공 여부 성공시 True
   * @type Boolean
   */
  this.cloneCol = function(psSrcCol, psDataSetId) {
  	var vnColIdx = this.header.getHeaderIndex(psSrcCol);
  	var voTargetDs = this.model.getDataSet(psDataSetId);
  	if(voTargetDs == null) {
  		throw new Error("DataSet is null : " + psDataSetId);
  	}
  	
  	var vnAppendIdx = voTargetDs.appendColumn(psSrcCol);
  	voTargetDs.originData.cloneColumn(vnColIdx, psSrcCol, this.originData);
  	return true;
  };
  /**
   * XPath filter 설정
   * @param {String} psXPath 적용대상 경로
   * @param {Boolean} pbApply 적용 유무
   * @param {Boolean} pbViewDelFlagRow delete flag row를 보이고자 할 경우 true 보이지 말고자 할 경우 false
   * @return -1
   * @type Number
   */
  this.compositeFilter = function(psXPath, pbApply) {
  	if(pbApply == true) {
  		this.filter.setIsViewDeleteFlag(pbApply);
  		this.filter.doFilter(psXPath);
  	} else {
  		this.filter.clear();
  	}
  };
  /**
   * xpath를 이용하여 필터링된 자료의 DataSet RowID를 알아낸다.
   * @param {String} psXPath 해당 DataSet에서 추출 하고자 하는 컬럼의 연산식
   * @return 해당 연산으로 필터링 된 RowIndex를 문자열로 ','로 구분하여 리턴한다.
   * 결과 값이 없을 경우 ""을 리턴한다.
   * @type String
   */
  this.compositeIdx = function(psXPath) {
  	var voIdxs = this.filter.retrieveIndex(psXPath);
  	return voIdxs.join(",");
  };
  /**
   * 찾고자 하는 Column:Value 쌍을 복수로 입력하여 값에 해당하는 RowID를 "," 구분하여 리턴한다.
   * 인자 값은 컬럼명과 그 컬럼에서 찾을 Value를 ":"로 구분하여 넣어주고 복수개일 경우 Column:Value쌍을 ","로 구분하여
   * 다수개의 조건을 넣어 줄 수 있다.
   * @param {String} psKeyArray 찾고자 하는 DataSet의 Column명
   * @return ","로 구분되어진 문자열
   * @type String
   */
  this.find = function(psKeyArray) {
  	if(psKeyArray == null || "" == psKeyArray || psKeyArray.indexOf(":") < 0) {
  		return null;
  	}
  	
  	var voKeys = psKeyArray.split(",");
  	var vnKeyLen = voKeys.length;
  	
  	var vnRowLen = this.viewData.getRowCnt();
  	var vbMatch;
  	var vnOrgIdx, voRow;
  	var i, j;
  	var voKeyAttr;
  	var vsColName, vsValue, vnColIdx, voNode;
  	var voResult = [];
  	
  	for(i = 0 ; i < vnRowLen ; i++) {
  		vbMatch = true;
  		vnOrgIdx = this.viewData.getOriginalIndex(i);
  		row = this.originData.getRowElement(vnOrgIdx);
  		
  		for(j = 0 ; j < vnKeyLen ; j++) {
  			voKeyAttr = voKeys[j].split(":");
  			vsColName = voKeyAttr[0];
  			vsValue = voKeyAttr[1];
  			
  			voNode = row.getElementByTagNameFromChildNodes(vsColName);
  			
  			if(vsValue != voNode.getNodeValue()) {
  				vbMatch = false;
  				break;
  			}
  		}
  		if(vbMatch) {
  			voResult[voResult.length] = i + 1;
  		}
  	}
  	return voResult.join(",");
  };
  /**
   * 주어진 index의 row를 delete 한다.
   * @param {Number} pnIndex 삭제 대상 row의 index
   * @return index가 범위를 넘으면 -1 리턴
   * @type Number
   */
  this.deleteRow = function(pnIdx) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	
  	if(this.viewData.rangeCheck(pnIdx) == false) {
  		return -1;
  	}
  	
  	var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);
  	if(vnOrgIdx == null) return -1;
  	
		this.viewData.deleteRow(pnIdx);
		var vnStatus = this.originData.getStatus(vnOrgIdx);
		
		if(this.srcSync) {
			if(vnStatus != this.ETBADDEDFLAG) {
				this.delData.addRow(vnOrgIdx);
			}
			if(vnStatus == this.ETBUNCHANGEDFLAG) {
				this.originData.setStatus(vnOrgIdx, this.REAL_DELETE_FLAG);
				this.originData.setStatus(vnOrgIdx, this.ETBDELETEDFLAG);
			} else if(vnStatus == this.ETBADDEDFLAG) {
				this.originData.setStatus(vnOrgIdx, this.REAL_DELETE_FLAG);
			} else {
				this.originData.setStatus(vnOrgIdx, this.ETBDELETEDFLAG);
			}
		} else {
			if(vnStatus == this.ETBADDEDFLAG) {
				this.originData.setStatus(vnOrgIdx, this.REAL_DELETE_FLAG);
			} else {
				this.originData.setStatus(vnOrgIdx, this.ETBDELETEDFLAG);
			}
		}
		return 0;
  };
  /**
   * 주어진 row의 fieldname을 통한 value 질의
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @return 조회 결과 리턴
   * @type String
   */
  this.get = function(pnIdx, psName) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	var vnHeaderIdx = this.header.getHeaderIndex(psName);
  	var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);
  	return (vnOrgIdx == null) ? "" : this.originData.getValue(vnOrgIdx, vnHeaderIdx);
  };
  /**
   * 컬럼의 수를 리턴
   * @return 컬럼의 수
   * @type Number
   */
  this.getColCnt = function() {
  	return this.header.getHeaderCnt();
  };
  /**
   * 주어진 컬럼 인덱스에 해당하는 컬럼 명을 반환하는 메소드
   * @return 주어진 컬럼 인덱스에 해당하는 컬럼 명
   * @param {Number} pnIndex 컬럼 인덱스
   * @type String
   */
  this.getColName = function(pnIdx) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	return this.header.getHeaderColumn(pnIdx);
  };
  /**
   * DataSet의 CRUD Node의 속성을 리턴한다.
   * @param {String} psAttrName 해당 속성 명
   * @return 해당 속성명에 속성값을 리턴한다.
   * @type String
   */
  this.getCRUDAttr = function(psAttrName) {
  	return this.autoCUD.getAttr(psAttrName);
  };
  /**
   * index 값을 얻는다
   * @return index값 리턴
   * @type Number
   */
  this.getIndex = function() {
  	return this.viewData.getIndex();
  };
  /**
   * Row에 설정한 특정 속성을 가져온다.
   * @param {Number} pnIndex 조회할 Row 번호
   * @param {String} psAttrName 질의 할 속성 명
   * @return 속성 값
   * @type String
   */
  this.getRowAttr = function(pnIdx, pnAttrNm) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	pnIdx = this.viewData.getOriginalIndex(pnIdx);
  	return this.originData.getRowAttr(pnIdx, pnAttrNm);
  };
  /**
   * Row 갯수를 얻는다
   * @return Row Count 값
   * @type Number
   */
  this.getRowCnt = function() {
  	return this.viewData.getRowCnt();
  };
  /**
   * DataSet에 설정한 Sort 정보를 Node Path 별로 질의하여 결과를 리턴한다.
   * @param {String} psRef 컬럼 Node Path
   * @return 질의한 소트 정보
   * @type String
   */
  this.getSortItem = function(psRef) {
  	return this.sorter.get(psRef);
  };
  /**
   * DataSet에 설정한 Sort Item의 Column 정보를 리턴한다.<br/>
   * 여러개의 Column 정보가 있을 경우 "," 딜리미터를 이용하여 분리하여 리턴
   * @return Sort Item에 존재하는 Column 명
   * @type String
   */
  this.getSortItemColumNames = function() {
  	var voNames = this.sorter.getColumnNames();
  	return voNames.join(",");
  };
  /**
   * crud type을 얻는다
   * @param {Number} pnIndex 조회대상 index
   * @return CrudType Number
   * @type Number
   */
  this.getStatus = function(pnIdx) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	return this.viewData.getStatus(pnIdx);
  };
  /**
   * 모든 Row 상태 중 입력한 상태를 가지고 있는 Row에 index 값을 구분자로 연결하여 리턴한다.
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.getStatusIndex(eXria.data.CrudType.ADDEDFLAG, ";");
   * @param {Number} pnType 조회대상 CRUDTYPE (eXria.data.CrudType)
   * @param {String} psDelimeter 연결할 구분자, 생략할 경우 ',' 기본 설정
   * @return 입력 상태를 가진 Row의 index값
   * @type String
   */
  this.getStatusIndex = function(pnType, psDelimeter) {
  	psDelimeter = psDelimeter == null ? "," : psDelimeter;

		var size = this.viewData.getRowCnt();
		var viewDataIdx;
		var status;
		
		var result = "";
		
		for(var i = 0 ; i < size ; i++) {
			status = this.viewData.getStatus(i);
			if(pnType == status) {
				viewDataIdx = i + 1;
				if(i == size - 1) {
         result = result + viewDataIdx; 
        } else {
         result = result + viewDataIdx + psDelimeter; 
        }
			}
		}
		return result;
  };
  /**
   * 주어진 index에 새로운 row를 insert 한다
   * @param {Number} pnIndex Insert 대상 Index
   * @param {Boolean} pbAfter pnIndex 뒤에 추가 유무
   * @return insert 후 row 갯수
   * @type Number
   */
  this.insertRow = function(pnIdx, pbAfter) {
  	var vnViewIdx = this.toArrayIndex(pnIdx);
		
		var vnOrgIdx = 0;
		
		if(this.viewData.getRowCnt() <= 0) {
			vnOrgIdx = this.originData.addRow();
			this.viewData.addRow(vnViewIdx, vnOrgIdx, this.ETBEMPTYEDFLAG);
		} else {
			if(pbAfter) {
				vnViewIdx++;
			}
	
			vnOrgIdx = this.originData.addRow();
			this.viewData.addRow(vnViewIdx, vnOrgIdx, this.ETBEMPTYEDFLAG);
			
			var voRow = this.originData.getRowElement(vnOrgIdx);
			var voTarget = this.originData.getRowElement(this.viewData.getOriginalIndex(vnViewIdx));
			
//			if(pbAfter) {
//				if(voTarget != null) {
//					voRow.getParentNode().insertBefore(voRow, voTarget);
//				}
//			} else {
//				voRow.getParentNode().insertBefore(voRow, voTarget);
//			}
		}
		
		var vnAfterRowCnt = this.viewData.getRowCnt();
		return vnAfterRowCnt;
  };
  
  this.getOriginDataList = function() {
  	return this.originData;
  }
  
  this.clear = function() {
		this.originData.clear();
		this.viewData.clear();
		this.delData.clear();
		this.sorter.clear();
		this.filter.clear();
  };
  /**
   * DataSet을 Rebuild 한다.
   * @param {Boolean} pbAdd Add 유무 설정
   * @return Row Count
   * @type Number
   */
  this.rebuild = function(pbAdd) {
  	if (!pbAdd) {
			this.clear();
		}

		var childNode;
		var rowElement;
		var tagName;
		var addedCnt = 0;
		
		var voInst = this.model.getInstance(this.conInfo);
		var rowNodes = (voInst) ? voInst.selectNodes(this.srcQuery) : null;
		if(rowNodes == null) return 0;
		var nodeSize = rowNodes.getLength();
		var vnIdx;
		var voColNodes, voColNode;
		var len, j;
		var voAttr, vnAttrSize, voAttrNode, vsAttrName;
		
		for (var i = 0; i < nodeSize; i++) {
			childNode = rowNodes.item(i);
			if(childNode.getNodeType() != 1) continue;
			
			var row = [];
			row[this.ROW_STATUS] = this.ETBUNCHANGEDFLAG;
			row[this.HIDE_ROW_STATUS] = this.ETBUNCHANGEDFLAG;
			row[this.ROW_NODE] = childNode;
			
//			row[this.ROW_ATTR] = {};
//			
//			voAttr = childNode.getAttributes();
//			vnAttrSize = voAttr.getLength();
//			for(j = 0 ; j < vnAttrSize ; j++) {
//				voAttrNode = voAttr.item(j);
//				if(voAttrNode != null) {
//					vsAttrName = voAttrNode.getNodeName();
//					if(vsAttrName != null) {
//						row[this.ROW_ATTR][vsAttrName] = voAttrNode.getNodeValue();
//					}
//				}
//			}
			
			childNode.setAttribute(this.DATA_ROW_ATTR_NAME, i);
			
			this.addRow(row);
			addedCnt++;
		}
    
    //parentNode sync 맞추기 위한 코드
    var voInst = this.dataSet.model.getInstance(this.dataSet.getConnectionInfo());
    var vsPath = this.dataSet.getSourceQuery().substr(0, this.dataSet.getSourceQuery().lastIndexOf("/"));
    this.originData.parentNode = (voInst) ? voInst.selectSingleNode(vsPath) : null;
    
		return addedCnt;
  };
  
  this.addRow = function(row) {
		var originIdx = this.originData.addRow(row);
		this.viewData.addRow(null, originIdx, this.ETBUNCHANGEDFLAG);
	};
	
  /**
   * primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 삭제할 primary key 값
   * @return void
   * @type void
   */
  this.removePrimaryKey = function(psTableName, psColName, psPkName) {
		var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			voTable.removePrimaryKey(psPkName);
		} else {
			throw new Error("AutoCUD Table not register : " + psTableName);
		}
	};
  /**
   * column 정보를 remove 한다
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName remove 할 값
   * @return void
   * @type void
   */
  this.removeUpdateColumn = function(psTableName, psColName, psDbName) {
		var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			voTable.removeUpdateColumn(psDbName);
		} else {
			throw new Error("AutoCUD Table not register : " + psTableName);
		}
	};
  /**
   * instance를 reset 한다
   * @param {Boolean} pbResetInstance 연결된 Instance와 동기화 여부를 결정한다. false시에 동기화 된다.
   * @return void
   * @type void
   */
  this.reset = function(pbResetInstance) {
		if(pbResetInstance) {
			//true일때 instance까지 지운다
			this.originData.clearInstance();
		}
		
		//false일때 dataSet만 지운다
		this.originData.clear();
		this.viewData.clear();
		this.delData.clear();
		this.sorter.clear();
		this.filter.clear();
  };
  /**
   * 원본값으로 restore 한다
   * @param {Boolean} pbAll all 유무
   * @return void
   * @type void
   */
  this.restoreOriginVal = function(pbAll) {
  	if(pbAll) {
			var vnViewRowCnt = this.viewData.getRowCnt();
			var vnHeaderCnt = this.header.getHeaderCnt();
			var vnOrgIdx;
			var voRow;
			var voCol;
			var vnStatus;
			var vsOrg, vsCurrent;
			
			for(var i = 0 ; i < vnViewRowCnt ; i++) {
				vnOrgIdx = this.viewData.getOriginalIndex(i);
				vnStatus = this.originData.getHideStatus(vnOrgIdx);
				
				if(vnStatus == this.ETBUNCHANGEDFLAG) continue;
				
				for(var j = 0; j < vnHeaderCnt ; j++) {
					this.originData.setValueOnly(vnOrgIdx, j, this.originData.getOriginalValue(vnOrgIdx, j));
				}
			}
		} else {
			var vnOrgIdx = this.viewData.getIndex();
			var voCol;
			
			var vnHeaderCnt = this.getColCnt();
			for(var i = 0; i < vnHeaderCnt; i++) {
				this.originData.setValueOnly(vnOrgIdx, i, this.originData.getOriginalValue(vnOrgIdx, i));
			}
		}
  };
  /**
   * 주어진 row의 fieldname에 value를 설정한다
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @param {String} psValue 설정할 값
   * @return 성공 : 1, 실패 : 0
   * @type Number
   */
  this.set = function(pnIdx, psFieldName, psValue) {
  	psValue = psValue == null ? "" : psValue.toString();

  	pnIdx = this.toArrayIndex(pnIdx);
		
		//range check
		if(this.viewData.rangeCheck(pnIdx) == false) {
			return 0;
		}
		
		var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);
		var vnColIdx = this.header.getHeaderIndex(psFieldName);
		
		if(vnColIdx == -1) {
			return 0;
		} else {
			this.originData.setValue(vnOrgIdx, vnColIdx, psValue);
			var vnStatus = this.originData.getStatus(vnOrgIdx);
			this.viewData.setStatus(pnIdx, vnStatus);
			
			return 1;
		}
  };
  /**
   * Data 동기화 설정을 한다
   * @param {Boolean} pbSync 동기화 여부 설정
   * @return void
   * @type void
   */
  this.setDataSync = function(pbSync) {
  	this.srcSync = pbSync;
  };
  /**
   * index를 설정한다
   * @param {Number} pnIndex 설정할 index 값
   * @return void
   * @type void
   */
  this.setIndex = function(pnIdx) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	this.viewData.setIndex(pnIdx);
  };
  /**
   * table에 prefix를 설정한다
   * @param {String} psTableName 설정 대상
   * @param {String} psPrefix 설정할 값
   * @return void
   * @type void
   */
  this.setPrefix = function(psTableName, psPrefix) {
		var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			voTable.setPrefix(psPrefix);
		} else {
			throw new Error("AutoCUD Table not register : " + psTableName);
		}
	};
  
  this.getOriginalDataIndex = function(pnIdx) {
  	pnIdx = this.toArrayIndex(pnIdx);
  	
		//range check
		if(this.viewData.rangeCheck(pnIdx) == false) {
			return -1;
		}
		
		var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);
		return vnOrgIdx;
  };
  /**
   * 해당 Row에 속성을 설정한다
   * @param {Number} pnIndex Row Number
   * @param {String} psAttrName 속성 명
   * @param {String} psAttrVal 속성 값
   * @return void
   * @type void
   */
  this.setRowAttr = function(pnIdx, psAttrName, psAttrVal) {
  	if(psAttrVal == null) psAttrVal = "";
		
		var vsOrgIdx = this.getOriginalDataIndex(pnIdx);
		
		if(vsOrgIdx == -1) {
			return;
		}
		
		var voRow = this.originData.setRowAttr(vsOrgIdx, psAttrName, psAttrVal);
  };
  /**
   * sort item을 설정한다
   * @param {String} psNodeName 대상 Node 설정
   * @param {Number} pnType 1 : text, 0 : not text
   * @param {Boolean} pbAscending true : 오름차순, false : 내림차순
   * @return void
   * @type void
   */
  this.setSortItem = function(psNodeName, pnType, pbAsc) {
  	this.sorter.addSortItem(psNodeName, pnType, pbAsc);
  };
  /**
   * 원하는 index에 CRUD type을 설정한다
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.setStatus(1, eXria.data.CrudType.MODIFIEDFLAG);
   * @param {Number} pnIndex 설정할 index
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatus = function(pnIdx, pnType) {
		var vnViewIdx = this.toArrayIndex(pnIdx);
		
		if(this.viewData.rangeCheck(vnViewIdx) == false) {
			return;
		}
		
		this.viewData.setStatus(vnViewIdx, pnType);

		//original
		var vnOrgIdx = this.viewData.getOriginalIndex(vnViewIdx);
		this.originData.setStatus(vnOrgIdx, pnType);
  };
  /**
   * CRUD type을 설정한다
   *  ex) var voDataset = page.getDataSet("dataset1");
   *      voDataset.setStatusAll(eXria.data.CrudType.MODIFIEDFLAG);
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusAll = function(pnType) {
  	var vnLen = this.viewData.getRowCnt();
		var vnOrgIdx;
		var row;
		for(var i = 0; i < vnLen; i++) {
			this.viewData.setStatus(i, pnType);

			vnOrgIdx = this.viewData.getOriginalIndex(i);
			this.originData.setStatus(vnOrgIdx, pnType);
		}
  };
  /**
   * 범위로 입력한 Row에 CRUD Type으로 설정한다.
   *  ex) page.getDataSet("dataset1").setStatusRange(1, 2, eXria.data.CrudType.ADDEDFLAG);
   * @param {Number} pnStart 시작 Row 번호
   * @param {Number} pnEnd 종료 Row 번호
   * @param {Number} pnType CRUDTYPE (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusRange = function(pnStart, pnEnd, pnType) {
  	var vnSt = this.toArrayIndex(pnStart);
		var vnEn = this.toArrayIndex(pnEnd);

		var vnOrgIdx;
		var row;
		for(var i = vnSt; i <= vnEn; i++) {
			this.viewData.setStatus(i, pnType);

			vnOrgIdx = this.viewData.getOriginalIndex(i);
			this.originData.setStatus(vnOrgIdx, pnType);
		}
  };
  /**
   * set은 값을 변경 하면서 동시에 그 Row에 상태값을 수정된 상태로 변경 하지만
   * 이 메서드는 status를 변경하지 않고 단지 value만을 변경 한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName Field Name
   * @param {String} psValue 설정할 값
   * @return 성공하면 1, 실패하면 0
   * @type Number
   */
  this.simpleSet = function(pnIdx, psName, psValue) {
  	pnIdx = this.toArrayIndex(pnIdx);

		if(this.viewData.rangeCheck(pnIdx) == false) {
			return 0;
		}
		
		psValue = psValue == null ? "" : psValue.toString();
    
		
		var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);

		var vnColIdx = this.header.getHeaderIndex(psName);
		if(vnColIdx == -1) {
			return 0;
		} else {
			this.originData.setValueOnly(vnOrgIdx, vnColIdx, psValue);
			return 1;
		}
  };
  /**
   * sort를 수행한다
   * @return void
   * @type void
   */
  this.sort = function() {
  	this.sorter.doSort();
  };
  /**
   * 현재 DataSet에 설정 되어 있는 PrimaryKey들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명. ""일 경우 모든 테이블의 primary key를 반환
   * @type String
   * @return Primary Key 값들
   */
  this.getPrimaryKeys = function(psTableName) {
		var result = "";
		var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			var pks = voTable.getPrimaryKeys();
			var pk;
			for(var m in pks) {
				result = result + pks[m] + ":" + m + ",";
			}

			if(result.length > 0) {
				result = result.substr(0, result.length - 1);
			}
		} else {
//			throw new Error("AutoCUD Table not register : " + psTableName);
		}
		
		return result;
  };
  /**
   * 현재 DataSet에 설정 되어 있는 update column들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명.
   * @type String
   * @return 현재 DataSet에서 입력한 table에 설정 되어 있는 UpdateColumn들을 "," 구분자로 하여 문자열로 리턴한다.
   */
  this.getUpdateCols = function(psTableName) {
		var result = "";
		var voTable = this.autoCUD.getTableInfo(psTableName);
		if(voTable != null) {
			var upCols = voTable.getUpdateCols();
			var pk;
			for(var m in upCols) {
				result = result + upCols[m] + ":" + m + ",";
			}

			if(result.length > 0) {
				result = result.substr(0, result.length - 1);
			}
		} else {
			throw new Error("AutoCUD Table not register : " + psTableName);
		}
		
		return result;
	};
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블명들을 "," 구분자로 하여 문자열로 리턴한다.
   * @type String
   * @return  DataSet에 등록 되어져 있는 AutoCRUD처리 테이블들의 이름을 리턴한다. 복수개일 경우 "," 구분자로 구분하여 리턴한다.
   */
  this.getCRUDTableNames = function() {
  	var voTableNames = this.autoCUD.getTableNames();
  	return voTableNames.join(",");
  };
  /**
   * DataSet에서 삭제된 로우의 전체 count를 리턴한다.
   * @type Number
   * @return delete된 row의 전체 수.
   */
  this.getDelTableRowCnt = function() {
  	return this.delData.getRowCnt();
  };
  /**
   * DataSet에서 삭제된 로우 중 해당 인덱스와 컬럼명의 값을 리턴한다.
   * @param {Number} pnIdx Row Index
   * @param {String} psFieldName 컬럼 명
   * @return index 조건으로 검색된 삭제 row의 해당 컬럼의 값.
   * @type String
   */
  this.getDelTableValue = function(pnIdx, psFieldName) {
  	var pnIdx = this.toArrayIndex(pnIdx);
		var vnColIdx = this.header.getHeaderIndex(psFieldName);

		var vnOrgIdx = this.delData.getOriginalIndex(pnIdx);
		var vsValue = this.originData.getValue(vnOrgIdx, vnColIdx);
		
		return vsValue;
  };
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블을 등록하는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return void
   * @type void
   */
  this.addCRUDTable = function(psName) {
		this.autoCUD.createTableInfo(psName);
	};
  /**
   * DataSet에 CRUD 테이블에서 해당 테이블 명을 가지고 있는 테이블을 삭제한다.
   * @param {String} psTableName 삭제할 테이블 명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeCRUDTable = function(psTableName) {
  	this.autoCUD.removeTableInfo(psTableName);
  	return 0;
  };
  /**
   * 현재 DataSet에 등록된 request 테이블의 prefix를 얻어오는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return 첫 인자로 입력한 아이디를 가지는 테이블의 Prefix 값을 문자열로 리턴하여 준다.
   * @type String
   */
  this.getPrefix = function(psTableName) {
  	var vsPrefix = null;
		var voTableInfo = this.autoCUD.getTableInfo(psTableName);
		if(voTableInfo != null) {
			vsPrefix = voTableInfo.getPrefix();
		} else {
			throw new Error("AutoCUD Table not register : " + psTableName);
		}
		return vsPrefix;
  };
  /**
   * submission에 추가할 수 있는 CRUD 문자열 정보를 반환해주는 메소드.
   * @param {Boolean} pbGetUnchanged Unchanged Status의 row데이타 정보도 가져올지 여부
   * @type String
   * @return submission에 추가할 수 있는 CRUD 문자열 정보를 반환
   */
  this.getAutoCRUDString = function() {
  	var vsData = this.autoCUD.getAutoCRUDString();
		return vsData;
  };
  /**
   * 해당 Row에서 필드명과 일치하는 곳에 수정 바로 이전 값을 리턴한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @type String
   * @return 수정되기 이전 값을 리턴한다. 이 기능을 쓰기 위해서는 Keep the Original Data 속성이 설정 되어 있어야 한다.
   */
  this.getOrigin = function(pnIdx, psName) {
  	pnIdx = this.toArrayIndex(pnIdx);
		
		if(this.viewData.rangeCheck(pnIdx) == false) {
			return null;
		}
		
		var vnOrgIdx = this.viewData.getOriginalIndex(pnIdx);
		var resultVal = null;

		var vnColIdx = this.header.getHeaderIndex(psName);
		if(vnColIdx == -1) {
			resultVal = null;
		} else {
			resultVal = this.originData.getOriginalValue(vnOrgIdx, vnColIdx);
		}
		
		return resultVal;
  };
  /**
   * DataSet과 원본 데이터와의 Sync 상태를 리턴한다.
   * @return Sync 상태시 True 리턴
   * @type Boolean
   */
  this.isDataSync = function() {
  	return this.srcSync;
  };
  /**
   * DataSet의 Keep Original Value 상태 리턴
   * @return Keep 상태시 True 리턴
   * @type Boolean
   */
  this.isKeepOriginalValue = function() {
  	return this.isKeepOrgin;
  };
  /**
   * CRUD에 관계된 데이타셋 속성 값을 설정하기 위한 메소드.
   * - submission에서 데이타셋으로 부터 unchanged status의 row정보를 하져올 때 setCRUDAttr("alltype", "true")를 호출함.
   *   해제시에는 setCRUDAttr("alltype", "false")를 호출함.
   * @param {String} psName 속성명
   * @param {String} psValue 속성값
   * @return void
   * @type void
   */
  this.setCRUDAttr = function(psName, psValue) {
  	if(psValue == null) psValue = "";
		this.autoCUD.setAttr(psName, psValue);
  };
  /**
   * 현재 DataSet을 초기화 시킨다.
   * @type void
   * @return void
   */
  this.refresh = function() {};
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 추가한다.
   * @param {Array} paCol 추가할 컬럼 Array
   * @type void
   * @return void
   */
  this.addSkipSCList = null;
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트 중 파라미터로 넘어온 컬럼들을 삭제한다.
   * @param {Array} paCol 삭제할 컬럼 Array
   * @type void
   * @return void
   */
  this.removeSkipSCList = null;
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 전부 삭제한다.
   * @type void
   * @return void
   */
  this.clearSkipSCList = null;
  /**
   * DataSet에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {Number} pnIndex 컬럼을 삽입시킬 위치 값
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.addColumn = function(pnIdx, psColName) {
  	var vnHeaderLen = this.header.getHeaderCnt();
  	pnIdx = (pnIdx == null || pnIdx > vnHeaderLen) ? vnHeaderLen + 1 : pnIdx;
  	pnIdx = this.toArrayIndex(pnIdx);
  	if(psColName == null) -1;
  	return this.originData.addColumn(pnIdx, psColName);
  };
  /**
   * DataSet의 마지막에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.appendColumn = function(psColName) {
  	if(psColName == null) return -1;
  	return this.addColumn(null, psColName);
  };
  /**
   * DataSet에 해당 컬럼명을 가지고 있는 컬럼을 삭제한다.
   * @param {String} psColName 삭제할 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeColumn = function(psColName) {
  	if(psColName == null) return -1;
  	var vnIdx = this.header.getHeaderIndex(psColName);
		this.originData.removeColumn(vnIdx);
		return 0;
  };
  /**
   * dataset의 Source Type을 리턴한다.
   * @return dataset의 Source Type
   * @type {Number}
   */
  this.getSrcType = function() {
  	return this.srcType;
  };
  /**
   * dataset의 Connection Info를 리턴한다.
   * @return dataset의 Connection Info
   * @type {String}
   */
  this.getConnectionInfo = function() {
  	return this.conInfo;
  };
  /**
   * dataset의 Source Query를 리턴한다.
   * @return dataset의 Source Query
   * @type {String}
   */
  this.getSourceQuery = function() {
  	return this.srcQuery;
  };
  /**
   * DataSet의 특정 Row에 해당하는 실제 Instance의 Row를 반환한다.
   * @param {Number} pnIdx 실제 리턴 받기를 원하는 DataSet Row Number
   * @return Instance Row 번호
   * @type {Number}
   */
  this.getInstanceRowIndex = function(pnIdx) {
  	var vnOrgIdx = this.getOriginalDataIndex(pnIdx);
  	return vnOrgIdx + 1;
  };
  
  this.toArrayIndex = function(pnIdx) {
  	pnIdx = (pnIdx <= 1 ? 0 : pnIdx - 1);
		return pnIdx;
  };

  this.getRowDataStrContainFrontIndex = function(pnStIdx, pnEndIdx) {
  	var pnStIdx = this.toArrayIndex(pnStIdx);
		var pnEndIdx = this.toArrayIndex(pnEndIdx);
		
		var orgIdx = null;
		var i, j;
		
		var headerNames = this.header.getHeaderColumns();
		var columnLen = headerNames.length;
		var voMainList = [];
		for(i = pnStIdx ; i < pnEndIdx ; i++) {
			orgIdx = this.viewData.getOriginalIndex(i);
			
			var voRow = {};
			voRow["@frontIndex"] = parseInt(this.viewData.getOriginalIndex(i)) + 1;
			for(j = 0 ; j < columnLen ; j++) {
				orgValue = this.originData.getValue(orgIdx, j);
				voRow[headerNames[j]] = orgValue;
			}
			voMainList.push(voRow);
		}
//    var resultData = (voMainList.toJSON) ? voMainList.toJSON() : JSON.stringify(voMainList);
    var resultData = null;
    if(window.JSON) {
      resultData = (voMainList.toJSON) ? voMainList.toJSON() : window.JSON.stringify(voMainList);
    } else {
      resultData = eXria.controls.xhtml.Util.toJSONString(voMainList);
    }
		return resultData; 
  };
  
  this.getRowTagName = function() {
  	return this.rowTagName;
  };
  
  this.getRowDataList = function(pnStart, pnEnd) {
    pnStart = this.toArrayIndex(pnStart);
    pnEnd = this.toArrayIndex(pnEnd);
    
    var voHeaderNames = this.header.getHeaderColumn();
		var vnColLen = voHeaderNames.length;
		
		var vnViewRowCnt = this.viewData.getRowCnt();
		
		if(pnEnd > (vnViewRowCnt - 1)) {
			pnEnd = vnViewRowCnt;
		}

		var vnOrgIdx = 0;
		var vsOrgVal = null;
		
		var voNodeList = [];
		
		var i=0, j=0;
		for(i = pnStart ; i <= pnEnd ; i++) {
			vnOrgIdx = this.viewData.getOriginalIndex(i);
			var voMap = new eXria.data.xhtml.MapNode();
			
			for(j = 0 ; j < vnColLen ; j++) {
				vsOrgVal = this.originData.getValue(vnOrgIdx, j);
				voMap.put(voHeaderNames[j], vsOrgVal);
			}
			voNodeList[i] = voMap;
		}
		return voNodeList;
  };
  
  this.getRowDataStr = function(pnStart, pnEnd) {
  	var pnStIdx = this.toArrayIndex(pnStIdx);
		var pnEndIdx = this.toArrayIndex(pnEndIdx);
		
		var orgIdx = null;
		var i, j;
		
		var headerNames = this.header.getHeaderColumns();
		var columnLen = headerNames.length;
		var voMainList = new Array();
		
		for(i = pnStIdx ; i <= pnEndIdx ; i++) {
			orgIdx = this.viewData.getOriginalIndex(i);
			var voRow = {};
			for(j = 0 ; j < columnLen ; j++) {
				orgValue = this.originData.getValue(orgIdx, j);
				voRow[headerNames[j]] = orgValue;
			}
			voMainList.push(voRow);
		}
		return (voMainList.toJSON) ? voMainList.toJSON() : window.JSON.stringify(voMainList);
  };
  
  /**
   * dataset 모든 row의 특정 속성 값을 배열에 담아 반환해주는 메소드
   * @param {String} psAttrName 검색 요청 속성명
   * @return 모든 row의 특정 속성 값을 담은 배열
   */
  this.getRowsAttr = function(psAttrName) {
  	var vnRowLen = this.viewData.getRowCnt();

		var voAttrData = [];
		var voRow = null;
		var voAttr = null;
		for(var i = 0 ; i < vnRowLen ; i++) {
			voRow = this.originData.getRow(this.viewData.getOriginalIndex(i));
			voAttr = voRow.getAttr(psAttrName);
			if(voAttr != null && voAttr != "") {
				var voAttribute = [];
				voAttribute[0] = i + 1;
				voAttribute[1] = voAttr;
				voAttrData.add(voAttribute);
			}
		}
		return voAttrData;
  };
  /**
   * dataset 모든 row의 특정 속성을 일괄 설정하기 위한 메소드
   * @param {String} psAttrName 값 설정 대상 속성명
   * @param {String} psAttrValue 일괄 설정 속성 값
   */
  this.setRowsAttr = function(psAttrName, psAttrValue) {
  	if(psAttrValue == null) psAttrValue = "";
		
		var vnRowLen = this.viewData.getRowCnt();
		var vnOrgIdx;
		for(var i = 0 ; i < vnRowLen ; i++) {
			vnOrgIdx = this.viewData.getOriginalIndex(i);
			this.originData.setRowAttr(vnOrgIdx, psAttrName, psAttrValue);
		}
  };
  /**
   * dataset originData 수정
   * @param {Number} pnIdx row index
   * @param {Number} pnColIdx column index
   * @param {Number} psVal value
   * @return void
   * @type void
   */
  this.setOrigin = function(pnIdx, pnColIdx, psVal) {
    this.originData.setOriginalData(pnIdx, pnColIdx, psVal);
  };
  
  this.init();
};
/**
 * @fileoverview
 * eXria.data.xhtml Package
 */
/**
 * eXria.data.xhtml package
 * @author Cho, Young Jin.
 */
eXria.data.json = {};
/**
 * @fileoverview
 * XHTML Mode 사용시 Document Node를 Collection으로 wrapping 해주는 클래스
 */
/**
 * XHTML Mode 사용시 Document Node를 Collection으로 wrapping 해주는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.xhtml.Node
 */
eXria.data.json.CollectionNode = function(paList) {
  this.node = paList;
  this.nodeList = paList;

  this.add = function(poNode) {
    if(this.size() == 0 && (page.metadata.useDomPath == true)){
      var vsRowName = (poNode.parentNode != null) ? poNode.parentNode.nodeName : poNode.name;
      
      var voArrayNode = this.node.createElement(vsRowName, []);
      if(this.nodeList.getLength() == 0) { // json object 선언은 되어있음
        this.node.appendChild(voArrayNode);
        this.nodeList.nodeList = voArrayNode.node;
      } else if(this.nodeList.nodeList[0] && (this.nodeList.nodeList[0].getNodeType() == 3)) { // json object 선언은 되어있음. text nodes
        var voNode = this.node.createElement(this.node.name, {});
        this.node.parentNode[this.node.name] = voNode;
        this.node.appendChild(voArrayNode);
        this.nodeList.nodeList = voArrayNode.node;
      }
    }
    if(this.nodeList instanceof eXria.data.json.NodeList || this.nodeList instanceof eXria.data.xhtml.NodeList) {
      this.nodeList.nodeList.push(poNode.node);
    }else {
      this.nodeList.push(poNode.node);
    }
  };
  /**
   * 현재 Collection의 Item 갯수를 리턴한다.
   * @return 하위 ElementNode의 갯수
   * @type Number
   */
  this.size = function() {
    if(this.nodeList == null) return 0;
    if(this.nodeList instanceof eXria.data.json.NodeList || this.nodeList instanceof eXria.data.xhtml.NodeList) {
      var voNodeList = this.nodeList;
      var vnSize = voNodeList.getLength();
      var vnCnt = 0;
      for (var i = 0; i < vnSize; i++){
        if(voNodeList.item(i).getNodeType() == 1){
          vnCnt++;
        }
      }
      return vnCnt;
    }
    return this.nodeList.length;
  };
  /**
   * Parameter로 넘어온 Index에 해당하는 위치의 Node를 리턴한다.
   * @param {Number} pnIndex 리턴받은 Node의 Index
   * @return 해당 Index의 Node. Index가 Node의 범위 밖인 경우 null을 리턴한다.
   * @type  XMLNode
   */
  this.get = function(pnIndex) {
    var voNodeList = this.nodeList;
    var vnLen = voNodeList.getLength();
    var voItem = null;
    for (var i = 0; i < vnLen; i++){
      if(voNodeList.item(i).getNodeType() == 3){
        pnIndex++;
      }
      if(i == pnIndex) voItem = this.nodeList.item(pnIndex);
    }
    return voItem;
  };
  /**
   * 주어진 값이 현재 Node 구성 요소의 인덱스 번호로서 적합한 지 여부를 검사하는 메소드
   * Collection의 Range안에 없을 경우 Error Throw.
   * @param {Number} pnIndex 체크할 Index
   * @return void
   * @type void
   * @private
   */
  this.rangeCheck = function(pnIndex) {
    if (pnIndex < 0 || pnIndex > this.size()) {
      throw new Error("Index out of range : " + pnIndex);
    }
  };
  /**
   * Collection에서 Parameter로 넘어온 Index에 해당되는 위치에 두번째 Parameter로 넘어온 Node를 추가한다. 만약 해당 Index에 기존 Node가 존재할 경우 기존 Node는 삭제 된다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type XMLNode
   */
  this.set = function(pnIndex, poNode) {
    var vnSize = this.size();
    if (vnSize < pnIndex) {
      throw new Error("Index out of range : " + pnIndex);
    } else if (vnSize == pnIndex) {
      this.add(poNode);
      return null;
    } else {
      var voNodeList = this.nodeList;
      var vnLen = voNodeList.getLength();
      var voItem = null;
      for (var i = 0; i < vnLen; i++){
        if(voNodeList.item(i).getNodeType() == 3){
          pnIndex++;
        }
        if(i == pnIndex) {
          this.nodeList[pnIndex] = poNode;
        }
      }
//      this.nodeList[pnIndex] = poNode;
      return poNode;
    }
    
  };
  /**
   * 넘겨 받은 Index에 Node를 추가 한다. 해당 Index에 기존에 Node가 존재 할 경우 해당 Node 및 이후 Index의 Node들의 Index가 하나씩 밀린다.
   * @param {Number} pnIndex 추가할 위치 Index
   * @param {XMLNode} poNode 추가할 Node
   * @return 넘겨받은 Index에 Node가 존재할 경우 기존 Node를 대체하고 기존 Node를 리턴한다.
   * @type XMLNode
   */
  this.insert = function(pnIndex, poNode) {
    
    var vnSize = this.size();
    if(vnSize < pnIndex - 1) { // over
      throw new Error("Index out of range : " + pnIndex);
    } else if(vnSize == pnIndex - 1) { // last
      this.add(poNode);
      return null;
    } else {
      if(poNode instanceof eXria.data.json.Node || poNode instanceof eXria.data.xhtml.Node) poNode = poNode.node;
      var voNodeList = this.nodeList;
      var vnLen = voNodeList.getLength();
      var voItem = null;
      for (var i = 0; i < vnLen; i++){
        if(voNodeList.item(i).getNodeType() == 3){
          pnIndex++;
        }
        if(i == pnIndex) {
          this.nodeList.nodeList.splice(pnIndex, 0, poNode);
        }
      }
//      this.nodeList.nodeList.splice(pnIndex, 0, poNode);
      return poNode;
    }
  };
  /**
   * Parameter로 넘어온 Index에 해당하는 Node를 삭제한다.
   * @param {Number} pnIndex 삭제할 Node Index
   * @return 삭제된 Node 참조값
   * @type XMLNode
   */
  this.remove = function(pnIndex) {
    var voNode = this.get(pnIndex);
    if(voNode) {
      var voNodeList = this.nodeList;
      var vnLen = voNodeList.getLength();
      var voItem = null;
      for (var i = 0; i < vnLen; i++){
        if(voNodeList.item(i).getNodeType() == 3){
          pnIndex++;
        }
        if(i == pnIndex) {
          this.nodeList.nodeList.splice(pnIndex, 1);
        }
      }
//      this.nodeList.splice(pnIndex, 1);
    }
    return voNode;
  };
  /**
   * Collection의 모든 Node를 삭제 하고 Collection을 초기화 한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    this.nodeList = [];
  };
  /**
   * 현재 Collection이 비어 있는지 체크하여 리턴한다.
   * @return 비어있는 노드일 경우 TRUE, 아닐 경우 FALSE
   * @type Boolean
   */
  this.isEmpty = function() {
    return (this.size() == 0);
  };
  /**
   * 현재 Collection의 모든 Node를 Iterator로 변환하여 리턴한다.
   * @return 내부객체를 조회하는 Iterator
   * @type eXria.data.ArrayIterator
   * @see eXria.data.ArrayIterator
   */
  this.iterator = function() {
    var voNodeList = this.nodeList;
    var vnLen = voNodeList.getLength();
    var vaList = [];
    for(var i = 0; i < vnLen; i++){
      if(voNodeList.item(i).getNodeType() == 1){
        vaList.push(voNodeList.item(i));
      }
    }
    this.elements = vaList;
    return new eXria.data.ArrayIterator(this);
  };
  /**
   * 현재 메소드 이름을 리턴한다.
   * @return 내부요소를 파싱한 String 값
   * @type String
   */
  this.toString = function() {
    return "CollectionNode";
  };
  /**
   * 반복되는 하위 노드의 tagName 저장 속성
   * @return void
   * @type void
   * @private
   */
  this.reset = function() {
    if(this.node instanceof eXria.data.json.Node || this.node instanceof eXria.data.xhtml.Node){
//      if(!(this.node.node instanceof Array))
      this.nodeList = this.node.getChildNodes();
//      if(this.nodeList == null) this.nodeList = this.node.createElement(this.node.name ,[]);
    } else {
      this.nodeList = this.node;
    }
//    if(this.node instanceof eXria.data.json.Node || this.node instanceof eXria.data.xhtml.Node){
//      var voNodeList = this.node.getChildNodes();
//      if(voNodeList == null) {
//        this.nodeList = [];
//        return;
//      }
//      var vnLen = voNodeList.getLength();
//      var vaList = [];
//      for(var i = 0; i < vnLen; i++){
//        if(voNodeList.item(i).getNodeType() == 1){
//          vaList.push(voNodeList.item(i));
//        }
//      }
//      this.nodeList = new eXria.data.json.NodeList(vaList, voNodeList.name, voNodeList.parentNode);
//    } else {
//      this.nodeList = this.node;
//    }
  };
  /**
   * 생성시 reset 메소드 호출
   * @private
   */
  this.reset();
};

/**
 * @fileoverview
 * XHTML Mode에서의 Instance 객체를 관리하는 클래스
 */
/**
 * XHTML Mode에서의 Instance 객체를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {String} psId Instance Id
 * @param {eXria.form.Model} poModel eXria Model Objecct
 * @constructor
 * @base eXria.data.Instance
 */
eXria.data.json.Instance = function(psId, poModel) {
  /**
   * inheritget
   */
  eXria.data.Instance.call(this, psId, poModel);

  /**
   * instObj
   * @type Object
   */
  this.instObj = {};
  //수정
  /**
   * copyInstObj
   * @type Object
   */
  this.copyInstObj = null;

  /**
   * XML Text를 파싱하여 인스턴스에 바인딩한다.
   * @param {String} psTxt 파싱할 XML Text
   * @return void
   * @type void
   */
  this.loadTXT = function(psTxt) {
    var voNode = eval("("+psTxt+")");
    this.instObj = voNode;
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 CollectionNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 CollectionNode
   * @type eXria.data.xhtml.CollectionNode
   * @see eXria.data.xhtml.CollectionNode
   */
  this.createCollectionNode = function(psName) {
    var voNode = this.document.createNode(psName)
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.CollectionNode(
        new eXria.data.xhtml.Node(voNode));
  };
  /**
   * 넘겨 받은 XPath의 하위에 Node를 추가한다.
   * @param {String} psPath 추가할 위치에 해당하는 XPath
   * @param {XMLNode} poNode 추가할 XMLNode
   * @return void
   * @type void
   */
  this.appendNode = function(psPath, poNode) {
    var voNode = null;
    voNode = this.selectSingleNode(psPath);
    if (voNode == null) {
      throw new Error("Can not find the node : " + psPath);
    }
    voNode.appendChild(poNode);
  };
  /**
   * 넘겨받은 XPath를 단순 Value형태로 처리하기 위한 ValueNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 ValueNode
   * @type eXria.data.xhtml.ValueNode
   * @see eXria.data.xhtml.ValueNode
   */
  this.getValueNode = function(psXpath) {
    var voNode = this.selectSingleNode(psXpath);
    if (voNode == null) {
      return null;
    }
    return new eXria.data.xhtml.ValueNode(voNode);
  };
  /**
   * 파라미터로 넘어온 XPath의 Node Value를 리턴한다.
   * @param {String} psXpath 조회대상의 XPath 경로
   * @type String
   * @return 조회된 Value
   */
  this.getValue = function(psXpath) {
    try {
      var voNode = this.selectSingleNode(psXpath);
      return voNode != null ? voNode.getNodeValue() : null;
    } catch (e) {
      return null;
    }
  };

  this.toJSONString = function(poNodeObj, pbEscape) {
    if(pbEscape == null) pbEscape = true;
    var voUtil = eXria.controls.xhtml.Util;
    var voNode = poNodeObj;
    if(poNodeObj instanceof eXria.data.json.Node || poNodeObj instanceof eXria.data.xhtml.Node) voNode = poNodeObj.node;

    if(voNode == null) {
      return "null";
    } else if(voNode.constructor == String) {
      if(pbEscape) return voUtil.escapeJSONString(voNode);
      else return "\"" + voNode.toString() + "\"";
    } else if(voNode.constructor == Number) {
      return voNode.toString();
    } else if(voNode.constructor == Boolean) {
      return voNode.toString();
    } else if(voNode.constructor == Date) {
      return '{javaClass: "java.util.Date", time: ' + voNode.valueOf() +'}';
    } else if(voNode.constructor == Array) {
      var v = [];
      for(var i = 0; i < voNode.length; i++) {
        v.push(this.toJSONString(voNode[i], pbEscape));
      }
      return "[" + v.join(", ") + "]";
    } else {
      var v = [];
      for (attr in voNode) {
        if (voNode [attr] == null) {
          v.push("\"" + attr + "\": null");
        }else if (typeof voNode [attr] == "function" || eXria.protocols.json.ReservedType[attr]) {
          // TODO function일 경우도 파싱
          // skip
        } else {
          v.push(voUtil.escapeJSONString(attr) + ": " + this.toJSONString(voNode[attr], pbEscape));
        }
      }
      var vsStr = v.join(", ");
      if (!vsStr) return "\"\"";
      else return "{" + v.join(", ") + "}";
    }
  };

  /**
   * Instance의 dom객체의 XML 내용을 XPath를 이용하여 해당 위치에 데이터를 문자열로 얻는다.
   * @return dom 객체의 XML 문자열
   * @param {String} psXPath XPath 문자열
   * @param {Boolean} pbEscape 노드 값을 escape 처리할지 여부. 미 지정 시 escape 처리됨
   * @type String
   */
  this.getJSON = function(psXPath, pbEscape) {
    if (!psXPath) {
      return;
    }

    var voObj = this.getInstObj(psXPath);

    if(!voObj) {
      return null;
    }
    //var vsName = voObj.name instanceof String ? voObj.name : "\""+voObj.name+"\"";
    var vsJson;
    if(voObj.name !=null) {
      if(voObj.node.parent instanceof Array) {
        vsJson = this.toJSONString(voObj, pbEscape);
      } else {
        vsJson = "{ " + voObj.name + " : " + this.toJSONString(voObj, pbEscape) + " }";
      }
    } else vsJson =  this.toJSONString(voObj, pbEscape);
    return vsJson;
  };
  /**
   * Instnace의 주어진 XPath 경로에 Value를 설정한다.
   * @param {String} psXpath Value를 설정하기 위한 XPath 경로
   * @param {String} psValue 설정하고자 하는 Value
   * @return void
   * @type void
   */
  this.setValue = function(psXpath, psValue) {
    var voNode = this.selectSingleNode(psXpath);
    if (voNode == null) { //!voNode
      return null;
    }
    psValue = (psValue ? psValue : "");
    var vsValue = voNode.setNodeValue(psValue);
  };
  /**
   * 넘겨받은 XPath를 Map형태로 처리하기 위한 MapNode를 생성하여 리턴한다.
   * @param {String} psXpath psClassName 참조 대상 클래스명
   * @return 생성된 MapNode
   * @type eXria.data.xhtml.MapNode
   * @see eXria.data.xhtml.MapNode
   */
  this.getMapNode = function(psXpath) {
    var voNode = this.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.MapNode(voNode);
  };
  /**
   * 넘겨받은 XPath를 Collection형태로 처리하기 위한 CollectionNode를 생성하여 리턴한다.
   * @param {String} psXpath 처리할 기준 Node XPath
   * @return 생성된 CollectionNode
   * @type eXria.data.xhtml.CollectionNode
   * @see eXria.data.xhtml.CollectionNode
   */
  this.getCollectionNode = function(psXpath) {
    var voNode = this.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    } else if(page.metadata.useDomPath) {
      var voFirst = voNode.getFirstChild();
      if(voFirst && voFirst.node instanceof Array) voNode = voFirst;
    }
    return new eXria.data.json.CollectionNode(voNode);
  };
  /**
   * 넘겨받은 Xpath의 Node를 삭제한다.
   * @param {String} psXpath 삭제할 Node의 XPath
   * @return 삭제된 노드
   * @type eXria.data.Node
   */
  this.removeNode = function(psXPath) {
    var voNode = null;
    var voPNodeObj = null;
    var voPNode = null;
    if (typeof (psXPath) == "string") {
      voNode = this.selectSingleNode(psXPath);
      if(!voNode) return null;
      voPNodeObj = voNode.parentNode;
      if (voPNodeObj instanceof Array) {
        voPNodeObj.splice(voNode.name, 1);
        if(page.metadata.useDomPath && voPNodeObj.length == 0) {
          var voGPNode = voPNodeObj.parent;
          delete voGPNode[voPNodeObj.nodeName];
        }
      } else {
        delete voPNodeObj [voNode.name];
      }
      voNode.parentNode = null;
      if (typeof (voNode.node) == "object") voNode.node.parent = null;
    } else {
      voNode = psXPath;
      voPNode = voNode.getParentNode();
      voPNode.removeChild(voNode);
    }
    return voNode;
  };
  /**
   * 해당 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 Node
   * @type XMLNode
   */
  this.selectSingleNode = function(psXpath) {
    var voBase = this;
    var voNode = null;
    if(this.isQueryPath(psXpath)) {
      var vsPath = this.convertToJsonPath(psXpath);
      var vaResPath = null;
      try {
        vaResPath = jsonPath(this.instObj, vsPath, {resultType:"PATH"});
      } catch(e) {}
      if(vaResPath) voNode = new eXria.data.json.Node(null, null, null, {
        instObj : voBase.instObj,
        path : vaResPath[0]
      });
    } else {
      voNode = this.getInstObj(psXpath);
    }
    return voNode;
  };
  /**
   * Instance의 하위Node를 넘겨받은 XPath로 조회하여 리턴한다.
   * @param {String} psXpath 조회할 Xpath
   * @return 생성된 NodeList
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = function(psXpath, pbNotTrim) {
    var voNode = null;
    var voNodeList = null;
//    if(page.metadata.useDomPath && !pbNotTrim && /.+\]$/.test(psXpath) == false) {
//      psXpath = psXpath.substring(0, psXpath.lastIndexOf("/"));
//    }

    if(this.isQueryPath(psXpath)) {
      voNodeList = [];
      var voInst = this.instObj;
      var vsPath = this.convertToJsonPath(psXpath);
      var vaResPath = null;
      try {
        vaResPath = jsonPath(voInst, vsPath, {resultType:"PATH"});
      } catch(e) {}
//      if(!vaResPath) return null;
      var vnSize = (!vaResPath) ? 0 : vaResPath.length;
      for(var i = 0; i < vnSize; i++){
        voNode = new eXria.data.json.Node(null, null, null, {
          instObj : voInst,
          path : vaResPath[i]
        });
        voNodeList.push(voNode);
      }
      var voParentNodeObj = null;
      if(voNodeList.length == 0) {
        voNodeList = null; 
      } else {
        voParentNodeObj = voNodeList[0].getParentNode().node; 
      }
      return new eXria.data.json.NodeList(voNodeList, this.getLastNodeName(psXpath), voParentNodeObj);
    }

    voNode = this.getInstObj(psXpath);
    if(voNode == null) return null;
    voNodeList = voNode.node;
    if(!(voNodeList instanceof Array)) {
      voNodeList = voNode;
      voNodeList = [voNodeList];
      voNodeList.nodeName = voNode.name;
      voNodeList.parent = voNode.parentNode;
    }
    return new eXria.data.json.NodeList(voNodeList, voNode.name, voNode.parentNode);
  };
  /**
   * Instance의 하위Node들을 넘겨받은 XPath로 조회하여 배열 객체로 반환하는 메소드.
   * plugin 버전은 데이타 호환성 때문에 문자열을 반환받으나 여기서는 배열 객체를 바로 반환함.
   * 일반적으로 이후에 응용코드에서 반환값을 eval하여 사용하게 되는데 이럴경우에만 이 메소드 사용이 가능하고
   * 메소드의 반환값을 문자열로만 취급할 경우에는 사용불가.
   * @param {String} psXpath 조회할 Xpath
   * @return 생성된 NodeList
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodesStr = function(psXpath) {
    var voNode = null;
    var voNodeList = null;

    if(this.isQueryPath(psXpath)) {
      voNodeList = [];
      var voInst = this.instObj;
      var vsPath = this.convertToJsonPath(psXpath);
      var vaResPath = null;
      try {
        vaResPath = jsonPath(voInst, vsPath, {resultType:"PATH"});
      } catch(e) {}
      if(!vaResPath) return null;
      var vnSize = vaResPath.length;
      for(var i = 0; i < vnSize; i++){
        voNode = new eXria.data.json.Node(null, null, null, {
          instObj : voInst,
          path : vaResPath[i]
        });
        voNodeList.push(voNode);
      }
      if(voNodeList.length == 0) { return null; }
      return voNodeList;
    }

    voNode = this.getInstObj(psXpath);
    if(voNode == null) return null;
    voNodeList = voNode.node;
    if(!(voNodeList instanceof Array)) {
      voNodeList = voNode;
      voNodeList = [voNodeList];
      voNodeList.nodeName = voNode.name;
      voNodeList.parent = voNode.parentNode;
    }
    return voNodeList;
  };
  /**
   * 모든 하위노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    delete this.document;
    this.model = null;
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 alert으로 출력
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return void
   * @type void
   */
  this.print = function(psXpath) {
    alert(this.getJSON(psXpath, false));
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = function(psXpath) {
    if (psXpath == null || psXpath == undefined) {
      return;
    }
    return this.getJSON(psXpath);
  };
  /**
   * 넘겨 받은 XPath의 Node를 복사하여 리턴한다.
   * @param {String} psXPath 복사할 Node의 XPath
   * @param {String} pbDeep 깊은복사 유무 ( True : Deep Copy )
   * @return 복사된 노드
   * @type XMLNode
   */
  this.cloneNode = function(psXPath, pbDeep) {
    try {
      return new eXria.data.json.Node(this.selectSingleNode(psXPath));
    } catch (e) {
      return null;
    }
  };
  /**
   * 해당 XPath 하위에 두번째 파라미터로 넘어온 XML Text Node구조를 생성한다.
   * @param {String} psXpath 생성할 Node의 Parent Node가 될 Node의 XPath
   * @param {String} psTxt 생성할 Node XML Text
   * @return void
   * @type void
   */
  this.appendNodeByTxt = function(psXPath, psTxt) {
    var voNode = this.selectSingleNode(psXPath);
    var voApdNodeObj = eval("("+psTxt+")");
    var voApdNode = null;
    if(voNode.node instanceof Array){ //부모가 배열O
      voApdNode = new eXria.data.json.Node(voApdNodeObj);
      voNode.appendChild(voApdNode);
    }else{                            //부모가 배열X
      for(var vsAttr in voApdNodeObj){
        voApdNode = new eXria.data.json.Node(voApdNodeObj[vsAttr], vsAttr);
        voNode.appendChild(voApdNode);
      }
    }
  };


  this.getInstObj = function(psPath) {
    var vaPath = psPath.split("/");
    var voNode = this.instObj;

    if(voNode == null) return null;
    var vnCnt = vaPath.length;
    var vsNodeName = null;
    var voParentNode = null;
    var vnIdx;
    for (var i = 0; i < vnCnt; i++) {
      if (vaPath[i] === "") continue;
      vsNodeName = vaPath[i];
      if((/^.*\[([0-9]+)\]/.test(vaPath [i]))) {
        vnIdx = eval(RegExp.$1);
        if(page.metadata.useDomPath) vnIdx--;
        vaPath[i] = vaPath[i].substring(0, vaPath[i].indexOf("["));
        vaPath.splice(i + 1, 0, vnIdx);
        vnCnt++;
      }
      voParentNode = voNode;
      voNode = voNode [vaPath [i]];
      if(voNode == null) break;
      if(typeof(voNode) == "object") {
        voNode.nodeName = vaPath [i];
        voNode.parent = voParentNode;
      }
    }

    if(voNode !== undefined) {
      voNode = new eXria.data.json.Node(voNode, vsNodeName, voParentNode);
    }
    return voNode;
  };


  this.getLastNodeName = function(psPath){
    var vaPath = psPath.match(/\/[^\/]*(\[[^\[]+\])*/g);
    var vnCnt = vaPath.length;
    var vsNodeName = null;

    for (var i = 0; i < vnCnt; i++) {
      if (!vaPath [i]) continue;
      vsNodeName = vaPath[i].substring(1);
      if (page.metadata.useDomPath) {
        if(/^.*\[([0-9]+)\]/.test(vsNodeName)) {
          vsNodeName = eval(RegExp.$1);
          vsNodeName--;
        }  else if(/^.*(\[.+\])/.test(vsNodeName)) {
          vsNodeName = "" + RegExp.$1;
        }
      }
    }
    return vsNodeName;
  };

  this.isQueryPath = function(psPath) {
    return /\[[^\[]*[^0-9\[]+[^\[]*\]/.test(psPath);
  };

  this.convertToJsonPath = function(psPath) {
    var vaPath = psPath.match(/\/[^\/]*/g);
    var vnCnt = vaPath.length;
    var vsNodeName = null;

    var voBase = this;
    var voQueryConvFunc = function(psQuery) {
      var vsConvQuery = "";
      var vnIdx = null;
      var vnSize = null;
      var vaVar = null;
      var vaSeparator = null;
      var vaAllVar = null;
      var vsVar = null;
      var vaInnReplaceTarget = [];
      psQuery = psQuery.substring(1, psQuery.length - 1);
      psQuery = psQuery.replace(/child\:\:/g, "");
      psQuery = psQuery.replace(/(\s)+or(\s)+/gi, " || ");
      psQuery = psQuery.replace(/(\s)+and(\s)+/gi, " && ");
      if(psQuery.indexOf("starts-with") > -1) {
        psQuery = psQuery.substring(psQuery.indexOf("(")+1, psQuery.lastIndexOf(")"));
        var vsParam = psQuery.split(",");
        psQuery = vsParam[0].trim()+".startsWith("+vsParam[1].trim()+")";
      }
      if (psQuery.indexOf("ends-with") > -1) {
        psQuery = psQuery.substring(psQuery.indexOf("(")+1, psQuery.lastIndexOf(")"));
        var vsParam = psQuery.split(",");
        psQuery = vsParam[0].trim()+".endsWith("+vsParam[1].trim()+")";
      }
      if (psQuery.indexOf("contains") > -1) {
        psQuery = psQuery.substring(psQuery.indexOf("(")+1, psQuery.lastIndexOf(")"));
        var vsParam = psQuery.split(",");
        psQuery = vsParam[0].trim()+".indexOf("+vsParam[1].trim()+")>=0";
      }
      var vnInnReqSeq = 0;
      var vsInnPath = null;
      while(/(^|\s|\+|\-|\*|\/?=(\s|\/)|&|\||=|>|<)(\/([^$\s\+\-\*\/&\|=><]|\/(?!(\s|\/)))+)/.test(psQuery)) {
        vsInnPath = "" + RegExp.$3;
        psQuery = psQuery.replace(vsInnPath, "@" + (vnInnReqSeq++));
        vaInnReplaceTarget.push(voBase.convertToJsonPath(vsInnPath));
      }
      vnSize = vaInnReplaceTarget.length;
      for(var i = 0; i < vnSize; i++) {
        psQuery = psQuery.replace("@" + i, vaInnReplaceTarget[i]);
      };
      vsConvQuery += "[?(";
      vaVar = psQuery.split(/(\s*=\s*|\s*<=*\s*|\s*>=*\s*|\s*&+\s*|\s*\|+\s*|\s*\+\s*|\s*\-\s*|\s*\*\s*|\s*\/\s*)/g);
      if(vaVar.join("") != psQuery) {
        vaSeparator = psQuery.match(/(\s*=\s*|\s*<=*\s*|\s*>=*\s*|\s*&+\s*|\s*\|+\s*|\s*\+\s*|\s*\-\s*|\s*\*\s*|\s*\/\s*)/g);
        vnSize = vaVar.length;
        vaAllVar = [];
        for(var i = 0; i < vnSize; i++) {
          vaAllVar.push(vaVar[i]);
          if(vaSeparator[i] != null) vaAllVar.push(vaSeparator[i]);
        }
      } else {
        vaAllVar = vaVar;
      }
      vnSize = vaAllVar.length;
      var vbString = false;
      for(var i = 0; i < vnSize; i++) {
        vsVar = vaAllVar[i];
        vsVar = vsVar.replace(/(\s*<=*\s*|\s*>=*\s*|\s*&+\s*|\s*\|+\s*|\s*\+\s*|\s*\-\s*|\s*\*\s*|\s*\/\s*)/g, "");
        if(vsVar == "") continue;
        if(/\s*=\s*/.test(vsVar)) {
          vaAllVar[i] = vaAllVar[i].replace("=", "==");
          continue;
        }
        if(/^'.*'$/.test(vsVar) || /^\$.*/.test(vsVar)) continue;
        if(vsVar.indexOf("'") == 0) {
            vbString = true;
        } else if(vsVar.lastIndexOf("'") == vsVar.length - 1) {
            if(vsVar.lastIndexOf("'") == vsVar.length - 1) vbString = false;
            continue;
        }
        if(vbString) {
          continue;
        }
        if(!isFinite(vsVar)) vaAllVar[i] = "@." + vsVar;
      }
      vsConvQuery += vaAllVar.join("");
      vsConvQuery += ")]";
      return vsConvQuery;
    };

    var vaRoBrk = null;
    var vaLoBrk = null;
    var vnRoCnt = 0;
    var vsQuery, vsConvQuery;
    for (var i = 0; i < vnCnt; i++) {
      if (!vaPath[i]) continue;
      vaRoBrk = vaPath[i].match(/\[/g);
      if(vaRoBrk == null) vaRoBrk = [];
      vaLoBrk = vaPath[i].match(/\]/g);
      if(vaLoBrk == null) vaLoBrk = [];
      if(vnRoCnt > 0) {
        vaPath[i] = vaPath[i - 1] + vaPath[i];
        vaPath[i - 1] = "";
      }
      vnRoCnt += vaRoBrk.length;
      vnRoCnt -= vaLoBrk.length;
      if(vnRoCnt > 0) continue;

      if (/^\/[^\/]*\[([0-9]+)\]/.test(vaPath[i])) {
        if(page.metadata.useDomPath) {
          vsQuery = eval(RegExp.$1);
          vsConvQuery = "[" + (vsQuery - 1) + "]";
          vsQuery = "[" + RegExp.$1 + "]";
          vaPath[i] = vaPath[i].replace(vsQuery, vsConvQuery);
        }
      } else if(/^\/[^\/]*(\[.+\])/.test(vaPath[i])) {
        vsQuery = "" + RegExp.$1;
        vsConvQuery = voQueryConvFunc(vsQuery);
//        if(page.metadata.useDomPath) vaPath[i] = vsConvQuery;
//        else vaPath[i] = vaPath[i].replace(vsQuery, vsConvQuery);
        vaPath[i] = vaPath[i].replace(vsQuery, vsConvQuery);
      }
      vaPath[i] = vaPath[i].replace(/^\//, ".");
    }
    psPath = vaPath.join("");
    psPath = "$" + psPath;
    return psPath;
  };


  this.createElement = function(psElementName) {
    var voNode = new eXria.data.json.Node({}, psElementName);
    return voNode;
  };

  this.createTextNode = function(psKey, psValue) {
    var voNode = {};
    voNode[psKey] = (psValue==null) ? "" : psValue;
    return new eXria.data.json.Node(voNode[psKey], psKey);
  };
  
  this.createNode = function(psNodeName, psValue) {
    var voNewNode = null;
    voNewNode = this.createElement(psNodeName);
    if(psValue) {
      voNewNode.setNodeValue(psValue);
    }
    return voNewNode;
  };
	
  this.createMapNode = function(psName) {
    var voNode = this.createElement(psName);
    return new eXria.data.json.MapNode(voNode);
  };
	/**
	 * Instance를 Copy 하기 위하여 사용한다.
	 * @param {String} psInstPath 해당 컨트롤의 Instance Path
	 */
	this.copyOriginInstance = function(psInstPath) {
		if(psInstPath == null) return null;
	  var vsInstancePath = psInstPath;
	  var vsJsonData = null;

		vsJsonData = this.getJSON(vsInstancePath);
		this.copyInstObj = eval("("+vsJsonData+")");
	};
};

/**
 * @fileoverview
 * XHTML Mode 사용시 Document Node를 Map으로 wrapping 해주는 클래스
 */
/**
 * XHTML Mode 사용시 Document Node를 Map으로 wrapping 해주는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.xhtml.Node
 */
eXria.data.json.MapNode = function(poNode) {
  /**
   * inherit
   */
  this.node = poNode;
  if(!(poNode.toString && poNode.toString() == "eXria.data.json.Node")) this.node = new eXria.data.json.Node(poNode);

  /**
   * ChildNode의 Element 갯수를 리턴한다.
   * @return ChildNode중 Element 갯수
   * @type Number
   */
  this.size = function() {
    var voNodes = this.node.getChildNodes();
    var vnSize = 0;
    if(voNodes == null) return vnSize;
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        // Element
        vnSize++;
      }
    }
    return vnSize;
  };
  /**
   * ChildNode중 넘겨받은 Tag명인 첫번째 노드를 리턴한다.
   * @param {String} psName Tag Name
   * @return 조회된 XMLElementNode
   * @type XMLElementNode
   */
  this.getNode = function(psName) {
    var voNode = this.node.getElementByTagNameFromChildNodes(psName);
    return voNode;
  };
  /**
   * ChildNode중 넘겨받은 Tag명인 첫번째 노드의 TextNode값을 리턴한다.
   * @param {String} psKey 조회할 ElementNode의 Tag명
   * @return 조회된 TextNode의 값
   * @type String
   */
  this.get = function(psKey) {
    if (!psKey || psKey == "") {
      return null;
    }
    var voNode = this.node.node;
    var vsRet = voNode[psKey];
    return vsRet;
  };
  /**
   * ChildNode에 넘겨받은 Key값이 존재할 경우 존재하는 ChildNode의 하위 TextNode로 값을 설정하고,</br>
   * 존재하지 않는 경우 ChileNode에 Append한다.
   * @param {String} psKey 설정할 Element Tag Name
   * @param {String} psValue 설정할 Value
   * @return void
   * @type void
   */
  this.put = function(psKey, psValue) {
    psValue = (psValue != null ? psValue : "");
    var voNode = this.node.node;
    voNode[psKey] = psValue;
  };
  /**
   * 넘겨받은 값을 Tag Name으로 가지는 첫번째 Node를 삭제한다.
   * @param {String} psKey 삭제할 Tag명
   * @return void
   * @type void
   */
  this.remove = function(psKey) {
    var voNode = this.getNode(psKey);
    if (voNode != null) {
      this.node.removeChild(voNode);
    }
  };
  /**
   * 모든 하위 노드를 삭제한다.
   * @return void
   * @type void
   */
  this.clear = function() {
    var voNodes = this.node.getChildNodes();
    if(voNodes == null) return;
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        this.node.removeChild(voNode);
      }
    }
  };
  /**
   * 하위 Element의 존재 유무 리턴
   * @return 하위 ElementNode가 없을 경우 true, 아니라면 false
   * @type Boolean
   */
  this.isEmpty = function() {
    return (this.size() == 0);
  };
  /**
   * ChildNode의 Tag명 만으로 구성된 Collection 객체를 리턴한다.
   * @return Tag Name으로 구성된 Collection
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getKeyCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
//      if (voNode.getNodeType() == 1) {
//        // Element
        voCollection.add(voNode.getNodeName());
//      }
    }
    return voCollection;
  };
  /**
   * ChildNode의 Element 하위 TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @return TextNode 및 CDataNode의 값만으로 구성된 Collection 객체를 리턴한다.
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getValueCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
//      if (voNode.getNodeType() == 1) {
//        // Element
        voCollection.add(String(voNode.getNodeValue()));
//      }
    }
    return voCollection;
  };
  /**
   * ChildNode의 Element, TextNode 및 CDataNode로 구성된 Object Collection 객체를 리턴한다.
   * @return Element, TextNode 및 CDataNode로 구성된 Collection 객체
   * @type eXria.data.ArrayCollection
   * @see eXria.data.ArrayCollection
   */
  this.getEntryCollection = function() {
    var voCollection = new eXria.data.ArrayCollection();
    var voNodes = this.node.getChildNodes();
    var vnLength = voNodes.getLength();
    var vsKey = null, voValue = null, vsValue = null;

    for (var i = 0; i < vnLength; i++) {
      var voNode = voNodes.item(i);
      if (voNode.getNodeType() == 1) {
        voValue = voNode.getFirstChild();
        vsValue = String(voNode.getNodeValue())
        vsKey = voNode.getNodeName();

        if (voValue != null && voValue.getNodeType() == 1) {
          voCollection.add({
            key : vsKey, value : voValue.cloneNode(true)
          });
        } else if (vsValue != null) {
          voCollection.add({
            key : vsKey, value : vsValue
          });
        } else {
          voCollection.add({
            key : vsKey, value : null
          });
        }
      }
    }
    return voCollection;
  };
  /**
   * JSON Format String 값으로 리턴한다.
   * @return JSON Format의 xml data
   * @type String
   */
  this.toString = function() {
    return this.node.getJSON();
  };
};

/**
 * @fileoverview
 * Document Node Object Class
 */
/**
 * json.Node
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 2.0
 * @param {Node} poNode XML Node
 * @constructor
 * @base eXria.data.JsNode
 */
eXria.data.json.Node = function(poNode, psName, poParent, poInfoObj) {
	this.infoObj = null;
  if(poInfoObj) {
  	this.infoObj = poInfoObj;
    var vsPath = this.infoObj.path;
    vsPath = vsPath.replace(/^\$/, "");
    var vaPath = vsPath.match(/\[[^\[]+\]/g);
    psName = vaPath[vaPath.length - 1].replace(/((\[\'?)|(\'?\]))/g, "");
    if(isFinite(psName)) psName = parseInt(psName);
    var vnPathStIdx = 0;
    if(this.infoObj.instObj.nodeName != null) vnPathStIdx = 1;
    if(psName == "#text") {
      vsPath = vaPath.slice(vnPathStIdx, vaPath.length - 1).join("");
    }
    poNode = eval("this.infoObj.instObj" + vsPath);
    this.infoObj.parentPath = vaPath.slice(0, vaPath.length - 1).join("");
  }
  if (poNode == null) {
    throw new Error("Node is null.");
  }
  /**
   * inherit
   */
//  eXria.data.Node.call(this, poNode);
  /**
   * XMLNode
   * @type XMLElementNode
   * @private
   */
  if(typeof(poNode) != "object" && (psName == null || !isNaN(psName))) psName = "#text";
  this.node = poNode;
  /**
   * XMLNode Tag Name
   * @type String
   * @private
   */
  this.name = psName;
  /**
   * parent json node object
   * @type Object
   * @private
   */
  this.parentNode = poParent;

  if(this.node != null && typeof(this.node) == "object") {
    if(psName == null) this.name = this.node.nodeName;
    else this.node.nodeName = psName;
    if(poParent == null) this.parentNode = this.node.parent;
    else this.node.parent = poParent;
  }
};

eXria.data.json.Node.prototype = {
  /**
   * 파라미터로 넘어온 Node를 자식 Node의 마지막에 추가한다.
   * @param {eXria.data.JsNode} poNode 추가할 Node Object
   * @type void
   * @return void
   */
  appendChild : function(poNode, psRowTagName) {
    var vsNodeName = poNode.getNodeName();
    if(!poNode) return;
    
    if(this.node === "") {
      this.parentNode[this.name] = this.createElement(this.name).node;
      this.node = this.parentNode[this.name];
      this.node.nodeName = this.name;
      this.node.parent = this.parentNode;
    }
    poNode.parentNode = this.node;
    
    //초기 데이터 셋에 대해 row 에 대해서 배열로 선언해 주는 부분 13.9.4 추가
    if(psRowTagName != null && this.node[psRowTagName] == null) this.node[psRowTagName] = [];
    
    if(psRowTagName != null && this.node[psRowTagName] instanceof Array){ //dataset일때 row이름이 배열인지 체크
      this.node[psRowTagName].push(poNode.node);
    }else if(this.node instanceof Array){   //this.node 배열O
      this.node.push(poNode.node);
    }else if(typeof(poNode.name) == "number") { // this.node 배열X , poNode가 배열의element
      var voOldPNode = poNode.getParentNode();
      var vsPNodeName = voOldPNode.name;
      var voPNode = null;
      if(this.node[vsPNodeName] == null) {
        voPNode = this.createElement(voOldPNode.name, []);
        
        this.appendChild(voPNode);
      }
      var voPNodeObj = this.node[vsPNodeName];
      voPNodeObj.push(poNode.node);
      poNode.parentNode = voPNodeObj;
      if(this.infoObj) {
        var voBase = this;
        poNode.infoObj =  {
            instObj : voBase.infoObj.instObj,
            path : voBase.infoObj.path + "/" + 	vsPNodeName
        } 
      }
    }else if(vsNodeName != "#text") {       //this.node 배열X
      this.node[vsNodeName] = poNode.node;
    }else {
      var voParentNode = this.node.parentNode;
      if(voParentNode) voParentNode[this.name] = poNode.node;
      this.node = poNode.node;
    }
  },
  /**
   * 현재 Node와 동일한 Node를 복사하여 리턴한다.
   * @param {Boolean} pbDeep deep copy 유무를 지정한다. (true | false)
   * @return 복사된 Node Object
   * @type eXria.data.JsNode
   */
  cloneNode : function(pbDeep) {
    if(pbDeep != true) pbDeep = false;
    var vsNode = this.getJSON(this.node);
    var voNode = eval("("+vsNode+")");
    if(!pbDeep) {
      for(var attr in voNode){
        voNode[attr] = "";
      }
    }
    var voPNode = this.getParentNode();
    voPNode = (voPNode == null) ? null : voPNode.node;
    return new eXria.data.json.Node(voNode, this.name, voPNode, this.infoObj);
  },
  /**
   * 현재 Node의 자식 Node들을 NodeList 형식으로 리턴한다.
   * @type eXria.data.JsNodeList
   * @return 생성된 자식 Node List
   */
  getChildNodes : function() {
    var voParent = this.node;
    var vaNodeList = [];
    var voNode = null;
    if(voParent instanceof Array) {
      vaNodeList = voParent;
    } else {
      if(typeof(voParent) != "object") {
        var voInfoObj = this.getInfoObj();
        if(voInfoObj != null) {
          voInfoObj.path += "[#text]";
          voNode = new eXria.data.json.Node(null, null, null, voInfoObj);
        } else {
          voNode = new eXria.data.json.Node(voParent, null, voParent);
        }
        vaNodeList.push(voNode);
      } else {
        for(var vsKey in voParent){
          if(eXria.protocols.json.ReservedType[vsKey]) continue;
          voNode = new eXria.data.json.Node(voParent[vsKey], vsKey, voParent);
          vaNodeList.push(voNode);
        }
      }
    }
//    if(vaNodeList.length == 0) { return null; }
    return new eXria.data.json.NodeList(vaNodeList, this.name, voParent);
  },
  /**
   * 현재 Node의 첫번째 자식 Node를 리턴한다.
   * @type eXria.data.JsNode
   * @return 현재 Node의 첫번째 자식 Node
   */
  getFirstChild : function() {
    var voChildNodes = this.node;
    var voFirstChild, vsFirstKey, voRet;

    if(voChildNodes instanceof Array) {
      voFirstChild = voChildNodes[0];
    } else if(typeof(voChildNodes) == "string"){
      voRet = null;
    } else {
      for (var i in voChildNodes) {
        if (i != "parent" && i != "nodeName") {
          vsFirstKey = i;
          break;
        }
      }
    }
    if(!!vsFirstKey) voRet = new eXria.data.json.Node(voChildNodes[vsFirstKey], vsFirstKey, voChildNodes);
    else if (!voFirstChild) voRet = null;
    else voRet = new eXria.data.json.Node(voFirstChild, null, voChildNodes);
    return voRet;
  },
  /**
   * 현재 Node의 마지막 자식 Node를 리턴한다.
   * @type eXria.data.JsNode
   * @return 현재 Node의 마지막 자식 Node
   */
  getLastChild : function() {
    var voNode = this.node.lastChild;
    if (!voNode) { return null; }
    return new eXria.data.json.Node(voNode);
  },
  /**
   * 현재 Node의 바로 다음 Node를 리턴한다.
   * @type eXria.data.JsNode
   * @return 현재 Node의 다음 Node
   */
  getNextSibling : function() {
    var voNode = this.node.nextSibling;
    if(!voNode) { return null; }
    return new eXria.data.json.Node(voNode);
  },
  /**
   * 현재 Node의 이름을 리턴한다.
   * @type String
   * @return 현재 Node의 이름
   */
  getNodeName : function() {
    return this.name;
  },
  /**
   * 현재 Node의 value를 리턴한다.
   * @type String
   * @return 현재 Node의 Value
   */
  getNodeValue : function() {
    var voValue = this.node;
    if(voValue == null) voValue = "";
    if(typeof(voValue) == "object") voValue = null;
    return voValue;
  },
  /**
   * 현재 Node의 부모 Node를 리턴한다.
   * @type eXria.data.JsNode
   * @return 현재 Node의 부모 Node
   */
  getParentNode : function() {
    var voBase = this;
    if(this.infoObj) return new eXria.data.json.Node(null, null, null, {
      instObj : voBase.infoObj.instObj,
      path : voBase.infoObj.parentPath
      });
    var voNode = this.parentNode;
    if(!voNode) { return null; }
    return new eXria.data.json.Node(voNode, voNode.nodeName, voNode.parent);
  },
  /**
   * 현재 Node의 바로 전 Node를 리턴한다.
   * @type eXria.data.JsNode
   * @return 현재 Node의 바로 전 Node
   */
  getPreviousSibling : function() {
    var voParentNode;
    var voNode;
    if(this.parentNode){
      voParentNode = this.parentNode;
      //만들어야함
    }
    if(!voNode) { return null; }
    return new eXria.data.json.Node(voNode);
  },
  /**
   * Element를 생성하여 리턴한다.
   * @param {String} psTagName 생성할 Element의 Tag Name
   * @param {String} psValue 생성할 Element의 Value [ null을 넘길 경우 TextNode가 생성되지 않은 Element 리턴 ]
   * @type {eXria.data.JsNode}
   * @return 생성된 Element
   */
  createElement : function(psTagName, psValue) {
    if(psValue == null) psValue = {};
    voNode = new eXria.data.json.Node(psValue, psTagName);
    return voNode;
  },
  /**
   * TextNode를 생성하여 리턴
   * @param {String} psValue 생성할 Node의 Value값
   * @type {eXria.data.JsNode}
   * @return 생성된 TextNode
   */
  createTextNode : function(psValue) {
    if(psValue == null) return null;
    return new eXria.data.json.Node(psValue);
  },
  /**
   * 현재 Node의 자식 Node 유무를 리턴한다.
   * @type Boolean
   * @return 자식 Node의 존재 유무
   */
  hasChildNodes : function() {
    if(this.node != null && typeof(this.node) == 'object'){
      var voNode = this.node;
      var vbHasChild = false;
      if(voNode instanceof Array) {
        if(voNode.length > 0) vbHasChild = true;
      } else {
        for(var vsAttr in voNode){
          if(eXria.protocols.json.ReservedType[vsAttr]) continue;
          vbHasChild = true;
          break;
        }
      }
      return vbHasChild;
    } else if(this.node != null && this.getNodeType() == 1) {
      return true;
    } else {
      return false;
    }
  },
  /**
   * 현재 Node의 자식 Node 중 파라미터로 넘어온 Node와 일치하는 Node를 삭제한다.
   * @param {eXria.data.JsNode} poNode 삭제할 Node
   * @type eXria.data.JsNode
   * @return 삭제된 Node
   */
  removeChild : function(poNode) {
    if (!poNode) return;
    var voNodeObj = poNode.node;
    var voPNodeObj = poNode.parentNode;
    var voPNodeArry = voPNodeObj[poNode.name];
    
    if (voPNodeObj instanceof Array) {
      voPNodeObj.splice(poNode.name, 1);
      if(page.metadata.useDomPath && voPNodeObj.length == 0) {
        var voGPNodeObj = voPNodeObj.parent;
        delete voGPNodeObj[voPNodeObj.nodeName];
      }
//      voParentNode.splice(voNodeObj.name + "[" + poNode.idx + "]", 1);
    }else if(voPNodeObj instanceof Object && voPNodeArry instanceof Array && !voNodeObj.parent){
      voPNodeArry.splice(voNodeObj.DataSetRowIdx, 1);
      if(page.metadata.useDomPath && voPNodeArry.length == 0) {
        var voGPNodeObj = voPNodeArry.parent;
        delete voGPNodeObj[voPNodeArry.nodeName];
      }
    }else{
      delete voPNodeObj [poNode.name];
    }
    voNodeObj.parent = null;
    poNode.parentNode = null;
    if (typeof (voNodeObj) == "object") voNodeObj.parent = null;

    return poNode;
  },
  /**
   * 현재 Node의 Value 파라미터로 넘어온 데이터로 변경한다.
   * @param {String} psValue 변경할 데이터
   * @type void
   * @return void
   */
  setNodeValue : function(psValue) {
    psValue = (psValue ? psValue : "");
    var voParent = this.parentNode;
    if(!!voParent) voParent[this.name] = psValue;
    this.node = psValue;
  },
  /**
   * 두번째 파라미터로 넘어온 Node와 동일한 Node가 있을 경우 해당 위치에 첫번째 파라미터로 넘어온 Node를 셋팅.
   * @param {eXria.data.JsNode} poNewNode 추가할 Node
   * @param {eXria.data.JsNode} poOldNode 덮어 쓸 Node
   * @type eXria.data.JsNode
   * @return 삭제된 Node
   */
  replaceChild : function(poNewNode, poOldNode) {
    if(poOldNode.node){
      this.node = poNewNode.node;
      var voNode = this.node;
      if(typeof(voNode) == "object"){
        voNode.nodeName = this.name;
        voNOde.parent = this.parentNode;
      }
      return poOldNode;
    } else {
      return null;
    }
  },
  /**
   * 두번째 파라미터로 넘어온 Node의 앞에 첫번째로 넘어온 파라미터 Node를 추가한다.
   * @param {eXria.data.JsNode} poNewNode 추가할 Node
   * @param {eXria.data.JsNode} poRefNode 덮어 쓸 Node
   * @type eXria.data.JsNode
   * @return insert 되기 전 Node
   */
  insertBefore : function(poNewNode, poRefNode) {
//    var voOldNode = this.node.insertBefore(poNewNode.node, poRefNode.node);
//    if(voOldNode) {
//      return poRefNode;
//    } else {
//      return null;
//    }
      var voParentNode = poRefNode.getParentNode();
      poNewNode.parentNode = voParentNode.node;
      var vbArray = voParentNode.node instanceof Array;
      var vnIdx = poRefNode.name;
      if(vbArray){
        voParentNode.splice(vnIdx, 0, poNewNode.node);
        poRefNode.name = vnIdx + 1;
        if(typeof(poRefNode.node) == "object") poRefNode.node.nodeName = vnIdx + 1;
      } else {
        voParentNode.node[poNewNode.name] = poNewNode.node;
      }
      return poRefNode;
  },
  /**
   * node type을 리턴한다.
   * @type Number
   * @return 해당 Node의 node Type
   */
 getNodeType : function() {
//    var vnNodeType = 3;
//    if(this.node != null) {
//      if(typeof(this.node) == "object") vnNodeType = 1;
//    }
//    return vnNodeType;
		return (this.name == "#text" ? 3 : 1);
  },
  /**
   * 현재 클래스의 이름을 반환 한다.
   * @type String
   * @return 현재 클래스 이름
   */
  toString : function() {
    return "eXria.data.json.Node";
  },
  /**
   * 파라미터로 넘어온 Node와 현재 Node가 같은 Node인지 비교한다.
   * @param {eXria.data.JsNode} poNode 비교할 Node
   * @return 두개의 Node가 같은 Node인지 유무
   * @type Boolean
   */
  equal : function(poNode) {
  return this.node == poNode.node;
  },
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.JsNode
   * @return Node Object
   */
  getElementByTagName : function(psTagName) {
    var voNodes = this.getChildNodes();
    var voNode;
    if(voNodes != null){
      for(var i = 0, vnLen = voNodes.getLength(); i < vnLen ; i++){
        voNode = voNodes.item(i);
        if(voNode == null) continue;
        if(voNode.name == psTagName) return voNode;
        
        if(voNode.getNodeType() == 1){
          if(voNode.getElementByTagName(psTagName) != null){
            return voNode;
          }
        }
      }
    }
//    var voNodes = this.getElementsByTagName(psTagName);
//    if(voNodes.getLength() == 0) {
//      return null;
//    } else {
//      return voNodes.item(0);
//    }
  },
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.JsNodeList
   * @return NodeList Object
   */
  getElementsByTagName : function(psTagName) {
  var voNodes = this.node.getElementsByTagName(psTagName);
  if(!voNodes) return null;
  return new eXria.data.json.NodeList(voNodes);
  },
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.JsNode
   * @return NodeList Object
   */
  getElementByTagNameFromChildNodes : function(psTagName) {
    var voNodes = this.getChildNodes();
    var voNode = null;
    var voTmpNode = null;
    for(var i = 0, vnLen = voNodes.getLength() ; i < vnLen ; i++) {
      voNode = voNodes.item(i);
      if(voNode.getNodeName() == psTagName) {
        voTmpNode = voNode;
        break;
      }
    }
    return voTmpNode;
  },
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Collection
   * @return eXria.data.Collection Object
   */
  getElementsByTagNameFromChildNodes : function(psTagName) {
    var voNodes = this.getChildNodes();
    var voNodeArr = new eXria.data.ArrayCollection();

    for(var i = 0, vnLen = voNodes.getLength() ; i < vnLen ; i++) {
      var voNode = voNodes.item(i);
      if(voNode.name == psTagName) {
        voNodeArr.add(new eXria.data.json.Node(voNode.node, psTagName, this.node));
      }
    }
    return voNodeArr;
  },
  /**
   * 현재 Node의 XML 스트링을 리턴.
   * @type String
   * @return XML String
   */
  getXML : function() {
    if (window.page.metadata.browser.ie > 0) {
      return this.node.xml;
    } else {
      var vSerializer = new XMLSerializer();
      return vSerializer.serializeToString(this.node);
    }
  },
  /**
   * 노드의 특정 속성 반환한다.
   * @param {String} psAttr 속성 명
   * @type String
   * @return 노드의 해당 속성 값
   */
  getAttribute : function(psAttr) {
    return this.node[psAttr];
  },
  
  getAttributes : function() {
  	return new eXria.data.json.NodeList([], this.name, this.parentNode);
  },
  /**
   * 노드의 특정 비표준 속성을 반환한다.
   * @param {String} psAttr 비표준 속성 명
   * @type String
   * @return 노드의 해당 속성 값
   */
  getUserAttribute : function(psAttr) {
    return this.node[psAttr];
  },
  /**
   * 노드의 특정 속성 값을 설정한다.
   * @param {String} psAttr 속성 명
   * @param {String} psValue 속성 값
   */
  setAttribute : function(psAttr, psValue) {
    this.node[psAttr] = psValue;
  },
  /**
   * 노드 관계 정보 저장 객체를 반환하는 메소드
   * @type Object
   * @return 노드 관계 정보 저장 객체
   */
  getInfoObj : function() {
    var voInfoObj = null;
    if(this.infoObj) {
      voInfoObj = this.infoObj;
    } else {
      vsPath = "['" + this.name + "']";
      voInstObj = null;
      voParent = this.parentNode;
      while(voParent) {
        voInstObj = voParent;
        if(voParent.nodeName == null) break;
        vsPath = "['" + voParent.nodeName + "']" + vsPath;
        voParent = voParent.parent;
      }
      if(voInstObj) {
        voInfoObj = {
          instObj : voInstObj,
          path : vsPath
        }
      }
    }
    return voInfoObj;
  },
  /**
   * 노드의 특정 비표준 속성 값을 설정한다.
   * @param {String} psAttr 비표준 속성 명
   * @param {String} psValue 속성 값
   */
  setUserAttribute : function(psAttr, psValue) {
    this.node[psAttr] = psValue;
  },
  
  getJSON : function(poNodeObj, pbFillKey) {
    var voNode = poNodeObj;
    var vsRet = null;
    if (voNode == null) {
      return "null";
    } else if (voNode.constructor == String) {
      if(pbFillKey && voNode.name != null) vsRet = "{" + voNode.name + " : " + escapeJSONString(voNode) + "}";
      else vsRet = escapeJSONString(voNode);
      return vsRet;
    } else if (voNode.constructor == Number) {
      return voNode.toString();
    } else if (voNode.constructor == Boolean) {
      return voNode.toString();
    } else if (voNode.constructor == Date) {
      return '{javaClass: "java.util.Date", time: ' + voNode.valueOf() + '}';
    } else if (voNode.constructor == Array) {
      var v = [];
      for (var i = 0; i < voNode.length; i++) {
        v.push(this.getJSON(voNode [i]));
      }
      return "[" + v.join(", ") + "]";
    } else {
      var v = [];
      for (attr in voNode) {
        if (voNode [attr] == null) {
          v.push("\"" + attr + "\": null");
        }  else if (typeof voNode [attr] == "function" || eXria.protocols.json.ReservedType[attr]) {
          // TODO function일 경우도 파싱
          // skip
        } else {
          v.push(escapeJSONString(attr) + ": " + this.getJSON(voNode [attr], false));
        }
      }
      var vsStr = v.join(", ");

      if (!vsStr) {
        vsRet =  "\"\"";
      } else {
        if(pbFillKey && voNode.name != null) vsRet = "{" + voNode.name + " : " + v.join(", ") + "}";
        else vsRet = "{" + v.join(", ") + "}";
      }return vsRet;
    }
  }
};

//====================================================================================

function escapeJSONChar(pcChar) {
  if (pcChar == "\"" || pcChar == "\\") return "\\" + pcChar;
  else if (pcChar == "\b") return "\\b";
  else if (pcChar == "\f") return "\\f";
  else if (pcChar == "\n") return "\\n";
  else if (pcChar == "\r") return "\\r";
  else if (pcChar == "\t") return "\\t";
  var hex = pcChar.charCodeAt(0).toString(16);
  if (hex.length == 1) return "\\u000" + hex;
  else if (hex.length == 2) return "\\u00" + hex;
  else if (hex.length == 3) return "\\u0" + hex;
  else return "\\u" + hex;
};
function escapeJSONString(psString) {
  //Rather inefficient way to do it
  var parts = psString.split("");
  for (var i = 0; i < parts.length; i++) {
    var c = parts [i];
    if (c == '"' || c == '\\' || c.charCodeAt(0) < 32 || c.charCodeAt(0) >= 128) {
      parts [i] = this.escapeJSONChar(parts [i]);
    }
  }
  return "\"" + parts.join("") + "\"";
};


/**
 * @fileoverview
 * XHTML Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 */
/**
 * XHTML Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 * @author Choe, hyeon jong.
 * @version 2.0
 * @param {NodeList} XHTML NodeList Object
 * @constructor
 * @base eXria.data.NodeList
 */
eXria.data.json.NodeList = function(poResult, psNodeName, poParent) {
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);
  /**
   * NodeList
   * @type Array (eXria.data.json.Node)
   * @private
   */
  this.nodeList = poResult;

  this.name = psNodeName;

  this.parentNode = poParent;
  /**
   * return item cound in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
    if(this.nodeList == null) return 0;
    return (this.nodeList.length != null) ? this.nodeList.length : this.nodeList.getLength();
  };
  /**
   * return NodeItem of parameter index
   * @param {Number} pnIdx
   * @return Node
   * @type Node
   */
  this.item = function(pnIdx) {
    var voNodeList = (this.nodeList.nodeList) ? this.nodeList.nodeList : this.nodeList;
    if(voNodeList == null) return null;
    
    var voNode = voNodeList[pnIdx];
    if(voNode == null) return null;

    if(!(voNode instanceof eXria.data.json.Node || voNode instanceof eXria.data.xhtml.Node)) {
      voNode = new eXria.data.json.Node(voNode, pnIdx, voNodeList);
    }
    return voNode;
  };
};
/**
 * @fileoverview
 * eXria.data.plugin Package
 */
/**
 * eXria.data.plugin package
 * @author Choe, hyeon jong.
 */ 
eXria.data.plugin = {}
/**
 * @fileoverview
 * Encoding Type에 대한 상수 정의 클래스</br>
 * "|"를 사용하여 BOM, NOBOM등의 상수와 조합 가능</br>
 * enum list</br>
 * eXria.data.plugin.EncType.ASCII<br/>
 * eXria.data.plugin.EncType.UTF8<br/>
 * eXria.data.plugin.EncType.UTF16<br/>
 * eXria.data.plugin.EncType.BOM<br/>
 * eXria.data.plugin.EncType.NOBOM<br/>
 */
/**
 * Encoding Type에 대한 상수 정의 클래스
 * @author Choe, Hyeon Jong
 * @version 1.0
 * @constructor
 */
eXria.data.plugin.EncType = {
	ASCII		:	0X100,
 	UTF8		:	0X200,
 	UTF16		:	0X400,
	BOM			:	0X1000,
	NOBOM		:	0X2000
};
/**
 * @fileoverview
 * File Open시 사용되는 Mode에 대한 상수정의 클래스</br>
 * enum list</br>
 * eXria.data.plugin.IOMode.READONLY</br>
 * eXria.data.plugin.IOMode.WRITEONLY</br>
 * eXria.data.plugin.IOMode.READWRITE</br>
 * eXria.data.plugin.IOMode.APPEND</br>
 * eXria.data.plugin.IOMode.BINARY
 */
/**
 * File Open시 사용되는 Mode에 대한 상수정의 클래스</br>
 * @author Choe, Hyeon Jong
 * @version 1.0
 * @constructor
 */
eXria.data.plugin.IOMode = {
	READONLY		:	0X0001,
	WRITEONLY		:	0X0002,
	READWRITE		:	0X0004,
	APPEND			:	0X0008,
	BINARY			:	0X0010,
	TEXT			:	0X0020,
	CREATE			:	0X0040
};
/**
 * @fileoverview
 * Plugin Mode 사용시 사용되는 Instance를 관리하는 클래스
 */
/**
 * Plugin Mode 사용시 사용되는 Instance를 관리하는 클래스
 * 
 * @version 1.0
 * @param {nsIInstance} poInstance Plugin Instance Object
 * @param {String} psId Instance Id
 * @param {eXria.form.Model} poModel Model Object
 * @constructor
 * @type eXria.data.plugin.Instance
 * @return void
 */
eXria.data.plugin.Instance = function(poInstance, psId, poModel) {
  /**
   * inherit
   */
  eXria.data.Instance.call(this, psId, poModel);
  /**
   * this.pluginInstance
   * @type Object
   * @private
   */
  this.pluginInstance = poInstance;
  /**
   * loadXML, loadURL, loadTXT 메소드 사용시 append 혹은 replace를 결정하는 플래그
   * <br/>Plugin에서만 사용 가능한 플래그
   * @type Number
   */
  this.LOADREPLACE = this.pluginInstance.LOAD_REPLACE;
  /**
   * loadXML, loadURL, loadTXT 메소드 사용시 append 혹은 replace를 결정하는 플래그
   * <br/>Plugin에서만 사용 가능한 플래그
   * @type Number
   */
  this.LOADAPPEND = this.pluginInstance.LOAD_APPEND;
  /**
   * page
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.page = this.model.page;
  /**
   * document
   * @type Object
   * @private
   */
  this.document = {};
  /**
   * document DOM
   * @type Object
   * @private
   */
  this.document.dom = poInstance.dom;
  /**
   * pluginType
   * @type Number
   * @private
   */
  this.modelType = this.page.metadata.modelType;
  /**
   * model type Object
   * @type Object
   * @private
   */
  this.modelTypeObj = eXria.form.ModelType;
  /**
   * plugin type
   * @type Number
   * @private
   */
  this.pluginType = this.modelTypeObj.PLUGIN;
  /**
   * use decode
   * @return void
   * @type Number
   * @private
   */
  this.isEncodeData = false;
  try {
    this.isEncodeData = (this.model.plugin.getJREVersionNumber() >= 1.7 && this.page.metadata.browser.ie == 0);
  } catch(e) {
    this.isEncodeData = false;
  }
  /**
   * plugin type에 맞춰 node Object를 생성하여 리턴
   * @param {XMLNode} poNode
   * @type eXria.data.Node
   * @return wrapping 된 Node
   * @private
   */
  this.getWrapNodeObject = function(poNode) {
    if (this.modelType == this.pluginType) {
      return new eXria.data.plugin.NativeNode(poNode);
    } else {
      if(this.isEncodeData) {
        if(poNode == null) return null;
        return new eXria.data.plugin.JreNode(poNode);
      } else {
        return poNode;
      }
    }
  };
  /**
   * 특정 URL의 XML Document를 인스턴스에 바인딩한다.
   * @param {String} psUrl 바인딩할 XML의 URL
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정
   * @return void
   * @type void
   */
  this.loadURL = function(psUrl, pnMode) {
  	if(pnMode != this.LOADAPPEND && pnMode != this.LOADREPLACE) pnMode = this.LOADAPPEND;
    this.pluginInstance.loadURL(psUrl, pnMode);
  };
  /**
   * XML Element를 인스턴스에 바인딩한다.
   * @param {XMLElement} poXML 바인딩할 XMLElement
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정
   * @return void
   * @type void
   */
  this.loadXML = function(poXML, pnMode) {
  	if(pnMode != this.LOADAPPEND && pnMode != this.LOADREPLACE) pnMode = this.LOADAPPEND;
    this.pluginInstance.loadXML(poXML, pnMode);
  };
  /**
   * XML Text를 파싱하여 인스턴스에 바인딩한다.
   * @param {String} psTxt 파싱할 XML Text
   * @param {Number} pnMode XML 바인딩 시 [InstanceObj.LOADREPLACE | InstanceObj.LOADAPPEND] 설정
   * @return void
   * @type void
   */
  this.loadTXT = function(psTxt, pnMode) {
  	if(pnMode != this.LOADAPPEND && pnMode != this.LOADREPLACE) pnMode = this.LOADAPPEND;
    this.pluginInstance.loadTXT(psTxt, pnMode);
  };
  // 2009-05-20 추가
  /**
   * Node를 주어진 타입에 따라 생성하여 그 객체를 리턴한다. Type이 없을 경우 Default로 Element Node가 리턴 된다.
   * @param {String} psNodeName 두번째 파라미터로 넘어오는 Type에 따라 Node명 또는 그 Node의 Value가 된다.
   * @param {Number} pnType Type [eXria.data.NodeType]
   * @type eXria.data.Node
   * @return 생성된 XML Node
   */
  this.createNode = function(psNodeName, psValue, pnType) {
    if (!pnType)
      pnType = this.pluginInstance.ETBNODETYPE_ELEMENT;
    try {
      if (!psValue) {
        return this.getWrapNodeObject(this.pluginInstance.createNullNode(psNodeName, pnType));
      } else {
        return this.getWrapNodeObject(this.pluginInstance.createNode(psNodeName, psValue, pnType));
      }
    } catch (e) {
      return null;
    }
  };
  /**
   * 파라미터로 넘어온 이름의 Element를 생성하여 리턴한다.
   * @param {String} psElementName 생성될 엘리먼트 이름
   * @return 생성된 Element Node
   * @type eXria.data.Node
   * @see eXria.data.Node
   */
  this.createElement = function(psElementName) {
    if(!psElementName) { return null; }
    return this.createNode(psElementName, null, this.pluginInstance.ETBNODETYPE_ELEMENT);
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 ValueNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 value node
   * @type eXria.data.ValueNode
   * @see eXria.data.ValueNode
   */
  this.createValueNode = function(psName) {
    var voNode = this.pluginInstance.createNode(psName, "", 1);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.ValueNode(this.getWrapNodeObject(voNode)); // create
                                                                            // Element
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 MapNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 MapNode
   * @type eXria.data.MapNode
   * @see eXria.data.MapNode
   */
  this.createMapNode = function(psName) {
    var voNode = this.pluginInstance.createNode(psName, "", 1);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.MapNode(this.getWrapNodeObject(voNode)); // create
                                                                          // Element
  };
  /**
   * 넘겨받은 Tag Name을 가지는 ElementNode를 생성하여 CollectionNode로 wrapping하여 리턴한다.
   * @param {String} psName 생성할 ElementNode의 TagName
   * @return 생성된 CollectionNode
   * @type eXria.data.CollectionNode
   * @see eXria.data.CollectionNode
   */
  this.createCollectionNode = function(psName) {
    var voNode = this.pluginInstance.createNode(psName, "", 1);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.CollectionNode(this.getWrapNodeObject(voNode)); // create
                                                                                // Element
  };
  /**
   * 넘겨 받은 XPath의 하위에 Node를 추가한다.
   * @param {String} psPath 추가할 위치에 해당하는 XPath
   * @param {XMLNode} poNode 추가할 XMLNode
   * @return void
   * @type void
   */
  this.appendNode = function(psPath, poNode) {
    if(poNode.node != null) poNode = poNode.node;
    this.pluginInstance.appendNode(psPath, poNode);
  };
  // 2009-05-20 추가
  /**
   * Instnace의 주어진 XPath 경로에 Value를 설정한다.
   * @param {String} psXpath Value를 설정하기 위한 XPath 경로
   * @param {String} psValue 설정하고자 하는 Value
   * @return void
   * @type void
   */
  this.setValue = function(psXpath, psValue) {
    this.pluginInstance.setValue(psXpath, psValue);
  };
  // 2009-05-20 추가
  /**
   * Instance의 Value를 XPath를 통해서 조회 한다.
   * @param {String} psXpath 조회대상의 XPath 경로
   * @type String
   * @return 조회된 Value
   */
  this.getValue = function(psXpath) {
    var voValue = this.pluginInstance.getValue(psXpath);
    if(voValue == null) return null;
    
    var vsValue = String(voValue) + "";  

    if(this.isEncodeData) {
      vsValue = decodeURIComponent(vsValue);
    }
    
    return vsValue;
  };
  /**
   * Instance의 dom객체의 XML 내용을 XPath를 이용하여 해당 위치에 데이터를 문자열로 얻는다.
   * @return dom 객체의 XML 문자열
   * @param {String} psXPath XPath 문자열
   * @type String
   */
  this.getXML = function(psXPath) {
    return String(this.pluginInstance.getXML(psXPath));
  };
  /**
   * 넘겨받은 XPath를 단순 Value형태로 처리하기 위한 ValueNode를 생성하여 리턴한다.
   * @param {String} psXpath Value Node로 얻고자 하는 Node의 Path
   * @return ValueNode
   * @type eXria.data.ValueNode
   * @see eXria.data.ValueNode
   */
  this.getValueNode = function(psXpath) {
    var voNode = this.pluginInstance.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.ValueNode(this.getWrapNodeObject(voNode));
  };
  /**
   * 넘겨받은 XPath를 Map형태로 처리하기 위한 MapNode를 생성하여 리턴한다.
   * @param {String} psXpath Map Node로 얻고자 하는 Node의 Path
   * @return MapNode
   * @type eXria.data.MapNode
   * @see eXria.data.MapNode
   */
  this.getMapNode = function(psXpath) {
    var voNode = this.pluginInstance.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.MapNode(this.getWrapNodeObject(voNode));
  };
  /**
   * 넘겨받은 XPath를 Collection형태로 처리하기 위한 CollectionNode를 생성하여 리턴한다.
   * @param {String} psXpath 처리할 기준 Node XPath
   * @return CollectionNode
   * @type eXria.data.CollectionNode
   * @see eXria.data.CollectionNode
   */
  this.getCollectionNode = function(psXpath) {
    var voNode = this.pluginInstance.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }
    return new eXria.data.xhtml.CollectionNode(this.getWrapNodeObject(voNode));
  };
  /**
   * 넘겨받은 Xpath의 Node를 삭제한다.
   * @param {String} psXpath 삭제할 Node의 XPath
   * @return 삭제된 노드
   * @type eXria.data.Node
   */
  this.removeNode = function(psXpath) {
    var voNode = this.pluginInstance.removeNode(psXpath);
    return this.getWrapNodeObject(voNode);
  };
  /**
   * 해당 XPath로 단일 Node를 조회한다.
   * @param {String} psXpath 조회할 XPath
   * @return 조회된 Node
   * @type eXria.data.Node
   */
  this.selectSingleNode = function(psXpath) {
    var voNode = this.pluginInstance.selectSingleNode(psXpath);
    if (!voNode) {
      return null;
    }

    return this.getWrapNodeObject(voNode);
  };
  /**
   * Instance의 하위Node를 넘겨받은 XPath로 조회하여 리턴한다.
   * @param {String} psXpath 조회할 Xpath
   * @return NodeList
   * @type eXria.data.NodeList
   * @see eXria.data.NodeList
   */
  this.selectNodes = function(psXpath) {
    var voNodeList = this.pluginInstance.selectNodes(psXpath);

    if (!voNodeList) {
      return null;
    }

    var voResultNodeList = null;

    if (this.modelType == this.pluginType) {
      voResultNodeList = new eXria.data.plugin.NativeNodeList(voNodeList);
    } else {
      if(this.isEncodeData) {
        voResultNodeList = new eXria.data.plugin.JreNodeList(voNodeList);
      } else {
        voResultNodeList = voNodeList;
      }
    }

    return voResultNodeList;
  };
  /**
   * clear
   * @return void
   * @type void
   * @ignore
   */
  this.clear = function() {
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 alert으로 출력
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return void
   * @type void
   */
  this.print = function(psXpath) {
    if (psXpath == null || psXpath == undefined) {
      return;
    }
    alert(this.getXML(psXpath));
  };
  /**
   * 넘겨받은 XPath에 해당하는 Element를 Browser Type에 맞춰 문자열로 반환
   * @param {String} psXpath 찾아올 Element의 XPath
   * @return xml 노드를 문자열화한 객체
   * @type String
   */
  this.nodeToStr = function(psXpath) {
    if (psXpath == null || psXpath == undefined) {
      return;
    }
    return this.getXML(psXpath);
  };
  /**
   * 넘겨 받은 XPath의 Node를 복사하여 리턴한다.
   * @param {String} psXPath 복사할 Node의 XPath
   * @param {String} pbDeep 깊은복사 유무 ( True : Deep Copy )
   * @return 복사된 노드
   * @type eXria.data.Node
   */
  this.cloneNode = function(psXPath, pbDeep) {
    var vnDeep = 1;
    if (pbDeep == false || pbDeep != 1) {
      vnDeep = 0;
    }
    return this.getWrapNodeObject(this.pluginInstance
        .cloneNode(psXPath, vnDeep));
  };
  /**
   * Instance의 하위Node를 넘겨받은 XPath로 조회하여 자바스크립트로 배열화할 수 있는 문자열을 반환하는 메소드
   * @param {String} psXpath 조회할 Xpath
   * @return 문자열화 된 Node List
   * @type String
   */
  this.selectNodesStr = function(psXPath) {
    return String(this.pluginInstance.selectNodesStr(psXPath));
  };
  /**
   * 해당 XPath 하위에 두번째 파라미터로 넘어온 XML Text Node구조를 생성한다.
   * @param {String} psXpath 생성할 Node의 Parent Node가 될 Node의 XPath
   * @param {String} psTxt 생성할 Node XML Text
   * @return void
   * @type void
   */
  this.appendNodeByTxt = function(psXPath, psTxt) {
	this.pluginInstance.appendNodeByTxt(psXPath, psTxt);
  };
};

/**
 * @fileoverview
 * Data 및 Source에 대한 Type을 결정하기 위한 상수 정의 클래스</br>
 * enum (Add Type)</br>
 * eXria.data.plugin.AddAndSrcType.DATAADD</br>
 * eXria.data.plugin.AddAndSrcType.DATAREPLACE</br>
 * eXria.data.plugin.AddAndSrcType.FIELDNAMENEW</br>
 * eXria.data.plugin.AddAndSrcType.FIELDMATCH</br>
 * eXria.data.plugin.AddAndSrcType.FIRSTROWFIELD_SRC</br>
 * eXria.data.plugin.AddAndSrcType.FIRSTROWFIELD_TGT</br>
 * eXria.data.plugin.AddAndSrcType.FIRSTROWFIELD_ALL</br>
 * enum (Source Type)</br>
 * eXria.data.plugin.AddAndSrcType.INSTANCESOURCE</br>
 * eXria.data.plugin.AddAndSrcType.DBSOURCE</br>
 * eXria.data.plugin.AddAndSrcType.CSVFILESOURCE</br>
 * eXria.data.plugin.AddAndSrcType.TABFILESOURCE</br>
 * eXria.data.plugin.AddAndSrcType.DATASETSOURCE</br>
 * eXria.data.plugin.AddAndSrcType.EXCELFILESOURCE</br>
 * eXria.data.plugin.AddAndSrcType.DELIMITERSOURCE</br>
 * eXria.data.plugin.AddAndSrcType.BOMFILETYPE</br>
 * eXria.data.plugin.AddAndSrcType.NOBOMFILETYPE</br>
 * eXria.data.plugin.AddAndSrcType.UTF8FILETYPE</br>
 * eXria.data.plugin.AddAndSrcType.UTF16FILETYPE</br>
 * eXria.data.plugin.AddAndSrcType.ADOSOURCE</br>
 */
/**
 * Data 및 Source에 대한 Type을 결정하기 위한 상수 정의 클래스
 * @author Choe, hyeon jong
 * @version 1.0
 * @constructor
 */
eXria.data.plugin.AddAndSrcType = {
	//ADD Type
	DATAADD				: 0X0001, // target에 이미 노드가 있을경우에 뒤에 추가
	DATAREPLACE			: 0X0002, // target에 이미 노드가 있을경우에 지우고 추가
	FIELDNAMENEW		: 0X0004, // 들어온 데이터의 필드명에 맞추어 target에 적용
	FIELDMATCH   		: 0X0008, // target에 있는 field만 생성
	FIRSTROWFIELD_SRC 	: 0X0010, // source에 첫줄을 필드명으로 생성
	FIRSTROWFIELD_TGT	: 0X0020, // target에 첫줄을 필드명으로 생성
	FIRSTROWFIELD_ALL	: 0X0030, // source와 target에 있는 모든 첫줄을 필드명으로 생성
	//Source Type
	INSTANCESOURCE	: 0X001,	//인스턴스소스
	DBSOURCE		: 0X002,	//내장 Sqlite 소스
	CSVFILESOURCE	: 0X004,	//CSV 형식 소스
	TABFILESOURCE	: 0X008,	//탭 구분 문자열 파일 소스
	DATASETSOURCE	: 0X010,	//Plugin DataSet 소스
	EXCELFILESOURCE	: 0X020, 	//엑셀파일 소스
	DELIMITERSOURCE : 0X040,	//사용자 정의 구분자 파일 소스
	BOMFILETYPE		: 0X080,	//유니코드 BOM 문자 형식 소스
	NOBOMFILETYPE	: 0X100,	//유니코드 NOBOM 문자 형식 소스
	UTF8FILETYPE	: 0X200,	//UTF8 형식 파일 소스
	UTF16FILETYPE	: 0X400,	//UTF16 형식 파일 소스
	ADOSOURCE		: 0X800		//ADO(Active Data Object) 형식 파일 소스(IE전용)
};

/**
 * @fileoverview
 * Plugin Mode 사용시 DB Command에 대한 관리를 하는 클래스
 */
/**
 * Plugin Mode 사용시 DB Command에 대한 관리를 하는 클래스
 * @author Choe, hyeon jong
 * @version 1.0
 * @param {Object} poCommand command
 * @constructor
 */
eXria.data.plugin.DBCommandCmd = function(psId, poModel, poCommand) {
  /**
   * id
   * @type String
   */
  this.id = psId;
  /**
   * model
   * @type eXria.form.Model
   */
  this.model = poModel;
  /**
   * command object
   * @type DBCommnadCmd
   * @private
   */
  this.command = poCommand;
  /**
   * target에 이미 노드가 있을경우에 뒤에 추가 한다.
   * @type Number
   */
  this.ETBDATAADD = this.command.ETBDATAADD;
  /**
   * target에 이미 노드가 있을경우에 지우고 추가 한다.
   * @type Number
   */  
  this.ETBDATAREPLACE = this.command.ETBDATAREPLACE;
  /**
   * 들어온 데이터의 필드명에 맞추어 target에 적용 한다.
   * @type Number
   */  
  this.ETBFIELDNAMENEW = this.command.ETBFIELDNAMENEW;
  /**
   * target에 있는 field만 생성 한다.
   * @type Number
   */  
  this.ETBFIELDMATCH = this.command.ETBFIELDMATCH;
  /**
   * source에 첫줄을 필드명으로 생성한다.
   * @type Number
   */  
  this.ETBFIRSTROWFIELD_SRC = this.command.ETBFIRSTROWFIELD_SRC;
  /**
   * target에 첫줄을 필드명으로 생성한다.
   * @type Number
   */  
  this.ETBFIRSTROWFIELD_TGT = this.command.ETBFIRSTROWFIELD_TGT;
  /**
   * source와 target에 있는 모든 첫줄을 필드명으로 생성한다.
   * @type Number
   */  
  this.ETBFIRSTROWFIELD_ALL = this.command.ETBFIRSTROWFIELD_ALL;
  /**
   * excel export시 cell안에 데이터 세로정렬을 위로 한다.
   * @type Number
   */
  this.EXCEL_VERTICALALIGN_TOP = this.command.EXCEL_VERTICALALIGN_TOP;
  /**
   * excel export시 cell안에 데이터 세로정렬을 가운데로 한다.
   * @type Number
   */
  this.EXCEL_VERTICALALIGN_MIDDLE = this.command.EXCEL_VERTICALALIGN_MIDDLE;
  /**
   * excel export시 cell안에 데이터 세로정렬을 아래로 한다.
   * @type Number
   */
  this.EXCEL_VERTICALALIGN_BOTTOM = this.command.EXCEL_VERTICALALIGN_BOTTOM;
  /**
   * 조회한 결과를 반영할 타겟을 설정한다.
   * @param {Number} pnType target의 타입
   * @param {String} psTargetName target name
   * @param {String} psTarget ConnectionString
   * @return void
   * @type void
   */
  this.changeTarget = function(pnType, psTargetName, psTargetConnectionString) {
    this.command.changeTarget(pnType, psTargetName, psTargetConnectionString);
  };
  /**
   * 등록된 파라미터들을 clear한다.
   * @return void
   * @type void
   */
  this.clearParameters = function() {
    this.command.clearParameters();
  };
  /**
   * setQueryString으로 설정한 조회 SQL을 실행한다.
   * @param {Number} pnTypeAdd
   * @return 조회돤 record 수 리턴
   * @type Number
   */
  this.executeQuery = function(pnTypeAdd) {
    return this.command.executeQuery(pnTypeAdd);
  };
  /**
   * setQueryString으로 설정한 SQL(Create, Insert, Update, Delete)을 실행한다.
   * @return 변경된 건수
   * @type Number
   */
  this.executeUpdate = function() {
    return this.command.executeUpdate();
  };
  /**
   * excel export시 cell의 세로정렬을 변경한다.
   * @param {Number} 세로정렬값
   * @return void
   * @type void
   */
  this.setVerticalAlign = function(pnVarticalAlign){
  	this.command.setVerticalAlign(pnVarticalAlign);
  }
  /**
   * 조회할 리스트의 마지막 row index를 리턴한다.
   * @return 마지막 row index
   * @type Number
   */
  this.getMaxRow = function() {
    return this.command.getMaxRow();
  };
  /**
   * 조회할 리스트의 처음 row index를 리턴한다.
   * @return 처음 row index
   * @type Number
   */
  this.getMinRow = function() {
    return this.command.getMinRow();
  };
  /**
   * 특정 index의 parameter를 삭제한다.
   * @param {Number} pnIndex 삭제대상 index
   * @return void
   * @type void
   */
  this.removeParameter = function(pnIndex) {
    this.command.removeParameter(pnIndex);
  };
  /**
   * 행 또는 열에 대한 사용자정의 구분자를 설정한다.
   * @param {Number} pnType type(1:Source Col, 2:Source Row, 4:Target Col, 8:Target Row)
   * @param {String} psDelimiter 사용자 정의 구분자
   * @return void
   * @type void
   */
  this.setDelimiter = function(pnType, psDelimiter) {
    this.command.setDelimiter(pnType, psDelimiter);
  };
  /**
   * 조회 시 source의 column과 매칭 할 target의 column명을 설정한다.
   * @param {String} psSourceName source column 이름
   * @param {String} psTargetName Target column 이름
   * @return void
   * @type void
   */
  this.setFieldMatch = function(psSourceName, psTargetName) {
    this.command.setFieldMatch(psSourceName, psTargetName);
  };
  /**
   * 조회할 리스트의 마지막 row index를 설정
   * @param {Number} pnIndex
   * @return void
   * @type void
   */
  this.setMaxRow = function(pnIndex) {
    this.command.setMaxRow(pnIndex);
  };
  /**
   * 조회할 리스트의 처음 row index를 설정
   * @param {Number} pnIndex
   * @return void
   * @type void
   */
  this.setMinRow = function(pnIndex) {
    this.command.setMinRow(pnIndex);
  };
  /**
   * 특정 index에 parameter를 추가하거나 설정한다.
   * @param {Number} pnIndex 설정 대상 index
   * @param {String} psValue 설정할 parameter
   * @return void
   * @type void
   */
  this.setParameter = function(pnIndex, psValue) {
    this.command.setParameter(pnIndex, psValue);
  };
  /**
   * SQL을 실행하기 위한 SQL문장을 설정한다.
   * @param {String} psQuery SQL 문장을 설정
   * @return void
   * @type void
   */
  this.setQueryString = function(psQuery) {
    this.command.setQueryString(psQuery);
  };
  /**
   * source와 target간의 동기화를 설정한다.
   * @param {Boolean} pbSync true일 경우 동기화 설정
   * @return void
   * @type void
   */
  this.setSync = function(pbSync) {
    this.command.setSync(pbSync);
  };
  /**
   * Export 할 Excel의 Column 순서를 지정한다.
   * @param {String} psSeq Column 순서
   * @return void
   * @type void
   */
  this.setColSeq = function(psSeq) {
    this.command.setColSeq(psSeq);
  }
};
/**
 * @fileoverview
 * Plugin Mode 사용시 File과 관련된 기능을 제공하는 클래스
 */
/**
 * Plugin Mode 사용시 File과 관련된 기능을 제공하는 클래스
 * @author Cheo, hyeon jong.
 * @version 1.0
 * @param {eXria.data.plugin.FoCmd} poFoCmd
 * @constructor
 */ 
eXria.data.plugin.FoCmd = function(poFoCmd, poModel) {
  /**
   * model
   * @type eXria.form.Model
   */
   this.model = poModel;
  /**
   * foCmd
   * @type eXria.data.plugin.FoCmd
   * @private
   */
  this.foCmd = poFoCmd;
  /**
   * file을 close 한다.
   * @return File이 정상적으로 close 되면 true 리턴
   * @type Boolean
   */
  this.close = function() {
	return this.foCmd.close();
  };
  /**
   * 대상 경로에 파일을 복사한다.
   * @param {String} psDestination 복사대상 경로
   * @param {Boolean} pbOverWrite 덮어쓰기 유무
   * @return void
   * @type void
   */
  this.copy = function(psDestination, pbOverWrite) {
	this.foCmd.copy();
  };  
  /**
   * 현재 파일의 포인터를 리턴한다.
   * @return 현재 파일 포인터의 위치
   * @type Number
   */
  this.getFilePos = function() {
	return this.foCmd.getFilePos();
  };
  /**
   * 파일 포인터의 위치가 EOF인지 검사
   * @return EOF이면 true 리턴
   * @type Boolean
   */
  this.isEndOfFile = function() {
	return this.foCmd.isEndOfFile();
  };
  /**
   * 파일의 내용을 모두 읽어서 문자열로 리턴한다.
   * @return 파일의 내용이 들어있는 문자열
   * @type String
   */
  this.readAll = function() {
	return this.foCmd.readAll();
  };
  /**
   * 파일의 내용을 줄단위로 읽어서 문자열로 리턴한다.
   * @return 파일에서 줄단위로 읽은 문자열
   * @type String
   */
  this.readLine = function() {
	return this.foCmd.readLine();
  };
  /**
   * 파일에서 파라미터로 넘어온 Byte만큼 문자열을 리턴한다.
   * @param {Number} pnReadLen 읽어올 문자열의 Byte
   * @return Byte 길이 만큼의 문자열
   * @type String
   */
  this.read = function(pnReadLen) {
	return this.foCmd.read(pnReadLen);
  };
  /**
   * 파일 포인터를 원하는 위치로 이동한다.
   * @param {Number} pnOffset 기준점으로 부터 이동할 거리(Byte단위)
   * @param {Number} pnWhence 이동의 기준점으로서 다음 중 선택(0:File의 시작점, 1:File의 현재위치, 2:File의 EOF(End Of File))
   * @return void
   * @type void
   */
  this.seek = function(pnOffset, pnWhence) {
	this.foCmd.seek(pnOffset, pnWhence);
  };
  /**
   * 파일의 시작지점으로 이동
   * @return void
   * @type void
   */
  this.seekToBegin = function() {
	this.foCmd.seekToBegin();
  };
  /**
   * 파일의 끝으로 이동
   * @return void
   * @type void
   */
  this.seekToEnd = function() {
	this.foCmd.seekToEnd();
  };
  /**
   * 파일에 문자열을 주어진 길이만큼 Write 한다.
   * @param {String} psWord Write 할 문자열
   * @param {Number} pnCount Write 할 길이
   * @return 쓰여질 파일이 읽기전용일때는 false 리턴
   * @type Boolean
   */
  this.write = function(psWord, pnCount) {
	return this.foCmd.write(psWord, pnCount);
  };
  /**
   * 파일에 줄단위로 주어진 문자열을 Write 한다.
   * @param {String} psWord write 할 문자열
   * @return 쓰여질 파일이 읽기 전용일때 false 리턴
   * @type Boolean
   */
  this.writeLine = function(psWord) {
	return this.foCmd.writeLine(psWord);
  };
  /**
   * 파일에 줄단위로 주어진 문자열을 Unicode로 Write 한다.
   * @param {String} psWord
   * @return 쓰여질 파일이 읽기전용일때는 false 리턴
   * @type Boolean
   */
  this.writeLineUnicodeStr = function(psWord) {
	return this.foCmd.writeLineUnicodeStr(psWord);
  };
  /**
   * 파일에 문자열을 ansi string으로 write한다.
   * @param {String} psWord write할 문자열
   * @return 쓰여질 파일이 읽기전용일때는 false리턴
   * @type Boolean
   */
  this.writeStr = function(psWord) {
	return this.foCmd.writeStr(psWord);
  };
  /**
   * 파일에 문자열을 Unicode로 Write한다.
   * @param {String} psWord write할 문자열
   * @return 쓰여질 파일이 읽기전용일때는 fasle 리턴
   * @type Boolean
   */
  this.writeUnicodeStr = function(psWord) {
	return this.foCmd.writeUnicodeStr(psWord);
  };
};
/**
 * @fileoverview
 * Plugin Mode 사용시 DB와의 Connection을 관리하는 클래스
 */
/**
 * Plugin Mode 사용시 DB와의 Connection을 관리하는 클래스
 * @author Choe, hyeon jong
 * @version 1.0
 * @param {Object} poConnection connection
 * @constructor
 */
eXria.data.plugin.DBConnectionCmd = function(poModel, psId, pnTypeSrc, psSrcConn, pnTarget, psTargetName, psTargerConn) {
  /**
   * model
   * @type eXria.form.Model
   */
  this.model = poModel;
  /**
   * id
   * @type String
   */
  this.id = psId;
//  /**
//   * connection Object
//   * @type DBConnectionCmd
//   * @private
//   */
//  this.connection = poConnection;
  this.typeSrc = pnTypeSrc;
  this.srcConn = psSrcConn;
  this.target = pnTarget;
  this.targetName = psTargetName;
  this.TargerConn = psTargerConn;
  
  /**
   * dbcommandcmd를 저장하는 map
   * @type eXria.data.ArrayMap
   * @private
   */
  this.dbCommandCmdMap = new eXria.data.ArrayMap();
  /**
   * Transaction start</br>
   * AutoCommit이 false로 되어있을 경우 Transaction을 시작하기 위해</br>
   * 명시적으로 호출 Transaction을 시작한다.</br>
   * AutoCommit이 false일 경우 Transaction을 시작하기 위해서는 반드시 호출해주어야 한다.</br>
   * @return void
   * @type void
   */
  this.begin = function() {
    this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).begin();
  };
  /**
   * Connection Close
   * @return void
   * @type void
   */
  this.close = function() {
    this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).close();
  };
  /**
   * transaction commit
   * @return void
   * @type void
   */
  this.commit = function() {
    this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).commit();
  };
  /**
   * DBCommandCmd 인터페이스를 구함
   * @param {String} psId 
   * @return DBCommandCmd 타입의 인터페이스가 리턴된다.
   * @type eXria.data.plugin.DBCommandCmd
   * @see eXria.data.plugin.DBCommandCmd
   */
  this.getCommand = function(psId) {
    var voCommand = null;
    voCommand = this.dbCommandCmdMap.get(psId);
    
    if(voCommand == null) {
      voCommand = new eXria.data.plugin.DBCommandCmd(psId, this.model, this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).getCommand(psId));
      this.dbCommandCmdMap.put(psId, voCommand);
    }
    return voCommand;
  };
  /**
   * Close 상태 체크
   * @return close 상태이면 true 리턴
   * @type Boolean
   */
  this.isClosed = function() {
    return this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).isClosed();
  };
  /**
   * open 상태 체크
   * @return open 상태이면 true리턴
   * @type Boolean
   */
  this.isOpened = function() {
    return this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).isOpened();
  };
  /**
   * Auto commit 설정
   * @param {Boolean} pbAuto true이면 AutoCommit 설정
   * @return void
   * @type void
   */
  this.setAutoCommit = function(pbAuto) {
    this.model.plugin.getConnection(this.id, this.typeSrc, this.srcConn, this.target, this.targetName, this.targerConn).setAutoCommit();
  };
};
/**
 * @fileoverview
 * Plugin Mode 사용시 파일의 추가 및 삭제 이동등을 담당하는 클래스
 */
/**
 * Plugin Mode 사용시 파일의 추가 및 삭제 이동등을 담당하는 클래스
 * @version 1.0
 * @author Choe, hyeon jong.
 * @param {eXria.data.plugin.FsoCmd} poFso
 * @constructor
 * @type eXria.data.plugin.FsoCmd
 * @return void
 */ 
eXria.data.plugin.FsoCmd = function(poFso, poModel) {
  /**
   * model
   * @type eXria.form.Model
   */
  this.model = poModel;
  /**
   * fso
   * @type eXria.data.plugin.FsoCmd
   * @private
   */
  this.fso = poFso;
  /**
   * 파일 오픈을 읽기전용으로 할 경우 선택.
   * @type Number
   */
  this.ETBFTYPE_READONLY = this.fso.ETBFTYPE_READONLY;
  /**
   * 파일 오픈을 쓰기전용으로 할 경우 선택. 기존 자료 있을 시에 삭제 된다.
   * @type Number
   */
  this.ETBFTYPE_WRITEONLY = this.fso.ETBFTYPE_WRITEONLY;
  /**
   * 파일 오픈을 읽고쓰기로 할 경우 선택.
   * @type Number
   */
  this.ETBFTYPE_READWRITE = this.fso.ETBFTYPE_READWRITE;
  /**
   * 파일 오픈을 추가 모드로 할 경우 선택. 파일 내용의 맨 뒤부터 자료가 저장 되어진다.
   * @type Number
   */
  this.ETBFTYPE_APPEND = this.fso.ETBFTYPE_APPEND;
  /**
   * 파일 오픈을 이진파일로 할 경우 선택.
   * @type Number
   */
  this.ETBFTYPE_BINARY = this.fso.ETBFTYPE_BINARY;
  /**
   * 파일 내용 저장 문자코드가 ansi일 경우 선택.
   * @type Number
   */
  this.ETBFFORMAT_ASCII = this.fso.ETBFFORMAT_ASCII;
  /**
   * 파일 내용 저장 문자코드가 UTF8일 경우 선택.
   * @type Number
   */
  this.ETBFFORMAT_UTF8 = this.fso.ETBFFORMAT_UTF8;
  /**
   * 파일 내용 저장 문자코드가 UTF8 NOBOM일 경우 선택.
   * @type Number
   */
  this.ETBFFORMAT_UTF8_NOBOM = this.fso.ETBFFORMAT_UTF8_NOBOM;
  /**
   * 파일 내용 저장 문자코드가 UTF16일 경우 선택.
   * @type Number
   */
  this.ETBFFORMAT_UTF16 = this.fso.ETBFFORMAT_UTF16;
  /**
   * 파일 내용 저장 문자코드가 UTF16 NOBOM일 경우 선택.
   * @type Number
   */
  this.ETBFFORMAT_UTF16_NOBOM = this.fso.ETBFFORMAT_UTF16_NOBOM;
	
  /**
   * 열기 대화상자시 단일선택을 가능하게 한다.
   * @type Number
   */
  this.ETBFPICKEROPEN = this.fso.ETBFPICKEROPEN;
  /**
   * 열기 대화상자시 다중선택을 가능하게 한다.
   * @type Number
   */
  this.ETBFPICKERMUILTI = this.fso.ETBFPICKERMUILTI;
  /**
   * 열기 대화상자시 다중선택을 가능하게 한다.
   * @type Number
   */
  this.ETBFPICKEROPENMUILTI = this.fso.ETBFPICKEROPENMUILTI;
  /**
   * 저장 대화상자를 연다.
   * @type Number
   */
  this.ETBFPICKERSAVE = this.fso.ETBFPICKERSAVE;
  /**
   * 폴더 선택 전용 대화상자를 연다.
   * @type Number
   */
  this.ETBFPICKERFOLDER = this.fso.ETBFPICKERFOLDER;
  /**
   * File을 복사한다.
   * @param {String} psSource 원본 File Path
   * @param {String} psDestination 대상 File Path
   * @param {Boolean} pbOverWrite 덮어쓰기 유무
   * @return 복사 실패시 false 리턴
   * @type Boolean
   */
  this.copyFile = function(psSource, psDestination, pbOverWrite) {
	return this.fso.copyFile(psSource, psDestination, pbOverWrite);
  };
  /**
   * Folder를 주어진 경로에 create 한다.
   * @param {String} psFolderName create할 path
   * @return 실패시 false 리턴
   * @type Boolean
   */
  this.createFolder = function(psFolderName) {
	return this.fso.createFolder(psFolderName);
  };
  /**
   * File을 삭제한다.
   * @param {String} psFileName 삭제 대상의 File Path
   * @param {String} psForce 미 정의 (""입력)
   * @return 실패시 false 리턴
   * @type Boolean
   */
  this.deleteFile = function(psFileName, psForce) {
	return this.fso.deleteFile(psFileName, psForce);
  };
  /**
   * 조회대상 드라이브가 존재하는지 검사
   * @param {String} psDriveSpec 조회 할 드라이브 지정
   * @return 조회대상 드라이브가 존재하면 true
   * @type Boolean
   */
  this.driveExists = function(psDriveSpec) {
	return this.fso.driveExists(psDriveSpec);
  };
  /**
   * 조회 대상 File이 존재하는지 검사
   * @param {String} psFileSpec 조회대상 File Path
   * @return 조회대상 File이 존재하면 true
   * @type Boolean
   */
  this.fileExists = function(psFileSpec) {
	return this.fso.fileExists(psFileSpec);
  };
  /**
   * 조회 대상의 Folder가 존재하는지 검사
   * @param psFolderSpec
   * @return 조회대상 Folder Path
   * @type Boolean
   */
  this.folderExists = function(psFolderSpec) {
	return this.fso.folderExists(psFolderSpec);
  };
  /**
   * File을 이동한다.
   * @param {String} psSource 원본 File Path
   * @param {String} psDestination 대상 File Path
   * @return 이동 실패시 false 리턴
   * @type Boolean
   */
  this.moveFile = function(psSource, psDestination) {
	return this.fso.moveFile(psSource, psDestination);
  };
  /**
   * Text File을 주어진 option으로 open하고 FoCmd 인터페이스를 얻는다.
   * @param {String} psFileName open대상의 File Path
   * @param {Number} pnIoMode 입출력에 대한 Option 설정 [eXria.data.plugin.IOMode 참조]
   * @param {Boolean} pbCreate true : file을 새로 생성하고 기존파일이 없으면 만들고 있으면 덮어씀. false : 존재하는 파일을 open할때 기존 파일이 있어야함.
   * @param {Number} pnFormat 인코딩 설정 [eXria.data.plugin.EncType 참조]
   * @return FoCmd 타입의 File Object를 다루기 위한 인터페이스
   * @type eXria.data.plugin.FoCmd
   */
  this.openTextFile = function(psFileName, pnIoMode, pbCreate, pnFormat) {
	return new eXria.data.plugin.FoCmd(this.fso.openTextFile(psFileName, pnIoMode, pbCreate, pnFormat), this.model);
  };
  /**
   * 조회대상 폴더의 파일 목록을 문자열로 리턴한다.
   * @param {String} psPathSpec 조회 대상 경로
   * @return psPathSpec 위치의 파일들을 ';' 구문자를 통하여 파일명을 리턴
   * @type String
   */
  this.getFileList = function(psPathSpec) {
	return this.fso.getFileList(psPathSpec);
  };
  /**
   * File Open, Save 대화상자를 사용자에게 보여주고 선택 가능하게 한다.
   * @param {String} psTitle 파일 선택 다이얼로그의 타이틀명을 설정
   * @param {String} psInitFileName 다이얼로그에 기본 파일 이름을 설정
   * @param {String} psFilter 확장자의 선택 콤보를 만든다.
   * @param {Number} pnPickerFlag 
	 * @param {String} psFilePath 사용자에게 처음으로 보여 줄 Path 지정
   * @return 선택된 파일명이 리턴, 다중선택 파일은 ';' 구분자로 연결됨
   * @type String
   */
  this.showFilePicker = function(psTitle, psInitFileName, psFilter, pnPickerFlag, psFilePath) {
	if(!psFilePath) psFilePath = null;
	return this.fso.showFilePicker(psTitle, psInitFileName, psFilter, pnPickerFlag, psFilePath);
  };
  /**
   * 외부명령을 실행한다.
   * @param {String} psPathSpec 실행하고자 하는 파일의 path
   * @return void
   * @type void
   */
  this.executeFile = function(psPathSpec) {
	this.fso.executeFile(psPathSpec);
  };
  /**
   * 클라이언트 파일의 권한을 변경한다.
   * @param {String} psFileName 권한설정 대상의 File Path
   * @paran {Number} pnPermission 권한설정 Flag
   * @return 실패시 false 리턴
   * @type Boolean
   */
  this.chmod = function(psFileName, pnPermission) {
	  return this.fso.chmod(psFileName, pnPermission);
  };
};
/**
 * @fileoverview
 * Plugin Mode에서의 DataSet 사용시 내부의 메서드를 래핑해주는 클래스
 */
/**
 * Plugin Mode에서의 DataSet 사용시 내부의 메서드를 래핑해주는 클래스
 * @author Choe, hyeon jong.
 * @version 1.0
 * @param {Object} poDataSet dataset
 * @constructor
 * @base eXria.data.DataSetCmd
 */
eXria.data.plugin.DataSetCmd = function(psId, poModel) {
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트
   * @type eXria.data.ArrayMap
   */
  this.skippedStatusCheckList = new eXria.data.ArrayMap();
  /**
   * Inherit
   */
  eXria.data.DataSetCmd.call(this, psId, poModel);
  /**
   * use decode
   * @return void
   * @type Number
   * @private
   */
  this.isEncodeData = false;
  try {
    this.isEncodeData = (this.model.plugin.getJREVersionNumber() >= 1.7 && this.model.page.metadata.browser.ie == 0);
  } catch(e) {
    this.isEncodeData = false;
  }
  /**
   * Primary key 정보를 설정한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 설정할 primary key
   * @return void
   * @type void
   */
  this.addPrimaryKey = function(psTableName, psName, psSourceName) {
    this.dataSet.addPrimaryKey(psTableName, psName, psSourceName);
  };
  /**
   * column 정보를 update 한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName update 할 값
   * @return void
   * @type void
   */
  this.addUpdateColumn = function(psTableName, psName, psSourceName) {
    this.dataSet.addUpdateColumn(psTableName, psName, psSourceName);
  };
  /**
   * source와 target의 index를 설정한다.
   * @param {Number} pnSourceIndex 대상 src index
   * @param {Number} pnTargetIndex 대상 target index
   * @return void
   * @type void
   */
  this.changeRowIndex = function(pnSourceIndex, pnTargetIndex) {
    this.dataSet.changeRowIndex(pnSourceIndex, pnTargetIndex);
  };
  /**
   * 해당 테이블에서 primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 테이블 이름
   * @return void
   * @type void
   */
  this.clearPrimaryKeys = function(psTableName) {
    this.dataSet.clearPrimaryKeys(psTableName);
  };
  /**
   * sort parameter를 clear 한다.
   * @return void
   * @type void
   */
  this.clearSortItem = function() {
    this.dataSet.clearSortItem();
  };
  /**
   * column 정보를 clear 한다.
   * @param {String} psTableName 대상 table name
   * @return void
   * @type void
   */
  this.clearUpdateColumns = function(psTableName) {
    this.dataSet.clearUpdateColumns(psTableName);
  };
  /**
   * 현재 DataSet에 특정 컬럼을 다른 DataSet으로 복사한다.
   * @param {String} psScrCol 원본 컬럼명
   * @param {String} pnDataSetId 복사할 데이터셋 Id명
   * @return 복사 성공 여부 성공시 True
   * @type Boolean
   */
  this.cloneCol = function(psScrCol, pnDataSetId) {
    return this.dataSet.cloneCol(psScrCol, pnDataSetId);
  };
  /**
   * XPath filter 설정.
   * @param {String} psXPath 적용대상 경로
   * @param {Boolean} pbApply 적용 유무
   * @param {Boolean} pbViewDelFlagRow delete flag row를 보이고자 할 경우 true 보이지 말고자 할 경우 false
   * @return -1
   * @type Number
   */
  this.compositeFilter = function(psXPath, pbApply, pbViewDelFlagRow) {
    if(pbViewDelFlagRow == null) {
      pbViewDelFlagRow = false;
    }
    return this.dataSet.compositeFilter(psXPath, pbApply, pbViewDelFlagRow);
  };
  /**
   * xpath를 이용하여 필터링된 자료의 DataSet RowID를 알아낸다.
   * @param {String} psXPath 해당 DataSet에서 추출 하고자 하는 컬럼의 연산식
   * @return 해당 연산으로 필터링 된 RowIndex를 문자열로 ','로 구분하여 리턴한다.
   * 결과 값이 없을 경우 ""을 리턴한다. 
   * @type String
   */
  this.compositeIdx = function(psXPath) {
    return this.dataSet.compositeIdx(psXPath);
  };
  /**
   * 주어진 index의 row를 delete 한다.
   * @param {Number} pnIndex 삭제 대상 row의 index
   * @return index가 범위를 넘으면 -1 리턴
   * @type Number
   */
  this.deleteRow = function(pnIndex) {
    return this.dataSet.deleteRow(pnIndex);
  };
  /**
   * 찾고자 하는 Column:Value 쌍을 복수로 입력하여 값에 해당하는 RowID를 "," 구분하여 리턴한다. 
   * 인자 값은 컬럼명과 그 컬럼에서 찾을 Value를 ":"로 구분하여 넣어주고 복수개일 경우 Column:Value쌍을 ","로 구분하여
   * 다수개의 조건을 넣어 줄 수 있다. 
   * @param {String} psKeyArray 찾고자 하는 DataSet의 Column명
   * @return ","로 구분되어진 문자열
   * @type String
   */
  this.find = function(psKeyArray) {
    return this.dataSet.find(psKeyArray);
  };
  /**
   * 주어진 row의 fieldname을 통한 value 질의.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName name
   * @return 조회 결과 리턴
   * @type String
   */
  this.get = function(pnIndex, psFieldName) {
    var voData = null;
    voData = this.dataSet.get(pnIndex, psFieldName);
    if(voData == null) voData = "";

    if(this.isEncodeData) {
      voData = decodeURIComponent(voData);
    }
    
    return String(voData);
  };
  /**
   * 컬럼의 수를 리턴
   * @return 컬럼의 수
   * @type Number
   */
  this.getColCnt = function() {
    return this.dataSet.getColCnt();
  };
  /**
   * 주어진 컬럼 인덱스에 해당하는 컬럼 명을 반환하는 메소드
   * @return 주어진 컬럼 인덱스에 해당하는 컬럼 명
   * @param {Number} pnIndex 컬럼 인덱스
   * @type String
   */
  this.getColName = function(pnIndex) {
    return this.dataSet.getColName(pnIndex);
  };
  /**
   * DataSet의 CRUD Node의 속성을 리턴한다.
   * @param {String} psAttrName 해당 속성 명
   * @return 해당 속성명에 속성값을 리턴한다.
   * @type String
   */
  this.getCRUDAttr = function(psAttrName) {
    return this.dataSet.getCRUDAttr(psAttrName);
  };
  /**
   * index 값을 얻는다
   * @return index값 리턴
   * @type Number
   */
  this.getIndex = function() {
    return this.dataSet.getIndex();
  };
  /**
   * Row에 설정한 특정 속성을 가져온다.
   * @param {Number} pnIndex 조회할 Row 번호
   * @param {String} psAttrName
   * @return 속성값
   * @type String
   */
  this.getRowAttr = function(pnIndex, psAttrName) {
    return this.dataSet.getRowAttr(pnIndex, psAttrName);
  };
  /**
   * Row 갯수를 얻는다
   * @return Row Count 값
   * @type Number
   */
  this.getRowCnt = function() {
    return this.dataSet.getRowCnt();
  };
  /**
   * DataSet에 설정한 Sort 정보를 Node Path 별로 질의하여 결과를 리턴한다.
   * @param {String} psRef
   * @return 질의한 소트 정보
   * @type String
   */
  this.getSortItem = function(psRef) {
    return this.dataSet.getSortItem(psRef);
  };
  /**
   * DataSet에 설정한 Sort Item의 Column 정보를 리턴한다.<br/>
   * 여러개의 Column 정보가 있을 경우 "," 딜리미터를 이용하여 분리하여 리턴
   * @return Sort Item에 존재하는 Column 명
   * @type String
   */
  this.getSortItemColumNames = function() {
	  return this.dataSet.getSortItemColumNames();
  };
  /**
   * crud type을 얻는다
   * @param {Number} pnIndex 조회대상 index
   * @return CrudType Number
   * @type Number
   */
  this.getStatus = function(pnIndex) {
    return this.dataSet.getStatus(pnIndex);
  };
  /**
   * 모든 Row 상태 중 입력한 상태를 가지고 있는 Row에 index 값을 구분자로 연결하여 리턴한다.
   * @param {Number} pnType 조회대상 CRUDTYPE (eXria.data.CrudType)
   * @param {String} psDelimeter 연결할 구분자, 생략할 경우 ',' 기본 설정
   * @return 입력 상태를 가진 Row의 index값
   * @type String 
   */
  this.getStatusIndex = function(pnType, psDelimeter) {
    return String(this.dataSet.getStatusIndex(pnType, psDelimeter));
  };
  /**
   * 주어진 index에 새로운 row를 insert 한다
   * @param {Number} pnIndex Insert 대상 Index
   * @param {Boolean} pbAfter pnIndex 뒤에 추가 유무
   * @return insert 후 row 갯수
   * @type Number
   */
  this.insertRow = function(pnIndex, pbAfter) {
    if(!(pbAfter === true)) pbAfter = false;
    return this.dataSet.insertRow(pnIndex, pbAfter);
  };
  /**
   * DataSet을 Rebuild 한다.
   * @param {Boolean} pbAdd Add 유무 설정
   * @return Row Count
   * @type Number
   */
  this.rebuild = function(pbAdd) {
	if(pbAdd == null) pbAdd = false;
    return this.dataSet.rebuild(pbAdd);
  };
  /**
   * primary key 정보를 삭제한다.
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName 삭제할 primary key 값
   * @return void
   * @type void
   */
  this.removePrimaryKey = function(psTableName, psName, psSourceName) {
    this.dataSet.removePrimaryKey(psTableName, psName, psSourceName);
  };
  /**
   * column 정보를 remove 한다
   * @param {String} psTableName 대상 table name
   * @param {String} psName 대상 col name
   * @param {String} psSourceName remove 할 값
   * @return void
   * @type void
   */
  this.removeUpdateColumn = function(psTableName, psName, psSourceName) {
    this.dataSet.removeUpdateColumn(psTableName, psName, psSourceName);
  };
  /**
   * instance를 reset 한다
   * @param {Boolean} pbResetInstance 
   * @return void
   * @type void
   */
  this.reset = function(pbResetInstance) {
    if(!(pbResetInstance === true)) pbResetInstance = false;
    this.dataSet.reset(pbResetInstance);
  };
  /**
   * 원본값으로 restore 한다
   * @param {Boolean} pbAll all 유무
   * @return void
   * @type void
   */
  this.restoreOriginVal = function(pbAll) {
    this.dataSet.restoreOriginVal(pbAll);
  };
  /**
   * 주어진 row의 fieldname에 value를 설정한다
   * @param {Number} pnIndex row index
   * @param {String} psFiledName field name
   * @param {String} psValue 설정할 값
   * @return 성공 : 1, 실패 : 0
   * @type Number
   */
  this.set = function(pnIndex, psFieldName, psValue) {
    var voMap = this.skippedStatusCheckList;
    if(voMap.get(psFieldName) == null) {
      return this.dataSet.set(pnIndex, psFieldName, psValue);
    } else {
      return this.dataSet.simpleSet(pnIndex, psFieldName, psValue);
	}
  };
  /**
   * Data 동기화 설정을 한다
   * @param {Boolean} pbSync 동기화 여부 설정
   * @return void
   * @type void
   */
  this.setDataSync = function(pbSync) {
    this.dataSet.setDataSync(pbSync);
  };
  /**
   * index를 설정한다
   * @param {Number} pnIndex 설정할 index 값
   * @return void
   * @type void
   */
  this.setIndex = function(pnIndex) {
    this.dataSet.setIndex(pnIndex);
  };
  /**
   * table에 prefix를 설정한다
   * @param {String} psTableName 설정 대상
   * @param {String} psPrefix 설정할 값
   * @return void
   * @type void
   */
  this.setPrefix = function(psTableName, psPrefix) {
    this.dataSet.setPrefix(psTableName, psPrefix);
  };
  /**
   * 해당 Row에 속성을 설정한다
   * @param {Number} pnIndex Row Number
   * @param {String} psAttrName 속성 명
   * @param {String} psAttrVal 속성 값
   * @return void
   * @type void
   */
  this.setRowAttr = function(pnIndex, psAttrName, psAttrVal) {
    this.dataSet.setRowAttr(pnIndex, psAttrName, psAttrVal);
  };
  /**
   * sort item을 설정한다
   * @param {String} psNodeName 대상 Node 설정
   * @param {Number} pnType 1 : text, 0 : not text
   * @param {Boolean} pbAscending true : 오름차순, false : 내림차순
   * @return void
   * @type void
   */
  this.setSortItem = function(psNodeName, pnType, pbAscending) {
    this.dataSet.setSortItem(psNodeName, pnType, pbAscending);
  };
  /**
   * 원하는 index에 CRUD type을 설정한다
   * @param {Number} 설정할 index
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatus = function(pnIndex, pnType) {
    this.dataSet.setStatus(pnIndex, pnType);
  };
  /**
   * CRUD type을 설정한다
   * @param {Number} pnType crud type (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusAll = function(pnType) {
    this.dataSet.setStatusAll(pnType);
  };
  /**
   * 범위로 입력한 Row에 CRUD Type으로 설정한다.
   * @param {Number} pnStart 시작 Row 번호
   * @param {Number} pnEnd 종료 Row 번호
   * @param {Number} pnType CRUDTYPE (eXria.data.CrudType)
   * @return void
   * @type void
   */
  this.setStatusRange = function(pnStart, pnEnd, pnType) {
    this.dataSet.setStatusRange(pnStart, pnEnd, pnType);
  };
  /**
   * set은 값을 변경 하면서 동시에 그 Row에 상태값을 수정된 상태로 변경 하지만
   * 이 메서드는 status를 변경하지 않고 단지 value만을 변경 한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName Field Name
   * @param {String} psValue 설정할 값
   * @return 성공하면 1, 실패하면 0
   * @type Number 
   */
  this.simpleSet = function(pnIndex, psFieldName, psValue) {
    return this.dataSet.simpleSet(pnIndex, psFieldName, psValue);
  };
  /**
   * sort를 수행한다
   * @return void
   * @type void
   */
  this.sort = function() {
    this.dataSet.sort();
  };
  /**
   * 현재 DataSet에 설정 되어 있는 PrimaryKey들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명. ""일 경우 모든 테이블의 primary key를 반환
   * @type String
   * @return Primary Key 값들
   */
  this.getPrimaryKeys = function(psTableName) {
    return this.dataSet.getPrimaryKeys(psTableName);
  };
  /**
   * 현재 DataSet에 설정 되어 있는 update column들을 "," 구분자로 하여 문자열로 리턴한다.
   * @param {String} psTableName AUTOCRUD request 테이블 명.
   * @type String
   * @return 현재 DataSet에서 입력한 table에 설정 되어 있는 UpdateColumn들을 "," 구분자로 하여 문자열로 리턴한다.
   */
  this.getUpdateCols = function(psTableName) {
    return this.dataSet.getUpdateCols(psTableName);
  };
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블명들을 "," 구분자로 하여 문자열로 리턴한다.
   * @type String
   * @return  DataSet에 등록 되어져 있는 AutoCRUD처리 테이블들의 이름을 리턴한다. 복수개일 경우 "," 구분자로 구분하여 리턴한다. 
   */
  this.getCRUDTableNames = function() {
    return this.dataSet.getCRUDTableNames();
  };
  /**
   * DataSet에서 삭제된 로우의 전체 count를 리턴한다.
   * @type Number
   * @return delete된 row의 전체 수.
   */
  this.getDelTableRowCnt = function() {
    return this.dataSet.getDelTableRowCnt();
  };
  /**
   * DataSet에서 삭제된 로우 중 해당 인덱스와 컬럼명의 값을 리턴한다.
   * @param {Number} pnIdx Row Index
   * @param {String} psFieldName 컬럼 명
   * @return index 조건으로 검색된 삭제 row의 해당 컬럼의 값.
   * @type String
   */
  this.getDelTableValue = function(pnIdx, psFieldName) {
    return this.dataSet.getDelTableValue(pnIdx, psFieldName);
  };
  /**
   * 현재 DataSet에 등록된 AUTOCRUD request 테이블을 등록하는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return void
   * @type void
   */
  this.addCRUDTable = function(psTableName) {
    return this.dataSet.addCRUDTable(psTableName);
  };
  /**
   * DataSet에 CRUD 테이블에서 해당 테이블 명을 가지고 있는 테이블을 삭제한다.
   * @param {String} psTableName 삭제할 테이블 명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeCRUDTable = function(psTableName) {
    return this.dataSet.removeCRUDTable(psTableName);
  };
  /**
   * 현재 DataSet에 등록된 request 테이블의 prefix를 얻어오는 메소드.
   * @param {String} psTableName AUTOCRUD request 테이블 명
   * @return 첫 인자로 입력한 아이디를 가지는 테이블의 Prefix 값을 문자열로 리턴하여 준다.
   * @type String
   */
  this.getPrefix = function(psTableName) {
    return this.dataSet.getPrefix(psTableName);
  };
  /**
   * submission에 추가할 수 있는 CRUD 문자열 정보를 반환해주는 메소드.
   * @param {Boolean} pbGetUnchanged Unchanged Status의 row데이타 정보도 가져올지 여부
   * @type String
   * @return submission에 추가할 수 있는 CRUD 문자열 정보를 반환
   */
  this.getAutoCRUDString = function(pbGetUnchanged) {
    if(pbGetUnchanged) return this.dataSet.getAutoCRUDString(1);
    else return this.dataSet.getAutoCRUDString();
  };
  /**
   * 해당 Row에서 필드명과 일치하는 곳에 수정 바로 이전 값을 리턴한다.
   * @param {Number} pnIndex row index
   * @param {String} psFieldName field name
   * @type String
   * @return 수정되기 이전 값을 리턴한다. 이 기능을 쓰기 위해서는 Keep the Original Data 속성이 설정 되어 있어야 한다. 
   */
  this.getOrigin = function(pnIndex, psFieldName) {
    var voOriginData = null;
    voOriginData = this.dataSet.getOrigin(pnIndex, psFieldName);
    if(voOriginData == null) voOriginData = "";

    if(this.isEncodeData) {
      voOriginData = decodeURIComponent(voOriginData);
    }
    
    return String(voOriginData);
  };
  /**
   * DataSet과 원본 데이터와의 Sync 상태를 리턴한다.
   * @return Sync 상태시 True 리턴
   * @type Boolean
   */
  this.isDataSync = function() {
    return this.dataSet.isDataSync();
  };
  /**
   * DataSet의 Keep Original Value 상태 리턴
   * @return Keep 상태시 True 리턴
   * @type Boolean
   */
  this.isKeepOriginalValue = function() {
    return this.dataSet.isKeepOriginalValue();
  };
  /**
   * CRUD에 관계된 데이타셋 속성 값을 설정하기 위한 메소드.
   * - submission에서 데이타셋으로 부터 unchanged status의 row정보를 하져올 때 setCRUDAttr("alltype", "true")를 호출함.
   *   해제시에는 setCRUDAttr("alltype", "false")를 호출함.
   * @param {String} psName 속성명
   * @param {String} psValue 속성값
   * @return void
   * @type void
   */
  this.setCRUDAttr = function(psName, psValue) {
    this.dataSet.setCRUDAttr(psName, psValue);
  };
  /**
   * 현재 DataSet을 초기화 시킨다.
   * @type void
   * @return void
   */
  this.refresh = function() {
    if(this.model) this.dataSet = this.model.plugin.getDataSet(this.id);
  };
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 추가한다.
   * @param {Array} paCol 추가할 컬럼 Array
   * @type void
   * @return void
   */
  this.addSkipSCList = function(paCol) {
    var voMap = this.skippedStatusCheckList;
    for(var i = paCol.length - 1; i >= 0; i--) {
      voMap.put(paCol[i], "");
    }
  };
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트 중 파라미터로 넘어온 컬럼들을 삭제한다.
   * @param {Array} paCol 삭제할 컬럼 Array
   * @type void
   * @return void
   */
  this.removeSkipSCList = function(paCol) {
  	var voMap = this.skippedStatusCheckList;
  	for(var i = paCol.length - 1; i >= 0; i--) {
  	  voMap.remove(paCol[i]);
  	}
  };
  /**
   * 데이타셋 status관리를 하지 않을 컬럼 리스트를 전부 삭제한다.
   * @type void
   * @return void
   */
  this.clearSkipSCList = function() {
    this.skippedStatusCheckList.clear();
  };
  /**
   * DataSet에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {Number} pnIndex 컬럼을 삽입시킬 위치 값
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.addColumn = function(pnIndex, psColName) {
    if(pnIndex == -1) return this.dataSet.addColumn(psColName)
    return this.dataSet.addColumn(pnIndex, psColName);
  };
  /**
   * DataSet의 마지막에 새로운 Column을 추가한다.
   * Instance와 Sync 되어 있을 시 Instance node의 구조도 자동으로 변경 되어진다.
   * @param {String} psColName 새로 생성 될 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.appendColumn = function(psColName) {
    return this.dataSet.addColumn(psColName);
  };
  /**
   * DataSet에 해당 컬럼명을 가지고 있는 컬럼을 삭제한다.
   * @param {String} psColName 삭제할 컬럼명
   * @return 성공시 0을 리턴하며 그 외에 값은 내부 에러코드
   * @type Number
   */
  this.removeColumn = function(psColName) {
    return this.dataSet.removeColumn(psColName);
  };
  /**
   * 요청된 범위의 Plugin ExriaNode 객체들을 배열에 담아 반환하는 메소드
   * @param {Number} pnStart 시작 행 인덱스(1 base)
   * @param {Number} pnStart 마지막 행 인덱스(1 base)
   * @return 요청된 범위의 Plugin ExriaNode 객체를 담은 배열
   * @type Array(Object)
   */
  this.getRowDataList = function(pnStart, pnEnd) {
    if(!pnStart || pnStart < 1) pnStart = 1;
    if(!pnEnd || pnEnd < 1) pnEnd = 0;
    return this.dataSet.getRowDataList(pnStart, pnEnd);
  };
  /**
   * 요청된 범위의 Plugin ExriaNode 객체들을 javascript에서 배열화할 수 있는 문자열을 반화하는 메소드
   * @param {Number} pnStart 시작 행 인덱스(1 base)
   * @param {Number} pnStart 마지막 행 인덱스(1 base)
   * @return 요청된 범위의 Plugin ExriaNode 객체를 담은 배열
   * @type Array(Object)
   */
  this.getRowDataStr = function(pnStart, pnEnd) {
    if(!pnStart || pnStart < 1) pnStart = 1;
    if(!pnEnd || pnEnd < 1) pnEnd = 0;
    return String(this.dataSet.getRowDataStr(pnStart, pnEnd));
  };
  /**
   * dataset 모든 row의 특정 속성 값을 배열에 담아 반환해주는 메소드
   * @param {String} psAttrName 검색 요청 속성명
   * @return 모든 row의 특정 속성 값을 담은 배열
   */
  this.getRowsAttr = function(psAttrName) {
    var voList = this.dataSet.getRowsAttr(psAttrName);
    return voList.toArray();
  };
  /**
   * dataset 모든 row의 특정 속성을 일괄 설정하기 위한 메소드
   * @param {String} psAttrName 값 설정 대상 속성명
   * @param {String} psAttrValue 일괄 설정 속성 값
   */
  this.setRowsAttr = function(psAttrName, psAttrValue) {
    return this.dataSet.setRowsAttr(psAttrName, psAttrValue);
  };
  /**
   * dataset의 Source Type을 리턴한다.
   * @return dataset의 Source Type
   * @type {Number}
   */
  this.getSrcType = function() {
    return this.dataSet.getSrcType();
  };
  /**
   * dataset의 Connection Info를 리턴한다.
   * @return dataset의 Connection Info
   * @type {String}
   */
  this.getConnectionInfo = function() {
    return this.dataSet.getConnectionInfo();
  };
  /**
   * dataset의 Source Query를 리턴한다.
   * @return dataset의 Source Query
   * @type {String}
   */
  this.getSourceQuery = function() {
    return this.dataSet.getSourceQuery();
  };
  
    /**
   * dataset originData 수정
   * @param {Number} pnIdx row index
   * @param {Number} pnColIdx column index
   * @param {Number} psVal value
   * @return void
   * @type void
   */
  this.setOrigin = function(pnIdx, pnColIdx, psVal) {
    this.dataSet.setOrigin(pnIdx, pnColIdx, psVal);
  };
  
  this.getHeader = function() {
    this.dataSet.getHeader();
  };
};
/**
 * @fileoverview
 * Document Node Object Class
 */
/**
 * plugin.NativeNode
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.data.Node} poNode Node Object
 * @constructor
 * @base eXria.data.Node
 */ 
eXria.data.plugin.NativeNode = function(poNode) {
  if (poNode == null) {
    throw new Error("Node is null.");
  }
  /**
   * inherit
   */
  eXria.data.Node.call(this, poNode);
  /**
   * eXria.data.Node
   * @type eXria.data.Node
   * @private
   */
  this.node = poNode;
  /**
   * XMLNode Tag Name
   * @type String
   * @private
   */
  this.name = this.node.nodeName;
  /**
   * 파라미터로 넘어온 Node를 자식 Node의 마지막에 추가한다.
   * @param {eXria.data.Node} poNode 추가할 Node Object
   * @type void
   * @return void
   */
  this.appendChild = function(poNode) {
	if(!poNode) return;
	this.node.appendChild(poNode.node);
  };
  /**
   * 현재 Node와 동일한 Node를 복사하여 리턴한다.
   * @param {Boolean} pbDeep deep copy 유무를 지정한다. (true | false)
   * @return 복사된 Node Object
   * @type eXria.data.Node
   */
  this.cloneNode = function(pbDeep) {
	if(pbDeep != true) pbDeep = false;
	return new eXria.data.plugin.NativeNode(this.node.cloneNode(pbDeep));
  };
  /**
   * 현재 Node의 자식 Node들을 NodeList 형식으로 리턴한다.
   * @type eXria.data.NodeList
   * @return 생성된 자식 Node List
   */
  this.getChildNodes = function() {
	var voChildNodes = this.node.childNodes;
	if(!voChildNodes) { return null; }
	return new eXria.data.plugin.NativeNodeList(this.node.childNodes);
  };
  /**
   * 현재 Node의 첫번째 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 첫번째 자식 Node
   */
  this.getFirstChild = function() {
	var voFirstChild = this.node.firstChild;
	if(!voFirstChild) { return null; }
	
	return new eXria.data.plugin.NativeNode(voFirstChild);
  };
  /**
   * 현재 Node의 마지막 자식 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 마지막 자식 Node
   */
  this.getLastChild = function() {
	var voLastChild = this.node.lastChild;
	if(!voLastChild) { return null; }
	
	return new eXria.data.plugin.NativeNode(voLastChild);
  };
  /**
   * 현재 Node의 바로 다음 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 다음 Node
   */
  this.getNextSibling = function() {
	var voNextNode = this.node.nextSibling;
	if(!voNextNode) { return null; }
	
	return new eXria.data.plugin.NativeNode(voNextNode);
  };
  /**
   * 현재 Node의 이름을 리턴한다.
   * @type String
   * @return 현재 Node의 이름
   */
  this.getNodeName = function() {
    return this.name;
  };
  /**
   * 현재 Node의 value를 리턴한다.
   * @type String
   * @return 현재 Node의 Value
   */
  this.getNodeValue = function() {
	var vsValue = null;
	var vnNodeType = this.node.nodeType;
	if(vnNodeType == 1) {
	  var voChildNode = this.node.firstChild;
	  if(!voChildNode) {
		vsValue = "";
	  } else {
	    vsValue = this.node.firstChild.nodeValue;
	  }
	} else if(vnNodeType == 3 || vnNodeType == 4) {
	  vsValue = this.node.nodeValue;
	} else {
	  vsValue = null;
	}
	return vsValue;
  };
  /**
   * 현재 Node의 부모 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 부모 Node
   */
  this.getParentNode = function() {
	var voParentNode = this.node.parentNode;
	if(!voParentNode) { return null; }
    return new eXria.data.plugin.NativeNode(this.node.parentNode);
  };
  /**
   * 현재 Node의 바로 전 Node를 리턴한다.
   * @type eXria.data.Node
   * @return 현재 Node의 바로 전 Node
   */
  this.getPreviousSibling = function() {
	var voPNode = this.node.previousSibling;
	if(!voPNode) { return null; }
	
    return new eXria.data.plugin.NativeNode(voPNode);
  };
  /**
   * Element를 생성하여 리턴한다.
   * @param {String} psTagName 생성할 Element의 Tag Name
   * @param {String} psValue 생성할 Element의 Value [ null을 넘길 경우 TextNode가 생성되지 않은 Element 리턴 ]
   * @type {eXria.data.Node}
   * @return 생성된 Element
   */
  this.createElement = function(psTagName, psValue) {
	var voNode = null;
	try {
	  var voOwnerDocument = this.node.ownerDocument;
	  voNode = new eXria.data.plugin.NativeNode(voOwnerDocument.createElement(psTagName));
	  if(psValue != null) {
		voNode.appendChild(new eXria.data.plugin.NativeNode(voOwnerDocument.createTextNode(psValue)));
	  }
	} catch(e) { voNode = null; }
	return voNode;
  };
  /**
   * TextNode를 생성하여 리턴
   * @param {String} psValue 생성할 Node의 Value값
   * @type {eXria.data.Node}
   * @return 생성된 TextNode
   */
  this.createTextNode = function(psValue) {
	var voNewNode = null;
	try {
	  voNewNode = this.node.ownerDocument.createTextNode(psValue);
	} catch(e) { return null; }
	return new eXria.data.plugin.NativeNode(voNewNode);
  };
  /**
   * 현재 Node의 자식 Node 유무를 리턴한다.
   * @type Boolean
   * @return 자식 Node의 존재 유무
   */
  this.hasChildNodes = function() {
    return this.node.hasChildNodes();
  };
  /**
   * 현재 Node의 자식 Node 중 파라미터로 넘어온 Node와 일치하는 Node를 삭제한다.
   * @param {eXria.data.Node} poNode 삭제할 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.removeChild = function(poNode) {
	if(!poNode) return;
	var voRmChild = this.node.removeChild(poNode.node);
	if(voRmChild) {
	  return poNode;
	} else {
	  return null;
	}
  };
  /**
   * 현재 Node의 Value 파라미터로 넘어온 데이터로 변경한다.
   * @param {String} psValue 변경할 데이터
   * @type void
   * @return void
   */
  this.setNodeValue = function(psValue) {
	try {
	  psValue = (psValue ? psValue : "");
      var voValue = this.node.firstChild;
      if(voValue != null) {
		voValue.nodeValue = psValue;
	  } else {
		this.node.appendChild(this.node.ownerDocument.createTextNode(psValue));
	  }
	} catch(e) { return null; }
  };
  /**
   * 두번째 파라미터로 넘어온 Node와 동일한 Node가 있을 경우 해당 위치에 첫번째 파라미터로 넘어온 Node를 셋팅.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poOldNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.replaceChild = function(poNewNode, poOldNode) {
	var voRepChild = this.node.replaceChild(poNewNode.node, poOldNode.node);
	if(voRepChild) {
	  return poOldNode;
	} else {
	  return null;
	}
  };
  /**
   * 두번째 파라미터로 넘어온 Node의 앞에 첫번째로 넘어온 파라미터 Node를 추가한다.
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poRefNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return insert 되기 전 Node
   */
  this.insertBefore = function(poNewNode, poRefNode) {
	var voOldNode = this.node.insertBefore(poNewNode.node, poRefNode.node);
	if(voOldNode) {
	  return poRefNode;
	} else {
	  return null;
	}
  };
  /**
   * node type을 리턴한다.
   * @type Number
   * @return 해당 Node의 node Type
   */
  this.getNodeType = function() {
	return this.node.nodeType;
  };
  /**
   * 현재 클래스의 이름을 반환 한다.
   * @type String
   * @return 현재 클래스 이름
   */
  this.toString = function() {
	return "eXria.data.plugin.NativeNode";
  };
  /**
   * 파라미터로 넘어온 Node와 현재 Node가 같은 Node인지 비교한다.
   * @param {eXria.data.Node} poNode 비교할 Node
   * @return 두개의 Node가 같은 Node인지 유무
   * @type Boolean
   */
  this.equal = function(poNode) {
	return this.node == poNode.node;
  };
  /**
   * C현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return Node Object
   */
  this.getElementByTagName = function(psTagName) {
    var voNodes = this.getElementsByTagName(psTagName);
    if(voNodes.getLength() == 0) {
      return null;
    } else {
      return voNodes.item(0);
    }
  };
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.NodeList
   * @return NodeList Object
   */
  this.getElementsByTagName = function(psTagName) {
	var voNodes = this.node.getElementsByTagName(psTagName);
	if(!voNodes) return null;
	return new eXria.data.plugin.NativeNodeList(voNodes);
  };
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return NodeList Object
   */
  this.getElementByTagNameFromChildNodes = function(psTagName) {
    var voNodes = this.getChildNodes();
    var voNode = null;
    var voTmpNode = null;
    for(var i = 0, vnLen = voNodes.getLength() ; i < vnLen ; i++) {
      voNode = voNodes.item(i);
      if(voNode.getNodeName() == psTagName) {
        voTmpNode = voNode;
        break;
      }
    }
    return voTmpNode;
  }
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Collection
   * @return eXria.data.Collection Object
   */
  this.getElementsByTagNameFromChildNodes = function(psTagName) {
   var voNodes = this.node.childNodes;
   var voNodeArr = new eXria.data.ArrayCollection();

   for(var i = 0, vnLen = voNodes.length ; i < vnLen ; i++) {
     var voNode = voNodes.item(i);
     if(voNode.nodeName == psTagName) {
       voNodeArr.add(new eXria.data.plugin.NativeNode(voNode));
     }
   }
   return voNodeArr;
  };
  /**
   * 현재 Node의 XML 스트링을 리턴.
   * @type String
   * @return XML String
   */
  this.getXML = function() {
    if (window.page.metadata.browser.ie > 0) {
      return this.node.xml;
    } else {
      var vSerializer = new XMLSerializer();
      return vSerializer.serializeToString(this.node);
    }
  };
};

/**
 * @fileoverview
 * PLUGIN Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 */
/**
 * PLUGIN Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 * @author Choe, hyeon jong.
 * @version 1.0
 * @param {NodeList} PLUGIN NodeList Object
 * @constructor
 * @base eXria.data.NodeList
 */ 
eXria.data.plugin.NativeNodeList = function(poResult) {
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);
  /**
   * PLUGINNodeList
   * @type PLUGINNodeList
   * @private
   */
  this.nodeList = poResult;
  /**
   * return item cound in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
//    var voNodeList = this.nodeList;
//    var vnLength = 0;
//	var voTmp = null;
//	var vnLen = (voNodeList.length != null) ? voNodeList.length : voNodeList.getLength();
//	for(var i = 0 ; i < vnLen ; i++) {
//	  voTmp = voNodeList.item(i)
//	  if(voTmp.nodeType == 1) { vnLength++; } 
//	}
//    return vnLength;
	return this.nodeList.length;
  };
  /**
   * return NodeItem of parameter index
   * @param {Number} pnIdx
   * @return Node
   * @type Node
   */
  this.item = function(pnIdx) {
//	var voNode = null;
//	var vnLen = (this.nodeList.length != null) ? this.nodeList.length : this.nodeList.getLength();
//	for(var i = 0, vnIdx = 0 ; i < vnLen ; i++) {
//	  voNode = this.nodeList.item(i);
//	  if(voNode.nodeType == 1 && vnIdx == pnIdx) { 
//		break;
//	  } else {
//		if(voNode.nodeType == 1) { vnIdx++; } 
//	  }
//	}
//	if(voNode == null) return null;
	var voNode = this.nodeList.item(pnIdx);
    if(voNode == null) return null;
	else return new eXria.data.plugin.NativeNode(voNode);
  };
};
/**
 * @fileoverview
 * Document Node Object Class
 */
/**
 * plugin.JreNode
 * 
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.data.Node} poNode Node Object
 * @constructor
 * @base eXria.data.Node
 */
eXria.data.plugin.JreNode = function(poNode) {
  if (poNode == null) {
    throw new Error("Node is null.");
  }
  /**
   * inherit
   */
  eXria.data.Node.call(this, poNode);
  /**
   * eXria.data.Node
   * 
   * @type eXria.data.Node
   * @private
   */
  this.node = poNode;
  /**
   * XMLNode Tag Name
   * 
   * @type String
   * @private
   */
  this.name = this.node.getNodeName();
  /**
   * 파라미터로 넘어온 Node를 자식 Node의 마지막에 추가한다.
   * @param {eXria.data.Node} poNode 추가할 Node Object
   * @type void
   * @return void
   */
  this.appendChild = function(poNode) {
    if (!poNode)
      return null;
    this.node.appendChild(poNode.node);
  };
  /**
   * 현재 Node와 동일한 Node를 복사하여 리턴한다.
   * 
   * @param {Boolean} pbDeep deep copy 유무를 지정한다. (true | false)
   * @return 복사된 Node Object
   * @type eXria.data.Node
   */
  this.cloneNode = function(pbDeep) {
    if (pbDeep != true)
      pbDeep = false;
    return new eXria.data.plugin.JreNode(this.node.cloneNode(pbDeep));
  };
  /**
   * 현재 Node의 자식 Node들을 NodeList 형식으로 리턴한다.
   * 
   * @type eXria.data.NodeList
   * @return 생성된 자식 Node List
   */
  this.getChildNodes = function() {
    var voChildNodes = this.node.getChildNodes();
    if (!voChildNodes) {
      return null;
    }
    return new eXria.data.plugin.JreNodeList(voChildNodes);
  };
  /**
   * 현재 Node의 첫번째 자식 Node를 리턴한다.
   * 
   * @type eXria.data.Node
   * @return 현재 Node의 첫번째 자식 Node
   */
  this.getFirstChild = function() {
    var voFirstChild = this.node.getFirstChild();
    if (!voFirstChild) {
      return null;
    }

    return new eXria.data.plugin.JreNode(voFirstChild);
  };
  /**
   * 현재 Node의 마지막 자식 Node를 리턴한다.
   * 
   * @type eXria.data.Node
   * @return 현재 Node의 마지막 자식 Node
   */
  this.getLastChild = function() {
    var voLastChild = this.node.getLastChild();
    if (!voLastChild) {
      return null;
    }

    return new eXria.data.plugin.JreNode(voLastChild);
  };
  /**
   * 현재 Node의 바로 다음 Node를 리턴한다.
   * 
   * @type eXria.data.Node
   * @return 현재 Node의 다음 Node
   */
  this.getNextSibling = function() {
    var voNextNode = this.node.getNextSibling();
    if (!voNextNode) {
      return null;
    }

    return new eXria.data.plugin.JreNode(voNextNode);
  };
  /**
   * 현재 Node의 이름을 리턴한다.
   * 
   * @type String
   * @return 현재 Node의 이름
   */
  this.getNodeName = function() {
    return this.name;
  };
  /**
   * 현재 Node의 value를 리턴한다.
   * 
   * @type String
   * @return 현재 Node의 Value
   */
  this.getNodeValue = function() {
    var vsValue = this.node.getNodeValue()
    vsValue = decodeURIComponent(vsValue);
    
    if(vsValue == "null") return null;
    
    return vsValue;
  };
  /**
   * 현재 Node의 부모 Node를 리턴한다.
   * 
   * @type eXria.data.Node
   * @return 현재 Node의 부모 Node
   */
  this.getParentNode = function() {
    var voParentNode = this.node.getParentNode();
    if (!voParentNode) {
      return null;
    }
    return new eXria.data.plugin.JreNode(voParentNode);
  };
  /**
   * 현재 Node의 바로 전 Node를 리턴한다.
   * 
   * @type eXria.data.Node
   * @return 현재 Node의 바로 전 Node
   */
  this.getPreviousSibling = function() {
    var voPNode = this.node.getPreviousSibling;
    if (!voPNode) {
      return null;
    }

    return new eXria.data.plugin.JreNode(voPNode);
  };
  /**
   * Element를 생성하여 리턴한다.
   * 
   * @param {String} psTagName 생성할 Element의 Tag Name
   * @param {String} psValue 생성할 Element의 Value [ null을 넘길 경우 TextNode가 생성되지 않은 Element 리턴 ]
   * @type {eXria.data.Node}
   * @return 생성된 Element
   */
  this.createElement = function(psTagName, psValue) {
    return new eXria.data.plugin.JreNode(this.node.createElement(psTagName, psValue));
  };
  /**
   * TextNode를 생성하여 리턴
   * 
   * @param {String} psValue 생성할 Node의 Value값
   * @type {eXria.data.Node}
   * @return 생성된 TextNode
   */
  this.createTextNode = function(psValue) {
    return new eXria.data.plugin.JreNode(this.node.createTextNode(psValue));
  };
  /**
   * 현재 Node의 자식 Node 유무를 리턴한다.
   * 
   * @type Boolean
   * @return 자식 Node의 존재 유무
   */
  this.hasChildNodes = function() {
    return this.node.hasChildNodes();
  };
  /**
   * 현재 Node의 자식 Node 중 파라미터로 넘어온 Node와 일치하는 Node를 삭제한다.
   * 
   * @param {eXria.data.Node} poNode 삭제할 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.removeChild = function(poNode) {
    if (!poNode)
      return null;
    var voRmChild = this.node.removeChild(poNode.node);
    if (voRmChild) {
      return poNode;
    } else {
      return null;
    }
  };
  /**
   * 현재 Node의 Value 파라미터로 넘어온 데이터로 변경한다.
   * 
   * @param {String} psValue 변경할 데이터
   * @type void
   * @return void
   */
  this.setNodeValue = function(psValue) {
    this.node.setNodeValue(psValue);
  };
  /**
   * 두번째 파라미터로 넘어온 Node와 동일한 Node가 있을 경우 해당 위치에 첫번째 파라미터로 넘어온 Node를 셋팅.
   * 
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poOldNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return 삭제된 Node
   */
  this.replaceChild = function(poNewNode, poOldNode) {
    var voRepChild = this.node.replaceChild(poNewNode.node, poOldNode.node);
    if (voRepChild) {
      return poOldNode;
    } else {
      return null;
    }
  };
  /**
   * 두번째 파라미터로 넘어온 Node의 앞에 첫번째로 넘어온 파라미터 Node를 추가한다.
   * 
   * @param {eXria.data.Node} poNewNode 추가할 Node
   * @param {eXria.data.Node} poRefNode 덮어 쓸 Node
   * @type eXria.data.Node
   * @return insert 되기 전 Node
   */
  this.insertBefore = function(poNewNode, poRefNode) {
    var voOldNode = this.node.insertBefore(poNewNode.node, poRefNode.node);
    if (voOldNode) {
      return poRefNode;
    } else {
      return null;
    }
  };
  /**
   * node type을 리턴한다.
   * 
   * @type Number
   * @return 해당 Node의 node Type
   */
  this.getNodeType = function() {
    return this.node.getNodeType();
  };
  /**
   * 현재 클래스의 이름을 반환 한다.
   * 
   * @type String
   * @return 현재 클래스 이름
   */
  this.toString = function() {
    return "eXria.data.plugin.JreNode";
  };
  /**
   * 파라미터로 넘어온 Node와 현재 Node가 같은 Node인지 비교한다.
   * 
   * @param {eXria.data.Node} poNode 비교할 Node
   * @return 두개의 Node가 같은 Node인지 유무
   * @type Boolean
   */
  this.equal = function(poNode) {
    return this.node == poNode.node;
  };
  /**
   * C현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 첫번째
   * Element를 리턴한다.
   * 
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return Node Object
   */
  this.getElementByTagName = function(psTagName) {
    var voNode = this.node.getElementByTagName(psTagName);
    if(voNode == null) return null;
    
    return new eXria.data.plugin.JreNode(voNode)
  };
  /**
   * 현재 Node 하위의 모든 ChildNode 중 Depth와 상관 없이 파라미터로 넘어온 Tag Name과 동일한 모든 Element를
   * 리턴한다.
   * 
   * @param {String} psTagName
   * @type eXria.data.NodeList
   * @return NodeList Object
   */
  this.getElementsByTagName = function(psTagName) {
    var voNodes = this.node.getElementsByTagName(psTagName);
    if (!voNodes)
      return null;
    return new eXria.data.plugin.JreNodeList(voNodes);
  };
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 첫번째 Element를 리턴한다.
   * 
   * @param {String} psTagName
   * @type eXria.data.Node
   * @return NodeList Object
   */
  this.getElementByTagNameFromChildNodes = function(psTagName) {
    var voNodes = this.node.getElementByTagNameFromChildNodes(psTagName);
    if(voNodes == null) return null;
    
    return new eXria.data.plugin.JreNode(voNodes)
  }
  /**
   * 현재 Node의 ChildNode 중 파라미터로 넘어온 Tag Name과 동일한 모든 Element를 리턴한다.
   * @param {String} psTagName
   * @type eXria.data.Collection
   * @return eXria.data.Collection Object
   */
  this.getElementsByTagNameFromChildNodes = function(psTagName) {
    var voNodes = this.node.getElementsByTagNameFromChildNodes(psTagName);
    var voNodeArr = new eXria.data.ArrayCollection();

    for ( var i = 0, vnLen = voNodes.size(); i < vnLen; i++) {
      var voNode = voNodes.get(i);
      if (voNode.getNodeName() == psTagName) {
        voNodeArr.add(new eXria.data.plugin.JreNode(voNode));
      }
    }
    return voNodeArr;
  };
  /**
   * 현재 Node의 XML 스트링을 리턴.
   * @type String
   * @return XML String
   */
  this.getXML = function() {
    return this.node.getXML();
  };
  
  this.getAttribute = function(vsName) {
    var vsAttr = this.node.getAttribute(vsName);
    vsAttr = decodeURIComponent(vsAttr);
    
    if(vsAttr == "null") return null;
    
    return vsAttr;
  };
  
  this.setAttribute = function(vsName, vsValue) {
    this.node.setAttribute(vsName, vsValue);
  };
  
  this.getUserAttribute = function(vsName) {
    return this.getAttribute(vsName);
  };
  
  this.setUserAttribute = function(vsName, vsValue) {
    this.setAttribute(vsName, vsValue);
  };
};

/**
 * @fileoverview
 * PLUGIN Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 */
/**
 * PLUGIN Mode 사용시 Document내부의 Node를 List로써 관리하는 클래스
 * 
 * @author Choe, hyeon jong.
 * @version 1.0
 * @param {NodeList}
 *          PLUGIN NodeList Object
 * @constructor
 * @base eXria.data.NodeList
 */
eXria.data.plugin.JreNodeList = function(poResult) {
  /**
   * Inherit
   */
  eXria.data.NodeList.call(this);
  /**
   * JreNodeList
   * @type PLUGINNodeList
   * @private
   */
  this.nodeList = poResult;
  /**
   * return item cound in NodeList
   * @return item count number
   * @type Number
   */
  this.getLength = function() {
    return this.nodeList.getLength();
  };
  /**
   * return NodeItem of parameter index
   * @param {Number} pnIdx
   * @return Node
   * @type Node
   */
  this.item = function(pnIdx) {
    var voNode = this.nodeList.item(pnIdx);
    if (voNode == null)
      return null;
    else
      return new eXria.data.plugin.JreNode(voNode);
  };
};
/**
 * @fileoverview
 * eXria.event package
 * @author 김경태
 * @version 2.0
 */

/**
 * eXria.event package
 */
eXria.event = {};

/**
 * @fileoverview
 * abstract Event
 */

/**
 * abstract Event
 * @author 김경태
 * @version 2.0
 * @param {HTMLEvent} e 윈도우 이벤트
 * @constructor
 **/
eXria.event.Event = function(e, poWindow) {
  /**
   * original event
   */
  // window.event를 먼저 기술해야 함. (IE가 e파라미터를 null로 보지 않아서 window.event를 더이상 쓸 수 없게 되는 현상 방지)
  this.e = poWindow ? (poWindow.event || e) : (e || null);

  /**
   * 이벤트 타입(이벤트 종류 식별 문자열).
   * readOnly
   * @type String
   */
  this.type = this.e ? this.e.type : null;

  /**
   * 누른 mouse button이 무엇인지를 나타냄
   * readOnly
   * @type String
   */
  this.mousebutton = this.e ? this.e.button : null;

  /**
   * alt key가 눌려져 있는지 여부.
   * readOnly
   * @type Boolean
   */
  this.altKey = this.e ? this.e.altKey : null;

  /**
   * ctrl key가 눌려져 있는지 여부.
   * readOnly
   * @type Boolean
   */
  this.ctrlKey = this.e ? this.e.ctrlKey : null;

  /**
   * shift key가 눌려져 있는지 여부.
   * readOnly
   * @type Boolean
   */
  this.shiftKey = this.e ? this.e.shiftKey : null;

  /**
   * 키보드에서 눌러진 키의 코드값.
   * readOnly
   * @type Number
   */
  //this.keyCode = (poWindow.event) ? this.e.keyCode : this.e.which;
  //this.keyCode = this.e ? ((poWindow.event) ? this.e.keyCode : this.e.which) : null;
  this.keyCode = this.e ? ((poWindow ? poWindow.event : null) ? this.e.keyCode : this.e.which) : null;
  /**
   * 이벤트 발생 taget 내에서의 마우스 x좌표.
   * readOnly
   * @type Number
   */
  this.clientX = this.e ? this.e.clientX : null;

  /**
   * 이벤트 발생 taget 내에서의 마우스 y좌표.
   * readOnly
   * @type Number
   */
  this.clientY = this.e ? this.e.clientY : null;

  /**
   * 전체 스크린에서의 마우스 x좌표.
   * readOnly
   * @type Number
   */
  this.screenX = this.e ? this.e.screenX : null;

  /**
   * 전체 스크린에서의 마우스 y좌표.
   * readOnly
   * @type Number
   */
  this.screenY = this.e ? this.e.screenY : null;

  /**
   * The element to which the event was originally dispatched.<br>
   * 이벤트 발생 element.
   * readOnly
   * @type HTMLElement
   * @private
   */
  this.target = this.e ? (this.e.srcElement || this.e.target) : null;

  /**
   * For mouse events, this is the element to which the mouse moved.<br>
   * 현재 버블링된 이벤트를 처리하고 있는 element
   * readOnly
   * @type HTMLElement
   * @private
   */
  this.currentTarget = this.e ? (this.e.toElement || this.e.currentTarget) : null;

  /**
   * 이벤트가 발생한 자바스크립트 객체에 대한 참조
   * readOnly
   * @type Unknown
   */
  this.object = null;

  /**
   * 이벤트가 발생한 자바스크립트 객체의 종류 (Control, item)
   * readOnly
   * @type String
   */
  this.objectType = null;

  /**
   * 이벤트가 발생한 자바스크립트 객체를 생성시킨 컨트롤 ID
   * readOnly
   * @type String
   */
  this.baseControlId = null;

  /**
   * 이벤트를 중지.
   */
  this.stopEvent = function() {
    if(this.e == null) return;
    this.stopPropagation();
    this.preventDefault();
  };

  /**
   * 이벤트 전달을 방지.
   */
  this.stopPropagation = function() {
    //      if (this.e.stopPropagation) {    // W3C 모델에서의 이벤트 버블링 방지
    //          this.e.stopPropagation();
    //      } else {                         // IE에서의 이벤트 버블링 방지
    //          this.e.cancelBubble = true;
    //      }
    //
    if(!this.e) return;
    if (this.e.stopImmediatePropagation)
      this.e.stopImmediatePropagation();
    else if (this.e.stopPropagation)
      this.e.stopPropagation();
    else
      this.e.cancelBubble = true;

  };

  /**
   * 이벤트에 대한 기본 동작을 방지
   */
  this.preventDefault = function() {
    //      if(this.e.returnValue){               // IE의 경우
    //        this.e.returnValue = false;
    //      }else if(this.e.preventDefault) {     // W3C 모델의 경우
    //          this.e.preventDefault();
    //      }
    if(this.e == null) return;
    if (this.e.preventDefault) {
      //if(this.e.cancelable) //opera error
      this.e.preventDefault();
    } else
      this.e.returnValue = false;
  };
};

/**
 * @fileoverview
 * abstract EventManager
 **/

/**
 * abstract EventManager
 * @author 김경태
 * @version 2.0
 * @constructor
 */
// TODO : 향후 page 또는 canvas에 붙여서 작동시킨다. 현재는 테스트를 위해서 컨트롤별로 생성하는 구조로 되어 있음
eXria.event.EventManager = function() {

  /**
   * 설정된 이벤트 수신자 정보를 보관
   * @type eXria.data.ArrayMap
   */
  this.events = new eXria.data.ArrayMap();

  /*
   * 실체화 객체(DOM)의 이벤트에 대한 수신자를 연결한다.
   * @param {HTMLElement} poSource 실체화 객체
   * @param {String} psSourceMemberName 이벤트 이름
   * @param {function} poTargetMember 이벤트 수신 함수
   */
  this.addListener = function(poSource, psName, poTargetMember) {
    if (!poTargetMember || !poTargetMember.call) {
      throw new Error("잘못된 함수와 이벤트 연결을 하고자 합니다.");
    } else {
      //if(this.events.get(poSource.id + "." + psName) == null) {
        this.events.put(poSource.id + "." + psName, poTargetMember);
      //} else {
      //  alert(poSource.id + "." + psName + " -> 이 이벤트는 이미 등록되어 있습니다.");
      //}

      /*if(window.attachEvent) {  // TODO : 향후 canvas.page.metadata.browser.ie로 변경할것              // IE의 경우
        poSource.attachEvent(psName,poTargetMember);
      } else {                                                      // IE 이외의 브라우저의 경우
        psName=psName.replace('on','');
        poSource.addEventListener(psName, poTargetMember, false);    // bubble phase의 이벤트 연결
      }*/
      poSource[psName] = poTargetMember;
    }
  };

  /*
   * 실체화 객체(DOM)의 이벤트에 대한 수신자를 해제한다.
   * @param {HTMLElement} poSource 실체화 객체
   * @param {String} psName 이벤트 이름
   * @param {function} poTargetMember 이벤트 수신 함수
   */
  this.removeListener = function(poSource, psName, poTargetMember) {
    if(!poTargetMember || !poTargetMember.call) {
      throw new Error("잘못된 콜백함수와의 이벤트 연결을 해제하고자 합니다.");
    } else {
      this.events.remove(poSource.id + "." + psName);

      /*if(window.detachEvent) { // TODO : 향후 canvas.page.metadata.browser.ie로 변경할것                // IE의 경우
        poSource.detachEvent(psName, poTargetMember);
      } else {                                                        // IE 이외의 브라우저의 경우
        psName=psName.replace('on','');
        poSource.removeEventListener(psName, poTargetMember, false);  // bubble phase의 이벤트 연결
      }*/
      poSource[psName] = null;
    }
  };

  /*
   * 이벤트에 연결된 수신자를 리턴한다.
   */
  this.getListener = function(poSource, psName) {
    return this.events.get(poSource.id + "." + psName);
  };
};
/**
 * @fileoverview
 * FlexEventManager
 **/

/**
 * FlexEventManager
 * @author 김경태
 * @version 1.0
 * @constructor
 */
// TODO : 향후 page 또는 canvas에 붙여서 작동시킨다. 현재는 테스트를 위해서 컨트롤별로 생성하는 구조로 되어 있음
eXria.event.FlexEventManager = function() {

  /*
   * 설정된 이벤트 수신자 정보를 보관
   */
  this.events = new eXria.data.ArrayMap();

  /*
   * 실체화 객체(DOM)의 이벤트에 대한 수신자를 연결한다.
   * @param {HTMLElement} poSource : 실체화 객체
   * @param {string} psSourceMemberName : 이벤트 이름
   * @param {function} poTargetMember : 이벤트 수신 함수
   */
  this.addListener = function(poCtrl, psEventType, poTargetMember) {
    if (!poTargetMember || !poTargetMember.call) {
      throw new Error("잘못된 함수와 이벤트 연결을 하고자 합니다.");
    } else {
      poCtrl.addEventListener(psEventType, poTargetMember);    // bubble phase의 이벤트 연결

      this.events.put(poCtrl.getName() + "." + psEventType, poTargetMember);
    }
  };

  /*
   * 실체화 객체(DOM)의 이벤트에 대한 수신자를 해제한다.
   * @param {HTMLElement} poSource : 실체화 객체
   * @param {string} psName : 이벤트 이름
   * @param {function} poTargetMember : 이벤트 수신 함수
   */
  this.removeListener = function(poCtrl, psEventType, poTargetMember) {
    if(!poTargetMember || !poTargetMember.call) {
      throw new Error("잘못된 콜백함수와의 이벤트 연결을 해제하고자 합니다.");
    } else {
      this.events.remove(poCtrl.getName() + "." + psEventType);

      poSource.removeEventListener(psEventType, poTargetMember);  // bubble phase의 이벤트 연결

    }
  };

  /*
   * 이벤트에 연결된 수신자를 리턴한다.
   */
  this.getListener = function(poCtrl, psEventType) {
    return this.events.get(poCtrl.getName() + "." + psEventType);
  };
};
/**
 * @fileoverview
 * eXria.form package
 */

/**
 * eXria.form package
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */
eXria.form = {};

/**
 * @fileoverview
 * Page 내부의 Canvas 객체에 대한 Interface
 */

/**
 * Page 내부의 Canvas 객체에 대한 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} psId Canvas Id
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 */
eXria.form.Canvas = function(psId, poPage) {
  /**
   * Canvas Id
   * @type String
   */
  this.id = psId;
  /**
   * 현재 Canvas를 포함하는 Page Obejct
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.page = poPage;
  /**
   * canvas에 놓여진 컨트롤들을 저장하고 있는 map
   * @type eXria.data.ArrayMap
   * @see eXria.data.ArrayMap
   */
  this.controls = new eXria.data.ArrayMap();
  /**
   * createControl에 의해 생성된 컨트롤을 id를 키로 하여 저장하는 map
   * @type eXria.data.ArrayMap
   */
  this.ctlMap = new eXria.data.ArrayMap();
/* style */
  /**
   * Canvas width
   * @type Number
   */
  this.width = null;
  /**
   * Canvas height
   * @type Number
   */
  this.height = null;
  /**
   * Canvas background color
   * @type String
   */
  this.backgroundColor = null;
  /**
   * Canvas background image
   * @type String
   */
  this.backgroundImage = null;
  /**
   * Canvas background repeat
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * Canvas background position
   * @type Number
   */
  this.backgroundPosition = null;

/* style */

  /**
   * canvas 초기화
   * @return void
   * @type void
   * @private
   */
  this.init = null;
  /**
   * 페이지 내부의 최상위 div를 리턴
   * @return 페이지 내부의 최상위 div 객체
   * @type Object
   */
  this.getCtrl = null;
  /**
   * 넘어온 속성에 맞춰 control을 생성한다.
   * @param {String} psType type
   * @param {String} psId id
   * @param {Number} pnLeft left
   * @param {Number} pnTop top
   * @param {Number} pnWidth width
   * @param {Number} pnHeight height
   * @type eXria.controls.Control
   * @return eXria.controls.Control
   */
  this.createControl = null;
  /**
   * 파라미터로 넘어온 컨트롤을 canvas에 추가 시킨다.
   * @param {eXria.control.Control} poControl control
   * @return void
   * @type void
   */
  this.appendControl = null;
  /**
   * 넘어온 id와 일치하는 control을 찾아 리턴
   * @param {String} psId control Id
   * @return control Object
   * @type eXria.control.Control
   * @ignore
   */
  this.getControl = function(psId) {
    var voControl = this[psId];
    return voControl ? voControl : null;
  };
  /**
   * 파라미터로 넘어온 ID의 control을 삭제한다.
   * @param {String} psId Control ID
   * @return void
   * @type void
   */
  this.removeControl = null;
  /**
   * canvas에 속한 모든 컨트롤을 해제.
   * @return void
   * @type void
   */
  this.close = null;
};

/**
 * @fileoverview
 * CanvasFactory
 */

/**
 * CanvasFactory
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 * @private
 */
eXria.form.CanvasFactory = {
  create : function(pnType, poPage) {
    if (poPage.canvas != null) { throw new Error("Canvas is already created."); }
    var vsId = poPage.id + "_canvas";
    switch (pnType) {
      case eXria.form.CanvasType.XHTML :
        return new eXria.form.xhtml.Canvas(vsId, poPage);
      case eXria.form.CanvasType.FLEX :
        var vsPlugin = eXria.controls.PluginFactory.create(vsId, eXria.controls.PluginType.FLEX, poPage.metadata.browser).toString();
        poPage.window.document.write(vsPlugin);
        return new eXria.form.flex.Canvas(vsId, poPage);
      case eXria.form.CanvasType.SILVERLIGHT :
        var vsPlugin = eXria.controls.PluginFactory.create(vsId, eXria.controls.PluginType.SILVERLIGHT, poPage.metadata.browser).toString();
        poPage.window.document.write(vsPlugin);
        return new eXria.form.silverlight.Canvas(vsId, poPage);
/*
      case eXria.form.CanvasType.XBUILDER : // reserved
        var vsPlugin = eXria.controls.PluginFactory.create(vsId, eXria.controls.PluginType.XBUILDER, poPage.metadata.browser).toString();
        poPage.window.document.write(vsPlugin);
        return new eXria.form.xbuilder.Canvas(vsId, poPage);
*/
      default :
        throw new Error("No such canvas type : " + pnType);
    }
  }
};

/**
 * @fileoverview
 * CanvasType
 */

/**
 * CanvasType
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 * @private
 */
eXria.form.CanvasType = {
  XHTML : 0,
  FLEX : 1,
  SILVERLIGHT : 2,
  XBUILDER : 3 /* reserved */
};

/**
 * @fileoverview
 * SessionContext, CookieContext의 Interface
 */

/**
 * SessionContext, CookieContext의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 */
eXria.form.Context = function(poPage) {
  /**
   * page
   * @type eXria.form.Page
   */
  this.page = poPage;
  /**
   * parameter로 넘어온 name과 일치하는 cookie 값을 찾아 리턴한다.
   * @param {String} psName 찾고자 하는 cookie의 name
   * @return cookie 데이터
   * @type String
   */
  this.getAttribute = null;
  /**
   * parameter로 넘어온 내용들을 cookie에 저장
   * @param {String} psName name
   * @param {String} psValue value
   * @param {Number} pnExpireDays expire days
   * @return void
   * @type void
   */
  this.setAttribute = null;
  /**
   * parameter로 넘어온 name과 일치하는 cookie 데이터를 삭제한다.
   * @param {String} psName name
   * @return void
   * @type void
   */
  this.removeAttribute = null;

};


/**
 * @fileoverview
 * 사용자 Cookie Data를 관리하는 클래스
 */

/**
 * 사용자 Cookie Data를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 * @base eXria.form.Context
 */
eXria.form.CookieContext = function(poPage) {
  /**
   * inherit
   */
  eXria.form.Context.call(this, poPage);

  /**
   * parameter로 넘어온 name과 일치하는 cookie 값을 찾아 리턴한다.
   * @param {String} psName 찾고자 하는 cookie의 name
   * @return cookie 데이터
   * @type String
   */
  this.getAttribute = function(psName) {
    var voCookies = this.page.window.document.cookie;
    if (voCookies.length > 0) {
      var vnStartIndex = voCookies.indexOf(psName + "=");
      if (vnStartIndex != -1) {
        vnStartIndex = vnStartIndex + psName.length + 1;
        var vnEndIndex = voCookies.indexOf(";", vnStartIndex);
        if (vnEndIndex == -1) { vnEndIndex = voCookies.length; }
        return decodeURIComponent(voCookies.substring(vnStartIndex, vnEndIndex));
      }
    }
    return null;
  };

  /**
   * parameter로 넘어온 내용들을 cookie에 저장
   * @param {String} psName name
   * @param {String} psValue value
   * @param {Number} pnExpireDays expire days
   * @return void
   * @type void
   */
  this.setAttribute = function(psName, psValue, pnExpireDays) {
    var vsCookie = psName + "=" + encodeURIComponent(psValue);
    if (pnExpireDays != null) {
      var vdNow = new Date();
      vdNow.setDate(vdNow.getDate() + pnExpireDays);
      vsCookie += ";expires=" + vdNow.toGMTString();
    }
    this.page.window.document.cookie = vsCookie;
  };

  /**
   * parameter로 넘어온 name과 일치하는 cookie 데이터를 삭제한다.
   * @param {String} psName name
   * @return void
   * @type void
   */
  this.removeAttribute = function(psName) {
    var vsValue = this.getAttribute(psName);
    if (vsValue != null) { this.setAttribute(psName, vsValue, -1); }
  };

};

/**
 * @fileoverview
 * Model Object의 Interface
 */

/**
 * Model Object의 Interface
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} psId Model Id
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 */
eXria.form.Model = function(psId, poPage) {
  /**
   * id
   * @type String
   */
  this.id = psId;
  /**
   * page Object
   * @type eXria.form.Page
   */
  this.page = poPage;

  /**
   * 서버로 부터 Submission 및 Instance Load
   * @param {String} psUrl server url (synchronization)
   * @return void
   * @type void

   */
  this.loadURL = null;
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   */
  this.loadXML = null;
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   */
  this.loadTXT = null;
  /**
   * loadModel
   * @param {String} psUrl server URL
   * @param {Object} poView UI Object
   * @return void
   * @type void
   */
  this.loadModel = null;

  /**
   * 인스턴스 생성
   * @param {String} psId Instance ID
   * @return 생성된 Instance 리턴
   * @type eXria.data.Instance
   * @see eXria.data.Instance
   */
  this.createInstance = null;
  /**
   * 넘어온 인스턴스를 instance 객체에 붙인다.
   * @param {eXria.data.Instance} poInstance Instance 객체
   * @return void
   * @type void
   */
  this.appendInstance = null;
  /**
   * 넘어온 ID와 일치하는 인스턴스를 찾아 리턴한다.
   * @param {String} psId
   * @return Instance Object
   * @type eXria.data.Instance
   */
  this.getInstance = null;
  /**
   * 넘어온 ID와 일치하는 인스턴스를 찾아 삭제한다.
   * @param {String} psId id
   * @return void
   * @type void
   */
  this.removeInstance = null;

  /**
   * submission을 생성한다.
   * @param {String} psId
   * @return 생성된 Submission
   * @type eXria.protocols.Submission
   * @see eXria.protocols.Submission
   */
  this.createSubmission = null;
  /**
   * 넘어온 submission 객체를 submission에 추가 시킨다.
   * @param {eXria.protocols.Submission} poSubmission submission
   * @return void
   * @type void
   */
  this.appendSubmission = null;
  /**
   * 넘어온 ID와 일치하는 서브미션을 리턴.
   * @param {String} psId
   * @return Submission Object
   * @type eXria.protocols.Submission
   */
  this.getSubmission = null;
  /**
   * 넘어온 ID와 일치하는 Submission을 삭제한다.
   * @param {String} psId Submission ID
   * @return void
   * @type void
   */
  this.removeSubmission = null;

  /**
   * dataset 리턴
   * @param {String} psId
   * @return dataset Object
   * @type eXria.data.DataSetCmd
   * @see eXria.data.DataSetCmd
   */
  this.getDataSet = null;

  /**
   * close
   * @return void
   * @type void
   * @ignore
   */
  this.close = null;

  /**
   * 화면 loading 시 progress bar 출력
   * @param {Boolean} pbShow boolean : true - progress bar 출력, false - progress bar 종료
   * @return void
   * @type void
   */
  this.progressAction = null;

  /**
   * Server Error Message를 전부 삭제한다.
   * @type void
   * @return void
   */
  this.clearErrorMessage = null;

  /**
   * Server Error Message를 반환한다.
   * @param {Boolean} pbCode 에러 코드 리턴 유무
   * @param {Boolean} pbMsg 에러 메세지 리턴 유무
   * @param {Boolean} pbSrc 에러 소스 리턴 유무
   * @type eXria.data.ArrayCollection
   * @return Error String을 담고 있는 Array 객체
   */
  this.getErrorMessage = null;
  /**
   * AES암호화 후 Base64 처리 된 문자열을 복호화 하여 원본 문자열을 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psStr
   * @type String
   * @return Base64 decoding 후 복호화 하여 원본 문자열
   */
  this.decryptStr = null;
  /**
   * plugin 내부 AES 알고리즘으로 입력된 파라미터 문자열을 암호화 하여 Base64 처리 후 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psStr
   * @type String
   * @return 암호화와 Base64처리 된 문자열
   */
  this.encryptStr = null;
  /**
   * 파라미터로 넘어온 이름과 동일한 DB를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psDBName DB Name
   * @return 넘어온 이름과 동일한 DB를 가져온다.
   * @type Object
   */
  this.getDB = null;
  /**
   * 커넥션 객체를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return connection 객체
   * @type eXria.data.plugin.DBConnectionCmd
   * @see eXria.data.plugin.DBConnectionCmd
   */
  this.getConnection = null;
  /**
   * 파일시스템 객체를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return 파일시스템 객체
   * @type eXria.data.plugin.FsoCmd
   */
  this.getFileSystemObject = null;
  /**
   * Client의 IP를 구한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return Client의 IP
   * @type String
   */
  this.getClientIP = null;
  /**
   * Host Name을 구한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return host name
   * @type String
   */
  this.getHostName = null;
  /**
   * 현재 이 플러그인의 버전을 확인한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return 현재 플러그인 버전 정보
   * @type String
   */
  this.getVersion = null;
  /**
   * Logger 인터페이스를 얻는다.<br/>(Plugin Mode 에서만 사용 가능)
   * @type  eXria.form.plugin.Logger
   * @return Logger Object
   */
  this.getLogger = null;
  /**
   * 콤보구분 DataSet ID 리스트 문자열을 반환하는 메소드.<br/>(Plugin Mode 에서만 사용 가능)
   * @type String
   * @return DataSet ID 리스트 (ex. dst1,dst2,dst3)
   */
  this.getDataSetIdList = null;
  /**
   * 콤보구분 인스턴스 ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return 인스턴스 ID 리스트 (ex. instance,instance1)
   */
  this.getInstanceIdList = null;
  /**
   * 콤보구분 Submission ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return Submission ID 리스트 (ex. sms1,sms2,sms3)
   */
  this.getSubmissionIdList = null;
  /**
   * 현재 클라이언트 PC의 Mac Address를 리턴
   * @type String
   * @return Mac Address
   */
  this.getMacAddr = null;
  
  this.asyncEventQueue = [];
  
  this.asyncEventQueueMap = new eXria.data.ArrayMap();
  
  this.runningStateMap = new eXria.data.ArrayMap();
  
  this.tranIdMap = new eXria.data.ArrayMap();
  
  this.startAsyncEventTransaction = function() {
    var vnSeq = 0;
    var vsSeq = null;
    while(true) {
      vsSeq = vnSeq + "";
      if(this.tranIdMap.get(vsSeq) == null) {
        this.tranIdMap.put(vsSeq, "");
        break;
      }
      vnSeq++;
    }
    this.asyncEventQueueMap.put(vsSeq, []);
    return vsSeq;
  };
  
  this.checkLastInQueue = function(psId) {
    var vaQueue = null;
    if(psId != null) vaQueue = this.asyncEventQueueMap.get(psId);
    else vaQueue = this.asyncEventQueue;
    var vnSize = vaQueue.length;
    var vnRes = 0;
    var voSub = null;
    for(var i = 0; i < vnSize; i++) {
      voSub = vaQueue[i];
      if(voSub.responseState != null) vnRes++;
    }
    return vnSize == vnRes;
  };
  
  this.runCallbacks = function(psId) {
    if(psId != null) this.runningStateMap.put(psId, true);
    else this.gonnaRunCallbacks = true;
    if(this.checkLastInQueue(psId)) this.excuteAndClearCallbacks(psId);
  };
  
  this.excuteAndClearCallbacks = function(psId) {
    var vaQueue = null;
    var vnSize = null;
    if(psId != null) {
      vaQueue = this.asyncEventQueueMap.get(psId);
//      this.asyncEventQueueMap.remove(psId);
      this.runningStateMap.remove(psId);
      this.tranIdMap.remove(psId);
      var voCollection = this.runningStateMap.getValueCollection();
      vnSize = voCollection.size();
      var vbRunning = false;
      for(var i = 0; i < vnSize; i++) {
        if(voCollection.get(i)) {
          vbRunning = true;
          break;
        }
      }
      if(!vbRunning) this.progressAction(false);
    } else {
      vaQueue = this.asyncEventQueue.slice(0);
      this.gonnaRunCallbacks = null;
//      this.asyncEventQueue.length = 0;
      this.progressAction(false);
    }
    
    vnSize = vaQueue.length;
    var voSub = null;
    for(var i = 0; i < vnSize; i++) {
      voSub = vaQueue[i];
      voSub.callback(voSub.responseState);
      voSub.callback = null;
      voSub.asynGrpId = null;
      voSub.responseState = null;
    }
    
    if(psId != null){
      this.asyncEventQueueMap.remove(psId);
    } else {
      this.asyncEventQueue.length = 0;
    }
  };
};

/**
 * @fileoverview
 * ModelFactory
 */

/**
 * ModelFactory
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 * @private
 */
eXria.form.ModelFactory = {
  create : function(pnType, poPage) {
    if(poPage.model != null) {
      throw new Error("Model is already created.");
    }

    var vsId = poPage.id + "_model";

    switch(pnType) {
      case eXria.form.ModelType.XHTML :
        return new eXria.form.xhtml.Model(vsId, poPage);
      case eXria.form.ModelType.PLUGIN :
    case eXria.form.ModelType.JRE :
        var voModel = new eXria.form.plugin.Model(vsId, poPage);
        voModel.create();
        return voModel;
      default :
        throw new Error("No such model type : " + pnType);
    }
  }
};

/**
 * @fileoverview
 * ModelType
 * enum(eXria.form.ModelType.XHTML, eXria.form.ModelType.PLUGIN)
 */

/**
 * ModelType
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 * @private
 */
eXria.form.ModelType = {
  XHTML : 0,
  PLUGIN : 1,
  JRE  : 2,
  SWITCH : 3
};

/**
 * @fileoverview
 * eXria CRE의 한 화면을 구성하는 객체로써, 화면에 보여지는 Control 및 화면에 보여지는 데이터를 관리하는 Data Component, 서버와의 통신을 위해 사용되는 Protocol 간의 연관 관계를 맺어주는 클래스
 */
/**
 * eXria CRE의 한 화면을 구성하는 객체로써, 화면에 보여지는 Control 및 화면에 보여지는 데이터를 관리하는 Data Component, 서버와의 통신을 위해 사용되는 Protocol 간의 연관 관계를 맺어주는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} psId Page Id
 * @constructor
 */
eXria.form.Page = function(psId) {
  /**
   * Page ID
   * @type String
   */
  this.id = psId;
  /**
   * window Object
   * @type Object
   */
  this.window = window;
  /**
   * 현재 Page에 대한 정보를 담고 있는 Object
   * @type eXria.form.PageMetadata
   */
  this.metadata = null;
  /**
   * parent Object
   * @type eXria.form.Page
   */
  this.parent = null;
  /**
   * 현재 Page에 포함되는 Canvas Object
   * @type eXria.form.Canvas
   */
  this.canvas = null;
  /**
   * 현재 Page에 포함된 model Object
   * @type eXria.form.Model
   * @see eXria.form.Model
   */
  this.model = null;
  /**
   * page의 view rendering 이전에 일어날 수 있는 컨트롤 이벤트들을 저장했다가
   * view rendering 이후에 순차적으로 수행하기 위한 이벤트 큐 객체
   * @type Array(function)
   */
  this.eventQueue = [];

  this.isRendered = false;

  this.modelType = null;


  /**
   * page metadata set
   * @return void
   * @type void
   * @private
   */
  this.setMetadata = function(poMetadata) {
    if(this.modelType != null) {
      poMetadata.modelType = this.modelType;
    }
	
	if(this.useJsonInstance != null) {
		poMetadata.useJsonInstance = this.useJsonInstance;
	}
  
  if(this.useDomPath != null) {
    poMetadata.useDomPath = this.useDomPath;
  }
    
  if(poMetadata.useJsonInstance) $createJsonInheritance();
    this.metadata = poMetadata;
  };
  /**
  * 현재 브라우저 언어를 셋팅
  * @return void
  * @type void
  * @private
  */
  this.setBrowserLanguage = function() {
    var vsLang = null;
    var voNavigator = this.window.navigator;
    var vsType = voNavigator.appName;

    if (vsType == "Netscape") {
      vsLang = voNavigator.language;
    } else {
      vsLang = voNavigator.userLanguage;
    }

    if (! vsLang) vsLang = "ko";
    this.metadata.language = vsLang;
  };
  /**
   * 로케일에 맞는 타이틀 지정
   * @param {String} psLang
   * @type void
   * @return void
   * @private
   */
  this.setMultiLangTitle = function(psLang) {
    if(this.metadata.multilingualTitle != null) {
      var vsTitle = eval('(' + ("this.metadata.multilingualTitle." + psLang) + ')');
      this.setTitle(vsTitle);
    } else {
      return;
    }
  };
  /**
   * creage model
   * @return void
   * @type void
   * @private
   */
  this.createModel = function() {
  if(this.metadata.modelType == eXria.form.ModelType.SWITCH) {
    if(this.metadata.browser.ie > 0) {
      this.metadata.modelType = eXria.form.ModelType.PLUGIN;
    } else {
      this.metadata.modelType = eXria.form.ModelType.JRE;
    }
  }
    this.model = eXria.form.ModelFactory.create(this.metadata.modelType, this);
  };
  /**
   * page lifecycle and event definitions
   * @return void
   * @type void
   * @private
   */
  this.init = function(poView) {
    this.setBrowserLanguage();
    this.setMultiLangTitle(this.metadata.eXriaLocale);
    //TODO event model에 대한 검증 필요.
//    this.window.document.body.onload = this.window.page.load;
    this.window.onbeforeunload = this.window.page.beforeunload;
    if(this.metadata.browser.ie > 0) {
      this.window.onbeforeunload = this.window.page.beforeunload;
      this.window.document.body.onunload = this.window.page.unload;
    } else {
      this.window.onunload = this.window.page.unload;
    }
    this.canvas = eXria.form.CanvasFactory.create(this.metadata.canvasType, this);

    //submission 및 instance load
    //PageMetadata의 modelUrl을 이용 XXX
    var vsPathName = this.window.location.pathname;
    var vaPath = vsPathName.split("/");
    vaPath.splice(vaPath.length - 1, 1);
    this.metadata.documentBaseUrl = vaPath.join("/") + "/";
    vsPathName = vsPathName.substring(0, vsPathName.lastIndexOf("."));
    var voMetadata = this.metadata;
    var vsUrl = voMetadata.url;
    if(vsUrl) {
      var vnIdx = vsUrl.indexOf(voMetadata.resourceBaseUrl);
      if(vnIdx != -1) voMetadata.domainUrl = vsUrl.substring(0, vnIdx) + "/";
    }

    if (this.window.page.metadata.useMultilingual == false || this.window.page.metadata.eXriaLocale == null) {
      vsPathName = vsPathName + ".xml";
    } else {
      if (page.metadata.multilingualType == "dynamic") vsPathName = vsPathName + "_" + this.metadata.eXriaLocale;
      vsPathName = vsPathName + ".xml";
    }

    var voParent = null;
    var voPage = null;
    var voDialogArguments = null;
    if(this.window.opener) voParent = this.window.opener;
    try {
      if(voParent && voParent.page) voPage = voParent.page;
    } catch(e) {
      voPage = null;
    }
    if(this.window.dialogArguments) voDialogArguments = this.window.dialogArguments;
    if(voParent && voPage && !voDialogArguments) {
      this.parent = voPage;
    } else {
      voParent = null;
      voPage = null;
      if(this.window.parent) voParent = this.window.parent;
      try {
          if(voParent && voParent.page) voPage = voParent.page;
      } catch(e) {
      voPage = null;
      }
      if(voParent && voPage && !voDialogArguments) { //iframe
        this.parent = this.window.parent.page;
      } else if(voDialogArguments) {
        if(this.metadata.browser.ie > 0 && voPage) {
          this.parent = this.window.parent.page;
        } else {
          this.parent = voDialogArguments;
        }
      }
    }

    if(eXria.util.StringUtil.startsWith(vsPathName, "/") == false) {
      vsPathName = "/" + vsPathName;
    }
    this.model.loadModel(vsPathName, poView);
  };
  /**
   * load
   * @return void
   * @type void
   * @private
   */
  this.load = function(poView) {
  var voPage = this.window.page;
  voPage.onInit();

  this.window.scrollBarWidth = this.window.getScrollBarWidth();
  //20080723 추가
  if(poView && poView.rendering) {
    poView.rendering(this);
  }
  //eventQueue 처리(20100527 추가)
  if(this.eventQueue.length > 0) {
    var vnSize = this.eventQueue.length;
    var voEvent = null;
    for(var i = 0; i < vnSize; i++) {
      voEvent = this.eventQueue[i];
      voEvent();
    }
    this.eventQueue = [];
  }
  //eventQueue 처리 종료
  if(this.metadata.useMultilingual) {
    //다국어 이용시 container control 내부의 import control 생성 문제 해결
    voPage.canvas.appendSubImp();
  }
  this.isRendered = true;
  //로딩시 첫번째 tab index로 지정된 control에 focusing
  var voCanvas = voPage.canvas;
  var voCtl = voCanvas.getFirstTabCtl(voCanvas.controls.getValueCollection());
  voCanvas.setFocusByControl(voCtl);

    if(this.metadata.loadingProgressEnabled) {
      this.model.progressAction(false);
    }
    voPage.onLoad();
  };
  /**
   * page components create
   * onInit
   * @return void
   * @type void
   * @private
   */
  this.onInit = function() {
    //
    // TO DO
    //
  };
  /**
   * onLoad
   * @return void
   * @type void
   * @private
   */
  this.onLoad = function() { //호출되지 않는다.
    //
    // TO DO
    //
  };
  /**
   * unload
   * @return void
   * @type void
   * @private
   */
  this.unload = function() {
    if(this.metadata.browser.ie == 0 && this.window.page.onUnLoad) this.window.page.onUnLoad();

    if(!(this.metadata.modelType == eXria.form.ModelType.JRE)) {
      if(!page.window) { return; }

      var voPage = this.window.page;
      var voDoc = this.window.document;
      var vnW = voDoc.body.offsetWidth;
      var vnH = voDoc.documentElement.clientHeight;
      var voCoverCtl = voPage.canvas.createControl("rectangle","coverRgt___" + this.window.page.id + "___",0,0,(vnW==0) ? 1 : vnW,(vnH==0) ? 1 : vnH);
      voCoverCtl.zIndex = 10000000;
      voCoverCtl.cursor = "auto";
      voCoverCtl.angle = "0";
      voCoverCtl.joinType = "miter";
      voCoverCtl.penStyle = "solid";
      voCoverCtl.penWeight = 0;
      voCoverCtl.penColor = "transparent";
      voCoverCtl.penOpacity = 0;
      voCoverCtl.focusDisplay = false;
      voCoverCtl.focusPenColor = "#FFFFFF";
      voCoverCtl.focusPenStyle = "solid";
      voCoverCtl.fillStartColor = "#FFFFFF";
      voCoverCtl.fillEndColor = "#FFFFFF";
      voCoverCtl.fillType = "solid";
      voCoverCtl.fillAngle = 0;
      voCoverCtl.fillOpacity = 1;

      this.window.page.canvas.appendControl(voCoverCtl);

      voCoverCtl.refresh();
    }

    this.window.page.close();
  };
  /**
   * beforeunload
   * @return void
   * @type void
   * @private
   */
  this.beforeunload = function() {
    //
    // TO DO
    //
    if(this.metadata.browser.ie > 0) {
		  if(this.window.page.onUnLoad) this.window.page.onUnLoad();
	  }
    
    var voBase = this.page;
    var voControls = voBase.canvas.controls.entries;
    var voControl = null;
    
    if(this.metadata.browser.ie < 8) {
      var voCtrl = null;
      var voParentCtrl = null;
      for(var member in voControls) {
        if(voControls[member].toString && (voControls[member].toString() == "HtmlSnippet" || voControls[member].toString() == "SubPage" || voControls[member].toString() == "ComboBox")) {
          voControl = voControls[member];
          voCtrl = voControl.ctrl;
          voParentCtrl = voCtrl.parentNode;
          if(voControl.toString() == "ComboBox"){
            voControl.clearListArea();
          }
          voParentCtrl.removeChild(voCtrl);
        }
      }
    } else {
      for(var member in voControls) {
        if(voControls[member].toString && voControls[member].toString() == "ComboBox") {
          voControl = voControls[member];
          voControl.clearListArea();
        }
      }
    }
  };
  /**
   * page components destroy
   * close
   * @return void
   * @type void
   * @private
   */
  this.close = function() {
    var voPage = this.window.page;

    if(voPage.canvas) {
      voPage.canvas.close();
    }
    if(voPage.model) {
      voPage.model.close();

    if(voPage.metadata.modelType == eXria.form.ModelType.PLUGIN) {
    var voPlugin = voPage.window.document.getElementById(voPage.model.id);
    if(voPlugin) voPlugin.parentNode.removeChild(voPlugin);
    }
    }
    if(voPage.controls) {
      voPage.controls.clear();
    }
    if(voPage.window) {
      voPage.window = null;
    }
    //
    // check
    //
    if(this.window != null && voPage != null && voPage.parent != null && voPage.parent.window != null) {
      if(!voPage.parent.window.closed) {
        voPage.parent.childPages.remove(voPage.id);
      }
    }
  };
  /**
   * 현재 page의 canvas에 포함된 Control 중 parameter로 넘어온 ID와 일치하는 Control 객체를 리턴한다
   * @param {String} psId 찾고자 하는 Control의 ID
   * @return 넘어온 ID와 일치하는 control Object
   * @type eXria.controls.Control
   */
  this.getControl = function(psId) {
     return this.canvas.getControl(psId);
  };
  /**
   * 현재 page의 canvas에 포함된 모든 Control을 refresh.
   * @return void
   * @type void
   */
  this.refresh = function() {
    if(this.canvas && this.canvas.controls) {
      var voIterator = this.canvas.controls.getValueCollection().iterator();
      var voControl = null;
      while(voIterator.hasNext()) {
        voControl = voIterator.next();
        if(voControl.parent) {
          vsControlType = voControl.parent.toString();
          if(vsControlType == "Tab" || vsControlType == "Group" || vsControlType == "FreeForm" || vsControlType == "Tab_TabPages") {
      			continue;
          }
        }
        if(voControl.refresh) {
          voControl.refresh();
        }
      }
    }
  };
  /**
   * parameter로 넘어온 Instance ID와 일치하는 Instance를 찾아 리턴.
   * @param {String} psId Instance ID
   * @return 넘어온 ID와 일치하는 Instance 객체
   * @type eXria.data.Instance
   */
  this.getInstance = function(psId) { return this.model.getInstance(psId); };
  /**
   * parameter로 넘어온 Submission ID와 일치하는 Submission을 찾아 리턴.
   * @param {String} psId 서브미션 ID
   * @return 넘어온 ID와 일치하는 Submission 객체
   * @type eXria.protocols.Submission
   * @see eXria.protocols.Submission
   */
  this.getSubmission = function(psId) { return this.model.getSubmission(psId); };
  /**
   * parameter로 넘어온 DataSet ID와 일치하는 DataSet을 찾아 리턴.
   * @param {String} psId 데이타셋 ID
   * @type eXria.data.DataSetCmd
   * @see eXria.data.DataSetCmd
   */
  this.getDataSet = function(psId) { return this.model.getDataSet(psId); };
  /**
   * Server Error Message를 반환한다.
   * @param {Boolean} pbCode 에러 코드 리턴 유무
   * @param {Boolean} pbMsg 에러 메세지 리턴 유무
   * @param {Boolean} pbSrc 에러 소스 리턴 유무
   * @type eXria.data.ArrayCollection
   * @return Error String을 담고 있는 Array 객체
   */
  this.getErrorMessage = function(pbCode, pbMsg, pbSrc) {
  return this.model.getErrorMessage(pbCode, pbMsg, pbSrc);
  };
  /**
   * Server Error Message를 전부 삭제한다.
   * @type void
   * @return void
   */
  this.clearErrorMessage = function() { this.model.clearErrorMessage(); };
  /**
   * cookie context
   * @type eXria.form.CookieContext
   * @see eXria.form.CookieContext
   * @private
   */
  this.cookieContext = null;
  /**
   * 현재 page에 포함된 Cookie를 리턴
   * @return 쿠키 Object
   * @type eXria.form.CookieContext
   * @see eXria.form.CookieContext
   */
  this.getCookieContext = function() {
    if (this.cookieContext == null) { this.cookieContext = new eXria.form.CookieContext(this); }
    return this.cookieContext;
  };
  /**
   * session context
   * @type eXria.form.SessionContext
   * @private
   */
  this.sessionContext = null;
  /**
   * 현재 페이지의 세션을 리턴
   * @return 현재 페이지의 세션 Object
   * @type eXria.form.SessionContext
   * @see eXria.form.SessionContext
   */
  this.getSessionContext = function() {
    if (this.sessionContext == null) { this.sessionContext = new eXria.form.SessionContext(this); }
    return this.sessionContext;
  };
  /**
   * 현재 페이지가 parameter로 넘어온 URL로 이동.
   * @param {String} psUrl
   * @return void
   * @type void
   */
  this.open = function(psUrl) {
    this.window.location.href = psUrl;
  };
  /**
   * 현재 page의 자식 페이지 객체들이 저장되는 Map
   * @type eXria.data.ArrayMap
   */
  this.childPages = new eXria.data.ArrayMap();
  /**
   * 현재 페이지를 기준으로 새로운 창을 여는 메소드
   * @param {String} psId page Id
   * @param {String} psUrl url
   * @param {int} pnType page type
   * @param {String} psFeature feature
   * @return 새로 생성된 Window에 대한 객체
   * @type eXria.form.Page
   */
  this.openPage = function(psId, psUrl, pnType, psFeature) {
    var voPage = null;
    switch (pnType) {
      case eXria.form.PageType.POPUP :
        voPage = (new eXria.form.PopupWindow(psUrl, psId, psFeature, this)).open();
        break;
      case eXria.form.PageType.FRAME :
        voPage = (new eXria.form.FrameWindow(psId, this)).open();
        break;
      case eXria.form.PageType.MODAL :
        voPage = (new eXria.form.ModalWindow(psUrl, psId, psFeature, this)).open();
        this.canvas.delayedKeydown.clear();
        break;
      default :
        throw new Error("No such page type : " + pnType);
    }
    this.childPages.put(psId, voPage);
    return voPage;
  };
  /**
   * 현재 페이지를 기준으로 자식페이지 중 parameter로 넘어온 ID와 일치하는 page를 리턴
   * @param {String} psId page Id
   * @return 넘어온 ID와 일치하는 page Object
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.getPage = function(psId) {
    var voPage = this.childPages.get(psId);
    if(voPage == null) {
      return null;
    }
    var voChildPage = voPage.getPage();
  if(voChildPage == null) {
      return null;
    }
    return voChildPage;
  };
  /*FrameSet*/
  /**
   * parameter로 넘어온 frame ID와 일치하는 frame을 찾아 리턴.
   * @param {String} psFrmId frame ID
   * @return frame Object
   * @type Object
   */
  this.getHtmlFrame = function(psFrmId) {
  if(psFrmId == null) { return null; }
  var resultFrm = this.searchParentHtmlFrame(psFrmId, this.window.parent);

  if(resultFrm == null) { throw new Error("Cannot find Frame."); }
  else return resultFrm;
  };
  /**
   * frame 검색시 모든 페이지에 대해 검색하기 위한 recursive 메소드
   * @return frame object
   * @type Object
   * @private
   */
  this.searchParentHtmlFrame = function(psFrmId, poParent) {
  if(poParent == null || poParent == undefined) { return null; }

  var voFrm = poParent.document.getElementById(psFrmId);
    if(voFrm != null || voFrm != undefined) {
      return voFrm;
    } else {
      if(poParent != poParent.top) {
      return this.searchParentHtmlFrame(psFrmId, poParent.parent);
      } else {
      return null;
      }
    }
  };
 /**
  * parameter로 넘어온 ID와 일치하는 프레임 내부의 page를 리턴.
  * @param {String} psFrmId frame id
  * @return page Object
  * @type eXria.form.Page
  */
  this.getPageInFrame = function(psFrmId) {
  if(psFrmId == null) { return null; }

  var voFrm = this.getHtmlFrame(psFrmId);
  var voPage = voFrm.contentWindow.page;
  if(!voPage || voPage.toString() != "eXria.form.Page") { throw new Error("Cannot find page."); }

  return voPage;
  };
  /**
   * parameter로 넘어온 ID와 일치하는 page를 찾아 리턴한다.
   * @param {String} psId page Id
   * @return page Object
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.searchPage = function(psId) {
    if(psId == null) { return; }
    if(this.id == psId) { return this; }

    var voFindPage = this.searchChildPage(this, psId, this.id);
    if(voFindPage != null && voFindPage != undefined) {
      return voFindPage;
    }

    if(this.parent == null) { return null; }

    if(this.parent != this) {
      voFindPage = this.searchParentPage(this.parent, psId, this.id);
    }

    if(voFindPage != null && voFindPage != undefined) {
      return voFindPage;
    } else {
      throw new Error("Cannot find page.");
    }
  };
  /**
   * 페이지 검색시 상위 페이지를 검색하기 위한 메소드
   * @return 찾은 page Object
   * @type eXria.form.Page
   * @see eXria.form.Page
   * @private
   */
  this.searchParentPage = function(poPage, psId, psNoSearchPageId) {
    if(poPage == null || poPage == null) { return; }
    if(psNoSearchPageId == null) { psNoSearchPageId = this.id; }
    if(poPage.id == psId) { return poPage; }

    var voFindPage = this.searchChildPage(poPage, psId, psNoSearchPageId);
    if(voFindPage != null && voFindPage != undefined) {
      return voFindPage;
    }

    if(poPage != poPage.parent) {
      voFindPage = this.searchParentPage(poPage.parent, psId, poPage.id);
    }

    if(voFindPage != null && voFindPage != undefined) {
      return voFindPage;
    } else {
      throw new Error("Cannot find page.");
    }
  };
  /**
   * 페이지 검색시 자식 페이지들을 검색하기 위한 recursive 메소드
   * @return page Object
   * @type eXria.form.Page
   * @see eXria.form.Page
   * @private
   */
  this.searchChildPage = function(poPage, psId, psNoSearchPageId) {
    if(poPage == null || psId == null) { return; }
    if(psNoSearchPageId == null) { psNoSearchPageId = this.id; }

    var voNodeList = poPage.childPages;

    //노드의 자식 노드가 있다면
    if(!voNodeList.isEmpty()) {
      //가진 노드들을 iterator로 리턴
      voNodeList = voNodeList.getValueCollection().iterator();
      var vnNodeCursor = voNodeList.cursor;

      while(voNodeList.hasNext()) {
        var voChildNode = voNodeList.next();
        if(voChildNode.getPage() == null){
          continue;
        }
        var vsPageId = voChildNode.getPage().id;
        if(vsPageId == psNoSearchPageId) { continue; }
        //페이지를 찾았다면 리턴
        if(vsPageId == psId) { return voChildNode.getPage(); }
      }
      //iterator의 초기 index
      voNodeList.cursor = vnNodeCursor;
      while(voNodeList.hasNext()) {
        var voChildPage = voNodeList.next();
        //찾지 말아야 할 자식 노드라면 continue
        if(voChildPage.getPage() == null) continue;
        if(psNoSearchPageId == voChildPage.getPage().id) { continue; }
        //자식 노드가 있다면 searchChildPage를 리턴
        if(!voChildPage.getPage().childPages.isEmpty()) {
          return this.searchChildPage(voChildPage.getPage(), psId, psNoSearchPageId);
        }
      }
    }
  };
  /**
   * 페이지의 타이틀을 지정
   * @param {String} vsTitle 타이틀로 지정할 문자열
   * @return void
   * @type void
   */
  this.setTitle = function(psTitle) {
    this.window.document.title = psTitle;
  };
  /**
   * 인스턴스의 데이터를 사용하여 페이지 타이틀 지정
   * @param {String} psInsId 인스턴스ID
   * @param {String} psPath XPath
   * @return void
   * @type void
   */
  this.setNodeSetTitle = function(psInsId, psPath) {
    try {
      var viIns = this.getInstance(psInsId);
      this.setTitle(viIns.getValueNode(psPath).getValue());
    } catch (e) {
      this.setTitle("");
    }
  };
  /**
   * Plugin Object를 model에 재설정한다.
   * @return void
   * @type void
   */
  this.resetPlugin = function() {
    this.model.setPlugin();
  };
  /** Class 명 리턴
   * @type String
   * @return Class 이름 리턴
   */
  this.toString = function() {
    return "eXria.form.Page";
  };
  /**
   * Java runtime 다운로드 주소를 특정 주소로 사용하고자 할 경우 지정
   * @param {String} psAddr JRE 설치 파일 주소
   * @return void
   * @type void
   */
  this.setJREAddr = function(psAddr) {
    if(!psAddr) {
      return;
    }
    this.window.page.metadata.jreDownloadAddr = psAddr;
  };
};
/**
 * Studio 스크립트 디버거 사용시 콘솔에 메세지를 출력합니다.
 * @param {String} psMsg Studio 콘솔에 출력할 메세지
 * @return void
 * @type void
 */
function xprint(psMsg) { };
/**
 * Studio 스크립트 디버거 사용시 콘솔에 메세지를 출력합니다.
 * @param {String} psMsg Studio 콘솔에 출력할 메세지
 * @return void
 * @type void
 */
function xprintln(psMsg) { };
/**
 * 동적 script include 전역 함수 2008-06-05
 * @private
 */
var eXriaGlobal = this;
/**
 * 외부 Javascript 파일을 현재 파일에 포함시킵니다.
 * @param {String} psUrl
 * @return void
 * @type void
 * @private
 */
function $include(psUrl) {
  var voRequest = eXria.form.xhtml.HttpRequestFactory.create();
  voRequest.open("GET", psUrl, false);
  voRequest.send(null);

  var vsJs = voRequest.responseText;
  if(window.execScript) { //IE
    window.execScript(vsJs);
  } else {
    var vbSafari = navigator.userAgent.match(/\Safari/i)!=null;
    if(vbSafari) { //SAFARI
      var voScript = document.createElement("script");
      voScript.appendChild(document.createTextNode(vsJs));
      document.documentElement.appendChild(voScript);
    } else { //FIREFOX, OPERA
      eXriaGlobal.eval(vsJs);
    }
  }
};
/**
 * Dynamic CSS Loading
 * @param {String} psUrl css 링크 url
 * @param {String} psCssId css 링크 태그 id(디폴트 값 : "eXriaDynamicCSS")
 * @public
 */
function $loadCSS(psUrl, psCssId) {
  var vsCSSId = psCssId;
  if(vsCSSId == null) vsCssId = "eXriaDynamicCSS";
  var voHead = document.getElementsByTagName("head")[0];
  var voCSS = document.getElementById(vsCSSId);

  if(voCSS) {
    //이미 dynamic loading 된 CSS가 있을 경우 삭제한다.
    voHead.removeChild(voCSS);
    if(psUrl == null) return;
  }
  //CSS Element 생성후 Header에 append
  var voCSSNode = document.createElement('link');
  voCSSNode.id = vsCSSId;
  voCSSNode.name = vsCSSId;
  voCSSNode.type = 'text/css';
  voCSSNode.rel = 'stylesheet';
  voCSSNode.href = psUrl;
  voCSSNode.media = 'screen';
  voHead.appendChild(voCSSNode);
};

function $createJsonInheritance() {
  eXria.controls.xhtml.Util.createInheritance(eXria.controls.JsDataRefNode, eXria.controls.DataRefNode);
  eXria.controls.xhtml.Util.createInheritance(eXria.controls.JsDataRefNodeset, eXria.controls.DataRefNodeset);
};

/**
 * @fileoverview
 * Page가 RunTime시 필요로하는 데이터들을 저장하는 클래스
 */

/**
 * Page가 RunTime시 필요로하는 데이터들을 저장하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 */
eXria.form.PageMetadata = function(poPage) {
  /**
   * 현재 Page 객체
   * @type eXria.form.Page
   */
  this.page = poPage;
  /**
   * 현재 Browser를 구분한다.
   * ie, opera, gecko, webkit, mobile로 구분가능하며 해당 Browser의 버전을 저장
   * @type eXria.lang.Browser
   */
  this.browser = new eXria.lang.Browser(this.page);
  /**
   * eXria version
   * @type Number
   */
  this.version = null;
  /**
   * 현재 Page의 url
   * @type String
   */
  this.url = this.page.window.document.URL;
  /**
   * 현재 Page의 url에서 contextpath에 이전 부분
   * @type String
   */
  this.domainUrl = null;
  /**
   * 현재 Page의 Domain
   * @type String
   */
  this.domain = this.page.window.document.domain;
  /**
   * 현재 Page의 referer
   * @type String
   */
  this.referer = this.page.window.document.referer;
  /**
   * base
   * @type Object
   * @private
   */
  this.base = null;
  /**
   * 현재 page type
   * @type Number
   */
  this.pageType = null;
  /**
   * 현재 Page에 포함된 canvas type
   * @type Number
   */
  this.canvasType = null;
  /**
   * 현재 Page에 포함된 model type
   * @type Number
   */
  this.modelType = null;
  /**
   * 현재 Browser의 language
   * @type String
   */
  this.language = null;
  /**
   * AJAX Submission시 호출될 Base URL
   * Server에서 Metadata 호출 시점에 생성하여 내려 보낸다.
   */
  this.submitBaseUrl = null;
  /**
   * static file이 위치하는 url
   * @type String
   */
  this.resourceBaseUrl = null;
  /**
   * 현재 page가 로딩된 화면의 location path 정보 저장
   * @type String
   */
  this.documentBaseUrl = null;
  /**
   * enable during page loading
   * define in web.xml
   * default false
   * @type Boolean
   */
  this.loadingProgressEnabled = false;
  /**
   * eXria Locale
   * @type String
   */
  this.eXriaLocale = null;
  /**
   * availableLocale
   * @type Array
   */
  this.availableLocale = null;
  /**
   * default Locale
   * @type String
   */
  this.defaultLocale =  null;
  /**
   * LocaleList
   * @type Map
   */
  this.localeList = null;
  /**
   * applyOrder
   * @type Array
   */
  this.applyOrder = null;
  /**
   * multi language type
   * @type String
   */
  this.multilingualType = "static";
  /**
   * multi language title
   * @type String
   */
  this.multilingualTitle = null;
  /**
   * eXriaLocale Query Parameter Name
   * @type String
   */
  this.localeParamName = null;
  /**
   * jre plugin log level
   * @type String
   */
  this.logLevel = null;
  /**
   * jre address tmp
   * @type String
   */
  this.jreDownloadAddr = null;
  /**
   * jre plugin info object
   * @type Object
   * @ignore
   */
  this.jre = {};
  /**
   * appletPath
   * @type String
   * @ignore
   */
  this.jre.appletPath = null;
  /**
   * version
   * @type String
   * @ignore
   */
  this.jre.version = null;
  /**
   * initHeapSize
   * @type String
   * @ignore
   */
  this.jre.initHeapSize = null;
  /**
   * maxHeapSize
   * @type String
   * @ignore
   */
  this.jre.maxHeapSize = null;
  /**
   * jvmArgument
   * @type String
   * @ignore
   */
  this.jre.jvmArgument = null;
  /**
   * updateCheck
   * @type String
   * @ignore
   */
  this.jre.updateCheck = null;
  /**
   * updatePolicy
   * @type String
   * @ignore
   */
  this.jre.updatePolicy = null;
  /**
   * offLineAllowed
   * @type String
   * @ignore
   */
  this.jre.offLineAllowed = null;
  /**
   * properties
   * @type String
   * @ignore
   */
  this.jre.properties = null;
};

/**
 * @fileoverview
 * Page Type을 상수 정의한 클래스</br>
 * enum</br>
 * - eXria.form.PageType.MAIN</br>
 * - eXria.form.PageType.POPUP</br>
 * - eXria.form.PageType.FRAME</br>
 * - eXria.form.PageType.IMPORT</br>
 */

/**
 * Page Type을 상수 정의한 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.form.PageType = {
  MAIN : 0,
  POPUP : 1,
  FRAME : 2,
  IMPORT : 3,
  MODAL : 4
};
/**
 * @fileoverview
 * Popup Window 생성 클래스
 */

/**
 * Popup Window 생성 클래스
 * @version 1.0
 * @param {String} psUrl Page URL
 * @param {String} psId Page Id
 * @param {String} psFeature Page Open Feature
 * @param {String} poPage Parent Page Object
 * @constructor
 */
eXria.form.PopupWindow = function(psUrl, psId, psFeature, poPage) {
  /**
   * url
   * @type String
   * @private
   */
  this.url = psUrl;
  /**
   * id
   * @type String
   */
  this.id = psId;
  /**
   * feature
   * @type String
   * @private
   */
  this.feature = psFeature;
  /**
   * parent
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.parent = poPage;
  /**
   * child window
   * @type Object
   * @private
   */
  this.childWindow = null;
  /**
   * 새로운 팝업을 여는 메소드.
   * @return 생성된 popup 객체
   * @type eXria.form.PopupWindow
   * @see eXria.form.PopupWindow
   */
  this.open = function() {
  this.childWindow = this.parent.window.open(eXria.util.UrlUtil.getAbsoluteUrl(this.url), this.id, this.feature);
    return this;
  };
  /**
   * 팝업 페이지의 page 객체 리턴
   * @return 생성된 팝업 내부의 page 객체
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.getPage = function() {
  try {
    this.childWindow.page;
  } catch(e) {
    return null;
  }
  return this.childWindow.page;
  };
};
/**
 * @fileoverview
 * Page 내부에 생성되는 Frame Window 객체를 관리하는 클래스
 */

/**
 * Page 내부에 생성되는 Frame Window 객체를 관리하는 클래스
 * @version 1.0
 * @param {String} psId Page Id
 * @param {String} poPage Parent Page Object
 * @constructor
 */
eXria.form.FrameWindow = function(psId, poPage) {
  /**
   * id
   * @type String
   */
  this.id = psId;
  /**
   * parent
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.parent = poPage;
  /**
   * subpage
   * @type Object
   */
  this.subpage = null;
  /**
   * FrameWindow를 생성하여 리턴한다.
   * @type eXria.form.FrameWindow
   * @see eXria.form.FrameWindow
   */
  this.open = function() {
    return this;
  };
  /**
   * 생성된 프레임 내부의 Page를 리턴한다.
   * @return 생성된 프레임 네부의 Page
   * @type eXria.form.Page
   * @see eXria.form.Page
   */
  this.getPage = function() {
  if(this.subpage == null) {
      this.subpage = this.parent.getControl(this.id).getCtrl();
  }
    return this.subpage.contentWindow.page;
  };
};
/**
 * @fileoverview
 * Modal Window 생성 클래스
 */

/**
 * Modal Window 생성 클래스
 * @version 1.0
 * @param {String} psUrl Page URL
 * @param {String} psId Page Id
 * @param {String} psFeature Page Open Feature
 * @param {String} poPage Parent Page Object
 * @constructor
 */
eXria.form.ModalWindow = function(psUrl, psId, psFeature, poPage) {
  if(!psUrl || !psId || !poPage) {
  throw new Exception("Modal parameter error.");
  }
  /**
   * url
   * @type String
   * @private
   */
  this.url = psUrl;
  /**
   * Modal Window id
   * @type String
   */
  this.id = psId;
  /**
   * Modal Window의 parent Page
   * @type eXria.form.Page
   */
  this.parent = poPage;

  if(psFeature) { this.feature = psFeature; }
  else { this.feature = ""; }
  /**
   * MODAL 윈도우를 생성하여 리턴한다.
   * @return 생성된 모달객체
   * @type eXria.form.ModalWindow
   * @see eXria.form.ModalWindow
   */
  this.open = function() {
    /*var vsParam = "?libScope=page";
    if(vsPopUrl.indexOf("?") > -1) vsParam = "&libScope=page";
    var vnPopIdx = vsPopUrl.lastIndexOf(".") + 1;
    if(vsPopUrl.substring(vnPopIdx, vnPopIdx+3) != "xrf") vsParam = "";*/

    var voBrowser = this.parent.metadata.browser;
    var vsUrl = eXria.util.UrlUtil.getAbsoluteUrl(this.url);
    if (voBrowser.ie > 0 || voBrowser.gecko == 1.9 || voBrowser.webkit > 0) {
      if (voBrowser.ie > 0) {
        this.parent.window.showModalDialog(poPage.metadata.resourceBaseUrl
            + "exria.modal.load.xrf?url=" + vsUrl/* + vsParam */, this.parent,
            this.feature);
      } else {
        this.parent.window.showModalDialog(vsUrl/* + vsParam */, this.parent,
            this.feature);
      }
    } else {
      if(voBrowser.gecko >= 1.9) {
        this.parent.window.showModalDialog(vsUrl/* + vsParam */, this.parent,
            this.feature);
      }else{
        if(!!parent.window.openDialog){
          this.parent.window.openDialog(vsUrl/* + vsParam */, this.id, "modal;"
              + this.feature);
        }else{
          this.parent.window.showModalDialog(vsUrl/* + vsParam */, this.parent,
              this.feature);
        }
      }
    }
    return this;
  };
  /**
   * get page
   * @type
   * @private
   */
  this.getPage = function() {};
};
/**
 * @fileoverview
 * Page에 Import 되는 Page를 관리하는 Class.</br>
 * 실질적으로 Import 되는 Page는 서버측에서 부모 페이지에 포함시키므로 해당 메서드는 Run Time 시 사용 불가.
 */
/**
 * Page에 Import 되는 Page를 관리하는 Class.</br>
 * 실질적으로 Import 되는 Page는 서버측에서 부모 페이지에 포함시키므로 해당 메서드는 Run Time 시 사용 불가.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @constructor
 */
eXria.form.Import = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poCanvas) {
  /**
   * base
   * @type eXria.form.Import
   * @private
   */
  var base = this;
  /**
   * Import Page Id
   * @type String
   */
  this.id = psId;
  /**
   * Import Page left
   * @type Number
   */
  this.left = pnLeft;
  /**
   * Import Page top
   * @type Number
   */
  this.top = pnTop;
  /**
   * Import Page width
   * @type Number
   */
  this.width = pnWidth;
  /**
   * Import Page height
   * @type Number
   */
  this.height = pnHeight;
  /**
   * Import 되는 Page의 Canvas Object
   * @type eXria.form.Canvas
   */
  this.pageCanvas = poCanvas;
  /**
   * Import 될 Page에 부쳐넣어질 Group Object</br>
   * Import 될 페이지는 해당 Group에 포함되어 Import 될 페이지에 생성
   * @type eXria.controls.Control
   * @see eXria.controls.Control
   */
  this.ctrl = this.pageCanvas.createControl("group", psId, pnLeft, pnTop, pnWidth, pnHeight); //group control

  var voImp = eXria.controls.xhtml.Default.Import;
  this.ctrl.disabled = voImp["disabled"];
  this.ctrl.movable = voImp["movable"];
  this.ctrl.showFocusLine = voImp["showFocusLine"];
  this.ctrl.tooltip = voImp["tooltip"];
  this.ctrl.tooltipDisplay = voImp["tooltipDisplay"];
  this.ctrl.tooltipLangKey = voImp["tooltipLangKey"];
  this.ctrl.userAttr = voImp["userAttr"];
  this.ctrl.visible = voImp["visible"];
  this.ctrl.focusBorderColor = voImp["focusBorderColor"];
  this.ctrl.focusBorderStyle = voImp["focusBorderStyle"];
  this.ctrl.focusBorderWidth = voImp["focusBorderWidth"];
  this.ctrl.focusDisplay = voImp["focusDisplay"];

  this.ctrl.className = "Default_Import_Class";
  this.ctrl.outerClassName = "Default_Import_OuterClass";

  /**
   * 현재 Import되는 페이지를 Import 될 페이지에서 보여질지를 결정하는 속성
   * @type String
   * @private
   */
  if(eXria.controls.xhtml.Default.Import["overflow"]) this.ctrl.overflow = eXria.controls.xhtml.Default.Import["overflow"];
  else this.ctrl.overflow = "visible"; //overflow visible 20081016
  /**
   * 현재 Import 될 Page가 존재할 Group의 Focus 속성
   * @type Boolean
   * @private
   */
  this.ctrl.focusDisplay = false;
  /**
   * Import 될 페이지의 Canvas
   * @type
   */
  this.canvas = {};
  /**
   * Canvas Width
   * @type Number
   */
  this.canvas.width = null;
  /**
   * Canvas height
   * @type Number
   */
  this.canvas.height = null;
  /**
   * Canvas refresh
   * @private
   */
  this.canvas.refresh = function() {
    //TODO 검토
  };

  /**
   * Import 될 페이지의 subcontrol을 생성하는 function
   * @param {String} psType type
   * @param {String} psId id
   * @param {Number} pnLeft Left
   * @param {Number} pnTop Top
   * @param {Number} pnWidth Width
   * @param {Number} pnHeight Height
   * @return 생성된 Control Object
   * @type eXria.controls.Control
   */
  this.canvas.createControl = function(psType, psId, pnLeft, pnTop, pnWidth, pnHeight) {
    return base.pageCanvas.createControl(psType, psId, pnLeft, pnTop, pnWidth, pnHeight);
  };

  /**
   * Import될 페이지가 존재할 Group에 Control을 ADD 한다.
   * @param {eXria.controls.Control} poCtl 컨트롤 Object
   * @return void
   * @type void
   */
  this.canvas.appendControl = function(poCtl) {
    base.ctrl.addChild(poCtl);
  };
  /**
   * Import될 페이지를 Import 할 페이지에 set
   * @return void
   * @type void
   * @private
   */
  this.setImport = function(poCtl) {
    //this.pageCanvas.appendControl(this.ctrl);

    if(!poCtl){ this.pageCanvas.appendControl(this.ctrl);}
    else{
     if('Tab_TabPages' === poCtl.toString() ||
        'SlidePage' === poCtl.toString()){
      this.pageCanvas.appendControl(this.ctrl);
     }else{
      poCtl.addChild(this.ctrl);
     }
    }
  };
};

/**
 * @fileoverview
 * 사용자 Session 정보를 관리하는 클래스
 */

/**
 * 사용자 Session 정보를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 * @base eXria.form.Context
 */
eXria.form.SessionContext = function(poPage) {
  /**
   * inherit
   */
  eXria.form.Context.call(this, poPage);
  /**
   * modified
   * @type Boolean
   * @private
   */
  this.modified = false;
   /**
    * resSessionData
    * @type Object
    * @private
    */
  this.resSessionData = null;
  /**
   * Ajax Request URL
   * @type String
   * @private
   */
  var vsRequestURL = this.page.metadata.resourceBaseUrl + "exria.server.session.xrf";
  /**
   * Request Header에 셋팅할 key데이터
   * @type String
   * @private
   */
  var vsReqHeaderKey = "method";
  /**
   * 셋팅된 키에 매핑될 데이터
   * @type String
   * @private
   */
  var vsSync = "synchronize"; //synchronize
  /**
   * 셋팅된 키에 매핑될 데이터
   * @type String
   * @private
   */
  var vsUpdate = "update";  //update
  /**
   * getHttpRequest
   * @type String
   * @return {Object} voHttpRequest
   * @private
   */
  this.getHttpRequest = function(vsReqHeaderValue, vsSendData) {
  var voHttpRequest = eXria.form.xhtml.HttpRequestFactory.create();
  voHttpRequest.open("POST", vsRequestURL, false);
  voHttpRequest.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
  voHttpRequest.setRequestHeader(vsReqHeaderKey, vsReqHeaderValue);
  voHttpRequest.send(vsSendData);

  return voHttpRequest;
  };
  /**
   * server의 session 정보를 읽어 client측에 동기화 시킨다.
   * @return void
   * @type void
   */
  this.synchronize = function() {
  var voHttpRequest = this.getHttpRequest(vsSync, null);

  if(voHttpRequest.readyState == 4) {
    var customEval = function(psJsonStr) {
    return (new Function("", "return " + psJsonStr + ";"))();
    };

    switch(voHttpRequest.status) {
    case 200 : {
      this.resSessionData = customEval(voHttpRequest.responseText);
      //커넥션이 제대로 이루어졌을 경우에만 this.modified 를  false로 변경
      this.modified = false;
      break;
    }
    case 500 : {
      var voJsonError = customEval(voHttpRequest.responseText);
      var vsErrorMessage = voJsonError["scErrorMessage"];
      throw new Error("Server Error : " + vsErrorMessage);
    }
    default : {
      this.resSessionData = null;
      throw new Error("Server Connection Error");
      break;
    }
    }
  }
  };
  /**
   * client에서 변경된 세션 정보를 사용하여 server의 session정보를 update한다.
   * @return void
   * @type void
   */
  this.update = function() {
  if(this.modified == true) {
    var voJsonBuilder = new eXria.protocols.JSONBuilder();
    var vsJsonStr = voJsonBuilder.toJSONString(this.resSessionData);
    var voHttpRequest = this.getHttpRequest(vsUpdate, vsJsonStr);

    if(voHttpRequest.readyState == 4) {
    var customEval = function(psJsonStr) {
      return (new Function("", "return " + psJsonStr + ";"))();
    };

    switch(voHttpRequest.status) {
      case 200 : {
      this.modified = false;
      break;
      }
      case 500 : {
      var voJsonError = customEval(voHttpRequest.responseText);
      var vsErrorMessage = voJsonError["scErrorMessage"];
      throw new Error("Server Error : " + vsErrorMessage);
      }
      default : {
      throw new Error("Server Connection Error.");
      break;
      }
    }
    }
  }
  };
  /**
   * 파라미터로 받는 Key와 일치하는 session 정보를 읽어 리턴.
   * @param {String} psName 가져오길 원하는 데이터의 Key값
   * @return 세션의 key가 일치하는 데이터
   * @type Object
   */
  this.getAttribute = function(psName) {
  if(psName == null || psName == undefined) return;

  if(this.resSessionData) {
    return this.resSessionData[psName];
  } else {
    return null;
  }
  };
  /**
   * 파라미터로 받는 key와 value를 세션에 셋팅한다.
   * value로 실제 올 수 있는 데이터는
   * primitive, list(eXria.data.Collection), map(eXria.data.Map) Type이다.
   * @param {String} psName 추가할 데이터의 Key
   * @param {Object} poValue 추가할 데이터의 Value
   * @return void
   * @type void
   */
  this.setAttribute = function(psName, poValue) {
  if(psName == null || psName == undefined) return;

  if(poValue instanceof eXria.data.Map) {
    poValue = poValue.entries;
  } else if(poValue instanceof eXria.data.Collection){
    poValue = poValue.elements;
  }

  try {
    this.resSessionData[psName] = poValue;
  } catch (e) {
    throw new Error("Session data is null.");
  }
  this.modified = true;
  };
  /**
   * 파라미터로 넘어온 Key와 일치하는 세션 정보를 삭제한다.
   * @param {String} psName 삭제할 데이터의 Key
   * @return void
   * @type void
   */
  this.removeAttribute = function(psName) {
  if(psName == null || psName == undefined) return;
  delete this.resSessionData[psName];
  this.modified = true;
  };
};

/**
 * @fileoverview
 * eXria.form.xhtml package
 */

/**
 * eXria.form.xhtml package
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */
eXria.form.xhtml = {};

/**
 * @fileoverview
 * 화면에 표시되는 모든 객체 및 이벤트를 관리하는 클래스
 */

/**
 * 화면에 표시되는 모든 객체 및 이벤트를 관리하는 클래스
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} psId Canvas Id
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 * @base eXria.form.Canvas
 */
eXria.form.xhtml.Canvas = function(psId, poPage) {
  /**
   * base
   * @private
   */
  var base = this;
  /**
   * 현재 Canvas 내부에서 일어나는 event를 관리하는 Object
   * @type eXria.event.EventManager
   * @private
   */
  this.eventManager = new eXria.event.EventManager();
  /**
   * tab index
   * @type Number
   * @private
   */
  this.tabIndex = -1; //@private
  /**
   * access key
   * @type Number
   * @private
   */
  this.accessKey = null; //@private
  /**
   * focus control
   * @type Number
   * @private
   */
  this.focusedControl = null; //@private
  /**
   * const key
   * @private
   */
  this.constKey = {
    TAB: 9,
    ALT: 18,
    0: 48,
    9: 57,
    A: 65,
    Z: 90,
    pad0: 96,
    pad9: 105
  };
  /**
   * context menu id
   * @type Number
   * @private
   */
  this.contextMenuId = null;
  /**
   * selected context menu id
   * @type Number
   * @private
   */
  this.selectedContextMenuId = null;  //@private
  /**
   * left
   * readonly
   * @type Number
   * @private
   */
  this.left = 0;  // readonly
  /**
   * top
   * readonly
   * @type Number
   * @private
   */
  this.top = 0;   // readonly
  /**
   * Canvas의 Width
   * @type Number
   */
  this.width = 1024;
  /**
   * Canvas의 Height
   * @type Number
   */
  this.height = 768;
  /**
   * Canvas backgound color
   * @type String
   */
  this.backgroundColor = null;
  /**
   * Canvas backgound image
   * @type String
   */
  this.backgroundImage = null;
  /**
   * Canvas backgound position
   * @type String/Number
   */
  this.backgroundPosition = null;
  /**
   * Canvas backgound repeat
   * @type String
   */
  this.backgroundRepeat = null;

  /**
   * Canvas Color
   * @type String
   */
  this.color = null;              // 컨트롤에 전파되는 속성
  /**
   * Canvas font-Family
   * @type String
   */
  this.fontFamily = null;         // 컨트롤에 전파되는 속성
  /**
   * Canvas font-Size
   * @type Number
   */
  this.fontSize = null;           // 컨트롤에 전파되는 속성
  /**
   * Canvas font-Style
   * @type String
   */
  this.fontStyle = null;          // 컨트롤에 전파되는 속성
  /**
   * Canvas font-Weight
   * @type String
   */
  this.fontWeight = null;         // 컨트롤에 전파되는 속성
  /**
   * Canvas focus-BorderColor
   * @type Number
   */
  this.focusBorderColor = null;   // 컨트롤에 전파되는 속성
  /**
   * Canvas focus-BorderStyle
   * @type String
   */
  this.focusBorderStyle = null;   // 컨트롤에 전파되는 속성
  /**
   * Canvas focus-BorderWidth
   * @type Number
   */
  this.focusBorderWidth = null;     // 컨트롤에 전파되는 속성

  /**
   * Canvas 의 CSS를 저장하고 있는 Map
   * @type eXria.data.ArrayMap
   */
  this.cssClassMap = new eXria.data.ArrayMap();
  
  this.recursiveCnt = 0;
  this.recursiveMap = new eXria.data.ArrayMap();

  /**
   * ctrl
   * @type Object
   * @private
   */
  this.ctrl = null;
  /**
   * @private
   */
  this.eventControlMap = null;
  /**
   * @private
   */
  this.delayedKeydown = new eXria.data.ArrayCollection();

  this.tooltipHandler = {
     //backgroundImage : "eXria/controls/xhtml/images/arrow.gif", // arrowImage
    rightBottomImage   : null,
    leftBottomImage    : null,
    rightTopImage      : null,
    leftTopImage       : null,
    borderWidth        : null,
    borderStyle        : null,
    borderColor        : null,
    backgroundColor    : null,
    fontSize           : null,
    filter             : null,
    opacity            : null,
    width              : null,
    height             : null,
    fontFamily         : null,
    fontStyle          : null,
    fontWeight         : null,
    padding            : null,
    paddingLeft        : null,
    paddingRight       : null,
    paddingTop         : null,
    paddingBottom      : null,
    backgroundImage    : null,
    backgroundPosition : null,
    backgroundRepeat   : null
  };
  /**
   * 컨트롤에 전파되는 툴팁 속성
   */
  /*
  this.tooltip = {
    backgroundImage : "eXria/controls/xhtml/images/arrow.gif", // arrowImage
    borderColor : "#317082",
    borderStyle : "solid",
    borderWidth : 2,
    color : null,
    backgroundColor : "#FFFFFF",
    fontSize : 10,
    filter : "alpha(opacity:70)",
    opacity : "0.70"
  };
  */
  //this.tooltip = null;
  /**
   * @private
   */
  this.df = {};

  /**
   * inherit
   */
  eXria.form.Canvas.call(this, psId, poPage);

  /**
   * canvas 초기화
   * @return void
   * @type void
   * @private
   */
  this.init = function() {
    var voDocument = this.page.window.document;
//    this.loadCssClassMap();

    var voCtrl = voDocument.createElement("div");
    voCtrl.id = this.id;
    voCtrl.tabIndex = 0;

    var vnIEVer = this.page.metadata.browser.ie;
    if(vnIEVer > 0 && vnIEVer < 8) {
      voCtrl.hideFocus = true;
    } else {
      voCtrl.style.outlineStyle = "none";
    }

    voDocument.id = this.id;

    this.eventManager.addListener(voDocument, "onclick", this.mediateEvent);
    this.eventManager.addListener(voDocument, "ondblclick", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmousedown", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmouseup", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmouseover", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmousemove", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmouseout", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onkeypress", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onkeydown", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onkeyup", this.mediateEvent);
    this.eventManager.addListener(voDocument, "onmousewheel", this.mediateEvent);

    //TODO theme theme
    //voCtrl.className = eXria.theme.DefaultStyle.CANVAS;
    //page style setup ?
    voDocument.body.appendChild(voCtrl);

    //html control set 20081127
    this.ctrl = voCtrl;

    // ContextMenu -> UI 컨트롤의 우클릭 시 표시되는 브라우저 기본 메뉴를 제한
    voDocument.oncontextmenu = function() {
      return false;
    };
    this.refresh();
  };
  /**
   * load css class map
   * @private
   */
  this.loadCssClassMap = function() {
    var voCssClassMap = this.cssClassMap;
    var voStyleSheets = this.page.window.document.styleSheets;
    var voStyleSheet = null;
    var voRules = null;
    var voRule = null;
    for (var s = 0; s < voStyleSheets.length; s++) {
      voStyleSheet = voStyleSheets[s];
      try {
        if(voStyleSheet.rules) {                       // IE와 Safari
          voRules = voStyleSheet.rules;
        }
        else if(voStyleSheet.cssRules) {               // FireFox와 Opera
          voRules = voStyleSheet.cssRules;
        }
        for (var r = 0; r < voRules.length; r++) {
          voRule = voRules[r];
          voCssClassMap.put(voRule.selectorText, voRule.style);
        }
      } catch(err) {}
    }
  };

  /**
   * 속성에 대한 값을 리턴
   * @private
   */
  this.getAttrValue = function(psAttrName, psAttrValue) {
    if(psAttrValue != null) {
      return psAttrValue;
    } else {
      var vsAttrValue = null;
      //if(this.canvas)  vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
      if(vsAttrValue != null) {
        return vsAttrValue;
      } else {
        vsAttrValue = this.getDefaultValue(psAttrName);  // TODO : 위의 소스로 교체할것
        return vsAttrValue;
      }
    }
  };
  /**
   * canvas의 default 속성값을 리턴
   * @param {String} psAttrName 속성명
   * @return 속성명에 해당하는 속성값
   * @type String
   */
  this.getDefaultValue = function(psAttrName){
    var vaAttrName = psAttrName.split(".");
    var vsDefaultValue = null;
    if(vaAttrName.length == 1) {
      vsDefaultValue = eXria.controls.xhtml.Default.Form[psAttrName];
    } else if (vaAttrName.length == 2) {
      vsDefaultValue = eXria.controls.xhtml.Default.Form[vaAttrName[0]][vaAttrName[1]] != null ? eXria.controls.xhtml.Default.Form[vaAttrName[0]][vaAttrName[1]] : vsDefaultValue;
    }
    if( vsDefaultValue === undefined) {
      //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
      return null;
    }
    return vsDefaultValue;
  };

  /**
   * Canvas 내부의 모든 객체에 대해 새로 고침을 수행한다.
   * @return void
   * @type void
   */
  this.refresh = function() {
    /* style */
    this.df = {};
    var voDf = this.df;
    var voCtrl = this.getCtrl();

  // yhkim 2009.09.16  최외곽에도 class를 적용해줘야 한다.
  voCtrl.className = "Default_Form_Class";

    voCtrl.style.position = "absolute";
    voCtrl.style.overflow = "hidden";
    voCtrl.style.top = "0px";
    voCtrl.style.left = "0px";

    this.backgroundColor = this.getAttrValue("backgroundColor", this.backgroundColor);
    this.backgroundImage = this.getAttrValue("backgroundImage", this.backgroundImage);
    if(this.backgroundImage != null) {
      this.backgroundImage = eXria.controls.xhtml.Util.getBackgroundImagePath(this.backgroundImage, this.page.window);
    }
    this.backgroundPosition = this.getAttrValue("backgroundPosition", this.backgroundPosition);
    this.backgroundRepeat = this.getAttrValue("backgroundRepeat", this.backgroundRepeat);

    if(this.backgroundColor) {
        voCtrl.style.backgroundColor = this.backgroundColor;
      }
    if(this.backgroundImage !== null ) {
      if(this.backgroundImage === '') this.backgroundImage = 'none';
    voCtrl.style.backgroundImage = this.backgroundImage;
      if(this.backgroundRepeat) {
          voCtrl.style.backgroundRepeat = this.backgroundRepeat;
      } else {
        //voCtrl.style.backgroundRepeat = "no-repeat";
      }
    }
    if(this.backgroundPosition) {
      voCtrl.style.backgroundPosition = this.backgroundPosition;
    } else {
      //voCtrl.style.backgroundPosition = "center center";
    }

    if(this.width) voCtrl.style.width = "" + this.width + "px";
    else voCtrl.style.width = "100%";
    if(this.height) voCtrl.style.height = "" + this.height + "px";
    else voCtrl.style.height = "100%";
    /* style */

    var voProgressCtrl = page.model.progressCtrl;
    if(voProgressCtrl) {
      voProgressCtrl.style.left = (this.width - page.model.pgImgWh) / 2 + "px";
      voProgressCtrl.style.top = (this.height - page.model.pgImgHt) / 2 + "px";
    }
  };

  /**
   * 페이지 내부의 최상위 div를 리턴
   * @return 페이지 내부의 최상위 div 객체
   * @type Object
   */
  this.getCtrl = function() {
  return this.ctrl; //20081127
    //return this.page.window.document.getElementById(this.id);
  };

  /**
   * 넘어온 속성에 맞춰 해당 control을 생성한다.
   * @param {String} psType type
   * @param {String} psId id
   * @param {Number} pnLeft left
   * @param {Number} pnTop top
   * @param {Number} pnWidth width
   * @param {Number} pnHeight height
   * @return eXria.controls.Control
   * @type eXria.controls.Control
   */
  this.createControl = function(psType, psId, pnLeft, pnTop, pnWidth, pnHeight) {
    var voControl = this.getControl(psId);
    if (voControl != null) { throw new Error("Control Id is already exist : " + psId); }
    var voType = eXria.controls.xhtml.ControlTypeProvider.get(psType);
    voControl = new voType(psId, pnLeft, pnTop, pnWidth, pnHeight);
    this.ctlMap.put(psId, voControl);
    return voControl;
  };

  /**
   * 파라미터로 넘어온 컨트롤을 canvas에 추가 시킨다.
   * @param {eXria.control.Control} poControl control
   * @return void
   * @type void
   */
  this.appendControl = function(poControl) {
    var voControl = this.getControl(poControl.id);
    if(voControl != null) { throw new Error("Control is already appended : " + poControl.id); }
    if(poControl.isLoaded()) { throw new Error("Control is already loaded : " + poControl.id); }
    poControl.canvas = this; /* control에  canvas 세팅 */
    poControl.window = this.page.window;
    poControl.document = poControl.window.document;
    var voCtrl = poControl.create();
    var voCanvasCtrl = this.getCtrl();

    if(voCtrl) {
      if(voCanvasCtrl != voCtrl.parentNode) voCanvasCtrl.appendChild(voCtrl);
    }
    this.controls.put(poControl.id, poControl);
    this[poControl.id] = poControl;
    if(poControl.load) {
      poControl.load(poControl.document, poControl);
    }
  };

  /**
   * 다국어 사용시 Container Control에 Import가 있을 경우 문제를 해결하기 위한 메소드
   * @type void
   * @private
   */
  this.appendSubImp = function() {
  var voCtls = this.controls.getValueCollection();
  var voContainer = null, voMoveCtl = null, voTabPageSet = null;
  var voTabPage = null, voImpList = null, voImpName = null, voParent = null;
  var vnCtlLen = 0, vnTabPageLen = 0, vnImpLen = 0;
  var i, j, k, m;

  var voDoc = this.page.window.document;
  var voXhtml = eXria.controls.xhtml;

  for(i = 0, vnCtlLen = voCtls.size() ; i < vnCtlLen ; i++) {
    voContainer = voCtls.get(i);
    if(voContainer instanceof voXhtml.Tab || voContainer instanceof voXhtml.SlideTab) {
    voTabPageSet = (voContainer.tabPageSet) ? voContainer.tabPageSet : voContainer.contentPaneSet;

    for(j = 0, vnTabPageLen = voTabPageSet.size() ; j < vnTabPageLen ; j++) {
      voTabPage = voTabPageSet.get(j);  //subPage 리스트 가져옴
      voImpList = voTabPage.impList;  //impList 가져옴
      if(voImpList.size() == 0) { continue; }
      else {  //list를 가지고 있을때
      for(k = 0, vnImpLen = voImpList.size() ; k < vnImpLen ; k++) {
        voImpName = voImpList.get(k);
        voMoveCtl = voDoc.getElementById(voImpName);
        voMoveCtl = voMoveCtl.parentNode.removeChild(voMoveCtl);
        voParent = voDoc.getElementById(voTabPage.id);
        voParent.appendChild(voMoveCtl);
      }
      }
    }
    } else if(voContainer instanceof voXhtml.FreeForm || voContainer instanceof voXhtml.Group) {
    voImpList = voContainer.impList;
    if(voImpList.size() == 0) { continue; }
    else {
      for(m = 0, vnImpLen = voImpList.size() ; m < vnImpLen ; m++) {
      voImpName = voImpList.get(m);
      voMoveCtl = voDoc.getElementById(voImpName);
      voMoveCtl = voMoveCtl.parentNode.removeChild(voMoveCtl);
      voParent = voDoc.getElementById(voContainer.id);
      voParent.appendChild(voMoveCtl);
      }
    }
    }
  }
  };

  //20081204-1 test
  //
  /**
   * register control
   * 넘어온 control을 canvas에 등록한다.
   * @param {eXria.controls.Control} poControl control
   * @return void
   * @type void
   * @private
   */
  this.registerControl = function(poControl) {
    var voControl = this.getControl(poControl.id);
    if(voControl != null) { throw new Error("Control is already registered : " + poControl.id); }
    this.controls.put(poControl.id, poControl);
    this[poControl.id] = poControl;
  };
  /**
   * unregister control
   * 넘어온 ID의 control이 canvas에 등록되어 있을 경우 등록을 해지한다.
   * @param {String} psId Control ID
   * @return void
   * @type void
   * @private
   */
  this.unregisterControl = function(psId) {
    var voControl = this.getControl(psId);
    if(voControl == null) { throw new Error("Control does not exist : " + psId); }
    if(this.focusedControl == voControl) this.focusedControl = null;
    if(this.collapseControl == voControl) this.collapseControl = null;
    this.controls.remove(psId);
    delete this[psId];
  };

  /**
   * 파라미터로 넘어온 ID의 control을 삭제한다.
   * @param {String} psId Control ID
   * @return void
   * @type void
   */
  this.removeControl = function(psId) {
    var voControl = this.getControl(psId);
    var voCtrl = voControl.getCtrl();
    if(this.focusedControl == voControl) this.focusedControl = null;
    voControl.clear();
    if(voCtrl.parentNode) voCtrl.parentNode.removeChild(voCtrl);
    this.controls.remove(psId);
    delete this[psId];
  };

  /**
   * ContextMenu를 보임
   * @param {String} psId context ID
   * @param {String} psMenuId menu ID
   * @param {Number} pnLeft Left
   * @param {Number} pnTop Top
   * @return void
   * @type void
   */
  this.showContextMenu = function(psId, psMenuId, pnLeft, pnTop) {
    var that = this;
    var voFunc = function(){
      that.hideContextMenu();
      var voDocument = that.page.window.document;
      var voMenuControl = that.getControl(psMenuId);
      if(voMenuControl == null || voMenuControl.visible == false) return;

      var vsDisplay = voMenuControl.ctrl.style.display;
      if(voMenuControl != null && voMenuControl !== undefined && vsDisplay == "none") {
        voMenuControl.baseControlId = psId;
        voMenuControl.left = pnLeft;
        voMenuControl.top = pnTop;
        voMenuControl.isShowing = true;
        voMenuControl.visible = true;
        voMenuControl.refresh();
        that.selectedContextMenuId = psMenuId;
        that.collapseControl = voMenuControl;
      }
    }

    if(!!this.page.metadata.browser.webkit){
      window.setTimeout(voFunc,200);
    } else {
      voFunc();
    }
  };

  /**
   * ContextMenu를 숨김
   * @return void
   * @type void
   */
  this.hideContextMenu = function() {
    if(this.selectedContextMenuId) {
      var voDocument = this.page.window.document;
      var voMenuControl = this.getControl(this.selectedContextMenuId);

      // 컨텍스트 메뉴 자신을 안보이게 처리
      var voMenuCtrl = voDocument.getElementById(voMenuControl.id);
      if(voMenuCtrl) voMenuCtrl.style.display = "none";
      voMenuControl.isShowing = false;

      this.collapseControl = null;

      if(voMenuControl.showedItem) {
        this.hideContextSubMenu(voMenuControl.showedItem);
        voMenuControl.showedItem = null;
      }

      this.selectedContextMenuId = null;
    }
  };
  /**
   * 서브 메뉴가 있는 경우 그 상위 아이템 메뉴까지 찾아가며 안보이게 처리하는 메소드
   * @param {eXria.controls.xhtml.MenuItem} poItem 서브 메뉴를 포함하는 아이템 객체
   * @return void
   * @type void
   * @private
   */
  this.hideContextSubMenu = function(poItem) {
    var voDocument = this.page.window.document;
    var voSubCtrl = voDocument.getElementById(poItem.id + "_SubMenu");
    if(voSubCtrl) voSubCtrl.style.display = "none";
    if(poItem.parent) this.hideContextSubMenu(poItem.parent);
  };

  /**
   * 컨트롤에 전파되는 폼 속성의 값을 구함.
   * @param {String} psAttrName 속성명
   * @return 컨트롤에 전파되는 폼 속성 값
   * @type Object
   * @private
   */
  this.getFormExtendAttrValue = function(psAttrName) {
    if(psAttrName == "color" || psAttrName == "fontFamily" || psAttrName == "fontSize" ||
    psAttrName == "fontStyle" || psAttrName == "fontWeight" || psAttrName == "focusBorderColor" ||
    psAttrName == "focusBorderStyle" || psAttrName == "focusBorderWidth") {
      return this[psAttrName];
    } else {
      return null;
    }
  };

  /**
   * 폼 속성의 디폴트 값을 구함.
   * @param {String} psAttrName 속성 이름
   * @return 넘어온 속성명에 대한 디폴트 값
   * @type String
   */
  this.getFormDefaultValue = function(psAttrName) {
    var vsDefaultValue = eXria.controls.xhtml.Default.Form[psAttrName];
    if(vsDefaultValue === undefined) return null;
    else return vsDefaultValue;
  };
  /**
   * tab index를 설정한다.
   * @param {Number} pnIndex
   * @param {eXria.controls.Control} poControl
   * @return void
   * @type void
   */
  this.setTabIndex = function(pnIndex, poControl) {
    if(pnIndex < 0 || pnIndex > this.controls.size()) {
      throw new Error("TabIndex must be with range(0 ~ " + (this.controls.size()) + ")");
    }
    var vnOldTabIndex = poControl.tabIndex;

    var voControls = this.controls.entries;
    var voControl = null;

    for(var member in voControls) {
      if(voControls[member].tabIndex == pnIndex) {
      voControls[member].tabIndex = vnOldTabIndex;
      break;
      }
    }
    poControl.tabIndex = pnIndex;
  };
  /**
   * mediate event
   * @return Boolean
   * @private
   */
  this.mediateEvent = function(e) {
    try {
      if(e != null || page.metadata.browser.ie != 0) base.runEvent(e, base);
    } catch(err) {
      return false;
    }
  };
  /**
   * run event
   * @param {eXria.controls.Control} poControl
   * @return void
   * @type void
   * @private
   */
  this.runEvent = function(e, poControl){
    var voEvent = new eXria.event.Event(e, this.page.window);
    var vsType = voEvent.type;
    var vsAtEvent = "at" + vsType;    // 컨트롤별 이벤트 처리
    var vsCoEvent = "co" + vsType;    // 공통 이벤트 처리
    var vsOnEvent = "on" + vsType;    // 사용자 지정 이벤트 처리
    var vsFinalEvent = "final" + vsType;    //이벤트 종료 처리
    if(vsType == "mouseover") {
      this.mouseoverObj = null;
    }

    if(vsType == "click" && this.isRClick(voEvent)) return;
    if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
    if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
    if (poControl[vsOnEvent]) { try { poControl[vsOnEvent](voEvent); } catch(err) {} }
    if (poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
  };

  /**
   * at mouse wheel
   * 마우스 휠 이벤트를 처리한다.
   * @return void
   * @type void
   * @private
   */
//  this.atmousewheel = function(e) {
//    var voTarget = e.target;
//    this.setFocusByControl(null, null, voTarget);
//    this.doCollapseForAllFrame();
//  };
  
  // ContextMenu
  /**
   * at mouse down
   * 마우스 다운 이벤트를 처리한다.
   * @return 왼쪽 마우스 클릭 시 true 리턴, 오른쪽 마우스 클릭 시 context menu 호출
   * @type Boolean
   * @private
   */
  this.atmousedown = function(e) {
//      if (!base.inElement(e, base.id)) {
//        var voTarget = e.target;
//        this.setFocusByControl(null, null, voTarget);
//        }
//      }
    if (base.isRClick(e)) {
      base.showContextMenu(base.id, base.contextMenuId, e.clientX, e.clientY);
    }
  };
  /**
   * 클릭 이벤트를 처리한다.
   * @param {Object} e event
   * @return void
   * @type void
   * @private
   */
  this.atclick = function(e) {
    var voTarget = e.target;
    this.setFocusByControl(null, null, voTarget);
    this.doCollapseForAllFrame();
  };

  /**
   * keydown 이벤트를 처리한다.
   * @param {Object} poEvent event
   * @return void
   * @type void
   * @private
   */
  this.atkeydown = function(poEvent) {
    if(poEvent.target && (poEvent.target.readOnly || (poEvent.target.tagName != "INPUT" && poEvent.target.tagName != "TEXTAREA"))) {
      if(poEvent.keyCode == 8) poEvent.stopEvent();
    }
    if(this.focusedControl && this.focusedControl.toString() == "GridEx") {
      return;
    }
    var vnKeyCode = poEvent.keyCode;
    if((poEvent.ctrlKey) && (vnKeyCode >= this.constKey["0"] && vnKeyCode <= this.constKey["pad9"])) {
      this.onHotKey(poEvent);
      if(this.selectedContextMenuId) poEvent.stopEvent();
      return;
    }

    if((vnKeyCode != this.constKey["TAB"]) &&
      (poEvent.altKey == false || (vnKeyCode < this.constKey["a"] || vnKeyCode > this.constKey["Z"]))) {
        return;
    }

    if(poEvent.altKey) this.onAccessKey(poEvent);
    if(vnKeyCode == this.constKey["TAB"]) this.onTab(poEvent);
    return;
  };

  /**
   * keyup 이벤트를 처리한다.
   * @param {Object} poEvent event
   * @return void
   * @type void
   * @private
   */
  this.atkeyup = function(poEvent) {
    var voCollection = this.delayedKeydown;
    var vnSize = voCollection.size();
    if(vnSize > 0) {
      for(var i = 0; i < vnSize; i++) {
        var voAction = voCollection.get(i);
        voAction(poEvent);
      }
      voCollection.clear();
    }
  };

  /**
   * 마우스 오른쪽 버튼이 눌려졌는지를 체크
   * @return 오른쪽 마우스가 눌렸다면 true, 아니라면 false 리턴
   * @type Boolean
   * @private
   */
  this.isRClick = function(e) {
    return (e.mousebutton == 2) ? true : false;
  };

  /**
   * 이벤트가 Form에서 발생했는지를 확인
   * @param {Object} e event
   * @param {String} psCanvasId
   * @return Boolean
   * @private
   */
  this.inElement = function(e, psCanvasId) {
    if(e.target.id == psCanvasId) return true;
    else if(e.target.parentNode == document && e.target.parentNode.id == psCanvasId) {
      return true;
    }
    else
      return false;
  };
  /**
   * 탭이 눌렸을때를 처리
   * @param {Object} poEvent
   * @return void
   * @type void
   * @private
   */
  this.onTab = function(poEvent) {
//debugger;
    var voContainer = null;
    var voFocusedControl = this.focusedControl;
    if(voFocusedControl) {
      if(voFocusedControl.parent) {
        voContainer = voFocusedControl.parent;
      }
    }
    var vnSize = this.getTabedSize(voContainer);
    var vnTab = this.tabIndex;
    var voControl = null;
    var voSubControls = null;
    var voBegin = null;
    var vbContinue = null;
    var vbOut = null;
    var vnBeginCnt = 0;
    do {
      vbOut = false;
      if(poEvent.shiftKey == true) {
        vnTab--;
        if(vnTab < 1) {
          if(voContainer) {
            if(voContainer instanceof eXria.controls.xhtml.TabPage ||
                voContainer instanceof eXria.controls.xhtml.SlidePage) {
              vnTab = voContainer.parent.tabIndex;
            } else {
              vnTab = voContainer.tabIndex;
            }
            if(voContainer.parent) {
              voContainer = voContainer.parent;
              if(voContainer instanceof eXria.controls.xhtml.Tab ||
                  voContainer instanceof eXria.controls.xhtml.SlideTab) {
                if(voContainer.parent) voContainer = voContainer.parent;
                else voContainer = null;
              }
            } else {
              voContainer = null;
            }
            vnSize = this.getTabedSize(voContainer);
            vbOut = true;
          } else {
            vnTab = vnSize;
          }
        }
      } else {
        vnTab++;
        if(vnTab > vnSize || vnTab == 0) {
          if(voContainer) {
            if(voContainer instanceof eXria.controls.xhtml.TabPage ||
                voContainer instanceof eXria.controls.xhtml.SlidePage) {
              vnTab = voContainer.parent.tabIndex;
            } else {
              vnTab = voContainer.tabIndex;
            }
            if(voContainer.parent) {
              voContainer = voContainer.parent;
              if(voContainer instanceof eXria.controls.xhtml.Tab ||
                  voContainer instanceof eXria.controls.xhtml.SlideTab) {
                if(voContainer.parent) voContainer = voContainer.parent;
                else voContainer = null;
              }
            } else {
              voContainer = null;
            }
            vnSize = this.getTabedSize(voContainer);
            vbOut = true;
          } else {
            vnTab = 1;
          }
        }
      }
      voControl = this.getControlByTabIndex(vnTab, voContainer);
      //voControl의 값이 루프 초기값과 같은 지 비교(무한루프 방지 목적)
      if(voControl == voBegin) {
        vnBeginCnt++;
        if(vnBeginCnt == 2) voControl = null;
      }
      if(voBegin == null) voBegin = voControl;
      if(!vbOut && voControl) {
        voSubControls = null;
        voSubControl = null;
        var voPage = null;
        if(voControl instanceof eXria.controls.xhtml.Group || voControl instanceof eXria.controls.xhtml.FreeForm) {
          voSubControls = voControl.controls;
        } else if(voControl instanceof eXria.controls.xhtml.Tab ||
            voControl instanceof eXria.controls.xhtml.SlideTab) {
          voPage = voControl.getPage(voControl.selectedIndex);
          if(voPage) voSubControls = voPage.controls;
        }
        if(voSubControls) {
          if(poEvent.shiftKey == true) voSubControl = this.getFirstTabedSub(voSubControls, true);
          else voSubControl = this.getFirstTabedSub(voSubControls);
        }
        if(voSubControl) {
          voControl = voSubControl;
          vnTab = voControl.tabIndex;
          if(voControl.parent) vnSize = this.getTabedSize(voControl.parent)
        }
      }
      vbContinue = false;
      if(voControl) {
        if(voControl instanceof eXria.controls.xhtml.Group ||
          voControl instanceof eXria.controls.xhtml.FreeForm ||
            voControl instanceof eXria.controls.xhtml.Tab ||
            voControl instanceof eXria.controls.xhtml.SlideTab) {
          vbContinue = true;
        }
      }

    if(voControl.visible == false || voControl.disabled == true) {
      if(voContainer === null && vnTab >= vnSize) vbContinue = false;
    else vbContinue = true;
    }
    } while(vbContinue)

    if(voControl) this.setFocusByControl(voControl, poEvent);
    poEvent.stopEvent();
  };

  /**
   * getFirstTabCtl
   * @param {eXria.controls.Control} poControls control Collection
   * @return {eXria.controls.Control} control Object
   * @private
   */
  this.getFirstTabCtl = function(poControls){
    var vnSize = poControls.size();
    var voControl = null;
    var voFirstTabedControl = null;

    var vaCList = [], vaGList = [];

    for(var i = 0; i < vnSize; i++) {
      voControl =  poControls.get(i);
      if(voControl.tabIndex > 0) {
        if(voControl.visible != false && voControl.disabled != true) {
          if("Freeform" === voControl.toString() ||
             "SlideTab" === voControl.toString() ||
             "Tab" === voControl.toString() ||
             "Group" === voControl.toString()) {
            vaGList.push(voControl);
          }else{
            vaCList.push(voControl);
          }
        }
      }
    }

    var voFnc = function(a, b){
      if(a.tabIndex < b.tabIndex)
        return -1;
      if(a.tabIndex > b.tabIndex)
        return 1;

      return 0;
    };

    if(!!vaCList[0]){
      vaCList.sort(voFnc);
      vaGList.sort(voFnc);
      voFirstTabedControl = vaCList[0];

      if(!!vaGList[0] && vaCList[0].tabIndex <= vaGList[0].tabIndex && null != vaGList[0].controls){
        voFirstTabedControl = this.getFirstTabCtl(vaGList[0].controls);
      }
    }else if(!!vaGList[0]){
      vaGList.sort(voFnc);
      
      if(!!vaGList[0] <= vaGList[0].tabIndex && null != vaGList[0].controls){
        voFirstTabedControl = this.getFirstTabCtl(vaGList[0].controls);
      }
    }
    
    return voFirstTabedControl;
  };

  /**
   * getFirstTabedSub
   * @param {eXria.controls.Control} poControls control Collection
   * @param {Boolean} pbReverse 재귀호출 유무
   * @param {Number} pnBound parent control의 tab index
   * @return {eXria.controls.Control} control Object
   * @private
   */
  this.getFirstTabedSub = function(poControls, pbReverse, pnBound) {
    var vnSize = poControls.size();
    var voControl = null;
    var voFirstTabedControl = null;
    for(var i = 0; i < vnSize; i++) {
      voControl =  poControls.get(i);
      if(voControl.tabIndex > 0) {
        if(voControl.visible != false && voControl.disabled != true) {
          if(pbReverse) {
            if(voFirstTabedControl == null || voControl.tabIndex > voFirstTabedControl.tabIndex) {
              if(pnBound == null) voFirstTabedControl = voControl;
              else if(voControl.tabIndex < pnBound) voFirstTabedControl = voControl;
            }
          } else {
            if(voFirstTabedControl == null || voControl.tabIndex < voFirstTabedControl.tabIndex) {
              if(pnBound == null) voFirstTabedControl = voControl;
              else if(voControl.tabIndex > pnBound) voFirstTabedControl = voControl;
            }
          }
        }
      }
    }
    var voBound = null;
    if(voFirstTabedControl instanceof eXria.controls.xhtml.Group) {
      voBound = voFirstTabedControl;
      voFirstTabedControl = this.getFirstTabedSub(voFirstTabedControl.controls, pbReverse);
    } else if(voFirstTabedControl instanceof eXria.controls.xhtml.Tab ||
        voFirstTabedControl instanceof eXria.controls.xhtml.SlideTab) {
      voBound = voFirstTabedControl;
      var voPage = voFirstTabedControl.getPage(voFirstTabedControl.selectedIndex);
      if(voPage) {
        voFirstTabedControl = this.getFirstTabedSub(voPage.controls, pbReverse);
      } else {
        voFirstTabedControl = null;
      }
    }
    if(voFirstTabedControl == null && voBound) {
      voFirstTabedControl = this.getFirstTabedSub(voBound.parent.controls, pbReverse, voBound.tabIndex);
    }

    return voFirstTabedControl;
  };

  /**
   * getTabedSize
   * @param {Object} poContainer
   * @return tabedsize
   * @type Number
   * @private
   */
  this.getTabedSize = function(poContainer) {
    var voParent = poContainer;
    if(poContainer == null) {
      poContainer = this;
    }
    var vnCnt = 0;
    var voControls = poContainer.controls
    var vnSize = voControls.size();
    var voCollection = null;
    if(voControls instanceof eXria.data.ArrayMap) {
      //voCollection = voControls.getValueCollection();
      voCollection = voControls.entries;
      for (var member in voCollection) {
    var voControl = voCollection[member];
    // 2009.09.18 yhkim
    if(voControl.tabIndex > 0 && voControl.parent == voParent) {
      vnCnt++;
    }
      }
    } else {
      voCollection = voControls;

      var voControl = null;
      for(var i = 0; i < vnSize; i++) {
        voControl = voCollection.get(i);
        // 2009.09.18 yhkim
    if(voControl.tabIndex > 0 && voControl.parent == voParent) {
          vnCnt++;
        }
      }
    }
//    var voControl = null;
//    for(var i = 0; i < vnSize; i++) {
//      voControl = voCollection.get(i);
//      if(voControl.df.tabIndex > 0 && voControl.parent == voParent) {
//        vnCnt++;
//      }
//    }
    return vnCnt;
  };
  /**
   * getControlByTabIndex
   * @param {Number} pnTabIndex
   * @param {Object} poContainer
   * @return voControl
   * @type eXria.controls.Control
   * @private
   */
  this.getControlByTabIndex = function(pnTabIndex, poContainer) {
    var voParent = poContainer;
    if(poContainer == null) poContainer = this;
    var voControls = poContainer.controls;
//    var voIterator = null;
    var voControl = null;

    if(voControls instanceof eXria.data.ArrayMap) {
      //voIterator = voControls.getValueCollection().iterator();
      var voElements = voControls.entries;
      for(var member in voElements) {
      voControl = voElements[member];
      if(voControl.tabIndex == pnTabIndex && voControl.parent == voParent) {
          break;
        }
      }
    } else {
      var voIterator = voControls.iterator();
      while(voIterator.hasNext()) {
      voControl = voIterator.next();
      if(voControl.tabIndex == pnTabIndex && voControl.parent == voParent) {
        break;
      }
      }
    }
    return voControl;
  };
  /**
   * onAccessKey
   * access key가 눌렸을때의 이벤트 처리
   * @param {Object} poEvent
   * @private
   */
  this.onAccessKey = function(poEvent) {
    var voOldFocusedControl = this.focusedControl;
    var vsKey = String.fromCharCode(poEvent.e.keyCode);
    vsKey = vsKey.toUpperCase();
    var vsControlKey = null;

    var voElements = this.controls.entries;

    var voControl = null;
    var vbPrevious = false, vbCurrent = false;
    if(voOldFocusedControl == null) vbPrevious = true;

    for(var member in voElements) {
      voControl = voElements[member];
      vsControlKey = voControl.accessKey;
      if(vsControlKey != null) vsControlKey = vsControlKey.toUpperCase();
      if(voControl == voOldFocusedControl) {
        if(voControl.setFocusStyle) voControl.setFocusStyle(false);
        if(voControl.doblur) voControl.doblur();
        vbPrevious = true;
      }
      if(vsControlKey == vsKey) {
        if(voControl.setFocusStyle) voControl.setFocusStyle(true);
        if(voControl.dofocus) voControl.dofocus();
        vbCurrent = true;
        this.focusedControl = voControl;
        if(voControl.tabIndex != 0) this.tabIndex = voControl.tabIndex;
      }
      if(vbPrevious && vbCurrent) break;
    }
    poEvent.stopEvent();
  };

  /**
   *  Ctrl + HotKey의 조합에서 HotKey 문자만을 추출.
   *  @param {String} psHotKey
   *  @return HotKey 문자
   *  @type String
   *  @private
   */
  this.getHotKeyChar = function(psHotKey) {
    var vaHotKey = null;
    var vsReturnChar = null;
    if(psHotKey == null || psHotKey === undefined || psHotKey == "") return "";
    vaHotKey = psHotKey.split(" ");
    if(vaHotKey.length == 3) {
        vsReturnChar = vaHotKey[2];
        if(vsReturnChar.length > 2) new Error("HOT Key is not one character");
    } else {
      vaHotKey = psHotKey.split("+");
      vsReturnChar = vaHotKey[0];
    }
    return eXria.util.StringUtil.trim(vsReturnChar).toUpperCase();
  };
  /**
   * onHotKey
   * hot key가 눌렸을 경우의 이벤트 처리
   * @param {Object} poEvent event
   * @return void
   * @type void
   * @private
   */
  this.onHotKey = function(poEvent) {
    var vsKey = String.fromCharCode(poEvent.keyCode);
    var voElements1, voElements2 = null;
    var voChildItem1, voChildItem2 = null;
    var voMenuControl = null;

    if(this.selectedContextMenuId != null) {
      voMenuControl = this.getControl(this.selectedContextMenuId);

      if(voMenuControl && voMenuControl.visible == true) {
        //voIterator1 = voMenuControl.items.getValueCollection().iterator();
      voElements1 = voMenuControl.items.entries;

      for(var member in voElements1) {
        voChildItem1 = voElements1[member];
          if(this.getHotKeyChar(voChildItem1.hotKey) == vsKey) {
            voChildItem1.selected = true;
            voMenuControl.selectedItem = voChildItem1;
            poEvent.objectType = "item";
            poEvent.object = voChildItem1;
            poEvent.baseControlId = voMenuControl.baseControlId;
            if(voMenuControl.atclick) voMenuControl.atclick(poEvent);
            if(voMenuControl.coclick) voMenuControl.coclick(poEvent);
            if(voMenuControl.onclick) voMenuControl.onclick(poEvent);
            this.hideContextMenu();
          }
        if(voMenuControl.showedItem) {
        if(voMenuControl.showedItem.id == voChildItem1.id) {
          voElements2 = voChildItem1.items.entries;
          for(var member2 in voElements2) {
            voChildItem2 = voElements2[member2];

              if(this.getHotKeyChar(voChildItem2.hotKey) == vsKey) {
                  voChildItem2.selected = true;
                  voMenuControl.selectedItem = voChildItem2;
                  poEvent.objectType = "item";
                  poEvent.object = voChildItem2;
                  poEvent.baseControlId = voMenuControl.baseControlId;
                if(voMenuControl.atclick) voMenuControl.atclick(poEvent);
                  if(voMenuControl.coclick) voMenuControl.coclick(poEvent);
                  if(voMenuControl.onclick) voMenuControl.onclick(poEvent);
                    this.hideContextMenu();
              }
            }
          }
        }
      }
    }
    }
  };
  /**
   * setFocus
   * 포커싱이 일어난 컨트롤에 대한 처리를 해준다.
   * @param {Number} pnTabIndex
   * @return void
   * @type void
   * @private
   */
  this.setFocus = function(pnTabIndex) {
    var voOldFocusedControl = this.focusedControl;
    var voElements = this.controls.entries;
    var voControl = null;
    var vbPrevious = false, vbCurrent = false;
    if(voOldFocusedControl == null) vbPrevious = true;

    for(var member in voElements) {
      voControl = voElements[member];
      if(voControl == voOldFocusedControl) {
        if(voControl.setFocusStyle) voControl.setFocusStyle(false);
        if(voControl.doblur) voControl.doblur();
        vbPrevious = true;
        if(voControl.toString && voControl.toString() == "ComboBox") {
          if(voControl != this.focusedControl) voControl.showList(false);
        }
      }

      if(voControl.tabIndex == pnTabIndex) {
        // 2009.07.20 focus시에 그룹 컨트롤 확인하기
        var vnCnt = this.controls.cnt;
        if(vnCnt > 1 && voControl.parent && voControl.parent.toString) {
          var voParent = voControl.parent.toString();
          if( voParent == "Group" || voParent == "SlideTab" ||
              voParent == "FreeForm" || voParent == "SubPage" || voParent == "tab")
            continue;
        }
        this.focusedControl = voControl;
        this.tabIndex = pnTabIndex;
        if(voControl.setFocusStyle) voControl.setFocusStyle(true);
        if(voControl.dofocus) voControl.dofocus();
        vbCurrent = true;
      }
      if(vbPrevious && vbCurrent) return;
    }


    this.clearAllFocus();
  };
  /**
   * setFocusByControl
   * 파라미터로 넘어온 컨트롤에 포커스를 맞춰준다.
   * @param {eXria.controls.Control} poControl
   * @param {eXria.event.Event} poEventToStop
   * @return void
   * @type void
   */
  this.setFocusByControl = function(poControl, poEventToStop) {
    if(poEventToStop) poEventToStop.stopEvent();
    if(!!poControl && !!poControl['disabled']) return;

    var voControl = null;
    voControl = this.focusedControl;
  // 초기 포커스가 없는 경우 부모노드에 포커스를 준다(form,group등)
  // subPage밀리는 현상으로 롤백
//  if(this.focusedControl === null) {
//    if(poControl && poControl.getCtrl() && poControl.getCtrl().parentNode) {
//      poControl.getCtrl().parentNode.focus();
//      poControl.getCtrl().parentNode.blur();
//    }
//  }

    if(voControl) {
      if(voControl.setFocusStyle) voControl.setFocusStyle(false);
      if(voControl.doblur) voControl.doblur();
    }
    this.focusedControl = null;

    var voCollapseControl = this.collapseControl;
    if(voCollapseControl && (voCollapseControl != poControl)) {
      this.doCollapseControl(this);
    }

    if(poControl) {
      if(poControl.setFocusStyle) poControl.setFocusStyle(true);
      this.focusedControl = poControl;
      // 2009.09.18 yhkim
    this.tabIndex = poControl.tabIndex;
      if(poControl.dofocus) poControl.dofocus(poEventToStop);
    } else {
      this.tabIndex = -1;
    }
  };
  /**
   * makeEventControlMap
   * @param {Object} poElement
   * @return voMap
   * @type eXria.data.Map
   * @private
   */
  this.makeEventControlMap = function(poElement) {
    var voMap = new eXria.data.ArrayMap();
    var voParent = null;
    var voControl = null;
    var vsId = null;
    voParent = poElement.parentNode;
    while(voParent) {
      if(voParent.id) vsId = voParent.id;
      if(vsId) {
        voControl = this.getControl(vsId);
        if(voControl) voMap.put(vsId, voControl);
      }
      voParent = voParent.parentNode;
    }
    return voMap;
  };
  /**
   * 컨트롤의 포커싱을 해제한다.
   * @return void
   * @type void
   */
  this.clearFocus = function() {
    //var voIterator = this.controls.getValueCollection().iterator();
  var voElements = this.controls.entries;
    var voControl = null;

    for(var member in voElements) {
      voControl = voElements[member];
      if(voControl.tabIndex == this.tabIndex || voControl == this.focusedControl) {
        if(voControl.setFocusStyle) voControl.setFocusStyle(false);
        this.tabIndex = -1;
        break;
      }
    }
  };
  /**
   * 모든 컨트롤의 포커싱을 해제한다.
   * @return void
   * @type void
   */
  this.clearAllFocus = function() {
    //var voIterator = this.controls.getValueCollection().iterator();
    var voElements = this.controls.entries;
    var voControl = null;

    for(var member in voElements) {
      voControl = voElements[member];
      if(voControl.setFocusStyle) voControl.setFocusStyle(false);
      if(voControl.toString && voControl.toString() == "ComboBox") voControl.showList(false);
      this.tabIndex = -1;
      this.focusedControl = null;
    }
  };
  /**
   * 등록된 이벤트를 해제한다.
   * @return void
   * @type void
   */
  this.clearEvents = function() {
    var voDocument = this.page.window.document;
    var voId = voDocument.id;
    voDocument.oncontextmenu = null;
    voDocument.ondragstart = null;
    var voTargetMember = this.eventManager.events.get(voId + ".onclick");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onclick", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".ondblclick");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "ondblclick", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onmousedown");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmousedown", this.mediateEvent);
    var voTargetMember = this.eventManager.events.get(voId + ".onmouseup");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmouseup", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onmouseover");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmouseover", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onmousemove");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmousemove", this.mediateEvent);
    var voTargetMember = this.eventManager.events.get(voId + ".onmouseout");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmouseout", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onkeypress");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onkeypress", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onkeydown");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onkeydown", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onkeyup");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onkeyup", this.mediateEvent);
    voTargetMember = this.eventManager.events.get(voId + ".onmousewheel");
    if(voTargetMember) this.eventManager.removeListener(voDocument, "onmousewheel", this.mediateEvent);
  };

  /**
   * canvas에 속한 모든 컨트롤을 해제.
   * @return void
   * @type void
   * @private
   */
  this.close = function() {
    //canvas에 속한 컨트롤들을 모두 제거한다.
//    for(var member in this) {
//      if(this[member]) {
//        this[member].ctrl = null;
//      }
//    }
//    this.ctrl = null;
  };
  /**
   * getCssStyle
   * 파라미터로 넘어온 classname과 일치하는 class를 리턴한다.
   * @param {String} psClassName class name
   * @return 넘어온 classname과 일치하는 class
   * @type eXria.data.ArrayMap
   * @private
   */
  this.getCssStyle = function(psClassName) {
    return this.cssClassMap.get("." + psClassName);
  };

  this.init();
};
/**
 * @private
 */
eXria.form.xhtml.Canvas.prototype.doCollapseForAllFrame = function() {
  var voTopWindow = this.page.window.top;
  this.doCollapseForWindow(voTopWindow);
};
/**
 * eXria.form.xhtml.Canvas.prototype.doCollapseForWindow
 * @param {Object} poWindow
 * @type Object
 * @return Boolean
 * @private
 */
eXria.form.xhtml.Canvas.prototype.doCollapseForWindow = function(poWindow) {
  var voDocument = null;
  try {
    voDocument = poWindow.document;
  } catch(err) {
    return false;
  }
  var voFrames = voDocument.getElementsByTagName("frame");
  var voFrame = null;
  var voWindow = null;
  var vbBreak = false;
  if(poWindow.page) {
    vbBreak = this.doCollapseOnPage(poWindow.page);
    if(vbBreak) return true;
  }

  for(var i = 0; i < voFrames.length; i++) {
    voFrame = voFrames[i];
    voWindow = voFrame.contentWindow;
    if(voWindow) {
      vbBreak = this.doCollapseForWindow(voWindow);
      if(vbBreak) return true;
    }
  }

  voFrames = voDocument.getElementsByTagName("iframe");
  for(var i = 0; i < voFrames.length; i++) {
    voFrame = voFrames[i];
    voWindow = voFrame.contentWindow;
    if(voWindow) {
      vbBreak = this.doCollapseForWindow(voWindow);
      if(vbBreak) return true;
    }
  }
  return false;
};
/**
 * doCollapseOnPage
 * @param {eXria.form.Page} poPage
 * @type Boolean
 * @return Boolean
 * @private
 */
eXria.form.xhtml.Canvas.prototype.doCollapseOnPage = function(poPage) {
  var voCanvas = poPage.canvas;
  if(voCanvas) {
    if(voCanvas.id == this.id) return false;
    if(voCanvas.focusedControl && voCanvas.focusedControl.doblur) voCanvas.focusedControl.doblur();
    var voCollapseControl = voCanvas.collapseControl;
    if(voCollapseControl) {
      this.doCollapseControl(voCanvas)
      return true;
    } else {
      return false;
    }
  }
  return false;
};
/**
 * doCollapseControl
 * @param {eXria.form.Canvas} poCanvas
 * @return void
 * @type void
 * @private
 */
eXria.form.xhtml.Canvas.prototype.doCollapseControl = function(poCanvas) {
  var voCollapseControl = poCanvas.collapseControl;
  if(!voCollapseControl) return;
  poCanvas.collapseControl = null;
  switch(voCollapseControl.toString()) {
  case "ComboBox" :
    voCollapseControl.showList(false);
    break;
  case "DateInput" :
  case "EditMask" :
    voCollapseControl.calendar.hide();
    break;
  case "ContextMenu" :
    poCanvas.hideContextMenu();
    break;
  }
};

/**
 * @fileoverview
 * Browser별 XMLHttpRequest 생성 Factory.
 */

/**
 * Browser별 XMLHttpRequest 생성 Factory.
 * @version 1.0
 * @constructor
 * @private
 */
eXria.form.xhtml.HttpRequestFactory = {
  msxmlNames : ["MSXML2.XMLHTTP.5.0",
                "MSXML2.XMLHTTP.4.0",
                "MSXML2.XMLHTTP.3.0",
                "MSXML2.XMLHTTP",
                "Microsoft.XMLHTTP" ]
  ,
  create : function() {
  /* Microsoft MSXML ActiveX */
  if(window.ActiveXObject !== undefined) {

    for(var i = 0;i < this.msxmlNames.length; i++) {
      try {
      return new ActiveXObject(this.msxmlNames[i]);
      } catch (e) {}
    }
  } else if(window.XMLHttpRequest) {
    /* Mozilla XMLHttpRequest */
    return new XMLHttpRequest();
  } else {
    /* None found */
    return null;
  }
  }
};
/**
 * @fileoverview
 * XHTML Mode 사용시 생성되는 Model Object Class
 */

/**
 * XHTML Mode 사용시 생성되는 Model Object Class
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @param {String} psId Model Id
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 * @base eXria.form.Model
 */
eXria.form.xhtml.Model = function(psId, poPage) {
  /**
   * inherit
   */
  eXria.form.Model.call(this, psId, poPage);
  /**
   * Model Object
   * @type eXria.form.xhtml.Model
   */
  var base = this;

  /**
   * instance
   * @type eXria.data.ArrayMap
   * @private
   */
  this.instances = new eXria.data.ArrayMap();

  /**
   * 서버로 부터 Submission 및 Instance Load
   * @param {String} psUrl server url (synchronization)
   * @return void
   * @type void
   * @ignore
   */
  this.loadURL = function(psUrl, pbAppend) {
  var vsResourceUrl = this.page.metadata.resourceBaseUrl;
  var vnResource = psUrl.indexOf(vsResourceUrl);
  if(vnResource == -1) {
    psUrl = vsResourceUrl.substring(0, vsResourceUrl.length - 1) + psUrl;
  }
    var voDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.page);
    voDocument.loadURL(psUrl);
    this.parseInitDocument(voDocument, pbAppend);
    if(this.mainDefaultInstanceId == null) this.mainDefaultInstanceId = this.defaultInstanceId;
	else this.defaultInstanceId = this.mainDefaultInstanceId;
  };
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   * @ignore
   */
  this.loadXML = function(poXML, pbAppend) {
    var voDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.page);
    voDocument.loadXML(poXML);
    this.parseInitDocument(voDocument, pbAppend);
  };
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   * @ignore
   */
  this.loadTXT = function(psTXT, pbAppend) {
    var voDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.page);
    voDocument.loadTXT(psTXT);
    this.parseInitDocument(voDocument, pbAppend);
  };

  /**
   * viewObj
   * @private
   */
  this.viewObj = null;
  /**
   * viewTimer
   * @private
   */
  this.viewTimer = null;

  this.defaultInstanceId = null;
  
  this.progressImg = "/eXria/controls/xhtml/images/bigWaiting.gif";
  
  this.pgImgWh = 32;
  
  this.pgImgHt = 32;

  /**
   * loadModel
   * @param {String} psUrl server URL
   * @param {Object} poView UI Object
   * @return void
   * @type void
   * @ignore
   */
  this.loadModel = function(psUrl, poView) {
  this.viewObj = poView;
    this.loadURL(psUrl);
    //progress start 20081217
    if(this.page.metadata.loadingProgressEnabled) {
      this.progressAction(true);
      this.viewTimer = this.page.window.setTimeout(this.viewRendering, 20);
    } else {
      this.viewRendering();
    }
  };
  /**
   * viewRendering
   * @return void
   * @type void
   * @ignore
   */
  this.viewRendering = function() {
    if(base.page.model.viewTimer) {
      base.page.window.clearTimeout(base.viewTimer);
    }
    base.page.load(base.viewObj);
    if(base.page.metadata.loadingProgressEnabled) {
      base.progressAction(false);
    }
  };
//progress end 20081217
  /**
   * parseInitDocument
   * @param {Object} poDOM
   * @param {Boolean} pbAppend
   * @return void
   * @type void
   * @ignore
   */
  this.parseInitDocument = function(poDOM, pbAppend) {
    var vnNodeCnt = 0;
    var voNode;
    var vsId;

    if(pbAppend == false) {
      this.submissions.clear();
      this.instances.clear();
    }

    //1. submission parsing
    {
    var voSubmissionList = null;
      voSubmissionList = poDOM.selectNodes("//*[namespace-uri()='http://www.exria.org/exria' and local-name()='submission']");
      if(!voSubmissionList) {
      voSubmissionList = poDOM.selectNodes("//xr:submission");
      }
      vnNodeCnt = voSubmissionList.getLength();

      var vsReqProtocol, vsResProtocol, vsAsync, vsMethod, vsAction, vsReqCharSet, vsResCharSet, vsReqType, vsResType;
      var voSubmission = null;
      var voInnerNodeList;
      var voInnerNode;

      for(var i = 0; i < vnNodeCnt; i++) {
        voNode = voSubmissionList.item(i); /* nodelist */

        //submission attribute parsing
        var voAttr = voNode.attributes;
        vsId = voAttr.getNamedItem("id").value;
        vsReqProtocol = voAttr.getNamedItem(eXria.protocols.SubmissionType.REQ_PROTOCOL_HEADER).value;
        vsResProtocol = voAttr.getNamedItem(eXria.protocols.SubmissionType.RES_PROTOCOL_HEADER).value;
        vsAsync = voAttr.getNamedItem("async").value;
        vsMethod = voAttr.getNamedItem("method").value;
        vsAction = voAttr.getNamedItem("action").value;
        vsReqCharSet = voAttr.getNamedItem("req-charset").value;
        vsResCharSet = voAttr.getNamedItem("res-charset").value;
        vsReqType = voAttr.getNamedItem("req-type").value;
        vsResType = voAttr.getNamedItem("res-type").value;

        voSubmission = new this.page.window.eXria.protocols.xhtml.Submission(vsId, this);

        voSubmission.setReqProtocol(vsReqProtocol);
        voSubmission.setResProtocol(vsResProtocol);

        voSubmission.setAsync((vsAsync == "false" ? false : true));
        voSubmission.setMethod(vsMethod);
        voSubmission.setAction(vsAction);
        voSubmission.setReqCharset(vsReqCharSet);
        voSubmission.setResCharset(vsResCharSet == null || vsResCharSet == "" ? vsReqCharSet : vsResCharSet); // response-characterset이 없을 경우 request-characterset으로
        voSubmission.setReqType(vsReqType);
        voSubmission.setResType(vsResType);

        //submission sub element parsing
        voInnerNodeList = voNode.childNodes;
        for(var j = 0; j < voInnerNodeList.length; j++) {
          voInnerNode = voInnerNodeList.item(j);
          if(voInnerNode.nodeType != 1) {
            continue;
          }
          var vsName = voInnerNode.baseName ? voInnerNode.baseName : voInnerNode.localName;
          switch(vsName) {
            case "listener" :
              var vsEvent   = voInnerNode.attributes.getNamedItem("event").value;
              var vsHandler = voInnerNode.attributes.getNamedItem("handler").value;
              switch(vsEvent) {
                case "onsubmit" :
                  voSubmission.onSubmit = new Function("e", "this.model." + vsHandler + "(e)");
                  break;
                case "onsubmitdone" :
                  voSubmission.onSubmitDone = new Function("e", "this.model." + vsHandler + "(e)");
                  break;
                case "onsubmiterror" :
                  voSubmission.onSubmitError = new Function("e", "this.model." + vsHandler + "(e)");
                  break;
              }
              break;
            case "request-ref" :
              var vsInstanceid = null;
              vsInstanceid = voInnerNode.attributes.getNamedItem("instanceid");
              if(vsInstanceid) vsInstanceid = vsInstanceid.value;
              
              if(vsInstanceid) {
                var vsRef = null;
                vsRef = voInnerNode.attributes.getNamedItem("ref");
                if(vsRef) vsRef = vsRef.value;
                voSubmission.addRef(vsInstanceid, vsRef);
              }
              
              var vsDsId = null
              vsDsId = voInnerNode.attributes.getNamedItem("datasetid");
              if(vsDsId) vsDsId = vsDsId.value;
              
              if(vsDsId) {
                voSubmission.addDataSetId(vsDsId);
              }
              break;
            case "header" :
              var vsName = voInnerNode.attributes.getNamedItem("name").value;
              var vsValue = voInnerNode.attributes.getNamedItem("value").value;
              voSubmission.setHeader(vsName, vsValue);
              break;
            case "parameter" :
              var vsName = voInnerNode.attributes.getNamedItem("name").value;
        try {
                var vsValue = voInnerNode.attributes.getNamedItem("value").value;
        } catch(e) {
        var vsValue = "";
        }
              voSubmission.addParameter(vsName, vsValue);
              break;
            case "response-ref" :
              try {
                var vsInstanceid   = voInnerNode.attributes.getNamedItem("instanceid").value;
              } catch (e) {
                throw new Error("Response-ref is support only Instance.");
              }
              var vsRef   = voInnerNode.attributes.getNamedItem("ref").value;
              var vsAdd   = voInnerNode.attributes.getNamedItem("add").value;
              voSubmission.addResRef(vsInstanceid, vsRef, vsAdd == "true" ? false : true);
              break;
          }
        }
        this.appendSubmission(voSubmission);
      }
    }

    //2. Instance parsing
    var voInstance = null;
    var voSrcInstObj, voTrgInstObj;
    var voInstanceList = null;

    if(this.page.metadata.useJsonInstance) {
      voInstanceList = poDOM.selectNodes("//*[namespace-uri()='http://www.w3.org/2002/xforms' and local-name()='jsoninstance']");
      if(!voInstanceList) voInstanceList = poDOM.selectNodes("//xf:jsoninstance");
      vnNodeCnt = voInstanceList.getLength();
      var voInstanceMap = this.instances;
      for(var i = 0; i < vnNodeCnt; i++) {
        voNode = voInstanceList.item(i);
        vsId = voNode.attributes.getNamedItem("id").value;
        voNode = new eXria.data.xhtml.Node(voNode, true);
        voSrcInstObj = eval("(" + voNode.getNodeValue() + ")");
        voInstance = voInstanceMap.get(vsId);
        if(voInstance == null) voInstance = new this.page.window.eXria.data.xhtml.Instance(vsId, this);
        voTrgInstObj = voInstance.instObj;
        voTrgInstObj = voTrgInstObj["root"];
        if(voTrgInstObj) {
          for(var attr in voSrcInstObj["root"]) {
            if(voTrgInstObj[attr] === undefined) {
              voTrgInstObj[attr] = voSrcInstObj["root"][attr];
            }
          }
        } else {
          voInstance.instObj = voSrcInstObj;
        }
        voInstanceMap.put(vsId, voInstance);
      }

    } else {
      voInstanceList = poDOM.selectNodes("//*[namespace-uri()='http://www.w3.org/2002/xforms' and local-name()='instance']");
      if(!voInstanceList) voInstanceList = poDOM.selectNodes("//xf:instance");
      vnNodeCnt = voInstanceList.getLength();

      for(var i = 0; i < vnNodeCnt; i++) {
        voNode = voInstanceList.item(i);
        vsId = voNode.attributes.getNamedItem("id").value;
        voInstance = new this.page.window.eXria.data.xhtml.Instance(vsId, this);

        var voChildNodes = voNode.childNodes;
        var vnLen = voChildNodes.length;
        var voItem = null;
        var vaNodes = [];

        for(var j = 0 ; j < vnLen ; j++) {
          voItem = voChildNodes.item(j);
          if(voItem.nodeType == 1) {
          vaNodes.push(voItem);
          }
        }

        if(vaNodes.length > 0) {
          voInstance.loadXML(vaNodes[0]);
          this.appendInstance(voInstance);
        }

      }
    }
    var voDefaultInstance = null;
    voDefaultInstance = poDOM.selectSingleNode("//*[namespace-uri()='http://www.w3.org/2002/xforms' and local-name()='model']");
    if(!voDefaultInstance) {
      voDefaultInstance = poDOM.selectSingleNode("//xf:model");
    }
    var voDefaultInstanceIdItem = voDefaultInstance.attributes.getNamedItem("defaultinstance");
    this.defaultInstanceId = voDefaultInstanceIdItem != null ? voDefaultInstanceIdItem.value : null;
    
    
  //dataset parse
    {
       var voDataSetList = poDOM.selectNodes("//*[namespace-uri()='http://www.exria.org/exria' and local-name()='dataset']");
       if(!voDataSetList) voDataSetList = poDOM.selectNodes("//xr:dataset");
       
       var vbInstanceSync, vsSourceType, vbUseOriginalValue, voAttr;
       var voSubNode, voSubNodes, vnSubLen, vsNodeName, voSubNodeFChild;
       var vsConnectionInfo, vsQuery;
       var i, j, k, l, m;
       var voTableNodes, vnTableLen, voTableNode, voTableSubNodes, voTableSubNode, vnTableSubLen, vsTableSubNodeName;
       var vsTableName, vsTablePrefix, vsPrimaryColName, vsPrimarySrcName, vsUpdateColName, vsUpdateSrcName;
       var voPrimaryNodes, voPrimaryNode, vnPrimaryLen;
       var voColNode, voColNodes, vnColLen;
       var voDataSet;

       vnNodeCnt = voDataSetList.getLength(); 
       for(i = 0; i < vnNodeCnt; i++) {
         voNode = voDataSetList.item(i);
         
         voAttr = voNode.attributes;
         vsId = voAttr.getNamedItem("id").value;
         vbInstanceSync = voAttr.getNamedItem("instanceSync");
         if(vbInstanceSync) vbInstanceSync = voAttr.getNamedItem("instanceSync").value;
         vbInstanceSync = (vbInstanceSync === "true" ? true : false);
         vsSourceType = voAttr.getNamedItem("sourceType");
         if(vsSourceType) vsSourceType = voAttr.getNamedItem("sourceType").value;
         vbUseOriginalValue = voAttr.getNamedItem("useoriginval");
         if(vbUseOriginalValue) vbUseOriginalValue = voAttr.getNamedItem("useoriginval").value;
         vbUseOriginalValue = (vbUseOriginalValue === "true" ? true : false);
         
         voSubNodes = voNode.childNodes;
         vnSubLen = voSubNodes.length;
         for(j = 0 ; j < vnSubLen ; j++) {
           voSubNode = voSubNodes.item(j);
           voSubNodeFChild = voSubNode.firstChild;
           if(voSubNode.nodeType != 1) continue;
           
           vsNodeName = voSubNode.nodeName;
           if(vsNodeName == "xr:connectioninfo") {
             if(voSubNodeFChild) vsConnectionInfo = voSubNodeFChild.nodeValue;
           } else if(vsNodeName == "xr:query") {
             if(voSubNodeFChild) vsQuery = voSubNodeFChild.nodeValue;
           } else if(vsNodeName == "xr:autocrud") {
             var voPrimaryKeys, voPrimaryKeyCols, voPrimaryKeyCol, voUpdates, voUpdateCols, voUpdateCol, vnSubLen;
              
             //데이터셋 생성
             voDataSet = this.createDataSet(vsId, vsSourceType, vsConnectionInfo, vsQuery, vbInstanceSync, vbUseOriginalValue);
             
             voTableNodes = voSubNode.childNodes;
             vnTableLen = voTableNodes.length;
             
             for(k = 0 ; k < vnTableLen ; k++) {
               voTableNode = voTableNodes.item(k);
               if(voTableNode.nodeType != 1) continue;
               voAttr = voTableNode.attributes;
               
               vsTableName = voAttr.getNamedItem("name").value;
               vsTablePrefix = voAttr.getNamedItem("prefix").value;
               //테이블, 프리픽스 추가
               voDataSet.addCRUDTable(vsTableName);
               voDataSet.setPrefix(vsTableName, vsTablePrefix);
               
               voTableSubNodes = voTableNode.childNodes;
               vnTableSubLen = voTableSubNodes.length;
               
               for(l = 0 ; l < vnTableSubLen ; l++) {
                 voTableSubNode = voTableSubNodes.item(l);
                 if(voTableSubNode.nodeType != 1) continue;
                 vsTableSubNodeName = voTableSubNode.nodeName;
                 
                 if(vsTableSubNodeName == "xr:primarykeys") {
                   voPrimaryNodes = voTableSubNode.childNodes;
                   vnPrimaryLen = voPrimaryNodes.length;
                   for(m = 0 ; m < vnPrimaryLen ; m++) {
                     voPrimaryNode = voPrimaryNodes.item(m);
                     if(voPrimaryNode.nodeType != 1) continue;
                     voAttr = voPrimaryNode.attributes;
                     
                     vsPrimaryColName = voAttr.getNamedItem("name").value
                     vsPrimarySrcName = voAttr.getNamedItem("sourceName").value
                     //프라이머리키 추가
                     voDataSet.addPrimaryKey(vsTableName, vsPrimarySrcName, vsPrimaryColName);
                   }
                 } else if(vsTableSubNodeName == "xr:updatecolumns") {
                   voPrimaryNodes = voTableSubNode.childNodes;
                   vnPrimaryLen = voPrimaryNodes.length;
                   for(m = 0 ; m < vnPrimaryLen ; m++) {
                     voPrimaryNode = voPrimaryNodes.item(m);
                     if(voPrimaryNode.nodeType != 1) continue;
                     voAttr = voPrimaryNode.attributes;
                     
                     vsUpdateColName = voAttr.getNamedItem("name").value
                     vsUpdateSrcName = voAttr.getNamedItem("sourceName").value
                     //업데이트 컬럼 추가
                     voDataSet.addUpdateColumn(vsTableName, vsUpdateSrcName, vsUpdateColName);
                   }
                 }
               }
             }
           } else if(vsNodeName == "xr:columns") {
             voColNodes = voSubNode.childNodes;
             vnColLen = voColNodes.length;
             var voHeader = voDataSet.getHeader();
             for(l = 0 ; l < vnColLen ; l++) {
               voColNode = voColNodes.item(l);
               if(voColNode.nodeType != 1) continue;
               //컬럼 추가
               voHeader.addHeaderColumn(null, voColNode.attributes.getNamedItem("sourceName").value);
             }
           }
         }
         if(!voDataSet) voDataSet = this.createDataSet(vsId, vsSourceType, vsConnectionInfo, vsQuery, vbInstanceSync, vbUseOriginalValue);
         voDataSet.rebuild(false);
       }
    }
  };
  /**
   * 인스턴스 생성
   * @param {String} psId Instance ID
   * @return 생성된 Instance 리턴
   * @type eXria.data.Instance
   * @return instance Object
   * @type eXria.data.xhtml.Instance
   * @see eXria.data.xhtml.Instance
   * @ignore
   */
  this.createInstance = function(psId) {
    var voInstance = new eXria.data.xhtml.Instance(psId, this);
    var voRootNode = voInstance.createNode("root");
    voInstance.appendNode("/", voRootNode);
    this.appendInstance(voInstance);
    return voInstance;
  };
  /**
   * 넘어온 인스턴스를 instance 객체에 붙인다.
   * @param {eXria.data.Instance} poInstance instance Object
   * @return void
   * @type void
   * @ignore
   */
  this.appendInstance = function(poInstance) {
    this.instances.put(poInstance.id, poInstance);
  };
  /**
   * 넘어온 ID와 일치하는 인스턴스를 찾아 리턴한다.
   * @param {String} psId instance id
   * @return Instance Object
   * @type eXria.data.Instance
   * @ignore
   */
  this.getInstance = function(psId) {
    return this.instances.get(psId);
  };
  /**
   * 넘어온 ID와 일치하는 인스턴스를 찾아 삭제한다.
   * @param {String} psId instance id
   * @return void
   * @type void
   * @ignore
   */
  this.removeInstance = function(psId) {
    var voInstance = this.instances.remove(psId);
    voInstance.clear();
  };

  /**
   * submission
   * @type eXria.data.ArrayMap
   * @private
   */
  this.submissions = new eXria.data.ArrayMap();

  /**
   * submission을 생성한다.
   * @param {String} psId submission id
   * @return 생성된 Submission
   * @type eXria.protocols.Submission
   * @ignore
   */
  this.createSubmission = function(psId) { /* pnType=Submission Type */
    var voSms = new eXria.protocols.xhtml.Submission(psId, this);
    this.appendSubmission(voSms);
    return voSms;
  };
  /**
   * 넘어온 submission 객체를 submission에 추가 시킨다.
   * @param {eXria.protocols.Submission) poSubmission submission object
   * @return void
   * @type void
   * @ignore
   */
  this.appendSubmission = function(poSubmission) {
    this.submissions.put(poSubmission.id, poSubmission);
  };
  /**
   * 넘어온 ID와 일치하는 서브미션을 리턴.
   * @param {String} psId
   * @return Submission Object
   * @type eXria.protocols.Submission
   * @ignore
   */
  this.getSubmission = function(psId) {
    return this.submissions.get(psId);
  };
  /**
   * 넘어온 ID와 일치하는 Submission을 삭제한다.
   * @param {String} psId Submission ID
   * @return void
   * @type void
   * @ignore
   */
  this.removeSubmission = function(psId) {
//    var voSubmission = this.submissions.remove(psId);
//    voSubmission.clear();
    this.submissions.remove(psId);
  };

  /**
   * datasets
   * @type eXria.data.ArrayMap
   * @ignore
   */
  this.datasets = new eXria.data.ArrayMap();
  /**
   * 넘어온 dataset을 추가. 동일한 id의 dataset이 존재할 경우 rewrite
   * @param {Object} poDataSet dataset Object
   * @return void
   * @type void
   * @ignore
   */
  this.appendDataSet = function(poDataSet) {
    this.datasets.put(poDataSet.id, poDataSet);
    this[poDataSet.id] = poDataSet;
  };
  /**
   * 넘어온 id와 일치하는 dataset 리턴
   * @param {String} psId dataset id
   * @return dataset Object
   * @type eXria.data.DataSetCmd
   * @ignore
   */
  this.getDataSet = function(psId) {
    return this.datasets.get(psId);
  };

  /**
   * 넘어온 id와 일치하는 dataset 생성</br>
   * 만약 일치하는 id의 dataset이 존재한다면 기존의 dataset 리턴 아니면 새로생성
   * @param {String} psId dataset Id
   * @return dataset Object
   * @type eXria.data.DataSetCmd
   * @ignore
   */
  this.createDataSet = function(psId, pnTypeSource, psConnectionInfo, psSourceQuery, pbSourceSync, pbKeepOriginValue){
    if(this.datasets.get(psId)) {
      return this.datasets.get(psId);
    } else {
      var voDs = new eXria.data.xhtml.DataSetCmd(psId, pnTypeSource, psConnectionInfo, psSourceQuery, pbSourceSync, pbKeepOriginValue, this);
      this.datasets.put(voDs.id, voDs);
      return voDs;
    }
  }
  /**
   * 넘어온 Id와 일치하는 dataset 삭제
   * @param {String} psId dataset Id
   * @return void
   * @type void
   * @ignore
   */
  this.removeDataSet = function(psId) {
    var voDataSet = this.datasets.remove(psId);
    voDataSet.clear();
    delete this[psId];
  };

  /**
   * 화면 loading 시 progress bar 출력
   * @param {Boolean} pbShow boolean : true - progress bar 출력, false - progress bar 종료
   * @return void
   * @type void
   * @ignore
   */
  this.progressCtrl = null;
  this.progressAction = function(pbShow, psProgressImg) {
    var voBase = this;
    if(pbShow) {
      if(!this.progressCtrl || psProgressImg != null) {
        if(psProgressImg == null) psProgressImg = this.getProgressImgPath();
        this.progressImg = psProgressImg;
        var voCtrl = this.page.window.document.createElement("div");
        voCtrl.id = "page_progress";
        voCtrl.style.position = "absolute";
        voCtrl.style.overflow = "hidden";
        voCtrl.style.left = (this.page.canvas.width - this.pgImgWh) / 2 + "px";
        voCtrl.style.top = (this.page.canvas.height - this.pgImgHt) / 2 + "px";
        voCtrl.style.height = this.pgImgHt + "px";
        voCtrl.style.width = this.pgImgWh + "px";
        voCtrl.style.zIndex = 50000;
        var vsResourceBaseUrl = (this.page.metadata.resourceBaseUrl == "/") ? "" : this.page.metadata.resourceBaseUrl;
        voCtrl.innerHTML = "<img src='" + vsResourceBaseUrl + this.progressImg + "' width='" + this.pgImgWh + "px' height='" + this.pgImgHt + "px' />";
        this.page.window.document.body.appendChild(voCtrl);
        this.progressCtrl = voCtrl;
      }
      this.progressCtrl.style.visibility = "visible";
    } else {
      if(this.progressCtrl) {
        this.progressCtrl.style.visibility = "hidden";
      }
    }
    //TODO ... use timer
  };

  /**
   * close
   * @ignore
   */
  this.close = function() {
    var voIterator = this.instances.getKeyCollection().iterator();
    while(voIterator.hasNext()) {
      var voInstance = voIterator.next();
      if(voInstance.clear) {
        voInstance.clear();
      }
      delete this[voInstance.id];
    }
    this.instances.clear();
    delete this.instances;

    voIterator = this.submissions.getKeyCollection().iterator();
    while(voIterator.hasNext()) {
      var voSubmission = voIterator.next();
      if(voSubmission.clear) {
        voSubmission.clear();
      }
      delete this[voSubmission.id];
    }
    this.submissions.clear();
    delete this.submissions;
  };
  /**
   * 콤보구분 인스턴스 ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return 인스턴스 ID 리스트 (ex. instance,instance1)
   */
  this.getInstanceIdList = function() {
    var vaInstance = this.instances.getKeyCollection().elements;
    return vaInstance.join(",");
  };
  /**
   * 콤보구분 DataSet ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return DataSet ID 리스트 (ex. dst1,dst2,dst3)
   */
  this.getDataSetIdList = function() {
    var voDataSetKeys = this.datasets.getKeyCollection();
    var vnSize = voDataSetKeys.size();
    var vsResult = "";

    for(var i = 0; i < vnSize; i++){
        vsResult += voDataSetKeys.get(i);
        vsResult += ","
    }

    if(vsResult.length > 0) {
        vsResult = vsResult.substring(0, vsResult.length - 1);
    }
    return vsResult;
//    throw new Error("not support method.");
  };
  /**
   * Server Error Message를 반환한다.
   * @param {Boolean} pbCode 에러 코드 리턴 유무
   * @param {Boolean} pbMsg 에러 메세지 리턴 유무
   * @param {Boolean} pbSrc 에러 소스 리턴 유무
   * @type eXria.data.ArrayCollection
   * @return Error String을 담고 있는 Array 객체
   * @ignore
   */
  this.getErrorMessage = function(pbCode, pbMsg, pbSrc) {
    if(pbCode != false) pbCode = true;
    if(pbMsg != false) pbMsg = true;
    if(pbSrc != false) pbSrc = true;

    var voNodeCollection = this.instances.get(this.defaultInstanceId).getCollectionNode("/root/EXRIAERRMSG");

    var voNode = null;
    var voChild = null;
//    var vnNodeChildSize = null;
    var vsErrFullStr = "";
    var vsErrCode = "", vsErrMsg = "", vsErrSrc = "";
    var vnNodeSize = voNodeCollection.size();
//    var voErrCollection = new eXria.data.ArrayCollection();

    if(vnNodeSize == 0) return null;

    for(var i = 0 ; i < vnNodeSize ; i++) {
      voNode = voNodeCollection.get(i);
      if(voNode.getNodeType() != 1) continue;
//      vnNodeChildSize = voNode.childNodes.length;
      if(page.metadata.useJsonInstance){
        if(voNode.node == "") continue;
        if(voNode.name == "ERRCODE" && pbCode) vsErrCode = voNode.getNodeValue();
        if(voNode.name == "ERRMSG" && pbMsg) vsErrMsg = voNode.getNodeValue();
        if(voNode.name == "ERRSRC" && pbSrc) vsErrSrc = voNode.getNodeValue();
      }else{
        if(voNode.nodeName == "ERRCODE" && pbCode) vsErrCode = "Error Code : \n" + voNode.childNodes[0].nodeValue + "\n";
        if(voNode.nodeName == "ERRMSG" && pbMsg) vsErrMsg = "Error Message : \n" + voNode.childNodes[0].nodeValue + "\n";
        if(voNode.nodeName == "ERRSRC" && pbSrc) vsErrSrc = "Error Source : \n" + voNode.childNodes[0].nodeValue + "\n";
      }
//      vsErrFullStr = vsErrCode + vsErrMsg + vsErrSrc;
//      if(vsErrFullStr != "") {
//        voErrCollection.add(vsErrFullStr.replace(/\\n/ig, "\n"));
//        vsErrCode = "";
//        vsErrMsg = "";
//        vsErrSrc = "";
//        vsErrFullStr = "";
//      }
    }
//    return voErrCollection;
    vsErrFullStr = vsErrCode + vsErrMsg + vsErrSrc;
    return (vsErrFullStr == "") ? null : vsErrFullStr;
  };

  /**
   * Server Error Message를 전부 삭제한다.
   * @type void
   * @return void
   * @ignore
   */
  this.clearErrorMessage = function() {
    var voNode = this.getInstance(this.defaultInstanceId).selectSingleNode("/root/EXRIAERRMSG");
    while(voNode.childNodes.length) {
      voNode.removeChild(voNode.childNodes[0]);
    }
  };
  /**
   * AES암호화 후 Base64 처리 된 문자열을 복호화 하여 원본 문자열을 리턴한다.
   * @param {String} psStr
   * @type String
   * @return Base64 decoding 후 복호화 하여 원본 문자열
   */
  this.decryptStr = function(psStr) {
    return null;
  };
  /**
   * plugin 내부 AES 알고리즘으로 입력된 파라미터 문자열을 암호화 하여 Base64 처리 후 리턴한다.
   * @param {String} psStr
   * @type String
   * @return 암호화와 Base64처리 된 문자열
   */
  this.encryptStr = function(psStr) {
    return null;
  };
  /**
   * 콤보구분 Submission ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return Submission ID 리스트 (ex. sms1,sms2,sms3)
   */
  this.getSubmissionIdList = function() {
    var vaInstance = this.submissions.getKeyCollection().elements;
    return vaInstance.join(",");
  };
  /**
   * 현재 클라이언트 PC의 Mac Address를 리턴
   * @type String
   * @return Mac Address
   */
  this.getMacAddr = function() {
    throw new Error("not support method.");
  };
  
  this.getDefInstanceID = function() {
    return this.defaultInstanceId
  };
  
  /**
   * Progress Image Path 리턴 메소드
   * @type String
   * @return Progress Image Path
   * @private
   */
  this.getProgressImgPath = function() {
    var vsImagePath = null;
    var vsProgressPath = eXria.protocols.Default.Submission.waitcursorImage;

    var vsResourceBaseUrl = this.page.metadata.resourceBaseUrl;

    if (vsResourceBaseUrl == "/" || vsResourceBaseUrl == ""
        || !vsResourceBaseUrl) {
      var host = page.window.location.host;
      var vsUrl = "http://" + host;
      vsImagePath = vsUrl + vsProgressPath;
    } else if (vsProgressPath != null) {
      var vsHref = this.page.metadata.url;
      var vsUrl = null;
      if (vsProgressPath.indexOf(vsResourceBaseUrl) > -1) {
        vsUrl = vsHref.substring(0, vsHref.indexOf(vsResourceBaseUrl));
      } else {
        vsUrl = vsHref.substring(0, vsHref.lastIndexOf("/") + 1);
      }
      vsImagePath = vsUrl + vsProgressPath;
    } else {
      var voLocation = this.page.window.location;
      var vsAddr = voLocation.host + vsResourceBaseUrl;

      vsImagePath = "http://" + vsAddr + "eXria/resource/images/progress.gif";
    }
    return vsImagePath;
  };
  
  this.setProgressImgSize = function(psWidth, psHeight) {
    this.pgImgWh = psWidth;
    this.pgImgHt = psHeight;
  };
};

/**
 * @fileoverview
 * eXria.form.plugin package
 */

/**
 * eXria.form.plugin package
 *
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 *
 */
eXria.form.plugin = {};

/**
 * @fileoverview
 * Log 출력 모드를 상수정의 한 클래스</br>
 * enum list</br>
 * - eXria.form.plugin.LogWriteType.MEMORY</br>
 * - eXria.form.plugin.LogWriteType.FILE
 */

/**
 * Log 출력 모드를 상수정의 한 클래스
 * @author Choe, Hyeon Jong
 * @version 1.0
 * @constructor
 */
eXria.form.plugin.LogWriteType = {
  MEMORY    : 1,
  FILE    : 2
};
/**
 * @fileoverview
 * Plugin Mode 사용시 시스템에 대한 로그를 사용하기 위한 클래스
 */

/**
 * Plugin Mode 사용시 시스템에 대한 로그를 사용하기 위한 클래스
 * @version 1.0
 * @param {Object} poPlugin
 * @constructor
 */
eXria.form.plugin.Logger = function(poPlugin) {
  /**
   * this.plugin
   * @private
   */
  this.plugin = poPlugin;
  /**
   * applet console logger
   * @private
   */
  this.logger = poPlugin.getLogger();
  /**
   * applet 콘솔에 지정된 레벨의 로그를 남겨주는 메소드
   * @param {String} psStr 출력 문자열
   * @param {String} psLevel 로그 출력의 기준이 될 로그 레벨(error|warn|info|debug)
   */
  this.printLog = function(psStr, psLevel) {
    if(psLevel == null) psLevel = "info";
    var voLogger = this.logger;
    switch(psLevel) {
    case "error" :
      voLogger.error(psStr);
      break;
    case "warn" :
      voLogger.warn(psStr);
      break;
    case "info" :
      voLogger.info(psStr);
      break;
    case "debug" :
      voLogger.debug(psStr);
      break;
    }
  };
};
/**
 * @fileoverview
 * Plugin Mode 사용시 생성되는 Model Object Class
 */

/**
 * Plugin Mode 사용시 생성되는 Model Object Class
 * @version 1.0
 * @param {String} psId Model Id
 * @param {eXria.form.Page} poPage Page Object
 * @constructor
 * @base eXria.form.Model
 */
eXria.form.plugin.Model = function(psId, poPage) {
  /**
   * dataset을 저장하는 map
   * @type eXria.data.ArrayMap
   */
  this.datasetMap = new eXria.data.ArrayMap();
  /**
   * wrapping 된 서브미션을 저장하는 Map
   * @type eXria.data.ArrayMap
   * @private
   */
  this.submissionsMap = new eXria.data.ArrayMap();
  /**
   * connection을 저장하는 map
   * @type eXria.data.ArrayMap
   * @private
   */
  this.connectionCmdMap = new eXria.data.ArrayMap();
  /**
   * inherit
   */
  eXria.form.Model.call(this, psId, poPage);

  /**
   * plugin
   * @type Object
   * @private
   */
  this.plugin = null;
  //this.isFireFox = false;

  /**
   * global main frame window
   * @type Object
   * @private
   */
  this.globalWindow = null;

  /**
   * Progress Image Path 리턴 메소드
   * @type String
   * @return Progress Image Path
   * @private
   */
  this.getProgressImgPath = function() {
    var vsImagePath = null;
    var vsProgressPath = eXria.protocols.Default.Submission.waitcursorImage;

    var vsResourceBaseUrl = this.page.metadata.resourceBaseUrl;

    if (vsResourceBaseUrl == "/" || vsResourceBaseUrl == ""
        || !vsResourceBaseUrl) {
      var host = page.window.location.host;
      var vsUrl = "http://" + host;
      vsImagePath = vsUrl + vsProgressPath;
    } else if (vsProgressPath != null) {
      var vsHref = this.page.metadata.url;
      var vsUrl = null;
      if (vsProgressPath.indexOf(vsResourceBaseUrl) > -1) {
        vsUrl = vsHref.substring(0, vsHref.indexOf(vsResourceBaseUrl));
      } else {
        vsUrl = vsHref.substring(0, vsHref.lastIndexOf("/") + 1);
      }
      vsImagePath = vsUrl + vsProgressPath;
    } else {
      var voLocation = this.page.window.location;
      var vsAddr = voLocation.host + vsResourceBaseUrl;

      vsImagePath = "http://" + vsAddr + "eXria/resource/images/progress.gif";
    }
    return vsImagePath;
  };

  /**
   * 모델 생성
   * @return void
   * @type void
   * @private
   */
 this.create = function() {
      var voDoc = this.page.window.document;
      var voModel = voDoc.getElementById(this.id);
      var voPlugin = null;
      var voGlobalFrm = "not established";
      var vbIsJREAlive = false;

      if (!voModel || voModel == null) {
       var vnModelType = poPage.metadata.modelType;
       var voModelType = eXria.form.ModelType;

       if (vnModelType == voModelType.PLUGIN) {
        if (this.plugin == null) {
         var voBrowser = this.page.metadata.browser;
         if (voBrowser.ie > 0) {
          //IE
          voDoc.write("<OBJECT id='" + this.id + "' classid='CLSID:88ADED8D-376C-4d6f-B48D-B336E140294B' ");
          voDoc.write("style='position:absolute;left:-1000px;top:-1000px' width='0' height='0'></OBJECT>");
         } else {
          //Firefox
          voDoc.write("<embed id='" + this.id + "' type='application/npETBClient' width='0' height='0' hidden='true'>");
         }
        }
       } else {
         if(this.page.metadata.libScope == "global") {
           var voWindow = this.page.window;

           try {
             voGlobalFrm = voWindow.document.getElementById("_eXriaGlobalLibraryFrame_");
           } catch(e) {}

           if(voGlobalFrm == null) {
             var voParent = voWindow.parent;

             while(voParent != voWindow) {
               voWindow = voParent;

               try {
                 voGlobalFrm = voWindow.document.getElementById("_eXriaGlobalLibraryFrame_");
               } catch(e) {}

               if(voGlobalFrm != null) break;

               voParent = voWindow.parent;
             }
           }

           if(voGlobalFrm == null) {
             var voOpener = voWindow.opener;
             var voDialogArg = voWindow.dialogArguments;
             var voParent = null;

             while (voOpener || voDialogArg) {
               voWindow = voOpener ? voOpener : voDialogArg.window;

               voParent = voWindow.parent;

               while(voParent != voWindow) {
                 voWindow = voParent;

                 try {
                   voGlobalFrm = voWindow.document.getElementById("_eXriaGlobalLibraryFrame_");
                 } catch(e) {}

                 if(voGlobalFrm != null) break;

                 voParent = voWindow.parent;
               }

               if(voGlobalFrm != null) break;

               voOpener = voWindow.opener;
               voDialogArg = voWindow.dialogArguments;
             }
           }

           var voPluginObject;

           try {
             this.globalWindow = voGlobalFrm.contentWindow;
             this.id = this.id + this.globalWindow.getSeq();
             voPluginObject = this.globalWindow.document.getElementById("jreFrameApplet");
             voPluginObject.getVersion();
             vbIsJREAlive = true;
           } catch (e) {
             vbIsJREAlive = false;
           }
         } else {
           vbIsJREAlive = false;
         }

        if(!vbIsJREAlive) {
          voGlobalFrm = null;
          var voMetaData = this.page.metadata;
          var voJreConf = voMetaData.jre;

          var vsAppPath = (voJreConf.appletPath == "") ? null : voJreConf.appletPath;
          var vsJreVer = (voJreConf.version == "") ? null : voJreConf.version;
          var vsJvmArg = (voJreConf.jvmArgument == "") ? null : voJreConf.jvmArgument;
          var vsInitHeap = (voJreConf.initHeapSize == "") ? null : voJreConf.initHeapSize;
          var vsMaxHeap = (voJreConf.maxHeapSize == "") ? null : voJreConf.maxHeapSize;
          var voJreProp = (voJreConf.properties == "") ? null : voJreConf.properties;
          var vbSupportChunked = (voJreConf.supportChunkedStream == "") ? null : voJreConf.supportChunkedStream;

          var vsCodeBase = null;
          if (vsAppPath) {
            vsCodeBase = vsAppPath;
          } else {
            var voLocation = this.page.window.location;
            var vsAddr = voLocation.host + voMetaData.resourceBaseUrl;
            vsCodeBase = voLocation.protocol + "//" + vsAddr + "eXria/applet/";
          }

          var attributes = {
            id : this.id,
            name : this.id,
            codebase : vsCodeBase,
            code : 'org.exria.plugin.main.PluginMain',
            archive : "ExriaPlugin.jar",
            style : "position:absolute; width:1px; height:1px; float:left; left:-10000000px; top:-10000000px;"
          };

          var voBrowser = this.page.metadata.browser;
          var vsBrowserType ;

          if(voBrowser.ie != 0){
            vsBrowserType = "MSIE";
          }else if(voBrowser.chrome != 0){
            vsBrowserType = "CHROME";
          }else if(voBrowser.gecko != 0){
            vsBrowserType = "GECKO";
          }else if(voBrowser.opera != 0){
            vsBrowserType = "OPERA";
          }else if(voBrowser.webkit != 0){
            vsBrowserType = "APPLEWEBKIT";
          }else {
            vsBrowserType = "";
          }

          var parameters = {
            mayscript : true,
            id : this.id,
            cache_archive : "ExriaPlugin.jar",
            log_level : voMetaData.logLevel,
            browserType : vsBrowserType,
            supportChunkedStream : vbSupportChunked
          };

          if (vsJreVer) {
            parameters.java_version = vsJreVer;
          } else {
            parameters.java_version = "1.6+";
          }

          var vsJavaArgs = "";
          vsJavaArgs = vsJavaArgs + ((vsJvmArg) ? vsJvmArg + " " : "");
          vsJavaArgs = vsJavaArgs + ((vsInitHeap) ? vsInitHeap + " " : "");
          vsJavaArgs = vsJavaArgs + ((vsMaxHeap) ? vsMaxHeap + " " : "");

          for ( var member in voJreProp) {
            vsJavaArgs = vsJavaArgs + "-D" + member + "=" + voJreProp[member] + " ";
          }

          if (vsJavaArgs != "") {
            parameters.java_arguments = vsJavaArgs;
          }

          deployJava.htmlDoc = voDoc;
          deployJava.metadata = voMetaData;
          var javaPlugin = voDoc.getElementById("deployJavaPlugin");
          if (!javaPlugin) {
            deployJava.do_initialize();
          }
          deployJava.runApplet(attributes, parameters, '1.6');
//          this.plugin = deployJava.runApplet(attributes, parameters, '1.6');
        } else {
          this.globalWindow.createPlugin(this.id, page.window.location.href, this.page.window);
        }
      }
    }
  };
  /**
   * load plugin object
   * @return null;
   * @type null
   * @private
   */
  this.setPlugin = function() {
    var voDoc = this.page.window.document;
    var voMetaData = this.page.metadata;
    if (voMetaData.modelType == eXria.form.ModelType.JRE) {
      if(this.globalWindow != null) {
        this.plugin = this.globalWindow.getPlugin(this.id);
      } else {
        this.plugin = voDoc.getElementById(this.id);
      }
    } else {
      if (voMetaData.browser.ie > 0) {
        this.plugin = voDoc.getElementById(this.id);
      } else {
        this.plugin = voDoc.getElementById(this.id).nsIETBClientFox;
      }
    }
  };
  /**
   * set default progress image
   * @type null
   * @return null
   * @private
   */
  this.setDefaultProgressImg = function() {
    this.plugin.setProgressImg(this.getProgressImgPath());
  };

  /**
   * model url
   * @type String
   * @private
   */
  this.modelURL = null;
  /**
   * viewObj
   * @type Object
   * @private
   */
  this.viewObj = null;

  /**
   * 모델 초기화
   * @return void
   * @type void
   * @private
   */
  this.init = function() {
    this.plugin.setSubmitBaseUrl(this.page.metadata.submitBaseUrl);
    this.plugin.setResourceUrl(this.page.metadata.resourceBaseUrl);

    if (this.modelURL) {
      this.modelURL = this.modelURL.substring(
          this.page.metadata.resourceBaseUrl.length - 1, this.modelURL.length);
      this.plugin.loadURL(this.modelURL, false);
    }
    if (this.page.metadata.loadingProgressEnabled) {
      this.progressAction(true);
      this.page.load(this.viewObj);
    } else {
      this.page.load(this.viewObj);
    }
  };

  /**
   * 요청 URL중 문제가 생길 수 있는 URL에 대해 수정하여 리턴
   * ex) /a.xrf -> a.xrf로 수정
   * @param {String} psUrl 수정할 url
   * @return 수정된 url
   * @type String
   * @private
   */
  this.modifyURL = function(psUrl) {
    var vsBaseUrl = this.page.metadata.submitBaseUrl;
    var vnBaseUrlLen = vsBaseUrl.length;

    var vsStartUrl = psUrl.substring(0, vnBaseUrlLen);
    if ((vsBaseUrl != vsStartUrl) && psUrl.substring(0, 1) == '/')
      psUrl = psUrl.substring(1, psUrl.length);

    return psUrl;
  };

  /**
   * 서버로 부터 Submission 및 Instance Load
   * @param {String} psUrl server url (synchronization)
   * @return void
   * @type void
   * @ignore
   */
  this.loadURL = function(psUrl, pnAppend) {
    if (pnAppend && pnAppend == 1) {
      pnAppend = true;
    } else {
      pnAppend = false;
    }
    this.plugin.loadURL(psUrl, pnAppend);
  };
  /**
   * 넘겨받은 XMLElement를 Node에 Append한다.
   * @param {XMLNode} poXML XML Node
   * @return void
   * @type void
   * @ignore
   */
  this.loadXML = function(poXML) {
    this.plugin.loadXML(poXML, 0);
  };
  /**
   * 넘겨받은 Text를 Parsing하여 Node에 Append한다.
   * @param {String} psTXT XML Text
   * @return void
   * @type void
   * @ignore
   */
  this.loadTXT = function(psTXT) {
    this.plugin.loadTXT(psTXT, 0);
  };
  /**
   * 모델을 로드한다.
   * @param {String} psUrl model의 URL
   * @param {Object} poView UI Object
   * @return void
   * @type void
   * @ignore
   */
  this.loadModel = function(psUrl, poView) {
    //this.modelURL = psUrl;
    this.modelURL = this.modifyURL(psUrl);
    this.viewObj = poView;

    this.init();
  };
  /**
   * 인스턴스 생성
   * @param {String} psId Instance ID
   * @return 생성된 Instance 객체
   * @type eXria.data.Instance
   * @see eXria.data.Instance
   * @ignore
   */
  this.createInstance = function(psId) {
    var voPlugin = this.plugin;
    voPlugin.createInstance(psId);
    var voPluginInstance = voPlugin.getInstance(psId);
    return new eXria.data.plugin.Instance(voPluginInstance, psId, this);
  };
  /**
   * 넘어온 ID와 일치하는 인스턴스를 리턴한다.
   * @return 넘어온 ID와 일치하는 인스턴스
   * @type eXria.data.Instance
   * @see eXria.data.Instance
   * @ignore
   */
  this.getInstance = function(psId) {
    var voPluginInstance = this.plugin.getInstance(psId);
    if (voPluginInstance && voPluginInstance != null) {
      return new eXria.data.plugin.Instance(voPluginInstance, psId, this);
    } else {
      return null;
    }
  };
  /**
   * 넘어온 ID와 일치하는 인스턴스를 삭제한다.
   * @param {String} psId instance ID
   * @return void
   * @type void
   * @ignore
   */
  this.removeInstance = function(psId) {
    this.plugin.removeInstance(psId);
  };
  /**
   * submission을 생성한다.
   * @param {String} psId Submission ID
   * @type eXria.protocols.Submission
   * @see eXria.protocols.Submission
   * @ignore
   */
  this.createSubmission = function(psId) { /* pnType=Submission Type */
    return this.plugin.createSubmission(psId);
  };
  /**
   * 넘어온 ID와 일치하는 서브미션을 리턴.
   * @param {String} psId Submission ID
   * @return 넘어온 ID와 일치하는 Submission을 리턴한다.
   * @type eXria.protocls.plugin.Submission
   * @see eXria.protocls.plugin.Submission
   * @ignore
   */
  this.getSubmission = function(psId) {
    var voSubmission = this.submissionsMap.get(psId);
    if (voSubmission == null) {
      voSubmission = new eXria.protocols.plugin.Submission(psId, this,
          this.plugin.getSubmission(psId));
      this.submissionsMap.put(psId, voSubmission);
    }
    return voSubmission;
  };
  /**
   * 넘어온 ID와 일치하는 Submission을 삭제한다.
   * @param {String} psId Submission ID
   * @return void
   * @type void
   * @ignore
   */
  this.removeSubmission = function(psId) {
    this.plugin.removeSubmission(psId);
    this.submissionsMap.remove(psId);
  };
  /**
   * extension method
   * @param {String} psDBName DB Name
   * @return 넘어온 이름과 동일한 DB를 가져온다.
   * @type Object
   */
  this.getDB = function(psDBName) { //TODO
    return this.plugin.getDB(psDBName);
  };
  /**
   * getDataSet
   * 넘어온 ID와 일치하는 DataSet을 리턴한다.
   * @param {String} psId DataSet Id
   * @return DataSet 객체
   * @type eXria.data.plugin.DataSetCmd
   * @ignore
   */
  this.getDataSet = function(psId) {
    var voDs = null;
    if (this.page.metadata.browser.ie > 0) {
      voDs = new eXria.data.plugin.DataSetCmd(psId, this);
    } else {
      voDs = this.datasetMap.get(psId);
      if (voDs == null) {
        voDs = new eXria.data.plugin.DataSetCmd(psId, this); //id, model
        this.datasetMap.put(psId, voDs);
      }
    }
    return voDs;
  };
  /**
   * 커넥션 객체를 리턴한다.
   * @return connection 객체
   * @type eXria.data.plugin.DBConnectionCmd
   * @see eXria.data.plugin.DBConnectionCmd
   */
  this.getConnection = function(psId, pnTypeSrc, psSrcConn, pnTarget,
      psTargetName, psTargerConn) {
    var voConnection = null;
    var voConnection = this.connectionCmdMap.get(psId);
    if (voConnection == null) {
      //    voConnection = new eXria.data.plugin.DBConnectionCmd(this, psId,
      //        this.plugin.getConnection(psId, pnTypeSrc, psSrcConn, pnTarget, psTargetName, psTargerConn));
      voConnection = new eXria.data.plugin.DBConnectionCmd(this, psId, pnTypeSrc, psSrcConn, pnTarget, psTargetName, psTargerConn);
      this.connectionCmdMap.put(psId, voConnection);
    }
    return voConnection;
  };
  /**
   * getFileSystemObject
   * 파일시스템 객체를 리턴한다.
   * @return 파일시스템 객체
   * @type eXria.data.plugin.FsoCmd
   */
  this.getFileSystemObject = function() {
    return new eXria.data.plugin.FsoCmd(this.plugin.getFileSystemObject(), this);
  };
  /**
   * DataSet을 생성한다.
   * @param {String} psDataSetId 생성할 ID
   * @param {Number} pnTypeSource source type
   * @param {String} psConnectionInfo 연결 부가정보
   * @param {String} psSourceQuery source의 query 정보
   * @param {Boolean} pbSourceSync source와의 동기화 유무
   * @param {Boolean} pbKeepOriginValue Keep Origin Value 유무
   * @return void
   * @type void
   * @ignore
   */
  this.createDataSet = function(psDataSetId, pnTypeSource, psConnectionInfo, psSourceQuery, pbSourceSync, pbKeepOriginValue) {
    if (pbKeepOriginValue == null || pbKeepOriginValue == "") {
      pbKeepOriginValue = true;
    }
    this.plugin.createDataSet(psDataSetId, pnTypeSource, psConnectionInfo,
        psSourceQuery, pbSourceSync, pbKeepOriginValue);
  };
  /**
   * DataSet을 제거한다.
   * @param {String} psDataSetId 제거할 dataset ID
   * @return void
   * @type void
   */
  this.removeDataSet = function(psDataSetId) {
    this.plugin.removeDataSet(psDataSetId);
    this.datasetMap.remove(psDataSetId);
  };
  /**
   * Client의 IP를 구한다.
   * @return Client의 IP
   * @type String
   */
  this.getClientIP = function() {
    return this.plugin.getClientIP();
  };
  /**
   * Host Name을 구한다.
   * @return host name
   * @type String
   */
  this.getHostName = function() {
    return this.plugin.getHostName();
  };
  /**
   * 사용자 PC의 시간을 구한다.
   * @return 사용자 PC의 시간 문자열
   * @type String
   */
  this.getSystemTime = function() {
    return this.plugin.getSystemTime();
  };
  /**
   * 현재 이 플러그인의 버전을 확인한다.
   * @return 현재 플러그인 버전 정보
   * @type String
   */
  this.getVersion = function() {
    return this.plugin.getVersion();
  };
  /**
   * 플러그인 내부에서 표시하는 메시지를 다른 나라 언어로 표시하고자 할때
   * 문자열 정의파일(XML형식)을 지정할 수 있다.
   * @param {String} psUrl 외국어 문자열 정의파일을 지정하는 URL
   * @return void
   * @type void
   */
  this.setMsgFile = function(psUrl) {
    this.plugin.setMsgFile(psUrl);
  };
  /**
   * Resource Url을 설정한다.
   * @param {String} psResourceUrl Resource Url
   * @return void
   * @type void
   * @ignore
   */
  this.setResourceUrl = function(psResourceUrl) {
    this.plugin.setResourceUrl(psResourceUrl);
  };
  /**
   * Submit Base Url을 설정한다.
   * @param {String} psBaseUrl
   * @return void
   * @type void
   * @ignore
   */
  this.setSubmitBaseUrl = function(psBaseUrl) {
    this.plugin.setSubmitBaseUrl(psBaseUrl);
  };
  /**
   * 사용자 PC의 시간을 설정한다.
   * @param {Number} pnYear 연도 4자리
   * @param {Number} pnMonth 월 2자리
   * @param {Number} pnDay 일 2자리
   * @param {Number} pnHour 시 2자리
   * @param {Number} pnMinute 분 2자리
   * @param {Number} pnSecond 초 2자리
   * @return void
   * @type void
   */
  this.setSystemTime = function(pnYear, pnMonth, pnDay, pnHour, pnMinute, pnSecond) {
    this.plugin.setSystemTime(pnYear, pnMonth, pnDay, pnHour, pnMinute, pnSecond);
  };
  /**
   * Logger 인터페이스를 얻는다.
   * @type eXria.form.plugin.Logger
   * @return Logger Object
   */
  this.getLogger = function() {
    return new eXria.form.plugin.Logger(this.plugin);
  };
  /**
   * close
   * @return void
   * @type void
   * @ignore
   */
  this.close = function() {
    //this.plugin.close();

    if (this.page.metadata.modelType == eXria.form.ModelType.JRE && this.globalWindow != null) {
      this.globalWindow.removeWindow(this.id);
    }
    delete this.plugin;
  };
  /**
   * 콤보구분 인스턴스 ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return 인스턴스 ID 리스트 (ex. instance,instance1)
   */
  this.getInstanceIdList = function() {
    return this.plugin.getInstanceIDListStr();
  };
  /**
   * 콤보구분 DataSet ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return DataSet ID 리스트 (ex. dst1,dst2,dst3)
   */
  this.getDataSetIdList = function() {
    return this.plugin.getDataSetIDListStr();
  };
  /**
   * Server Error Message를 반환한다.
   * @param {Boolean} pbCode 에러 코드 리턴 유무
   * @param {Boolean} pbMsg 에러 메세지 리턴 유무
   * @param {Boolean} pbSrc 에러 소스 리턴 유무
   * @type eXria.data.ArrayCollection
   * @return Error String을 담고 있는 Array 객체
   * @ignore
   */
  this.getErrorMessage = function(pbCode, pbMsg, pbSrc) {
    if (pbCode != false)
      pbCode = true;
    if (pbMsg != false)
      pbMsg = true;
    if (pbSrc != false)
      pbSrc = true;

    var vnDefInstId = this.plugin.getDefInstanceID();
    if (!vnDefInstId)
      throw new Error("Default Instance ID is null.");
    var voMapNode = this.getInstance(vnDefInstId).getMapNode("/root/EXRIAERRMSG");
    if (voMapNode.size() == 0)
      return null;

    var vsErrFullStr = "", vsErrCode = "", vsErrMsg = "", vsErrSrc = "";
    if (pbCode)
      vsErrCode = voMapNode.get("ERRCODE");
    if (pbMsg)
      vsErrMsg = voMapNode.get("ERRMSG");
    if (pbSrc)
      vsErrSrc = voMapNode.get("ERRSRC");

    vsErrFullStr = vsErrCode + vsErrMsg + vsErrSrc;

    return vsErrFullStr.replace(/\\n/ig, "\n");
  };
  /**
   * Server Error Message를 전부 삭제한다.
   * @type void
   * @return void
   * @ignore
   */
  this.clearErrorMessage = function() {
    var vnDefInstId = this.plugin.getDefInstanceID();
    if (!vnDefInstId)
      throw new Error("Default Instance ID is null.");
    var voNode = this.getInstance(vnDefInstId).selectSingleNode("/root/EXRIAERRMSG");
    while (voNode.childNodes.length) {
      voNode.removeChild(voNode.childNodes[0]);
    }
  };
  /**
   * 화면 loading 시 progress bar 출력
   * @param {Boolean} pbShow boolean : true - progress bar 출력, false - progress bar 종료
   * @return void
   * @type void
   * @ignore
   */
  this.progressAction = function(pbShow, psImage) {
    if (pbShow) {
      if (psImage == null || psImage == "") {
        this.plugin.progressAction(pbShow, this.getProgressImgPath());
      } else {
        this.plugin.progressAction(pbShow, psImage);
      }
    } else {
      this.plugin.progressAction(pbShow, "");
    }
  };
  /**
   * AES암호화 후 Base64 처리 된 문자열을 복호화 하여 원본 문자열을 리턴한다.
   * @param {String} psStr
   * @type String
   * @return Base64 decoding 후 복호화 하여 원본 문자열
   */
  this.decryptStr = function(psStr) {
    if (!psStr)
      return null;
    return this.plugin.decryptStr(psStr);
  };
  /**
   * plugin 내부 AES 알고리즘으로 입력된 파라미터 문자열을 암호화 하여 Base64 처리 후 리턴한다.
   * @param {String} psStr
   * @type String
   * @return 암호화와 Base64처리 된 문자열
   */
  this.encryptStr = function(psStr) {
    if (!psStr)
      return null;
    return this.plugin.encryptStr(psStr);
  };
  /**
   * 콤보구분 Submission ID 리스트 문자열을 반환하는 메소드.
   * @type String
   * @return Submission ID 리스트 (ex. sms1,sms2,sms3)
   */
  this.getSubmissionIdList = function() {
    return this.plugin.getSubmissionIdListStr();
  };
  /**
   * 현재 클라이언트 PC의 Mac Address를 리턴
   * @type String
   * @return Mac Address
   */
  this.getMacAddr = function() {
    return this.plugin.getMacAddr();
  };
};

/**
 * @fileoverview
 * 이 파일은 controls package를 정의한다.
 * @author 김경태
 * @version 1.0
 */

/**
 * eXria controls package
 */
eXria.controls = {};

/**
 * abstract Bound
 * @작성자 : 김경태
 * @version 1.0

/**
 * Bound (추상클래스)
 * 화면에서 차지하는 영역 정보를 보관하는 기본 클래스
 * @param poParent : Bound 영역을 가진 객체가 포함된 상위 객체
 */
eXria.controls.Bound = function(poContol, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  // Bound의 초기값 설정
  if(poContol == null || poContol == undefined) {
    this.left = pnLeft || 0;
    this.top = pnTop || 0;
    this.width = pnWidth || 100;
    this.height = pnHeight || 50;
  } else {
    this.left = pnLeft || poContol.getDefaultControl("left");
    this.top = pnTop || poContol.getDefaultControl("top");
    this.width = pnWidth || poContol.getDefaultControl("width");
    this.height = pnHeight || poContol.getDefaultControl("height");
  }

  //////////////////////////////////////////////////////////////////
  // 메소드
  this.getInt = function(psPos) { return parseInt(psPos, 10); };

  this.cloneBound = function() {
    return new eXria.controls.Bound(
      this.left != null ? new Number(this.left) : null
      , this.top != null ? new Number(this.top) : null
      , this.width != null ? new Number(this.width) : null
      , this.height != null ? new Number(this.height) : null
    );
  };

  this.copyBound = function(poBound) {
    this.left = poBound.left != null ? new Number(poBound.left) : null;
    this.top = poBound.top != null ? new Number(poBound.top) : null;
    this.width = poBound.width != null ? new Number(poBound.width) : null;
    this.height = poBound.height != null ? new Number(poBound.height) : null;
  };
};
/**
 * @fileoverview
 * Abstract CommonDefine(공통적으로 사용하는 예약어를 정의하는 패키지).
 * @author 김경태
 * @version 1.0
 */

/**
 * 공통적으로 사용하는 예약어를 정의하는 패키지
 */
eXria.controls.CommonDefine = {};


/**
 * 옵저버 객체에 대한 통지 형태를 정의
 */
eXria.controls.CommonDefine.Notice = {
  APPLY_ATTRIBUTE : "APPLY_ATTRIBUTE",
  REMOVE_ATTRIBUTE : "REMOVE_ATTRIBUTE",
  REFRESH : "REFRESH"
};
/**
 * @fileoverview
 * controls 패키지의 최상위 Abstract Control을 정의
 * @author 김경태
 */

/**
 * @class 모든 컨트롤에 대한 기본 클래스가 되는 최상위 클래스
 * @version 2.0
 * @constructor
 * @param {String} psId 컨트롤 식별자
 * @return 모든 컨트롤이 상속받게 되는 eXria.controls.Control 객체
 * @type eXria.controls.Control
 */
eXria.controls.Control = function(psId) {
  /**
   * 컨트롤 식별자.
   * @type String
   */
  this.id = psId;
  /**
   * 자기자신을 가지고 있는 부모 객체인 Canvas를 참조.
   * @type Xria.form.xhtml.Canvas
   */
  this.canvas = null;
  /**
   * 자기자신의 실체화 객체를 참조.
   * @type String
   */
  this.ctrl = null;
  /**
   * innerHTML 템플릿.
   * @type Array
   */
  this.template = null;
  /**
   * 사용자 정의 값을 저장하기 위한 속성.
   * @type String
   */
  this.userAttr = null;
}; // End of Control

/**
 * Ctrl(실체화 컨트롤)을 생성한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치할 Doucment에 대한 참조
 * @return 실체화 컨트롤에 대한 참조
 * @type object
 */
eXria.controls.Control.prototype.create = function(poDocument) {
  if(poDocument == null) poDocument = this.document;
  var voCtrl = null;

  if(this.createCtrl) {                                                                               // 1. Main Ctrl 생성 후 추가
    voCtrl = this.createCtrl(poDocument);
    if(voCtrl) this.canvas.getCtrl().appendChild(voCtrl);
    else new Error("create main ctrl error");
  };

  if(this.createSubCtrl && voCtrl) { this.createSubCtrl(voCtrl, poDocument); };                       // 2. Composite Child Ctrl 생성

  if(this.setTemplate && voCtrl) { this.setTemplate(voCtrl, poDocument); };                           // 13. innerHTML 방식으로 생성하는 컨트롤인 경우 Template 생성
  if(this.setMainCtrlStyles && voCtrl) { this.setMainCtrlStyles(voCtrl, poDocument); };               // 3. Main Style 적용
  if(this.setSubCtrlStyles && voCtrl) { this.setSubCtrlStyles(voCtrl, poDocument); };                 // 4. Composite Child Style 적용

  if(this.setFormDefaults && voCtrl) { this.setFormDefaults(voCtrl, poDocument); };
  if(this.setUIGeneralDefaults && voCtrl) { this.setUIGeneralDefaults(voCtrl, poDocument); };         // 5. 공통 초기값 설정
  if(this.setSpecificDefaults && voCtrl) { this.setSpecificDefaults(voCtrl, poDocument); };           // 6. 개별 초기값 설정

  //if(this.setFormAttrs && voCtrl) { this.setFormAttrs(voCtrl, poDocument); };
  //if(this.setGeneralAttrs && voCtrl) { this.setGeneralAttrs(voCtrl, poDocument); };                   // 7. 공통 Attrs 적용
  //if(this.setUIGeneralAttrs && voCtrl) { this.setUIGeneralAttrs(voCtrl, poDocument); }                // 8. UI 공통 Attrs 적용
  if(this.setSpecificAttrs && voCtrl) { this.setSpecificAttrs(voCtrl, poDocument); }                  // 9. 개별 Attrs 적용

  if(!this.printMode) {
    if(this.setGeneralEvents && voCtrl) { this.setGeneralEvents(voCtrl); }                            // 10. 공통 Events 적용
    if(this.setUIGeneralEvents && voCtrl) { this.setUIGeneralEvents(voCtrl); }                        // 11. UI 공통 Events 적용
    if(this.setSpecificEvents && voCtrl) { this.setSpecificEvents(voCtrl); }                          // 12. 개별 Events 적용
  }

  return voCtrl;
};
/**
 * 속성 값을 설정한다.
 * 그러나 값만 설정할 뿐 해당 속성의 관련된 UI 갱신작업까지 수행하지는 않음.
 * @ignore
 */
eXria.controls.Control.prototype.setAttr = null;
/**
 * 속성 값을 구한다.
 * @ignore
 */
eXria.controls.Control.prototype.getAttrValue = null;
/**
 * 속성을 제거한다.
 * @ignore
 */
eXria.controls.Control.prototype.removeAttr = null;
 /**
  * 속성 값을 설정하고 바로 적용한다. (설정된 속성을 실체화 컨트롤에 바로 적용)
  * @ignore
  */
eXria.controls.Control.prototype.applyAttr = null;
/**
 * canvas에 컨트롤이 로딩되어 있는지의 여부를 구한다.
 * @return 컨트롤의 로딩 여부
 * @type Boolean
 */
eXria.controls.Control.prototype.isLoaded = function() {
  if(this.canvas == null || this.canvas == undefined)
    return false;
  else
    return true;
};
/**
 * 컨트롤의 정보를 문자열로 구한다.
 * @ignore
 */
eXria.controls.Control.prototype.toString = null;
/**
 * 실체화 컨트롤을 구한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document에 대한 참조
 * @return 실체화 컨트롤
 * @type Object
 */
eXria.controls.Control.prototype.getCtrl = function(poDocument) {
  if(this.ctrl == null) this.ctrl = this.lookup(this.id, poDocument);
  return this.ctrl;
};
/**
 * 컨트롤이 속한 canvas를 구한다.
 * @return 컨트롤이 속한 eXria.form.Canvas에 대한 참조
 * @type eXria.form.Canvas
 */
eXria.controls.Control.prototype.getCanvas = function() {
  if(this.canvas) { return this.canvas; }
};
/**
 * 브라우저에서 발생한 이벤트를 전달받아 자바스크립트 컨트롤 이벤트로 처리한다.
 * @param {HTMLEvent} e 브라우저 이벤트
 * @param {eXria.controls.Control} poControl 이벤트를 실행할 컨트롤 객체에 대한 참조
 * @private
 */
eXria.controls.Control.prototype.runEvent = function(e, poControl) {
  if(!!this.skipEvent) return;
  var voCanvas = this.canvas;
  var voEvent = new eXria.event.Event(e, this.window);
  var vsType = voEvent.type;
  if(voCanvas.page.waitingSend && vsType == "blur") {
    voEvent.stopEvent();
    return;
  }

  if(this.disabled || this.isEditing) { //input 계열 컨트롤에서 MaxByteLength를 넘어가는 keyup을 구분하기 위해 isEditing속성 사용
    voEvent.stopPropagation();
    if(vsType == "focus") this.isEditing = false;
    return;
  }

  voEvent.object = poControl;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;

  switch(vsType) {
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  case "change" :
    if(this.isComboMousedown) vbSkip = true;
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  case "focus" :
    if(voCanvas.page.metadata.browser.gecko) {
      var voTarget = voEvent.target;
      if(voTarget == null) return;

      var vsNodeName = voTarget.nodeName.toUpperCase();
      var vsType = voTarget.type.toUpperCase();

      if(vsNodeName == "INPUT") {
        if(vsType == "TEXT" || vsType == "PASSWORD") break;
      } else if(vsNodeName == "TEXTAREA") {
        break;
      }
    }
  default :
    voEvent.stopPropagation();
    break;
  }
};
/**
 * 해당 사용자 이벤트 핸들러 수행 후의 Callback 메소드 지정
 * @param {String} 이벤트 타입 분류 문자열(click, change..)
 * @param {Function} poFunc 사용자 이벤트 콜백 메소드
 */
eXria.controls.Control.prototype.bindEventCallback = function(psEventType, poFunc) {
  this[psEventType + "EventCallback"] = poFunc;
};
/**
 * 자바스크립트 컨트롤에서 일차적으로 처리한 이벤트를 전달받아 자바스크립트 컨트롤 이벤트로 실행한다.
 * @param {eXria.event.Event} poEvent 자바스크립트 이벤트
 * @param {eXria.controls.Control} poControl 이벤트를 실행할 컨트롤 객체에 대한 참조
 * @private
 */
eXria.controls.Control.prototype.runControlEvent = function(poEvent, poControl) {
  var vsType = poEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](poEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](poEvent); }
  if (poControl[vsOnEvent]) { poControl[vsOnEvent](poEvent); }
  if (poControl[vsFinalEvent]) { poControl[vsFinalEvent](poEvent); }
};
/**
 * 컨트롤(Control)에 설정된 최신 정보로 실체화 컨트롤(Ctrl)을 새로고침한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {Boolean} pbChildRefresh 하위 컨트롤의 refresh 여부(생략시 true) ex)true -> 새로고침 O, false -> 새로고침 X
 */
eXria.controls.Control.prototype.refresh = function(poDocument, pbChildRefresh) {
  if(poDocument == null) poDocument = this.document;
  if(pbChildRefresh == null || pbChildRefresh == undefined) pbChildRefresh = true;
//  voCtrl = this.getCtrl(poDocument);

  if(this.removeUIGeneralDefaults) { this.removeUIGeneralDefaults(this.ctrl, poDocument); };           // 공통 초기값으로 지정된 속성값을 제거
  if(this.removeSpecificDefaults) { this.removeSpecificDefaults(this.ctrl, poDocument); };             // 개별 초기값으로 지정된 속성값을 제거

  if(this.refreshTemplate) { this.refreshTemplate(this.ctrl, poDocument, pbChildRefresh); };
  if(this.refreshMainStyles) { this.refreshMainStyles(this.ctrl, poDocument); };                       // Main Style 새로고침
  if(this.refreshSubStyles) { this.refreshSubStyles(this.ctrl, poDocument); };                         // Composite Child Style 새로고침

  if(this.refreshUIGeneralDefaults) { this.refreshUIGeneralDefaults(this.ctrl, poDocument); };                // 공통 초기값으로 새로고침
  if(this.refreshSpecificDefaults) { this.refreshSpecificDefaults(this.ctrl, poDocument, pbChildRefresh); };  // 개별 초기값으로 새로고침

  //if(this.refreshGeneralAttrs) { this.refreshGeneralAttrs(voCtrl, poDocument); };                     // 공통 속성으로 새로고침
  //if(this.refreshUIGeneralAttrs) { this.refreshUIGeneralAttrs(voCtrl, poDocument); };                 // UI 공통 속성으로 새로고침
  if(this.refreshSpecificAttrs) { this.refreshSpecificAttrs(this.ctrl, poDocument, pbChildRefresh); };  // 개별 속성으로 새로고침

  //if(this.refhresGeneralEvents) { this.refhresGeneralEvents(voCtrl); };                           // 공통 Events로 새로고침
  //if(this.refreshUIGeneralEvents) { this.refreshUIGeneralEvents(voCtrl); };                       // UI 공통 Events로 새로고침
  if(this.refreshSpecificEvents) { this.refreshSpecificEvents(this.ctrl); };                        // 개별 Events로 새로고침

  if(this.reloadData) { this.reloadData(this.ctrl, poDocument, pbChildRefresh); };                                   // Data 새로고침
  //if(voCtrl != this.getCtrl(poDocument)) voCtrl = this.getCtrl(poDocument); //20090621 dhkim
  if(this.refreshComplete) {this.refreshComplete(this.ctrl, poDocument, pbChildRefresh); };                           // 새로고침 최종 처리
};
/**
 * 컨트롤과 실체화컨트롤을 모두 제거한다.
 */
eXria.controls.Control.prototype.clear = function() {
   if(this.clearCtrl) { this.clearCtrl(); };                        // 1. Ctrl 제거
   if(this.clearControl) { this.clearControl(); };                  // 2. Control을 제거
};
/**
 * 컨트롤을 제거한다.
 * @private
 */
eXria.controls.Control.prototype.clearControl = function() {
  for (member in this) {
    this[member] = null;
    delete this[member];
  }
};
/**
 * 공통 초기화 수행
 * @ignore
 */
eXria.controls.Control.prototype.initGeneral = null;
/**
 * 사용자 정의 속성 추가
 * @param {String} psUserAttr 사용자 정의 속성 문자열 값
 */
eXria.controls.Control.prototype.setUserAttr = null;
/**
 * @fileoverview
 * Abstract Group(UI 컨트롤들을 그룹짓는 클래스)
 * @author 김경태
 */

/**
 * @class Group (추상클래스).<br>
 * UI 컨트롤들을 그룹짓는 클래스.
 * @version 1.0
 * @constructor
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.Group 객체
 * @type eXria.controls.Group
 */
eXria.controls.Group = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 컨트롤 식별자
   * @type String
   */
  this.id = psId;
  /**
   * 컨트롤의 left 좌표
   * @type Number
   */
  this.left = pnLeft || 0;
  /**
   * 컨트롤의 top 좌표
   * @type Number
   */
  this.top = pnTop || 0;
  /**
   * 컨트롤의 가로길이
   * @type Number
   */
  this.width = pnWidth || 200;
  /**
   * 컨트롤의 세로길이
   * @type Number
   */
  this.height = pnHeight || 200;
  /**
   * 하위 구성요소(컨트롤)를 담고 있는 컬렉션 배열
   * @type eXria.data.ArrayCollection
   */
  this.controls = new eXria.data.ArrayCollection();
};
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 하위 구성요소(컨트롤)를 추가한다.
 * @param {Object} poItem 추가될 구성요소(컨트롤)
 * @private
 */
eXria.controls.Group.prototype.addItem = function(poItem) {
  this.controls.add(poItem);
};
/**
 * 하위 구성요소(컨트롤)들에 대한 참조를 반환합니다.
 * @return 구성요소(컨트롤)들에 대한 참조로 구성된 ArrayCollection
 * @type eXria.data.ArrayCollection
 */
eXria.controls.Group.prototype.getControls = function() {
  return this.controls;
};
/**
 * 하위 구성요소(컨트롤)를 반환합니다.
 * @param {pnIndex} 반환할 구성요소(컨트롤) 인덱스
 * @return 지정된 구성요소(컨트롤)
 * @private
 */
eXria.controls.Group.prototype.getItem = function(pnIndex) {
  return this.controls.get(pnIndex);
};
/**
 * 하위 구성요소(컨트롤)를 삭제 시킵니다.
 * @param {pnIndex} 삭제될 구성요소(컨트롤) 인덱스
 * @private
 */
eXria.controls.Group.prototype.removeItem = function(pnIndex) {
  this.controls.remove(pnIndex);
};

/**
 * @fileoverview
 * Abstract TableLayout(UI 컨트롤들을 그룹짓는 클래스)
 * @author 정희수
 */

/**
 * @class TableLayout (추상클래스).<br>
 * UI 컨트롤들을 그룹짓는 클래스.
 * @version 1.0
 * @constructor
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.TableLayout 객체
 * @type eXria.controls.TableLayout
 */
eXria.controls.TableLayout = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  eXria.controls.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
};

//eXria.controls.xhtml.Util.createInheritance(eXria.controls.Group, eXria.controls.TableLayout);
//////////////////////////////////////////////////////////////////
// 메소드
eXria.controls.TableLayout.prototype.setCellSpan = null;

eXria.controls.TableLayout.prototype.getCellSpan = null;
/**
 * @fileoverview
 * Abstract Notify(옵저버에 통지되는 데이터 형태 정의)
 * @author 김경태
 */

/**
 * @class notify (추상클래스).<br>
 * 옵저버에 통지되는 데이터 형태 정의.
 * @version 1.0
 * @constructor
 * @return 새로운 eXria.controls.Notify 객체
 * @type eXria.controls.Notify
 */
eXria.controls.Notify = function() {
  /**
   * 옵저버에 대한 통지 형태(스트링 상수 지정).<br>
   * <a href="../../../eXria.controls.CommonDefine.js">eXria.controls.CommonDefine.Notice를 참조</a>
   * @type String
   */
  this.type = null;       // eXria.controls.CommonDefine.Notice를 참조

  /**
   * 옵저버에 대한 통지 데이터
   * @type eXria.data.ArrayMap
   */
  this.datas = new eXria.data.ArrayMap();
};

/**
 * @fileoverview
 * Abstract ObserverHandler(컨트롤이 가지고 있는 속성의 변경을 관찰하여 필요한 경우에 이를 관련 메소드에 통지)
 * @author 김경태
 */

/**
 * @class ObserverHandler (추상클래스).<br>
 * 컨트롤이 가지고 있는 속성의 변경을 관찰하여 필요한 경우에 이를 관련 메소드에 통지.
 * @version 1.0
 * @constructor
 * @return 새로운 eXria.controls.ObserverHandler 객체
 * @type eXria.controls.ObserverHandler
 */
eXria.controls.ObserverHandler = function() {

  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 옵저버 객체들에 대한 보관소.
   * @type eXria.data.ArrayMap
   */
  this.observers = new eXria.data.ArrayMap();

  //////////////////////////////////////////////////////////////////
  // 메소드
  /**
   * 옵저버 객체를 추가한다.
   * @param {String} psKey 옵저버에 매칭되는 키값
   * @param {Object} poObserver 옵저버 객체
   */
  this.addObserver = function(psKey, poObserver) {
    if(poObserver.update == null || poObserver.update == undefined) {
      throw new Error("옵저버에 적합하지 않은 객체입니다.");
    } else {
      this.observers.put(psKey, poObserver);
    }
  };

  /**
   * 지정된 키에 해당하는 옵저버 객체를 구한다.
   * @param {String} psKey 옵저버에 매칭되는 키값
   * @return 옵저버 객체
   * @type Object
   */
  this.getObserver = function(psKey) {
    return this.observers.get(psKey);
  };

  /**
   * 옵저버 객체를 제거한다.
   * @param {String} psKey 옵저버에 매칭되는 키값
   */
  this.removeObserver = function(psKey) {
    this.observers.remove(psKey);
  };

  /**
   * 옵저버핸들러에 도착한 통지를 처리한다. (옵저버들에게 통지에 따른 처리를 명령한다.)
   * @param {Object} poNotify 통지 객체
   */
  this.notify = function(poNotify) {
    var voIterator = this.observers.getKeyCollection().iterator();
    while(voIterator.hasNext()) {
      var vsKey = voIterator.next();
      this.observers.get(vsKey).update(poNotify);
    }
  };
};
/**
 * @fileoverview
 * Abstract Item(Select형 컨트롤에서 사용될 아이템의 추상 클래스)
 * @author 김경태
 */

/**
 * @class eXria.controls.Item.<br>
 * Select형 컨트롤에서 사용될 아이템의 추상 클래스
 * @version 2.0
 * @constructor
 * @param {String} psId 아이템 식별자
 * @param {Object} poParent 상위컨트롤
 * @param {String} psLabelText 아이템에 표시될 문자열
 * @param {String} psValue 아이템에 할당될 값
 * @param {Number} pnLeft 아이템 좌상단 점 x좌표
 * @param {Number} pnTop 아이템 좌상단 점 y좌표
 * @param {Number} pnWidth 아이템의 가로 길이
 * @param {Number} pnHeight 아이템의 세로 길이
 * @return 새로운 eXria.controls.Item 객체
 * @type eXria.controls.Item
 */
eXria.controls.Item = function(psId, poParent, psLabelText, psValue, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 컨트롤 식별자.
   * @type String
   */
  this.id = psId;
  /**
   * 상위 컨트롤 객체.<br>
   * 읽기 전용 속성.
   * @type Object
   */
  this.parent = poParent;             // readonly
  /**
   * 디폴트로 이 아이템 객체가 선택될 지 여부.
   * @type Boolean
   */
  this.defaultSelected = false;       // boolean
  /**
   * 컨트롤에 표시될 문자열 값 저장.
   * @type String
   */
  this.text = psLabelText;            // string
  /**
   * 상위 컨트롤에서 option들 상호간에 식별자 역할 속성.<br>
   * 읽기 전용 속성.
   * @type Number
   */
  this.index = null;                  // readonly number
  /**
   * 아이템의 활성화 여부 지정.
   * @type Boolean
   */
  this.disabled = false;              // boolean
  /**
   * 아이템이 선택되었는지 여부 지정.
   * @type Boolean
   */
  this.selected = null;               // boolean
  /**
   * 아이템에 할당된 String value값 저장.
   * @type String
   */
  this.value = psValue;               // string
  /**
   * 아이템의 적용될 css 클래스 명.
   * @type String
   */
  this.className = "";                // string
  /**
   * 아이템의 디스플레이 타입 지정.<br>
   * none/radio/check
   * @type String
   */
  this.type = "none";                 // none/radio/check
  /**
   * 아이템의 하위 label object 저장.
   * @type Object
   */
  this.label = null;                  // object
  /**
   * 아이템의 하위 selector object 저장.
   * @type Object
   */
  this.selector = null;               // object
  /**
   * 라벨의 상대 위치를 지정.<br>
   * left/right/top/bottom
   * @type String
   */
  this.labelPos = null;            // 라벨의 상대 위치를 지정 - left/right/top/bottom
  /**
   * 아이템의 텍스트 가로 정렬.<br>
   * left/center/right
   * @type String
   */
  this.textAlign = null;          // 옵션의 가로 정렬 left/center/right
  /**
   * 아이템의 세로 정렬.<br>
   * top/middle/bottom
   * @type String
   */
  this.verticalAlign = null;      // 옵션의 세로 정렬 top/middle/bottom
  /**
   * 아이템의 좌측 시작 x좌표.
   * @type Number
   */
  this.left = pnLeft || 0;            // 옵션의 좌측 시작 x좌표
  /**
   * 아이템의 상단 시작 y좌표.
   * @type Number
   */
  this.top = pnTop || 0;              // 옵션의 상단 시작 y좌표
  /**
   * 아이템의 가로길이
   * @type Number
   */
  this.width = pnWidth || 200;        // 옵션의 넓이 - number
  /**
   * 아이템의 세로길이
   * @type Number
   */
  this.height = pnHeight || 20;       // 옵션의 높이 - number
  /**
   * 글자색.
   * @type String
   */
  this.color = null;                  // 글자색
  /**
   * 글자 크기.
   * @type Number
   */
  this.fontSize = null;                // 글자 크기
  /**
   * 아이템의 배경색.
   * @type String
   */
  this.backgroundColor = null;        // 옵션의 배경색
  /**
   * 보더 두께.
   * @type Number
   */
  this.borderWidth = null;            // border의 폭 - number
  /**
   * border 스타일.<br>
   * none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset
   * @type String
   */
  this.borderStyle = null;            // none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset
  /**
   * 보더 색상.
   * @type String
   */
  this.borderColor = null;            // border색
};

//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 아이템의 실체화 컨트롤 생성.
 * @ignore
 */
eXria.controls.Item.prototype.createCtrl = function() {};
/**
 * 아이템의 실체화 컨트롤 하위 요소 생성.
 * @ignore
 */
eXria.controls.Item.prototype.createSubCtrl = function() {};
/**
 * 아이템에 할당된 값 반환.
 * @return 아이템에 할당된 값
 * @type String
 */
eXria.controls.Item.prototype.getValue = function(){
  return this.value;
};

/**
 * @fileoverview
 * Abstract MenuItem(메뉴형 컨트롤에서 사용될 아이템의 추상 클래스)
 * @author 김경태
 */

/**
 * @class eXria.controls.MenuItem.<br>
 * 메뉴형 컨트롤에서 사용될 아이템의 추상 클래스
 * @version 1.0
 * @constructor
 * @param {String} psId 아이템 식별자
 * @param {Object} poParent 상위컨트롤
 * @param {String} psLabelText 아이템에 표시될 문자열
 * @param {String} psValue 아이템에 할당될 값
 * @param {Number} pnLeft 아이템 좌상단 점 x좌표
 * @param {Number} pnTop 아이템 좌상단 점 y좌표
 * @param {Number} pnWidth 아이템의 가로 길이
 * @param {Number} pnHeight 아이템의 세로 길이
 * @return 새로운 eXria.controls.MenuItem 객체
 * @type eXria.controls.MenuItem
 */
eXria.controls.MenuItem = function(psId, poControl, psLabel, psValue, psImage, psHotKey, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 컨트롤 식별자.
   * @type String
   */
  this.id = psId;
  /**
   * 상위 컨트롤 객체.<br>
   * 읽기 전용 속성.
   * @type Object
   */
  this.parentControl = poControl;
  /**
   * 상위 아이템에 객체.<br>
   * @type eXria.controls.MenuItem
   */
  this.parent = null;
  /**
   * label 텍스트.
   * @type String
   */
  this.label = psLabel;
  /**
   * 아이템에 할당된 String value값.
   * @type String
   */
  this.value = psValue;
  /**
   * 아이템에 할당된 아이콘 이미지의 경로.
   * @type String
   */
  this.image = psImage;
  /**
   * 아이템에 할당된 HotKey(단축키).
   * @type String
   */
  this.hotKey = psHotKey;
  /**
   * 상위 컨트롤에서 option들 상호간에 식별자 역할 속성.<br>
   * 읽기 전용 속성.
   * @type Number
   */
  this.index = null;                  // readonly number
  /**
   * 아이템의 활성화 여부 지정.
   * @type Boolean
   */
  this.disabled = null;              // boolean
  /**
   * 아이템이 선택되었는지 여부 지정.
   * @type Boolean
   */
  this.selected = false;               // boolean
  /**
   * 아이템의 텍스트 가로 정렬.<br>
   * left/center/right
   * @type String
   */
  this.textAlign = null;          // 옵션의 가로 정렬 left/center/right
  /**
   * 아이템의 세로 정렬.<br>
   * top/middle/bottom
   * @type String
   */
  this.verticalAlign = null;        // 옵션의 세로 정렬 top/middle/bottom
  /**
   * 아이템의 좌측 시작 x좌표.
   * @type Number
   */
  this.left = pnLeft || 0;            // 옵션의 좌측 시작 x좌표
  /**
   * 아이템의 상단 시작 y좌표.
   * @type Number
   */
  this.top = pnTop || 0;              // 옵션의 상단 시작 y좌표
  /**
   * 아이템의 가로길이
   * @type Number
   */
  this.width = pnWidth || 200;        // 옵션의 넓이 - number
  /**
   * 아이템의 세로길이
   * @type Number
   */
  this.height = pnHeight || 20;       // 옵션의 높이 - number
  /**
   * 글자색.
   * @type String
   */
  this.color = null;                  // 글자색
  /**
   * 글자 크기(단위:pt).
   * @type Number
   */
  this.fontSize = null;                // 글자 크기
  /**
   * 아이템의 배경색.
   * @type String
   */
  this.backgroundColor = null;        // 옵션의 배경색
  /**
   * 보더 두께.
   * @type Number
   */
  this.borderWidth = null;            // border의 폭 - number
  /**
   * border 스타일.<br>
   * none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset
   * @type String
   */
  this.borderStyle = null;            // none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset
  /**
   * 보더 색상.
   * @type String
   */
  this.borderColor = null;            // border색
};

//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 아이템의 실체화 컨트롤 생성.
 * @ignore
 */
eXria.controls.MenuItem.prototype.createCtrl = function() {};
/**
 * 아이템의 실체화 컨트롤 하위 요소 생성.
 * @ignore
 */
eXria.controls.MenuItem.prototype.createSubCtrl = function() {};
/**
 * 하위 아이템에서 발생한 이벤트를 컨트롤에 전달한다. (하위 아이템의 이벤트가 컨트롤에 버블링되지 않을 경우 사용)
 * @param {HTMLEvent} e 브라우저 이벤트
 * @param {eXria.controls.Control} poControl 이벤트를 실행할 컨트롤 객체에 대한 참조
 */
eXria.controls.MenuItem.prototype.notifyEvent = function(e, poItem, poControl) {
  var voEvent = new eXria.event.Event(e, poControl.window);
  voEvent.object = this;
  voEvent.objectType = "item";
  voEvent.baseControlId = poControl.baseControlId;
  poControl.runControlEvent(voEvent, poControl);
};

/**
 * @fileoverview
 * Abstract MDIGroup(UI 컨트롤들을 그룹짓는 클래스)
 * @author 박상찬
 */

/**
 * @class MDIGroup (추상클래스).<br>
 * UI 컨트롤들을 그룹짓는 클래스.
 * @version 1.0
 * @constructor
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.MDIGroup 객체
 * @type eXria.controls.MDIGroup
 */
eXria.controls.MDIGroup = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 컨트롤 식별자
   * @type String
   */
  this.id = psId;
  /**
   * 컨트롤의 left 좌표
   * @type Number
   */
  this.left = pnLeft || 0;
  /**
   * 컨트롤의 top 좌표
   * @type Number
   */
  this.top = pnTop || 0;
  /**
   * 컨트롤의 가로길이
   * @type Number
   */
  this.width = pnWidth || 200;
  /**
   * 컨트롤의 세로길이
   * @type Number
   */
  this.height = pnHeight || 200;
  /**
   * 하위 구성요소(컨트롤)를 담고 있는 컬렉션 배열
   * @type eXria.data.ArrayCollection
   */
  this.controls = new eXria.data.ArrayCollection();
};
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 하위 구성요소(컨트롤)를 추가한다.
 * @param {Object} poItem 추가될 구성요소(컨트롤)
 * @private
 */
eXria.controls.MDIGroup.prototype.addItem = function(poItem) {
  this.controls.add(poItem);
};
/**
 * 하위 구성요소(컨트롤)들에 대한 참조를 반환합니다.
 * @return 구성요소(컨트롤)들에 대한 참조로 구성된 ArrayCollection
 * @type eXria.data.ArrayCollection
 */
eXria.controls.MDIGroup.prototype.getControls = function() {
  return this.controls;
};
/**
 * 하위 구성요소(컨트롤)를 반환합니다.
 * @param {pnIndex} 반환할 구성요소(컨트롤) 인덱스
 * @return 지정된 구성요소(컨트롤)
 * @private
 */
eXria.controls.MDIGroup.prototype.getItem = function(pnIndex) {
  return this.controls.get(pnIndex);
};
/**
 * 하위 구성요소(컨트롤)를 삭제 시킵니다.
 * @param {pnIndex} 삭제될 구성요소(컨트롤) 인덱스
 * @private
 */
eXria.controls.MDIGroup.prototype.removeItem = function(pnIndex) {
  this.controls.remove(pnIndex);
};

/**
 * gCore
 *
 * @use YAHOO UI 2.4.1 (BSD) Browser Check
 */
gCore = {
  /**
   * browser
   */  
  browser : {
  msie : 0,
  gecko : 0,
  opera : 0,
  webkit : 0,
  mobile : null,
  trident : 0
  },

  /**
   * init
   * public static method
   */
  init : function(poWindow) {
  var voDocument = poWindow.document;
  var vnDocumentMode = voDocument.documentMode;
  if(vnDocumentMode == null) vnDocumentMode = 0;
  var vsAgent = poWindow.navigator.userAgent;
  var voInfo = null;
    // Modern KHTML browsers should qualify as Safari X-Grade
    if ((/KHTML/).test(vsAgent)) { gCore.browser.webkit = 1; }

    // Modern WebKit browsers are at least X-Grade
    voInfo = vsAgent.match(/AppleWebKit\/([^\s]*)/);
    if (voInfo && voInfo[1]) {
      gCore.browser.webkit = parseFloat(voInfo[1]);

      // Mobile browser check
      if (/ Mobile\//.test(vsAgent)) {
        gCore.browser.mobile = "Apple"; // iPhone or iPod Touch
      } else {
        voInfo = vsAgent.match(/NokiaN[^\/]*/);
        if (voInfo) {
          gCore.browser.mobile = voInfo[0]; // Nokia N-series, ex: NokiaN95
        }
      }
    }

    if (!gCore.browser.webkit) { // not webkit
      // @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
      voInfo = vsAgent.match(/Opera[\s\/]([^\s]*)/);
      if (voInfo && voInfo[1]) {
        gCore.browser.opera = parseFloat(voInfo[1]);
        voInfo = vsAgent.match(/Opera Mini[^;]*/);
        if (voInfo) {
          gCore.browser.mobile = voInfo[0]; // ex: Opera Mini/2.0.4509/1316
        }
      } else { // not opera or webkit
        voInfo = vsAgent.match(/MSIE\s([^;]*)/);
        if (voInfo && voInfo[1]) {
          gCore.browser.msie = parseFloat(voInfo[1]);
          voInfo = vsAgent.match(/Trident\/([^;]*)/);
          if(voInfo && voInfo[1]) gCore.browser.trident = parseFloat(voInfo[1]);
        } else { // not opera, webkit, or ie
          voInfo = vsAgent.match(/Gecko\/([^\s]*)/);
          if (voInfo) {
            gCore.browser.gecko = 1; // Gecko detected, look for revision
            voInfo = vsAgent.match(/rv:([^\s\)]*)/);
            if (voInfo && voInfo[1]) {
              gCore.browser.gecko=parseFloat(voInfo[1]);
            }
          }
        }
      }
    }    
    
    var voPackage = null;

    if (gCore.browser.msie && vnDocumentMode < 9) {
      var vbHasNameSpace = false;
      for (var i = 0; i < voDocument.namespaces.length; i++) {
        if (voDocument.namespaces.item(i).name == "v") vbHasNameSpace = true;
      }
      if (vbHasNameSpace == false) {
        voDocument.namespaces.add("v", "urn:schemas-microsoft-com:vml");
        var voSheet = voDocument.createStyleSheet();
        var voTmpFnc = function() {
          voSheet.addRule("v\\:arc", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:oval", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:line", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:group", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:polyline", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:rect", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:roundrect", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:stroke", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:path", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:textpath", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:fill", "behavior: url(#default#VML);");
          voSheet.addRule("v\\:image", "behavior: url(#default#VML);");
        }

        if(gCore.browser.msie <= 7){
          try {
           voSheet.addRule("v\\:*", "behavior: url(#default#VML);");
          }catch(e){
           voTmpFnc();
          }
        }else{
          voTmpFnc();
        }
      }

      voPackage = gCore.vml; 
    } else {
      voPackage = gCore.svg;
    }

    poWindow.Pane      = voPackage.Pane      ? voPackage.Pane      : null;
    poWindow.Line      = voPackage.Line      ? voPackage.Line      : null;
    poWindow.Rectangle = voPackage.Rectangle ? voPackage.Rectangle : null;
    poWindow.RoundRect = voPackage.RoundRect ? voPackage.RoundRect : null;
    poWindow.Ellipse   = voPackage.Ellipse   ? voPackage.Ellipse   : null;
    poWindow.Circle    = voPackage.Circle    ? voPackage.Circle    : null;
    poWindow.Polyline  = voPackage.Polyline  ? voPackage.Polyline  : null;
    poWindow.Text      = voPackage.Text      ? voPackage.Text      : null;

/*    
    document.body.style.margin = "0px";
    document.body.style.padding = "0px";
*/
  }

};


/**
 * gCore.Arc
 */
gCore.Arc = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pnStartAngle, pnEndAngle) {
  /**
   * inherit
   */
  gCore.Ellipse.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * startAngle
   * public member
   */
  this.startAngle = pnStartAngle;

  /**
   * endAngle
   * public member
   */
  this.endAngle = pnEndAngle;

};

/**
 * gCore.Circle
 */
gCore.Circle = function(psId, pnCenterX, pnCenterY, pnRadius) {

  /**
   * init
   */
  var vnLeft = pnCenterX - pnRadius;
  var vnTop = pnCenterY - pnRadius;
  var vnDiameter = pnRadius * 2;

  /**
   * inherit
   */
  gCore.Ellipse.call(this, psId, vnLeft, vnTop, vnDiameter, vnDiameter);

  /**
   * centerX
   * public member
   */
  this.centerX = pnCenterX;

  /**
   * centerY
   * public member
   */
  this.centerY = pnCenterY;

  /**
   * radius
   * public member
   */
  this.radius = pnRadius;

};

/**
 * gCore.Drawable
 */
gCore.Drawable = function(psId) {

  this.id = psId;

  this.getCtrl = null;

  /**
   * draw
   * public method
   */
  this.draw = null;

};

/**
 * gCore.Ellipse
 */
gCore.Ellipse = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

};

/**
 * gCore.Fill
 */
gCore.Fill = function(psType, psColor, psColor2, pnOpacity, pnAngle) {

  /**
   * shape
   * public member
   */
  this.shape = null;

  /**
   * type
   * public member
   */
  this.type = psType;

  /**
   * color
   * public member
   */
  this.color = psColor;

  /**
   * color2
   * public member
   */
  this.color2 = psColor2;

  /**
   * opacity
   * public member
   */
  this.opacity = pnOpacity;

  /**
   * angle
   * public member
   */
  this.angle = pnAngle;

  /**
   * visible
   * public member
   * default true
   */
  this.visible = true;

};
/**
 * FillableShape
 */
gCore.FillableShape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /*
   * inherit
   */
  gCore.Shape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * fill
   * public member
   */
  this.fill = null;

  /**
   * setFill
   * public method
   */
  this.setFill = null;

  /**
   * attachFill
   * private method
   */
  this.attachFill = null;

};

/**
 * gCore.FillType
 */
gCore.FillType = {
  DEFAULT : "solid",
  NONE : "none",
  SOLID : "solid",
  GRADIENT : "gradient",
  GRADIENTRADIAL : "gradientradial" // reserved
};

/**
 * JoinType
 */
gCore.JoinType = {
  DEFAULT : 1,
  MITER : 0,
  ROUND : 1,
  BEVEL : 2
};

/**
 * gCore.Line
 */
gCore.Line = function(psId, pnX1, pnY1, pnX2, pnY2) {

  var vnLeft = Math.min(pnX1, pnX2);
  var vnTop = Math.min(pnY1, pnY2);
  var vnWidth = Math.abs(pnX1 - pnX2) + 1;
  var vnHeight = Math.abs(pnY1 - pnY2) + 1;

  /**
   * inherit
   */
  gCore.Shape.call(this, psId, vnLeft, vnTop, vnWidth, vnHeight);

  /**
   * startX
   * public member
   */
  this.startX = pnX1;

  /**
   * startY
   * public member
   */
  this.startY = pnY1;

  /**
   * endX
   * public member
   */
  this.endX = pnX2;

  /**
   * endY
   * public member
   */
  this.endY = pnY2;

};
/**
 * LineCapType
 */
gCore.LineCapType = {
  DEFAULT : 1,
  FLAT : 0,
  ROUND : 1,
  SQUARE : 2
};

/**
 * gCore.LineType
 */
gCore.LineType = {
  DEFAULT : 0,
  SOLID : 0,
  DOT : 1,
  DASH : 2
};

/**
 * gCore.Pane
 */
gCore.Pane = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poDocument) {
  /**
   * inherit
   */
  gCore.Drawable.call(this, psId);

  this.document = poDocument || document;

  /**
   * getCtrl
   * public member
   */
  this.getCtrl = function() {
  return this.document.getElementById(this.id);
  };

  /**
   * left
   * public member
   */
  this.left = pnLeft;

  /**
   * top
   * public member
   */
  this.top = pnTop;

  /**
   * width
   * public member
   */
  this.width = pnWidth;

  /**
   * height
   * public member
   */
  this.height = pnHeight;

  /**
   * coords
   */
  this.coordLeft = 0;

  this.coordTop = 0;

  this.coordWidth = this.width;

  this.coordHeight = this.height;

  /**
   * shapes
   * private member
   * array
   */
  this.shapes = [];

  /**
   * addShape
   * public member
   */
  this.addShape = function(poShape) {
  poShape.pane = this;
    this.shapes.push(poShape);
  };

  this.getAreaCtrl = function() {
  return this.document.getElementById(this.id + "_area");
  };

  /**
   * draw
   * public method
   */
  this.draw = function(poParent) {
    var voCtrl = this.createCtrl();
    (poParent ? poParent : this.document.body).appendChild(voCtrl);
    var vnLength = this.shapes.length;
    for (var i = 0; i < vnLength; i++) {
      this.shapes[i].draw(this.getAreaCtrl()||voCtrl.childNodes[0]);
    }

    return voCtrl;
  };

  /**
   * createCtrl
   * private method
   */
  this.createCtrl = null;

};

/**
 * gCore.Polyline
 */
gCore.Polyline = function(psId) {
  /**
   * inherit
   */
  gCore.FillableShape.call(this, psId, null, null, null, null);

  /**
   * points
   * public member
   * array
   */
  this.points = null;

  /**
   * addPoint
   * public method
   */
  this.addPoint = null;

  this.minX = null;
  this.minY = null;
  this.maxX = null;
  this.maxY = null;

};

/**
 * gCore.Rectangle
 */
gCore.Rectangle = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

};

/**
 * gCore.RoundRect
 */
gCore.RoundRect = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pnRound) {
  /**
   * inherit
   */
  gCore.Rectangle.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * round
   * public member
   * 0.0 ~ 1.0
   */
  this.round = pnRound;

};

/**
 * Shape
 */
gCore.Shape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.Drawable.call(this, psId);

  /**
   *
   */
  this.pane = null;

  /**
   * left
   * public member
   */
  this.left = pnLeft;

  /**
   * top
   * public member
   */
  this.top = pnTop;

  /**
   * width
   * public member
   */
  this.width = pnWidth;

  /**
   * height
   * public member
   */
  this.height = pnHeight;

  this.getCtrl = function() {
  return this.pane ? this.pane.document.getElementById(this.id) : null;
  };

  /**
   * createCtrl
   * private method
   */
  this.createCtrl = null;

  /**
   * stroke
   * public member
   */
  this.stroke = null;

  /**
   * setStroke
   * public method
   */
  this.setStroke = null;

  /**
   * attachStroke
   * private method
   */
  this.attachStroke = null;

  /**
   * angle
   * public member
   */
  this.angle = 0;

};

/**
 * Stroke
 */
gCore.Stroke = function(pnType, pnWeight, psColor, pnOpacity, pnLineCap, pnJoinType) {

  this.shape = null;
  this.type = pnType;
  this.weight = pnWeight;
  this.color = psColor;
  this.opacity = pnOpacity;
  this.lineCap = pnLineCap;
  this.joinType = pnJoinType;

  this.visible = true;
};
/**
 * gCore.Text
 */
gCore.Text = function(psId, pnLeft, pnTop, pnWidth, pnHeight, psString, pnPosition) {
  /**
   * inherit
   */
  gCore.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.string = psString;

  this.position = pnPosition;

  this.fontFamily = "Dotum";
  this.fontSize = 12;
  this.fontStyle = "normal";
  this.fontWeight = "normal";

};
/**
 * gCore.TextPosition
 */
gCore.TextPosition = {
  DEFAULT : 0,
  TOPLEFT : 0,
  TOPCENTER : 1,
  TOPRIGHT : 2,
  MIDDLELEFT : 3,
  MIDDLECENTER : 4,
  MIDDLERIGHT : 5,
  BOTTOMLEFT : 6,
  BOTTOMCENTER : 7,
  BOTTOMRIGHT : 8
};
/**
 * gCore.svg
 */
gCore.svg = {};
/**
 * gCore.svg.Circle
 */
gCore.svg.Circle = function(psId, pnCenterX, pnCenterY, pnRadius) {

  var vnLeft = pnCenterX - pnRadius;
  var vnTop = pnCenterY - pnRadius;
  var vnDiameter = pnRadius * 2;

  /**
   * inherit
   */
  gCore.svg.Ellipse.call(this, psId, vnLeft, vnTop, vnDiameter, vnDiameter);

  this.centerX = pnCenterX;
  this.centerY = pnCenterY;
  this.radius = pnRadius;

  this.createCtrl = function() {
  var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "circle");
  voCtrl.setAttribute("id", this.id);
  voCtrl.setAttribute("cx", this.centerX);
  voCtrl.setAttribute("cy", this.centerY);
  voCtrl.setAttribute("r", this.radius);
  voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + this.centerX + "," + this.centerY + ")");
  var voStyle = voCtrl.style;
  voStyle.cursor = this.cursor;
  return voCtrl;
  };

};

/**
 * gCore.svg.DefaultFill
 */
gCore.svg.DefaultFill = function() {

  gCore.svg.Fill.call(this, gCore.FillType.DEFAULT, "#F0F0F0", "F0F0F0", 1.0, 0);

};

/**
 * gCore.svg.DefaultStroke
 */
gCore.svg.DefaultStroke = function() {

  gCore.svg.Stroke.call(this, gCore.LineType.DEFAULT, 1, "#505050", 1.0, gCore.LineCapType.DEFAULT, gCore.JoinType.DEFAULT);

};

/**
 * gCore.svg.Ellipse
 */
gCore.svg.Ellipse = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.svg.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.createCtrl = function() {
  var vnRx = Math.round(this.width / 2);
  var vnRy = Math.round(this.height / 2);
  var vnCx = this.left + vnRx;
  var vnCy = this.top + vnRy;
    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("cx", vnCx);
    voCtrl.setAttribute("cy", vnCy);
    voCtrl.setAttribute("rx", vnRx);
    voCtrl.setAttribute("ry", vnRy);
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnCx + "," + vnCy + ")");
    var voStyle = voCtrl.style;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.svg.Fill
 */
gCore.svg.Fill = function(psType, psColor, psColor2, pnOpacity, pnAngle) {
  /**
   * inherit
   */
  gCore.Fill.call(this, psType, psColor, psColor2, pnOpacity, pnAngle);

  this.apply = function(poCtrl) {

  // visible false or FillType.NONE
    if (this.visible == false || this.type == gCore.FillType.NONE) {
      poCtrl.setAttribute("fill", "none");
    } else {
    // FillType.SOLID
      if (this.type == gCore.FillType.SOLID) {
        poCtrl.setAttribute("fill", this.color);
      // FillType.GRADIENT
      } else if (this.type == gCore.FillType.GRADIENT) {
        var voDefs = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "defs");

        var voLinearGradient = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
        var vsId = this.shape.id + "_gradient_fill";
        voLinearGradient.setAttribute("id", vsId);
        voLinearGradient.setAttribute("gradientUnits", "objectBoundingBox");
   //     var vnCx = this.shape.left + Math.round(this.shape.width / 2);
   //     var vnCy = this.shape.top + Math.round(this.shape.height / 2);
        var vnCx = 0;
        var vnCy = 0;
        voLinearGradient.setAttribute("gradientTransform", "rotate(" + this.angle + ", " + vnCx + ", " + vnCy + ")");

        var voStop1 = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "stop");
        voStop1.setAttribute("id", vsId + "_stop1");
        voStop1.setAttribute("offset", "5%");
        voStop1.setAttribute("stop-color", this.color);
        voLinearGradient.appendChild(voStop1);

        var voStop2 = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "stop");
        voStop2.setAttribute("id", vsId + "_stop2");
        voStop2.setAttribute("offset", "95%");
        voStop2.setAttribute("stop-color", this.color2);
        voLinearGradient.appendChild(voStop2);

        poCtrl.parentNode.appendChild(voDefs);
        voDefs.appendChild(voLinearGradient);

        poCtrl.setAttribute("fill", "url(#" + vsId + ")");
      } else if (this.type == gCore.FillType.GRADIENTRADIAL) {
        var voDefs = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "defs");

        var voRadialGradient = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
        var vsId = this.shape.id + "_gradientradial_fill";
        voRadialGradient.setAttribute("id", vsId);
        var vsCx = "0";
        var vsCy = "0";
        var vsR = "100%";
        var vsFx = "0";
        var vsFy = "0";
        voRadialGradient.setAttribute("cx", vsCx);
        voRadialGradient.setAttribute("cy", vsCy);
        voRadialGradient.setAttribute("r", vsR);
        voRadialGradient.setAttribute("fx", vsFx);
        voRadialGradient.setAttribute("fy", vsFy);
        
        var voStop1 = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "stop");
        voStop1.setAttribute("id", vsId + "_stop1");
        voStop1.setAttribute("offset", "5%");
        voStop1.setAttribute("stop-color", this.color);
        voRadialGradient.appendChild(voStop1);

        var voStop2 = this.shape.pane.document.createElementNS("http://www.w3.org/2000/svg", "stop");
        voStop2.setAttribute("id", vsId + "_stop2");
        voStop2.setAttribute("offset", "95%");
        voStop2.setAttribute("stop-color", this.color2);
        voRadialGradient.appendChild(voStop2);

        poCtrl.parentNode.appendChild(voDefs);
        voDefs.appendChild(voRadialGradient);

        poCtrl.setAttribute("fill", "url(#" + vsId + ")");
      }
      poCtrl.setAttribute("fill-opacity", this.opacity);
    }
    return poCtrl;
  };

};

/**
 * gCore.svg.FillableShape
 */
gCore.svg.FillableShape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /*
   * inherit
   */
  gCore.svg.Shape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * fill
   * public member
   */
  this.fill = null;

  /**
   * setFill
   * public method
   */
  this.setFill = function(poFill) {
  this.fill = poFill;
  this.fill.shape = this;
  };

  /**
   * attachFill
   * private method
   */
  this.attachFill = function(poCtrl) {
    this.fill.apply(poCtrl);
    return poCtrl;
  };

  /*
   * init
   */
  this.setFill(new gCore.svg.DefaultFill());

};

/**
 * gCore.svg.JoinTypes
 */
gCore.svg.JoinTypes = [
  "miter", // MITER
  "round", // ROUND
  "bevel"  // BEVEL
];

/**
 * gCore.svg.Line
 */
gCore.svg.Line = function(psId, pnX1, pnY1, pnX2, pnY2) {

  var vnLeft = Math.min(pnX1, pnX2);
  var vnTop = Math.min(pnY1, pnY2);
  var vnWidth = Math.abs(pnX1 - pnX2) + 1;
  var vnHeight = Math.abs(pnY1 - pnY2) + 1;

  /**
   * inherit
   */
  gCore.svg.Shape.call(this, psId, vnLeft, vnTop, vnWidth, vnHeight);

  this.startX = pnX1;
  this.startY = pnY1;
  this.endX = pnX2;
  this.endY = pnY2;

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "line");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("x1", this.startX);
    voCtrl.setAttribute("y1", this.startY);
    voCtrl.setAttribute("x2", this.endX);
    voCtrl.setAttribute("y2", this.endY);

    var vnCx = this.left + Math.round(this.width);
    var vnCy = this.top + Math.round(this.height);
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnCx + "," + vnCy + ")");
    var voStyle = voCtrl.style;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};
/**
 * gCore.svg.LineCapTypes
 */
gCore.svg.LineCapTypes = [
  "butt", // FLAT
  "round", // ROUND
  "square" // SQUARE
];

/**
 * gCore.svg.LineTypes
 */
gCore.svg.LineTypes = [
  "none", // solid
  "1,2",  // dot
  "6,2"  // dash
];

/**
 * gCore.svg.Pane
 */
gCore.svg.Pane = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poDocument) {
  /**
   * inherit
   */
  gCore.Pane.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight, poDocument);

  this.createCtrl = function() {
    var voDiv = this.document.createElement("div");
    voDiv.setAttribute("id", this.id);
    var voDivStyle = voDiv.style;
    voDivStyle.position = "absolute";
    voDivStyle.left = this.left + "px";
    voDivStyle.top = this.top + "px";
    voDivStyle.width = this.width + "px";
    voDivStyle.height = this.height + "px";
    voDivStyle.overflow = "visible";

    // yhkim shapeType 추가
    var vsWeight = null;
    var vnWeight = 0;
    var vnOffset = 0;
    if(this.shapes[0]) {
      if(this.shapes[0].shapeType) {
        if(this.shapes[0].shapeType == "line") {
          vsWeight = this.shapes[0].stroke.weight;
            vnWeight = Number(vsWeight.replace("px",""));
            vnOffset = vnWeight / 2;
        }
      }
    }

    var voCtrl = this.document.createElementNS("http://www.w3.org/2000/svg", "svg");
    voCtrl.setAttribute("id", this.id + "_area");
    voCtrl.setAttribute("width", (this.width+vnWeight) + "px");
    voCtrl.setAttribute("height", (this.height+vnWeight) + "px");
    voCtrl.setAttribute("viewBox", (this.coordLeft-vnOffset) + " " + (this.coordTop-vnOffset) + " " + (this.coordWidth+vnWeight) + " " + (this.coordHeight+vnWeight));
    var voStyle = voCtrl.style;
    voStyle.position = "absolute";
    voStyle.left = -(vnOffset) + "px";
    voStyle.top = -(vnOffset) + "px";
    voStyle.width = (this.width+vnWeight) + "px";
    voStyle.height = (this.height+vnWeight) + "px";
    voDiv.appendChild(voCtrl);
    return voDiv;
  };

};
/**
 * gCore.svg.Polyline
 */
gCore.svg.Polyline = function(psId) {
  /**
   * inherit
   */
  gCore.svg.FillableShape.call(this, psId, null, null, null, null);

  this.minX = 0;
  this.minY = 0;
  this.maxX = 0;
  this.maxY = 0;

  this.points = [];

  this.addPoint = function(pnX, pnY) {
    this.points.push({"x":pnX, "y":pnY});
    if (this.minX > pnX) { this.minX = pnX; }
    if (this.maxX < pnX) { this.maxX = pnX; }
    if (this.minY > pnY) { this.minY = pnY; }
    if (this.maxY < pnY) { this.maxY = pnY; }
    this.left = this.minX;
    this.top = this.minY;
    this.width = this.maxX - this.minX + 1;
    this.height = this.maxY - this.minY + 1;
  };

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    voCtrl.setAttribute("id", this.id);
    var vsPoints = "";
    var vnLength = this.points.length;
    for (var i = 0; i < vnLength; i++) {
      var voPoint = this.points[i];
      vsPoints += voPoint.x + ", " + voPoint.y + " ";
    }
    voCtrl.setAttribute("points", vsPoints);

    var vnCx = this.left + Math.round(this.width);
    var vnCy = this.top + Math.round(this.height);
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnCx + "," + vnCy + ")");
    var voStyle = voCtrl.style;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.svg.Rectangle
 */
gCore.svg.Rectangle = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.svg.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "rect");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("x", this.left);
    voCtrl.setAttribute("y", this.top );
    voCtrl.setAttribute("width", this.width);
    voCtrl.setAttribute("height", this.height);

    var vnCx = this.left + this.width/2;
    var vnCy = this.top + this.height/2;
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnCx + "," + vnCy + ")");
    var voStyle = voCtrl.style;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.svg.RoundRect
 */
gCore.svg.RoundRect = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pnRound) {
  /**
   * inherit
   */
  gCore.svg.Rectangle.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.round = pnRound;

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "rect");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("x", this.left);
    voCtrl.setAttribute("y", this.top);
    voCtrl.setAttribute("width", this.width);
    voCtrl.setAttribute("height", this.height);
    voCtrl.setAttribute("rx", ((this.height > this.width ? this.width : this.height) * (this.round / 2)));

    var vnCx = this.left + Math.round(this.width/2);
    var vnCy = this.top + Math.round(this.height/2);
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnCx + "," + vnCy + ")");
    var voStyle = voCtrl.style;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.svg.Shape
 */
gCore.svg.Shape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /*
   * inherit
   */
  gCore.Shape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * @inherited
   */
  this.draw = function(poParent) {
    var voCtrl = this.createCtrl();
    poParent.appendChild(voCtrl);
    if (this.attachStroke) { this.attachStroke(voCtrl); }
    if (this.attachFill) { this.attachFill(voCtrl); }

    return voCtrl;
  };

  /**
   * @inherited
   */
  this.setStroke = function(poStroke) {
  this.stroke = poStroke;
  this.stroke.shape = this;
  };

  /**
   * @inherited
   */
  this.attachStroke = function(poCtrl) {
    this.stroke.apply(poCtrl);
    return poCtrl;
  };

  /*
   * init
   */
  this.setStroke(new gCore.svg.DefaultStroke());

};

/**
 * gCore.svg.Stroke
 */
gCore.svg.Stroke = function(pnType, pnWeight, psColor, pnOpacity, pnLineCap, pnJoinType) {
  /**
   * inherit
   */
  gCore.Stroke.call(this, pnType, pnWeight, psColor, pnOpacity, pnLineCap, pnJoinType);

  this.apply = function(poCtrl) {
    poCtrl.setAttribute("stroke", this.visible ? this.color : "none");
    poCtrl.setAttribute("stroke-width", this.weight);
    poCtrl.setAttribute("stroke-opacity", this.opacity);
    var vnWeight = parseInt(this.weight);
    var vsDash = gCore.svg.LineTypes[this.type];
    if(vnWeight > 1 && this.type) {
      var vaLength = vsDash.split(",");
      vaLength[1] = vnWeight * parseInt(vaLength[1]);
      vsDash = vaLength.join(",");
    }
    poCtrl.setAttribute("stroke-dasharray", vsDash);
    poCtrl.setAttribute("stroke-linecap", gCore.svg.LineCapTypes[this.lineCap]);
    poCtrl.setAttribute("stroke-linejoin", gCore.svg.JoinTypes[this.joinType]);
    return poCtrl;
  };

};

/**
 * gCore.svg.Text
 */
gCore.svg.Text = function(psId, pnLeft, pnTop, pnWidth, pnHeight, psString, pnPosition) {
  /**
   * inherit
   */
  gCore.svg.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * init
   */
  this.stroke.visible = false;
  this.fill.color = "#000000";

  this.string = psString;

  this.position = pnPosition || gCore.TextPosition.DEFAULT;


  /**
   * fontFamily
   * public member
   * default Dotum
   */
  this.fontFamily = "Dotum";

  /**
   * fontSize
   * public member
   * default 12
   */
  this.fontSize = 12;

  /**
   * fontStyle
   * public member
   * default normal
   */
  this.fontStyle = "normal";

  /**
   * fontWeight
   * public member
   * default normal
   */
  this.fontWeight = "normal";

  /**
   * createCtrl
   * private method
   */
  this.createCtrl = function() {

  var vsTextAnchor = null;
  var vsBaseLine = null;
  var vnX = 0;
  var vnY = 0;

  var vnTopCorrect = 0;
  var vnMiddleCorrect = 0;
  var vnBottomCorrect = 0;

  if (gCore.browser.opera) {
    vnTopCorrect = Math.round(this.fontSize * 0.85);
    vnMiddleCorrect = Math.round(this.fontSize * 0.7 / 2);
    vnBottomCorrect = Math.round(this.fontSize /  10);
    } else if (gCore.browser.webkit) {
    vnTopCorrect -= Math.round(this.fontSize * 0.05);
    vnMiddleCorrect = Math.round(this.fontSize * 0.12);
    vnBottomCorrect = Math.round(this.fontSize * 0.30);
    }

  switch (this.position) {
    case gCore.TextPosition.TOPLEFT :
      vnX = this.left;
      vnY = this.top + vnTopCorrect;
      vsTextAnchor = "start";
      vsBaseLine = "text-before-edge";
      break;
    case gCore.TextPosition.TOPCENTER :
      vnX = this.left + Math.round(this.width / 2);
      vnY = this.top + vnTopCorrect;
      vsTextAnchor = "middle";
      vsBaseLine = "text-before-edge";
      break;
    case gCore.TextPosition.TOPRIGHT :
      vnX = this.left + this.width - 1;
      vnY = this.top + vnTopCorrect;
      vsTextAnchor = "end";
      vsBaseLine = "text-before-edge";
      break;
    case gCore.TextPosition.MIDDLELEFT :
      vnX = this.left;
      vnY = this.top + Math.round(this.height / 2) + vnMiddleCorrect;
      vsTextAnchor = "start";
      vsBaseLine = "middle";
      break;
    case gCore.TextPosition.MIDDLECENTER :
      vnX = this.left + Math.round(this.width / 2);
      vnY = this.top + Math.round(this.height / 2) + vnMiddleCorrect;
      vsTextAnchor = "middle";
      vsBaseLine = "middle";
      break;
    case gCore.TextPosition.MIDDLERIGHT :
      vnX = this.left + this.width - 1;
      vnY = this.top + Math.round(this.height / 2) + vnMiddleCorrect;
      vsTextAnchor = "end";
      vsBaseLine = "middle";
      break;
    case gCore.TextPosition.BOTTOMLEFT :
      vnX = this.left;
      vnY = this.top + this.height - 1 - vnBottomCorrect;
      vsTextAnchor = "start";
      vsBaseLine = "text-after-edge";
      break;
    case gCore.TextPosition.BOTTOMCENTER :
      vnX = this.left + Math.round(this.width / 2);
      vnY = this.top + this.height - 1 - vnBottomCorrect;
      vsTextAnchor = "middle";
      vsBaseLine = "text-after-edge";
      break;
    case gCore.TextPosition.BOTTOMRIGHT :
      vnX = this.left + this.width - 1;
      vnY = this.top + this.height - 1 - vnBottomCorrect;
      vsTextAnchor = "end";
      vsBaseLine = "text-after-edge";
      break;
    }

    var voCtrl = this.pane.document.createElementNS("http://www.w3.org/2000/svg", "text");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("x", vnX);
    voCtrl.setAttribute("y", vnY);

    voCtrl.setAttribute("font-family", "\"" + this.fontFamily + "\"");
    voCtrl.setAttribute("font-size", this.fontSize);
    voCtrl.setAttribute("font-style", this.fontStyle);
    voCtrl.setAttribute("font-weight", this.fontWeight);
    voCtrl.setAttribute("text-anchor", vsTextAnchor);
    voCtrl.setAttribute("dominant-baseline", vsBaseLine);
    voCtrl.setAttribute("transform", "rotate(" + this.angle + "," + vnX + "," + vnY + ")");

    var voText = document.createTextNode(this.string);
    voCtrl.appendChild(voText);
    return voCtrl;
  };

};
/**
 * gCore.vml
 */
gCore.vml = {};
/**
 * gCore.vml.Arc
 */
gCore.vml.Arc = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pnStartAngle, pnEndAngle) {
  /**
   * inherit
   */
  gCore.vml.Ellipse.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.startAngle = pnStartAngle;

  this.endAngle = pnEndAngle;

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:arc");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("startAngle", this.startAngle);
    voCtrl.setAttribute("endAngle", this.endAngle);
    var voStyle = voCtrl.style;
    voStyle.left = this.left;
    voStyle.top = this.top;
    voStyle.width = this.width < 0 ? 0 : this.width;
    voStyle.height = this.height < 0 ? 0 : this.height;
    voStyle.rotation = this.angle; //
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.vml.Circle
 */
gCore.vml.Circle = function(psId, pnCenterX, pnCenterY, pnRadius) {

  var vnLeft = pnCenterX - pnRadius;
  var vnTop = pnCenterY - pnRadius;
  var vnDiameter = pnRadius * 2;

  /**
   * inherit
   */
  gCore.vml.Ellipse.call(this, psId, vnLeft, vnTop, vnDiameter, vnDiameter);

  this.radius = pnRadius;
};

/**
 * gCore.vml.DefaultFill
 */
gCore.vml.DefaultFill = function() {

  gCore.vml.Fill.call(this, gCore.FillType.DEFAULT, "#F0F0F0", "F0F0F0", 1.0, 0);

};

/**
 * gCore.vml.DefaultStroke
 */
gCore.vml.DefaultStroke = function() {

  gCore.vml.Stroke.call(this, gCore.LineType.DEFAULT, 1, "#505050", 1.0, gCore.LineCapType.DEFAULT, gCore.JoinType.DEFAULT);

};

/**
 * gCore.vml.Ellipse
 */
gCore.vml.Ellipse = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.vml.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:oval");
    voCtrl.setAttribute("id", this.id);
    var voStyle = voCtrl.style;
    voStyle.left = this.left;
    voStyle.top = this.top;
    voStyle.width = (this.width < 0 ? 0 : this.width) + "px";
    voStyle.height = (this.height < 0 ? 0 : this.height) + "px";
    voStyle.rotation = this.angle; //
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.vml.Fill
 */
gCore.vml.Fill = function(psType, psColor, psColor2, pnOpacity, pnAngle) {
  /**
   * inherit
   */
  gCore.Fill.call(this, psType, psColor, psColor2, pnOpacity, pnAngle);

  this.apply = function(poCtrl) {
    var voCtrl = this.shape.pane.document.createElement("v:fill");
    voCtrl.setAttribute("id", this.shape.id + "_fill");
    voCtrl.setAttribute("type", this.type);
    voCtrl.setAttribute("color", this.color);
    voCtrl.setAttribute("color2", this.color2);
    voCtrl.setAttribute("opacity", (this.opacity * 100) + "%");
    if(this.opacity == 0) voCtrl.setAttribute("type", "solid");
    voCtrl.setAttribute("angle", 270 - this.angle);
    voCtrl.setAttribute("on", this.visible && this.type != gCore.FillType.NONE ? true : false);
    poCtrl.appendChild(voCtrl);
    return poCtrl;
  };

  this.getCtrl = function() {
  return this.shape.pane.document.getElementById(this.shape.id + "_fill");
  };

};

/**
 * gCore.vml.FillableShape
 */
gCore.vml.FillableShape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /*
   * inherit
   */
  gCore.vml.Shape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * fill
   * public member
   */
  this.fill = null;

  /**
   * setFill
   * public method
   */
  this.setFill = function(poFill) {
  this.fill = poFill;
  this.fill.shape = this;
  };

  /**
   * attachFill
   * private method
   */
  this.attachFill = function(poCtrl) {
    this.fill.apply(poCtrl);
    return poCtrl;
  };

  /*
   * init
   */
  this.setFill(new gCore.vml.DefaultFill());

};

/**
 * gCore.vml.JoinTypes
 */
gCore.vml.JoinTypes = [
  "miter", // MITER
  "round", // ROUND
  "bevel"  // BEVEL
];

/**
 * gCore.vml.Line
 */
gCore.vml.Line = function(psId, pnX1, pnY1, pnX2, pnY2) {

  var vnLeft = Math.min(pnX1, pnX2);
  var vnTop = Math.min(pnY1, pnY2);
  var vnWidth = Math.abs(pnX1 - pnX2) + 1;
  var vnHeight = Math.abs(pnY1 - pnY2) + 1;

  /**
   * inherit
   */
  gCore.vml.Shape.call(this, psId, vnLeft, vnTop, vnWidth, vnHeight);

  this.startX = pnX1;
  this.startY = pnY1;
  this.endX = pnX2;
  this.endY = pnY2;

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:line");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("from", this.startX + "," + this.startY);
    voCtrl.setAttribute("to", this.endX + "," + this.endY);
    var voStyle = voCtrl.style;
    voStyle.rotation = this.angle; //
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};
/**
 * gCore.vml.LineCapTypes
 */
gCore.vml.LineCapTypes = [
  "flat", // FLAT
  "round", // ROUND
  "square" // SQUARE
];

/**
 * gCore.vml.LineTypes
 */
gCore.vml.LineTypes = [
  "solid", // solid
  "1 1", // dot
  "2 2" // dash
];

/**
 * gCore.vml.Pane
 */
gCore.vml.Pane = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poDocument) {
  /**
   * inherit
   */
  gCore.Pane.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight, poDocument);

  this.createCtrl = function() {
  var voDiv = this.document.createElement("div");
  voDiv.setAttribute("id", this.id);
  var voDivStyle = voDiv.style;
  voDivStyle.position = "absolute";
  voDivStyle.left = this.left + "px";
  voDivStyle.top = this.top + "px";
  voDivStyle.width = this.width + "px";
  voDivStyle.height = this.height + "px";
  voDivStyle.overflow = "visible";

    var voCtrl = this.document.createElement("v:group");
    voCtrl.setAttribute("id", this.id + "_area");
    voCtrl.setAttribute("coordorigin", this.coordLeft + "," + this.coordTop);
    voCtrl.setAttribute("coordsize", this.coordWidth + "," + this.coordHeight);

    var voStyle = voCtrl.style;
    voStyle.position = "absolute";
    voStyle.left = 0 + "px";
    voStyle.top = 0 + "px";
    voStyle.width = this.width + "px";
    voStyle.height = this.height + "px";

    voDiv.appendChild(voCtrl);
    return voDiv;
  };

};
/**
 * gCore.vml.Polyline
 */
gCore.vml.Polyline = function(psId) {
  /**
   * inherit
   */
  gCore.vml.FillableShape.call(this, psId, null, null, null, null);

  this.minX = 0;
  this.minY = 0;
  this.maxX = 0;
  this.maxY = 0;

  this.points = [];

  this.addPoint = function(pnX, pnY) {
    this.points.push({"x":pnX, "y":pnY});
    if (this.minX > pnX) { this.minX = pnX; }
    if (this.maxX < pnX) { this.maxX = pnX; }
    if (this.minY > pnY) { this.minY = pnY; }
    if (this.maxY < pnY) { this.maxY = pnY; }
    this.left = this.minX;
    this.top = this.minY;
    this.width = this.maxX - this.minX + 1;
    this.height = this.maxY - this.minY + 1;
  };

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:polyline");
    voCtrl.setAttribute("id", this.id);
    var vsPoints = "";
    var vnLength = this.points.length;
    for (var i = 0; i < vnLength; i++) {
      var voPoint = this.points[i];
      vsPoints += voPoint.x + "," + voPoint.y + " ";
    }
    voCtrl.setAttribute("points", vsPoints);
    var voStyle = voCtrl.style;
    voStyle.rotation = this.angle;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.vml.Rectangle
 */
gCore.vml.Rectangle = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /**
   * inherit
   */
  gCore.vml.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:polyline");
    var vaPoints = [];
    vaPoints.push(0);
    vaPoints.push(this.height / 2);
    vaPoints.push("0 0");
    vaPoints.push(this.width);
    vaPoints.push(0);
    vaPoints.push(this.width);
    vaPoints.push(this.height);
    vaPoints.push(0);
    vaPoints.push(this.height);
    vaPoints.push(0);
    vaPoints.push(this.height - (this.height / 2));

    voCtrl.setAttribute("points", vaPoints.join(" "));
    voCtrl.setAttribute("id", this.id);
    var voStyle = voCtrl.style;
    voStyle.left = this.left;
    voStyle.top = this.top;
    voStyle.width = (this.width < 0 ? 0 : this.width) + "px";
    voStyle.height = (this.height < 0 ? 0 : this.height) + "px";
    voStyle.rotation = this.angle;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.vml.RoundRect
 */
gCore.vml.RoundRect = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pnRound) {
  /**
   * inherit
   */
  gCore.vml.Rectangle.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  this.round = pnRound;

  this.createCtrl = function() {
    var voCtrl = this.pane.document.createElement("v:roundrect");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("arcSize", this.round / 2);
    var voStyle = voCtrl.style;
    voStyle.left = this.left;
    voStyle.top = this.top;
    voStyle.width = (this.width < 0 ? 0 : this.width) + "px";
    voStyle.height = (this.height < 0 ? 0 : this.height) + "px";
    voStyle.rotation = this.angle;
    voStyle.cursor = this.cursor;
    return voCtrl;
  };

};

/**
 * gCore.vml.Shape
 */
gCore.vml.Shape = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  /*
   * inherit
   */
  gCore.Shape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * @inherited
   */
  this.draw = function(poParent) {
    var voCtrl = this.createCtrl();
    poParent.appendChild(voCtrl);
    if (this.attachStroke) { this.attachStroke(voCtrl); }
    if (this.attachFill) { this.attachFill(voCtrl); }
    return voCtrl;
  };

  /**
   * @inherited
   */
  this.setStroke = function(poStroke) {
    this.stroke = poStroke;
    this.stroke.shape = this;
  };

  /**
   * @inherited
   */
  this.attachStroke = function(poCtrl) {
    this.stroke.apply(poCtrl);
    return poCtrl;
  };

  /**
   * init
   */
  this.setStroke(new gCore.vml.DefaultStroke());

};

/**
 * gCore.vml.Stroke
 */
gCore.vml.Stroke = function(pnType, pnWeight, psColor, pnOpacity, pnLineCap, pnJoinType) {
  /**
   * inherit
   */
  gCore.Stroke.call(this, pnType, pnWeight, psColor, pnOpacity, pnLineCap, pnJoinType);

  this.apply = function(poCtrl) {
  /*
  var voPane = this.shape.pane;
  var voReadWidth = voPane.width;
  var voRealHeight = voPane.height;
  var voCoordWidth = voPane.coordWidth;
  var voCoordHeight = voPane.coordHeight;
*/
    var voCtrl = this.shape.pane.document.createElement("v:stroke");
    var vsType = gCore.vml.LineTypes[this.type];
    voCtrl.setAttribute("id", this.shape.id + "_stroke");
    voCtrl.setAttribute("dashstyle", vsType);
    voCtrl.setAttribute("weight", this.weight);
    voCtrl.setAttribute("color", this.color);
    voCtrl.setAttribute("opacity", (this.opacity * 100) + "%");
    voCtrl.setAttribute("endcap", gCore.vml.LineCapTypes[this.lineCap]);
    voCtrl.setAttribute("joinstyle", gCore.vml.JoinTypes[this.joinType]);
    voCtrl.setAttribute("on", this.visible ? true : false);

    if(vsType == "none" || parseInt(this.weight) == 0) voCtrl.setAttribute("on", false);

    poCtrl.appendChild(voCtrl);
    return poCtrl;
  };

  this.getCtrl = function() {
  return this.shape.pane.document.getElementById(this.shape.id + "_stroke");
  };

};

/**
 * gCore.vml.Text
 */
gCore.vml.Text = function(psId, pnLeft, pnTop, pnWidth, pnHeight, psString, pnPosition) {
  /**
   * inherit
   */
  gCore.vml.FillableShape.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * default
   */
  this.stroke.visible = false;
  this.fill.color = "#000000";

  this.string = psString;

  this.position = pnPosition || gCore.TextPosition.DEFAULT;

  this.fontFamily = "Dotum";
  this.fontSize = 12;
  this.fontStyle = "normal";
  this.fontWeight = "normal";

  this.createCtrl = function() {

  var vsTextAlign = null;
  var vnSx = 0;
  var vnSy = 0;

  switch (this.position) {
    case gCore.TextPosition.TOPLEFT :
      vnSx = this.left;
      vnSy = this.top + Math.round(this.fontSize / 2);
      vsTextAlign = "left";
      break;
    case gCore.TextPosition.TOPCENTER :
      vnSx = this.left + Math.round(this.width / 2);
      vnSy = this.top + Math.round(this.fontSize / 2);
      vsTextAlign = "center";
      break;
    case gCore.TextPosition.TOPRIGHT :
      vnSx = this.left + this.width - 1;
      vnSy = this.top + Math.round(this.fontSize / 2);
      vsTextAlign = "right";
      break;
    case gCore.TextPosition.MIDDLELEFT :
      vnSx = this.left;
      vnSy = this.top + Math.round(this.height / 2);
      vsTextAlign = "left";
      break;
    case gCore.TextPosition.MIDDLECENTER :
      vnSx = this.left + Math.round(this.width / 2);
      vnSy = this.top + Math.round(this.height / 2);
      vsTextAlign = "center";
      break;
    case gCore.TextPosition.MIDDLERIGHT :
      vnSx = this.left + this.width - 1;
      vnSy = this.top + Math.round(this.height / 2);
      vsTextAlign = "right";
      break;
    case gCore.TextPosition.BOTTOMLEFT :
      vnSx = this.left;
      vnSy = this.top + this.height - Math.round(this.fontSize / 2);
      vsTextAlign = "left";
      break;
    case gCore.TextPosition.BOTTOMCENTER :
      vnSx = this.left + Math.round(this.width / 2);
      vnSy = this.top + this.height - Math.round(this.fontSize / 2);
      vsTextAlign = "center";
      break;
    case gCore.TextPosition.BOTTOMRIGHT :
      vnSx = this.left + this.width - 1;
      vnSy = this.top + this.height - Math.round(this.fontSize / 2);
      vsTextAlign = "right";
      break;
    }

  var vnEx = vnSx + 1;
  var vnEy = vnSy + 1;

    var voCtrl = this.pane.document.createElement("v:line");
    voCtrl.setAttribute("id", this.id);
    voCtrl.setAttribute("from", vnSx + " " + vnSy);
    voCtrl.setAttribute("to", vnEx + " " + vnEy);
    voCtrl.style.rotation = this.angle - 45;

    var voPath = this.pane.document.createElement("v:path");
    voPath.setAttribute("textpathok", true);
    voCtrl.appendChild(voPath);

    var voTextPath = this.pane.document.createElement("v:textpath");
    voTextPath.setAttribute("on", true);
    voTextPath.setAttribute("string", this.string);

    voTextPath.setAttribute("fitpath", false);
    voTextPath.setAttribute("fitshape", false);

    var voStyle = voTextPath.style;
    voStyle.fontFamily = "\"" + this.fontFamily + "\"";
    voStyle.fontSize = this.fontSize;
    voStyle.fontStyle = this.fontStyle;
    voStyle.fontWeight = this.fontWeight;
    voStyle["v-text-align"] = vsTextAlign;

    voCtrl.appendChild(voTextPath);

    return voCtrl;
  };


};
/**
 * eXria.resource.js
 *
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 *
 */

/**
 * eXria.resource
 */
eXria.resource = {};

/**
 * @fileoverview
 * ResourceManager
 * Resource clear
 */

/**
 * ResourceManager
 * Resource clear
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 * @constructor
 */
eXria.resource.ResourceManager = {
  clear : function(poCtrl) {
    //TODO
  }
};
/**
 * @fileoverview
 * eXria.protocols package

 */

/**
 * eXria.protocols package
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */
eXria.protocols = {};

/**
 * Abstract Default
 * @작성자 : 최현종
 * @version 1.0

/**
 * Const (추상클래스)
 * Protocol에서 사용하는 기본값에 대한 정의 클래스
 */
eXria.protocols.Default = {};
eXria.protocols.Default.Submission = {};
/**
 * @fileoverview
 * JSONBuilder
 */

/**
 * JSONBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.JSONBuilder = function(poSubmission) {
  //inheritance
  eXria.protocols.RequestBuilder.call(this, poSubmission);

  /* JSONRPC에서 사용함 */
  //escape a character
  this.escapeJSONChar = function(pcChar) {
    if(pcChar == "\"" || pcChar == "\\") return "\\" + pcChar;
    else if(pcChar == "\b") return "\\b";
    else if(pcChar == "\f") return "\\f";
    else if(pcChar == "\n") return "\\n";
    else if(pcChar == "\r") return "\\r";
    else if(pcChar == "\t") return "\\t";
    var hex = pcChar.charCodeAt(0).toString(16);
    if(hex.length == 1) return "\\u000" + hex;
    else if(hex.length == 2) return "\\u00" + hex;
    else if(hex.length == 3) return "\\u0" + hex;
    else return "\\u" + hex;
  };

  //encode a string into JSON format
  this.escapeJSONString = function(psString) {
    //Rather inefficient way to do it
    var parts = psString.split("");
    for(var i = 0; i < parts.length; i++) {
      var c =parts[i];
      if(c == '"' || c == '\\' || c.charCodeAt(0) < 32 || c.charCodeAt(0) >= 128) {
        parts[i] = this.escapeJSONChar(parts[i]);
      }
    }
    return "\"" + parts.join("") + "\"";
  };

  // Marshall objects to JSON format
  this.toJSONString = function(poObject) {
    if(poObject == null) {
      return "null";
    } else if(poObject.constructor == String) {
      return this.escapeJSONString(poObject);
    } else if(poObject.constructor == Number) {
      return poObject.toString();
    } else if(poObject.constructor == Boolean) {
      return poObject.toString();
    } else if(poObject.constructor == Date) {
      return '{javaClass: "java.util.Date", time: ' + poObject.valueOf() +'}';
    } else if(poObject.constructor == Array) {
      var v = [];
      for(var i = 0; i < poObject.length; i++) {
        v.push(this.toJSONString(poObject[i]));
      }
      return "[" + v.join(", ") + "]";
    } else {
      var v = [];
      for(attr in poObject) {
        if(poObject[attr] == null) {
          v.push("\"" + attr + "\": null");
        } else if(typeof poObject[attr] == "function") {
          // TODO function일 경우도 파싱
          // skip
        } else {
          v.push(this.escapeJSONString(attr) + ": " + this.toJSONString(poObject[attr]));
        }
      }
      return "{" + v.join(", ") + "}";
    }
  };

  this.xml2json = function(xml) {
  var X = {
    toObj: function(xml) {
    var o = {};
    if (xml.nodeType==1) {   // element node ..
      if (xml.attributes.length)   // element with attributes  ..
      for (var i=0; i<xml.attributes.length; i++)
        o["@"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||"").toString();
      if (xml.firstChild) { // element has child nodes ..
      var textChild=0, cdataChild=0, hasElementChild=false;
      for (var n=xml.firstChild; n; n=n.nextSibling) {
        if (n.nodeType==1) hasElementChild = true;
        else if (n.nodeType==3 && n.nodeValue.match(/[^ \f\n\r\t\v]/)) textChild++; // non-whitespace text
        else if (n.nodeType==4) cdataChild++; // cdata section node
      }
      if (hasElementChild) {
        if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..
        X.removeWhite(xml);
        for (var n=xml.firstChild; n; n=n.nextSibling) {
          if (n.nodeType == 3)  // text node
          o["#text"] = X.escape(n.nodeValue);
          else if (n.nodeType == 4)  // cdata node
          o["#cdata"] = X.escape(n.nodeValue);
          else if (o[n.nodeName]) {  // multiple occurence of element ..
          if (o[n.nodeName] instanceof Array)
            o[n.nodeName][o[n.nodeName].length] = X.toObj(n);
          else
            o[n.nodeName] = [o[n.nodeName], X.toObj(n)];
          } else  // first occurence of element..
            o[n.nodeName] = X.toObj(n);
        }
        } else { // mixed content
        if (!xml.attributes.length)
          o = X.escape(X.innerXml(xml));
        else
          o["#text"] = X.escape(X.innerXml(xml));
        }
      } else if (textChild) { // pure text
        if (!xml.attributes.length)
        o = X.escape(X.innerXml(xml));
        else
        o["#text"] = X.escape(X.innerXml(xml));
      } else if (cdataChild) { // cdata
        if (cdataChild > 1)
        o = X.escape(X.innerXml(xml));
        else
        for (var n=xml.firstChild; n; n=n.nextSibling)
          o["#cdata"] = X.escape(n.nodeValue);
      }
      }
      if (!xml.attributes.length && !xml.firstChild) o = null;
    } else if (xml.nodeType==9) { // document.node
      o = X.toObj(xml.documentElement);
    } else
      alert("unhandled node type: " + xml.nodeType);
    return o;
  },
  toJson: function(o, name, ind) {
    var json = name ? ("\""+name+"\"") : "";
    if (o instanceof Array) {
    for (var i=0,n=o.length; i<n; i++)
      o[i] = X.toJson(o[i], "", ind+"\t");
    json += (name ? ":[":"[") + (o.length > 1 ? ("\n"+ind+"\t"+o.join(",\n"+ind+"\t")+"\n"+ind) : o.join("")) + "]";
    } else if (o == null)
    json += (name&&":") + "null";
    else if (typeof(o) == "object") {
    var arr = [];
    for (var m in o)
      arr[arr.length] = X.toJson(o[m], m, ind+"\t");
    json += (name?":{":"{") + (arr.length > 1 ? ("\n"+ind+"\t"+arr.join(",\n"+ind+"\t")+"\n"+ind) : arr.join("")) + "}";
    } else if (typeof(o) == "string")
    json += (name&&":") + "\"" + o.toString() + "\"";
    else
    json += (name&&":") + o.toString();
    return json;
  },
  innerXml: function(node) {
    var s = ""
    if ("innerHTML" in node)
    s = node.innerHTML;
    else {
    var asXml = function(n) {
      var s = "";
      if (n.nodeType == 1) {
      s += "<" + n.nodeName;
      for (var i=0; i<n.attributes.length;i++)
        s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue||"").toString() + "\"";
      if (n.firstChild) {
        s += ">";
        for (var c=n.firstChild; c; c=c.nextSibling)
        s += asXml(c);
        s += "</"+n.nodeName+">";
      } else
        s += "/>";
      } else if (n.nodeType == 3)
        s += n.nodeValue;
      else if (n.nodeType == 4)
        s += "<![CDATA[" + n.nodeValue + "]]>";
      return s;
    };
    for (var c=node.firstChild; c; c=c.nextSibling)
      s += asXml(c);
    }
    return s;
  },
  escape: function(txt) {
    return txt.replace(/[\\]/g, "\\\\")
       .replace(/[\"]/g, '\\"')
       .replace(/[\n]/g, '\\n')
       .replace(/[\r]/g, '\\r');
      },
      removeWhite: function(e) {
    e.normalize();
    for(var n = e.firstChild; n; ) {
      if(n.nodeType == 3) {  // text node
      if(!n.nodeValue.match(/[^ \f\n\r\t\v]/)) { // pure whitespace text node
        var nxt = n.nextSibling;
        e.removeChild(n);
        n = nxt;
      } else
        n = n.nextSibling;
      } else if(n.nodeType == 1) {  // element node
      X.removeWhite(n);
      n = n.nextSibling;
      } else                      // any other node
      n = n.nextSibling;
    }
    return e;
    }
  };
  if(xml.nodeType == 9) { // document node
    xml = xml.documentElement;
  }

  return X.toJson(X.toObj(X.removeWhite(xml)), null, "");
  };
  /*
   * create json request data and
   * sendAction method call from Submission
   */
  this.build = function() {
    var viDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.submission.model.page);
    var viRootNode = viDocument.dom.createElement("root");

    //request ref build
    var vaRefs = this.submission.getRefs();
    var voXPath;
    var viInstance;
    var viRefInstance;
    for(var i = 0; i < vaRefs.length; i++) {
      voXPath = vaRefs[i]; //eXria.protocols.Ref
      //Instance의 Id와 xpath는 eXria.protocols.Ref를 이용하여 가져온다. Submission의 Refs는 eXria.protocols.Ref를 배열로 관리한다.
      viInstance = this.submission.model.getInstance(voXPath.getId());
      viRefInstance = viInstance.document.selectSingleNode(voXPath.getPath()); //DOM Instance
      if(viRefInstance) {
        viRootNode.appendChild(viRefInstance.cloneNode(true));
      }
    }
    //parameter set
    var vaParamValue; //Array
    var viParamNode, viParamValueNode;
    for(var vsParamName in this.submission.parameters.entries) { //parameter search loop
      vaParamValue = this.submission.getParameter(vsParamName);
      for(var i = 0; i < vaParamValue.length; i++) { //parameter value loop
        viParamValueNode = viDocument.dom.createTextNode(vaParamValue[i]); //text node
        viParamNode = viDocument.dom.createElement(vsParamName); //element
        viParamNode.appendChild(viParamValueNode);

        //Root Node의 마지막에 Append
        viRootNode.appendChild(viParamNode);
      }
    }
    this.submission.sendAction(this.xml2json(viRootNode));
  };
};
/**
 * @fileoverview
 * JSONParser
 */

/**
 * JSONParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.ResponseParser
 * @constructor
 * @private
 */
eXria.protocols.JSONParser = function(poSubmission) {
  eXria.protocols.ResponseParser.call(this, poSubmission);

  /**
   * argument로 넘어온 JavaScript Object를 넘어온 argument의 xml 태그로 변환한다.
   * @param poValue javaScript Object
   * @param psName javaScript Object Name
   * @return String xml Tag
   */
  this.toXml = function(poValue, psName) {
    var vsXml = "";

    if(poValue instanceof Array) {
      for(var i = 0; i < poValue.length; i++) {
        vsXml += this.toXml(poValue[i], psName);
      }
    } else if(typeof(poValue) == "object") {
      var vbHasChild = false;
      vsXml += "<" + psName;
      for(var vsName in poValue) {
        if(vsName.charAt(0) == "@") {
          vsXml += " " + vsName.substr(1) + "=\"" + poValue[vsName].toString() + "\"";
        } else {
          vbHasChild = true;
        }
      }
      vsXml += vbHasChild ? ">" : "/>";
      if(vbHasChild) {
        for(var vsName in poValue) {
          if(vsName == "#text") {
            vsXml += poValue[vsName];
          } else if (vsName == "#cdata") {
            vsXml += "<![CDATA[" + poValue[vsName] + "]]>";
          } else if (vsName.charAt(0) != "@") {
            vsXml += this.toXml(poValue[vsName], vsName);
          }
        }
        vsXml += "</" + psName + ">";
      }
    } else {
      vsXml += "<" + psName + ">";
      vsXml += poValue.toString();
      vsXml += "</" + psName + ">";
    }
    return vsXml;
  }
  /**
   * argument로 넘어온 JavaScript Object를 xml로 변환한다.
   * @param poJSON JavaScript Object
   * @return String xml tag
   */
  this.json2xml = function(poJSON, psRootName) {
    var vsXml = new eXria.lang.StringBuilder();
    vsXml.append("<"); //start tag
    vsXml.append(psRootName);
    vsXml.append(">");

    var voAtt = null;
    for(var vsAttNm in poJSON) {
      voAtt = poJSON[vsAttNm];
      vsXml.append(this.toXml(voAtt, vsAttNm));
    }
    vsXml.append("</"); //end tag
    vsXml.append(psRootName);
    vsXml.append(">");

    return vsXml;
  }

  this.textParse = function(psText) {
  var voResponse;
  if(!psText || psText == "") {
    voResponse = "";
  } else {
    eval('voResponse = ' + psText);
  }

  var vsRoot = null;
  for(vsRoot in voResponse) {
    voRoot = voResponse[vsRoot];
  }

  var vsXml = this.json2xml(voRoot, vsRoot); //converting

  var voResponseXML = this.text2Dom(vsXml); //parsing
  return voResponseXML;
  }

  this.parse = function(poXMLHttpRequest) {
    var vsJSON = poXMLHttpRequest.responseText; //json text
    return this.textParse(vsJSON);
  };
};
/**
 * @fileoverview
 * JSONRPCBuilder
 */

/**
 * JSONRPCBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.JSONBuilder
 * @base eXria.protocols.Proxy
 * @constructor
 * @private
 */
eXria.protocols.JSONRPCBuilder = function(poSubmission) {
  //inheritance
  eXria.protocols.JSONBuilder.call(this, poSubmission);
  eXria.protocols.Proxy.call(this, poSubmission);

  //proxy build
  this.buildProxy = function() {
    /* Add standard methods */
    //this.addMethods(["system.listMethods"]);
    var voRequest = this.makeRequest("system.listMethods", []);
    var vaMethods = this.sendRequest(voRequest); /* synchronized send */
    this.addMethods(vaMethods);

    return this;
  };

  //Proxy abstract method implementation
  this.makeRequest = function(psMethodName, paArgs) {
    var poReqData = {};
    poReqData.method = psMethodName;
    poReqData.params = paArgs;

    return this.toJSONString(poReqData);
  };

  /*
   * Stub을 만들기 위한 Server Request Sender
   * synchronized ajax call
   */
  this.sendRequest = function(poRequest) {
    //get XMLHttpRequest
    var voHttpRequest = eXria.form.xhtml.HttpRequestFactory.create();

    //synchronized ajax call
    voHttpRequest.open("POST", this.submission.action, false);
    voHttpRequest.onreadystatechange = function() {};

    try {
      voHttpRequest.setRequestHeader("Content-type", "text/plain");
      voHttpRequest.setRequestHeader("req-protocol", "json/rpc");
      voHttpRequest.setRequestHeader("res-protocol", "json/rpc");
    } catch(e) {}

    try {
      voHttpRequest.send(poRequest);
    } catch(e) {
      throw new Error("Connection failed");
    }

    return this.handleResponse(voHttpRequest);
  };

  //XMLHttpRequest Response Handler
  this.handleResponse = function(poHttpRequest) {
    /* Get request results */
    var vnStatus;     /* response status of XMLHttpRequest */
    var vsStatusText; /* response status text of XMLHttpRequest */
    var vsData;       /* response data of XMLHttpRequest */
    try {
      vnStatus = poHttpRequest.status;
      vsStatusText = poHttpRequest.statusText;
      vsData = poHttpRequest.responseText;
    } catch(e) {
      throw new Error("Connection failed");
    }

    /* Unmarshall the response */
    if(vnStatus != 200) { //TODO Exception debug
      throw new Error(vsStatusText);
    }

    var voResponse;
    try {
      eval("voResponse = " + vsData);
    } catch(e) {
      throw new Exception("error parsing result");
    }
    if(voResponse.error) {
      throw new Exception(voResponse.error.msg);
    }
    var voResult = voResponse.result;

    return voResult;
  };

  /*
   * submission's build implementation
   */
  this.build = function() {
    //start point
    return this.buildProxy();
  };
};
/**
 * @fileoverview
 * JSONRPCParser
 */

/**
 * JSONRPCParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.JSONParser
 * @constructor
 * @private
 */
eXria.protocols.JSONRPCParser = function(poSubmission) {
  eXria.protocols.JSONParser.call(this, poSubmission);

  this.bind = false;

  this.parse = function(poXMLHttpRequest) {
    var vsJSON = poXMLHttpRequest.responseText; //json text
    var voResponse;
    eval('voResponse = ' + vsJSON);

    return voResponse.result;
  };
};
/**
 * @fileoverview
 * ProtocolParserFactory
 */
/**
 * ProtocolParserFactory
 * @version 1.0
 * @constructor
 * @constructor
 * @private
 */
eXria.protocols.ProtocolParserFactory = {
  //create RequestBuilder and return
  getRequestBuilder : function(poSubmission) {
    var voBuilder;
    switch(poSubmission.reqProtocol) {
      case eXria.protocols.SubmissionType.URL_ENCODED :
        voBuilder = new eXria.protocols.URLEncodingBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.JSON :
        voBuilder = new eXria.protocols.JSONBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.JSON_RPC :
        voBuilder = new eXria.protocols.JSONRPCBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.XML :
        voBuilder = new eXria.protocols.XMLBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.SOAP_RPC :
        voBuilder = new eXria.protocols.SOAPRPCBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.MULTIPART :
        voBuilder = new eXria.protocols.MultipartBuilder(poSubmission);
        break;
      case eXria.protocols.SubmissionType.UNENCODED :
        voBuilder = new eXria.protocols.UnEncodingBuilder(poSubmission);
        break;
      default :
        throw new Exception("Unsupported Submission Type.");
    }
    return voBuilder;
  },
  //create ResponseParser and return
  getResponseParser : function(poSubmission, psResponseType) {
    var voParser;
    if(psResponseType == null) {
      voParser = new eXria.protocols.XMLParser(poSubmission);
    } else if(psResponseType.indexOf("urlencoded") > -1) {
      voParser = new eXria.protocols.URLEncodingParser(poSubmission);
    } else if(psResponseType.indexOf("json/rpc") > -1) {
      voParser = new eXria.protocols.JSONRPCParser(poSubmission);
    } else if(psResponseType.indexOf("json") > -1) {
      voParser = new eXria.protocols.JSONParser(poSubmission);
    } else if(psResponseType.indexOf("xml") > -1) {
      voParser = new eXria.protocols.XMLParser(poSubmission);
    } else if(psResponseType.indexOf("webservice") > -1) {
      voParser = new eXria.protocols.SOAPRPCParser(poSubmission);
    } else {
      voParser = new eXria.protocols.XMLParser(poSubmission);
    }
    return voParser;
  },
  //select Request ContentType by type of submission
  getContentType : function(poSubmission) {
    var vsContentType = "";
    switch(poSubmission.reqProtocol) {
      case eXria.protocols.SubmissionType.URL_ENCODED :
        vsContentType = "application/x-www-form-urlencoded";
        break;
      case eXria.protocols.SubmissionType.JSON :
        vsContentType = "text/plain";
        break;
      case eXria.protocols.SubmissionType.JSON_RPC :
        vsContentType = "text/plain";
        break;
      case eXria.protocols.SubmissionType.XML :
        vsContentType = "application/xml";
        break;
      case eXria.protocols.SubmissionType.SOAP_RPC :
        vsContentType = "application/xml";
        break;
      case eXria.protocols.SubmissionType.UNENCODED :
        vsContentType = "application/x-www-form-urlencoded";
        break;
      default :
        throw new Exception("Unsupported Submission Type.");
    }
    return vsContentType;
  }
};


/**
 * @fileoverview
 * Proxy Interface
 */

/**
 * Abstract Proxy
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @constructor
 * @private
 */
eXria.protocols.Proxy = function(poSubmission) {
  /**
   * @private
   */
  this.submission = poSubmission;
  /**
   * Proxy에 Stub Function을 Proxy에 추가한다.
   * @param {String} paMethodNames 배열의 function명
   * @return void
   * @type void
   * @socpe private
   * @private
   */
  this.addMethods = function(paMethodNames) {
  for(var i = 0; i < paMethodNames.length; i++) {
    var poProxy = this;
    var paNames = paMethodNames[i].split(".");
    var psMethodName = paNames[paNames.length - 1]; /* real exeution method */
    var poMethod = this.createMethod(paMethodNames[i]);
    poProxy[psMethodName] = poMethod;
  }
  };
  /**
   * Function Object를 생성한다.
   * @param psMethodName String Function 명
   * @return Function Object
   * @type Object
   * @private
   */
  this.createMethod = function(psMethodName) {
    /*
     * 생성 Method의 Template.
     */
    var poFunctionTemplate = function() {
      var vaParam = new Array();
      for(var i = 0; i < arguments.length; i++) {
        vaParam[i] = arguments[i];
      }
      var voProxy = poFunctionTemplate.proxy;
      var voRequestData = voProxy.makeRequest.call(voProxy, poFunctionTemplate.methodName, vaParam);

      var voSubmission = voProxy.submission; //submission
      return voSubmission.sendAction(voRequestData);
    };
    poFunctionTemplate.proxy = this;
    poFunctionTemplate.methodName = psMethodName;
    return poFunctionTemplate;
  };

  /**
   * 하위 클래스에서 Proxy를 생성하기 위한 Processor를 구현한다.
   * @return void
   * @type void
   */
  this.buildProxy = null; //abstract
  /**
   * Request Datqa를 생성한다.
   * 각 하위 Builder는 각 Platform에 맞게 구현한다.
   * @param psMethodName 실행할 Method 명
   * @param paArgs 서버에 전달할 Argument Array
   * @param poCallback AJAX Callback Function
   * @return 서버에 전달할 Object
   * @scope protected
   * @private
   */
  this.makeRequest = null; //abstract
};
/**
 * @fileoverview
 * Request 및 Response시 Submission에 포함 시킬 Reference를 포함하는 클래스
 */

/**
 * Request 및 Response시 Submission에 포함 시킬 Reference를 포함하는 클래스
 * @version 1.0
 * @param {String} psId Instance Id
 * @param {String} psPath Node XPath
 * @param {Boolean} pbReplace Element Replace 여부
 * @constructor
 * @private
 */
eXria.protocols.Ref = function(psId, psPath, pbReplace) {
  /**
   * @private
   */
  this.id = psId;
  /**
   * @private
   */
  this.path = psPath;
  /**
   * @private
   */
  this.replace = pbReplace ? pbReplace : false;
  /**
   * 현재 Ref 클래스의 Id를 리턴
   * @return Ref Class Id
   * @type String
   */
  this.getId = function() {
    return this.id;
  };
  /**
   * 현재 클래스가 저장하고 있는 Instance Path를 리턴
   * @return Instance path
   * @type String
   */
  this.getPath = function() {
    return this.path;
  };
  /**
   * Replace Type 리턴
   * @return Replace Type
   * @type Number
   */
  this.getReplace = function() {
    return this.replace;
  };
};
/**
 * @fileoverview
 * Abstract RequestBuilder
 */

/**
 * Abstract RequestBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @constructor
 * @private
 */
eXria.protocols.RequestBuilder = function(poSubmission) {
  /**
   * Submission Object
   */
  this.submission = poSubmission;
  /**
   * Submission의 parameter 및 refs를 이용하여
   * XMLHttpRequest에서 send할때 필요한 DOMString 또는 XMLDocument를 생성하고,
   * Submission객체의 sendAction function을 호출하여 실제 submission을 send한다.
   * JSON-RPC 또는 SOAP-RPC의 경우는 서버 콜을 처리할 Proxy 객체를 생성하여 리턴한다.
   * Proxy객체는 Submission을 내부에 포함하고 있고, 서버 요청시 내부의 Submission을 이용하여
   * Submission의 sendAction function을 호출하여 실제 submission을 send한다.
   * @param
   * @return Object DOMString or XMLDocument
   */
  this.build = null;
};
/**
 * @fileoverview
 * Abstract ResponseParser
 */

/**
 * Abstract ResponseParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @constructor
 * @private
 */
eXria.protocols.ResponseParser = function(poSubmission) {
  this.submission = poSubmission;
  /**
   * 서버로 부터 받은 결과 데이터를 파싱하고
   * Response Ref에 처리하기 위한 DOMDocument로 변환하여 리턴한다.
   */
  this.parse = null;
  this.bind = true;
  /**
   * Text를 DOM Element로 Parsing한다.
   * @param psXml xml String
   * @return DOM Element
   */
  this.text2Dom = function(psXml) {
    var voDomParser = eXria.data.DOMParserFactory.getParser(poSubmission.model.page); //create parser
    var voResponseXML = voDomParser.parse(psXml); //parsing
    voDomParser.clear();
    return voResponseXML;
  };
};
/**
 * @fileoverview
 * SOAPRPCBuilder
 */

/**
 * SOAPRPCBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.XMLBuilder
 * @base eXria.protocols.Proxy
 * @constructor
 * @private
 */
eXria.protocols.SOAPRPCBuilder = function(poSubmission) {
  //inheritance
  eXria.protocols.XMLBuilder.call(this, poSubmission);
  eXria.protocols.Proxy.call(this, poSubmission);

  this.buildProxy = function() {
    /*
     * TODO
     * 1. WSDML 호출
     * 2. Method List Create
     * 3. Proxy 생성
     * 4. Proxy 리턴
     */
    /* WSDL 호출 */
    var voWSDL = this.sendRequest();
    if(voWSDL == null) {
      //TODO Exception or Null return
      return;
    }

    /* Proxy 생성 */
    var voDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.submission.model.page);
    voDocument.loadXML(voWSDL);

    var voOperationNodeList = voDocument.selectNodes("//*[namespace-uri()='http://schemas.xmlsoap.org/wsdl/' and local-name()='operation']");

    var vnNodeSize = voOperationNodeList.getLength();
    for(var i = 0; i < vnNodeSize; i++) {
      var voNode = voOperationNodeList.item(i);
      var vsMethodName = voNode.attributes.getNamedItem("name").value; //method name xpath-> //operation/@name
      var poMethod = this.createMethod(vsMethodName);
      this[vsMethodName] = poMethod;
    }

    return this;
  };

  //TODO encoding 설정 추가
  this.soapHeader = '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap:Body>';
  this.soapTail   = '</soap:Body></soap:Envelope>';

  /**
   * <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
   *                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   *                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   *   <soap:Body>
   *     <tns:sampleMethod xmlns:tns="SampleService">
   *       <mystring xsi:type="xsd:string">AJAX Script를 이용한 WebService Call!!!</mystring>
   *       <count xsi:type="xsd:int">5</count>
   *     </tns:sampleMethod>
   *   </soap:Body>
   * </soap:Envelope>
   *
   * <tns:sum xmlns:tns="SampleService">
   *   <arrayofint1 xmlns:ns2="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:Array" ns2:arrayType="xsd:int[5]">
   *     <item xsi:type="xsd:int">1</item>
   *     <item xsi:type="xsd:int">2</item>
   *     <item xsi:type="xsd:int">3</item>
   *     <item xsi:type="xsd:int">4</item>
   *     <item xsi:type="xsd:int">5</item>
   *   </arrayofint1>
   * </tns:sum>
   *
   * <multiRef id="id1" xsi:type="ns11:Map" xmlns:ns11="http://xml.apache.org/xml-soap">
   *   <item>
   *     <key xsi:type="xsd:dateTime">2001-10-05T22:07:04.629Z</key>
   *     <value xsi:type="xsd:string">string value</value>
   *   </item>
   *   <item>
   *     <key xsi:type="xsd:string">stringKey</key>
   *     <value xsi:type="xsd:int">5</value>
   *   </item>
   * </multiRef>
   *
   * support type :
   * String, Number, Boolean, Date, Array, eXria.data.Map, eXria.data.ArrayMap
   */
  this.makeRequest = function(psMethodName, paArgs) {
    /*
     * TODO
     * WSDL 요청시에는 호출되지 않음.
     * Method Invoke 시 넘겨 받은 Parameter 정보를 기준으로
     * SOAP Message를 만듦
     * primitive type and complex type?
     */
    /* soap message */
    var vsSoapMsg = new eXria.lang.StringBuilder();
    /* header */
    vsSoapMsg.append(this.soapHeader);

    /* body */
    vsSoapMsg.append('<tns:' + psMethodName + ' xmlns:tns="');
    {
      var vsServiceName = this.submission.action;
      if(vsServiceName.indexOf("/") > -1) {
        vsServiceName = vsServiceName.substring(vsServiceName.lastIndexOf("/") + 1);
      }
      vsSoapMsg.append(vsServiceName + '">');
    }

    /* parameter setting */
    //TODO Parameter Setting
    //primitive, array, map
    var vsParamName = "param";
    var voParam;
    var paramSeq = 1;

    for(var i = 0; i < paArgs.length; i++) {
      vsSoapMsg.append("<" + vsParamName + paramSeq + " " + this.getXsiType(paArgs[i]) + ">");
      voParam = paArgs[i];

      //TODO Dom으로 바꾸던지 값을 encoding하던지 결정
      switch(voParam.constructor) {
        case String :  //String
        case Number :  //long or double
        case Boolean : //boolean
        case Date :    //Date
          vsSoapMsg.append(voParam);
          break;
        case Array :                     //Array
        case eXria.data.Collection :      //Array
        case eXria.data.ArrayCollection : //Array
          /* <arrayofint1 xmlns:ns2="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="ns2:Array" ns2:arrayType="xsd:int[5]">
           * <item xsi:type="xsd:int">1</item>
           * ...
           * </arrayofint1>
           */
          var vaArray;
          if(voParam.constructor == Array) {
            vaArray = voParam;
          } else {
            vaArray = voParam.elements;
          }
          if(vaArray.length > 0) {
            var vsInitiType = this.getXsiType(vaArray[0]);
            for(var i = 0; i < vaArray.length; i++) {
              vsSoapMsg.append('<item ' + vsInitiType + '>');
              vsSoapMsg.append(vaArray[0]);
              vsSoapMsg.append('</item>');
            }
          }
          break;
        case eXria.data.Map :      //Map
        case eXria.data.ArrayMap : //Map
          /* <multiRef id="id1" xsi:type="ns11:Map" xmlns:ns11="http://xml.apache.org/xml-soap">
           * <item>
           * <key xsi:type="xsd:dateTime">2001-10-05T22:07:04.629Z</key>
           * <value xsi:type="xsd:string">string value</value>
           * </item>
           * ...
           * </multiRef>
           */
          var vsValueType; /* xsd type of value */
          var voValue;     /* value in map */
          for(var vsKey in voParam.entries) {
            vsSoapMsg.append('<item>');
            vsSoapMsg.append('<key xsi:type="xsd:string">'); /* Map의 key는 string type */
            vsSoapMsg.append(vsKey);
            vsSoapMsg.append('</key>');
            voValue = voParam.entries[vsKey];
            vsValueType = this.getXsiType(voValue);
            vsSoapMsg.append('<value ' + vsValueType + '>');
            vsSoapMsg.append(voValue);
            vsSoapMsg.append('</value>');
            vsSoapMsg.append('</item>');
          }
          break;
        default :
          vsSoapMsg.append(voParam);
      }

      vsSoapMsg.append("</" + vsParamName + paramSeq + ">");
      paramSeq++; //sequence increase
    }

    vsSoapMsg.append('</tns:' + psMethodName + '>');

    /* tail */
    vsSoapMsg.append(this.soapTail);

    //Parse from String to XMLDocument
    var voDomParser = eXria.data.DOMParserFactory.getParser(poSubmission.model.page);
    var voRequestDocument = voDomParser.parse(vsSoapMsg.toString());

    return voRequestDocument;
  };

  /**
   * Support Type :
   * String, Number, Boolean, Date, Array[primitive], eXria.data.Collection[primitive], eXria.data.ArrayCollection[primitive], eXria.data.Map, eXria.data.ArrayMap
   */
  this.getXsiType = function(poParam) {
    var vsXsiType = new eXria.lang.StringBuilder();

    switch(poParam.constructor) {
      case String : //String
        vsXsiType.append('xsi:type="xsd:string"');
        break;
      case Number : //long or double
        if(new String(poParam).indexOf(".") > -1) {
          vsXsiType.append('xsi:type="xsd:double"');
        } else {
          vsXsiType.append('xsi:type="xsd:long"');
        }
        break;
      case Boolean : //boolean
        vsXsiType.append('xsi:type="xsd:boolean"');
        break;
      case Date : //Date
        vsXsiType.append('xsi:type="xsd:date"');
        break;
      case Array : //Array
      case eXria.data.Collection : //Array
      case eXria.data.ArrayCollection : //Array
        vsXsiType.append('xmlns:typens="http://schemas.xmlsoap.org/soap/encoding/" xsi:type="typens:Array"');
        vsXsiType.append(' typens:arrayType="');

        var vaArray;
        if(poParam.constructor == Array) {
          vaArray = poParam;
        } else {
          vaArray = poParam.elements;
        }

        {
          var vnArraySize = vaArray.length;
          var vsType;
          if(vaArray.length > 0) {
            //Array의 구성요소는 기본형만 지원한다.
            vsType = this.getXsiType(vaArray[0]);
            if(vsType == null || vsType == "") {
              vsType = "xsd:string"; //default String
            } else if(vsType <= 10) {
              vsType = "xsd:string";
            } else {
              vsType = vsType.substring(10, vsType.length - 1);
            }
          } else {
            vsType = "xsd:string"; //default String
          }
          vsType += "[" + vnArraySize + "]";
          vsXsiType.append(vsType);
        }
        vsXsiType.append('"');
        break;
      case eXria.data.Map : //Map
      case eXria.data.ArrayMap : //Map
        vsXsiType.append('xmlns:typens="http://xml.apache.org/xml-soap" xsi:type="typens:Map"');
      break;
      default :
        vsXsiType.append('xsi:type="xsd:string"'); //default string
    }

    return vsXsiType.toString();
  };

  /**
   * wsdl 요청
   */
  this.sendRequest = function() {
    //get XMLHttpRequest
    var voHttpRequest = eXria.form.xhtml.HttpRequestFactory.create();

    //synchronized ajax call
    //append '?wsdl' to this.serverURL
    voHttpRequest.open("GET", this.submission.action + "?wsdl", false); //GET 으로 할까?
    voHttpRequest.onreadystatechange = function() {};

    try {
      voHttpRequest.setRequestHeader("Content-type", "text/xml");
      voHttpRequest.setRequestHeader("req-protocol", "webservice");
      voHttpRequest.setRequestHeader("res-protocol", "webservice");
    } catch(e) {}

    try {
      voHttpRequest.send(""); //WSDL요청시에는 메시지 없음.
    } catch(e) {
      throw new Error("Connection failed");
    }

    return this.handleResponse(voHttpRequest);
  };

  this.handleResponse = function(poHttpRequest) {
    /* Get request results */
    var vnStatus;     /* response status of XMLHttpRequest */
    var vsStatusText; /* response status text of XMLHttpRequest */
    var voWSDL;       /* response xml data of XMLHttpRequest */
    try {
      vnStatus = poHttpRequest.status;
      vsStatusText = poHttpRequest.statusText;
      voWSDL = poHttpRequest.responseXML;
    } catch(e) {
      throw new Error("Connection failed");
    }

    /* Unmarshall the response */
    if(vnStatus != 200) { //TODO Exception 처리 debug
      throw new Error(vsStatusText);
    }

    if(voWSDL.documentElement) {
      return voWSDL.documentElement; /* DOM Document */
    } else {
      return voWSDL; /* DOM Document */
    }
  };

  /*
   * submission's build implementation
   */
  this.build = function() {
    //start point
    return this.buildProxy();
  };
};
/**
 * @fileoverview
 * SOAPRPCParser
 * 서버 리턴 타입에 대하여 현재 서버는
 * primitive type과 Primitive Type Array 만을 지원한다.
 * Client에서 WebService로 지원할 리턴 타입은
 * primitive type, array, map 까지 구현
 * 보다 복잡한 타입은 지원 불가.
 * 예) Array안에 Map 또는 Map안에 Array 등
 * TODO ID를 참조하는 XML 문서의 파싱 부분 고려 예정
 */
/**
 * SOAPRPCParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.ResponseParser
 * @constructor
 * @private
 */
eXria.protocols.SOAPRPCParser = function(poSubmission) {
  eXria.protocols.ResponseParser.call(this, poSubmission);

  this.bind = false;

  this.parse = function(poXMLHttpRequest) { //TODO 현재 Text로 되어 있으나 향후 DOM으로 하던지 아니면 xml encoding 로직 추가
    var voResponseXML = poXMLHttpRequest.responseXML;
    if(!voResponseXML) {
      return;
    }

    var voResultList = voResponseXML.documentElement.getElementsByTagName("result");
    if(!voResultList) {
      return null;
    }

    var voResult = eXria.data.xhtml.DocumentFactory.createDocument(this.submission.model.page);
    voResult.loadXML(voResponseXML.documentElement);

    var vsReturnDataType;
    var voDocElement = voResultList[0];
    vsReturnDataType = voDocElement.attributes.getNamedItem('xsi:type').value;
    vsReturnDataType = vsReturnDataType.substring(vsReturnDataType.lastIndexOf(':') + 1);

    //TODO multi response ref 가 되면서 본 코드는 수정되어야 한다.
    //var vsRootName = this.getResponseTagName(); //get response ref instance tag name
    var vsRootName = "root";
    var vsXml = new eXria.lang.StringBuilder();

    //xml text create
    vsXml.append('<');
    vsXml.append(vsRootName);
    vsXml.append('>');

    switch(vsReturnDataType) { //parsing
      case "string" :
      case "int" :
      case "long" :
      case "double" :
      case "date" :
      case "boolean" :
        vsXml.append(String(this.getNodeValue(voDocElement, voResult)));
        break;
      case "Array" :
        for(var i = 0; i < voDocElement.childNodes.length; i++) { //item loop
          vsXml.append('<list>'); //임시로 배열일 경우 tag name을 item으로 TODO 확정 필요
          vsXml.append(this.toXml(voDocElement.childNodes[i], voResult));
          vsXml.append('</list>');
        }
        break;
      case "Map" :
        var voItemNode, vsKey, vsValue;
        for(var i = 0; i < voDocElement.childNodes.length; i++) { //item loop
          var voItem = voDocElement.childNodes[i];
          var voInnerItem;
          if(voItem.attributes && voItem.attributes.getNamedItem('href')) {
            //link item
            voInnerItem = this.getLinkElement(voItem.attributes.getNamedItem('href').value, voResult);
          } else {
            //item
            voInnerItem = voItem;
          }

          var vsKey = String(this.getNodeValue(voInnerItem.getElementsByTagName('key')[0]));
          var vsValue = String(this.getNodeValue(voInnerItem.getElementsByTagName('value')[0]));

          vsXml.append('<');
          vsXml.append(vsKey);
          vsXml.append('>');
          vsXml.append(vsValue);
          vsXml.append('</');
          vsXml.append(vsKey);
          vsXml.append('>');
        }
        break;
    }

    vsXml.append('</');
    vsXml.append(vsRootName);
    vsXml.append('>');

    var voResXML = this.text2Dom(vsXml); //parsing
    return voResXML.documentElement;
  };

  this.toXml = function(poValue, poResponseXML) { /* element, document */
    var vsReturnDataType;
    if(poValue.attributes && poValue.attributes.getNamedItem('xsi:type')) {
      vsReturnDataType = poValue.attributes.getNamedItem('xsi:type').value;
      vsReturnDataType = vsReturnDataType.substring(vsReturnDataType.lastIndexOf(':') + 1);
    } else {
      vsReturnDataType = "";
    }

    //xml text create
    var vsXml = new eXria.lang.StringBuilder();
    switch(vsReturnDataType) { //parsing
      case "string" :
      case "int" :
      case "long" :
      case "double" :
      case "date" :
      case "boolean" :
        vsXml.append(String(this.getNodeValue(poValue, poResponseXML)));
        break;
      case "Array" :
        for(var i = 0; i < poValue.childNodes.length; i++) { //item loop
          vsXml.append('<list>'); //임시로 배열일 경우 tag name을 item으로 TODO 확정 필요
          vsXml.append(this.toXml(poValue.childNodes[i], poResponseXML));
          vsXml.append('</list>');
        }
        break;
      case "Map" :
        var voItemNode, vsKey, vsValue;
        for(var i = 0; i < poValue.childNodes.length; i++) { //item loop
          var voItem = poValue.childNodes[i];
          var voInnerItem;
          if(voItem.attributes && voItem.attributes.getNamedItem('href')) {
            //link item
            voInnerItem = this.getLinkElement(voItem.attributes.getNamedItem('href').value, poResponseXML);
          } else {
            //item
            voInnerItem = voItem;
          }

          var vsKey = String(this.getNodeValue(voInnerItem.getElementsByTagName('key')[0], poResponseXML));
          var vsValue = String(this.getNodeValue(voInnerItem.getElementsByTagName('value')[0], poResponseXML));

          vsXml.append('<');
          vsXml.append(vsKey);
          vsXml.append('>');
          vsXml.append(vsValue);
          vsXml.append('</');
          vsXml.append(vsKey);
          vsXml.append('>');
        }
        break;
    }

    return vsXml;
  };

  this.getLinkElement = function(psId, poResponseXML) {
    if(eXria.util.StringUtil.startsWith(psId, "#")) {
      psId = psId.substring(1);
    }
    var vvelement = poResponseXML.selectSingleNode("//*[@id='" + psId + "']");

    return poResponseXML.selectSingleNode("//*[@id='" + psId + "']");
  };

  this.getNodeValue = function(poNode, poResponseXML) { /* element, document */
    if(poNode.attributes && poNode.attributes.getNamedItem("href")) {
      return this.toXml(this.getLinkElement(poNode.attributes.getNamedItem("href").value, poResponseXML));
    } else if(poNode.childNodes.length == 1 && poNode.childNodes[0].nodeType != 1) {
      return poNode.childNodes[0].nodeValue;
    } else if(poNode.childNodes.length == 1) {
      return this.toXml(poNode.childNodes[0], poResponseXML);
    } else if(poNode.childNodes.length > 1) {
      return this.toXml(poNode, poResponseXML);
    }
  };
};
/**
 * @fileoverview
 * 서버와의 Data 통신 프로세스를 담당하는 클래스의 Interface
 */
/**
 * eXria.protocols.Submission
 * 서버와의 data통신 프로세스를 담당하는 클래스의 Interface
 * @param {String} psId Submission Id
 * @param {eXria.form.Model} poModel eXria.form.Model Object
 * @constructor
 */
eXria.protocols.Submission = function(psId, poModel) {
  /**
   * Submission ID<br/>
   * XHTML 모드에서만 사용 가능
   * @type String
   */
  this.id = psId;
  /**
   * request Type
   * @type String
   * @private
   */
  this.reqProtocol = null;
  /**
   * response Type
   * @type String
   * @private
   */
  this.resProtocol = null;
  /**
   * HTTP ASync통신할 때 송수신된 정보의 진행율을 표시할 수 있는 기능에 사용되어 지며<br/>
   * 진행된 크기의 수치값이 반환된다.<br/>
   * 현재 Plugin Mode일때만 사용 가능하다.
   * @return 현재 진행 값
   * @type Number
   */
  this.getCurrentPos = null;
  /**
   * HTTP ASync통신할 때 송수신된 정보의 진행율을 표시할 수 있는 기능에<br/>
   * 사용되어 지며 수신될 데이터의 전체 크기이며 수치값이 반환된다.<br/>
   * 현재 Plugin Mode일때만 사용 가능하다.
   * @return 수신될 데이터의 전체 크기
   * @type Number
   */
  this.getMaxPos = null;
  /**
   * PlugIn과 Server가 HTTP ASync통신할 때 현재 송수신된 데이터 크기의 수치값이 반환된다.<br/>
   * 현재 Plugin Mode일때만 사용 가능하다.
   * @return 현재 진행된 데이터의 크기
   * @type Number
   * @private
   */
  this.currentPos = null;
  /**
   * Model Object<br/>
   * XHTML 모드에서만 사용 가능
   * @type eXria.form.Model
   * @see eXria.form.Model
   * @private
   */
  this.model = poModel;
  /**
   * XMLHttpRequest를 synchronized 방식으로 동작시킬지</br>
   * asynchronized로 동작시킬지를 설정한다.</br>
   * true : asynchronized, false : synchronized
   * @type Boolean
   * @default true
   * @private
   */
  this.async = null;
  /**
   * synchronize 유무를 결정한다.
   * XHTML 모드에서만 사용 가능
   * @param {Boolean} pbAsync sync 유무
   * @return void
   * @type void
   */
  this.setAsync = null;
  /**
   * HTTP Method (GET/POST)
   * @type String
   * @private
   */
  this.method = null;
  /**
   * HTTP Meothod를 셋팅한다. (XHTML Mode에서만 사용 가능)
   * @param {String} psMethod method
   * @return void
   * @type void
   */
  this.setMethod = null;
  /**
   * HTTP Server URL
   * @type String
   * @private
   */
  this.action = null;
  /**
   * 서브미션의 action Url 지정
   * @param {String} psAction Action
   * @return void
   * @type void
   */
  this.setAction = null;
  /**
   * submission의 send가 호출될때 호출되는 callback function
   * @param {eXria.protocols.Submission} poSubmission 해당 Event가 발생해야 하는 Submission Object
   * @return void
   * @type void
   * @private
   */
  this.onSubmit = null;
  /**
   * submission 진행중 진행 상태를 표현하기 위한 callback function
   * @param {eXria.protocols.Submission} poSubmission 해당 Event가 발생해야 하는 Submission Object
   * @return void
   * @type void
   * @private
   */
  this.onSubmitProgress = null;
  /**
   * submission 정상처리후 호출되는 callback function
   * @param {eXria.protocols.Submission} poSubmission 해당 Event가 발생해야 하는 Submission Object
   * @return void
   * @type void
   * @private
   */
  this.onSubmitDone = null;
  /**
   * 서버와 통신중 에러가 발생하였을 때의 처리를 담당
   * Application에서 등록 한다. callback function
   * @param {eXria.protocols.Submission} poSubmission 해당 Event가 발생해야 하는 Submission Object
   * @return void
   * @type void
   * @private
   */
  this.onSubmitError = null;
  /**
   * Request Instance Reference Map(Instance id, XPATH)
   * @type Array
   * @private
   */
  this.refs = null;
  /**
   * Request Instance Reference Array(Instance id, XPATH)를 리턴 한다.<br/>
   * XHTML 모드에서만 사용 가능하다.
   * @return Request Instance Reference Array
   * @type Array
   */
  this.getRefs = null;
  /**
   * Request Instance Reference를 추가한다.
   * @param {String} psId instance id
   * @param {String} psPath instance xpath
   * @return void
   * @type void
   */
  this.addRef = null;
  /**
   * HttpRequest Header
   * (K : String, V : String)
   * @type eXria.data.ArrayMap
   * @private
   */
  this.headers = null;
  /**
   * HttpRequest Header 값을 리턴한다.
   * @param {String} psName Header Name
   * @return Header Value
   * @type String
   */
  this.getHeader = null;
  /**
   * HttpRequest Header를 추가한다.
   * @param {String} psName String Header Name
   * @param {String} psValue String Header Value
   * @return void
   * @type void
   */
  this.setHeader = null;
  /**
   * HttpRequest Header를 삭제한다.
   * XHTML 모드에서만 사용 가능
   * @param {String} psName Header Name
   * @return header Value
   * @type String
   */
  this.removeHeader = null;
  /**
   * HttpRequest Parameter
   * @type eXria.data.ArrayMap
   * @private
   */
  this.parameters = null;
  /**
   * HttpRequest에 Parameter를 추가한다.
   * @param {String} psName parameter Name
   * @param {String} psValue parameter Value
   * @return void
   * @type void
   */
  this.addParameter = null;
  /**
   * submission에 데이타셋 CRUD 문자열 정보를 추가시켜 주는 메소드
   * XHTML 사용시 Protocol은 urlencoded 일때만 사용 가능.
   * @param {String} psString 서브미션 전송 시 추가로 보내고자 하는 CRUD 데이터
   * @return void
   * @type void
   */
  this.addCRUDString = null;
  /**
   * HttpRequest에 DataSet을 추가한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.addDataSetId = null;
  /**
   * HttpRequest에 설정된 DataSet을 삭제한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.removeDataSetId = null;
  /**
   * HttpRequest Parameter를 조회한다.</br>
   * 값이 여럿일 경우 가장 첫번째 값을 리턴
   * @param {String} psName Parameter Name
   * @return Parameter Values
   * @type Array
   */
  this.getParameter = null;
  /**
   * HttpRequest Parameter를 삭제한다.
   * @param {String} psName Parameter Name
   * @return void
   * @type void
   */
  this.removeParameter = null;
  /**
   * HttpRequest Parameter를 모두 삭제한다.
   * @return void
   * @type void
   */
  this.clearParameter = null;
  // from document
  /**
   * Submit Request CharacterSet Encoding Type
   * @type String
   * @private
   */
  this.reqCharset = null;
  /**
   * Submit Response CharacterSet Encoding Type
   * @type String
   * @private
   */
  this.resCharset = null;
  /**
   * Submit Request CharacterSet Encoding Type을 설정한다.
   * @param {String} psCharset request charset
   * @return void
   * @type void
   */
  this.setReqCharset = null;
  /**
   * Submit Response CharacterSet Encoding Type을 설정한다.
   * @param {String} psCharset response Character Set
   * @return void
   * @type void
   */
  this.setResCharset = null;
  /**
   * Response Data Instance XPath
   * @type Array
   * @private
   */
  this.resRefs = null;
  /**
   * Submission 완료 후 서버로 부터 받은 결과를 붙일 Instance를 추가한다.
   * </br>plugin 사용시 Arguement와 상관 없이 Replace : True로 동작.<br/>
   * @param {String} psId instance id
   * @param {String} psPath instance path
   * @param {Boolean} pbReplace instance replace 여부 (Plugin 모드 사용시 생략 가능)
   * @return void
   * @type void
   */
  this.addResRef = null;
  /**
   * Response Ref의 Instance Path를 리턴한다.<br/>
   * XHTML 모드에서만 사용가능하다.
   * @return Instance Path
   * @type Array
   */
  this.getResRefs = null;
  /**
   * Submission Send
   * @return Proxy
   * @type Object
   */
  this.send = null;
  /**
   * Request Reference를 모두 삭제.
   * @return void
   * @type void
   */
  this.clearRef = null;
  /**
   * Server 통신 후 반환 된 HTTP Error Code를 반환
   * <br/>Plugin Mode에서만 동작
   * @return Number Type의 오류 코드 숫자값
   * @type Number
   */
  this.getResultCode = null;
  /**
   * Server로 MultiPart 데이터를 전송할때 파일을 설정하는 함수로 클라이언트 파일의 절대 경로를 설정
   * <br/>Plugin Mode에서만 동작
   * @param {String} psFilePath Upload 대상 FilePath
   * @return void
   * @type void
   */
  this.setUpLoadFileNames = null;
  /**
   * request protocol을 셋팅한다.<br/>
   * @param {String} psReqProtocol request protocol
   * @return void
   * @type void
   */
  this.setReqProtocol = null;
  /**
   * response protocol을 셋팅한다.<br/>
   * @param {String} psResProtocol response protocol
   * @return void
   * @type void
   */
  this.setResProtocol = null;
  /**
   * request protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getReqProtocol = null;
  /**
   * response protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getResProtocol = null;
  /**
   * Header Attribute 값을 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psAttrName 리턴 받을 Attribute Name
   * @return Attribute Value
   * @type String
   * @return Attribute Value
   */
  this.getAttrStr = null;
  /**
   * Header Attribute 값을 설정한다. 만약 해당 Attribute가 있다면 해당 값으로 덮어씌운다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psAttrName 설정 Attribute Name
   * @param {String} psValue 설정할 Attribute 값
   * @type void
   * @return void
   */
  this.setAttrStr = null;
  /**
   * Header의 Content-type을 재설정한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @type void
   * @return void
   */
  this.initReqType = null;
  /**
   * Submission에서 서버로 보낼 데이터를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return Submission Send 시 서버로 보낼 데이터 문자열
   * @type String
   */
  this.getSubmitData = null;
  /**
   * 파라미터로 넘어온 문자열을 Submission의 Response Ref에 지정한 Node에 바인딩 한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psData 바인딩하고자 하는 데이터 문자열
   * @type void
   * @return void
   */
  this.bindUserData = null;
  /**
   * 파라미터로 넘어온 데이터를 서버로 보낸다.<br/>
   * 해당 메소드를 사용할 경우 Submission에 바인딩 된 Request 데이터는 모두 무시 되며<br/>
   * 오로지 파라미터로 넘긴 문자열에 대해서만 처리한다.<br/>
   * 또한 서버로부터 내려온 데이터는 인스턴스에 바인딩 되지 않으며 문자열로 리턴 된다.<br/>
   * (Plugin Mode 에서만 사용 가능)
   * @param psData 서버로 보낼 데이터 문자열
   * @type String
   * @return 서버로부터 내려온 데이터 문자열
   */
  this.sendUserData = null;
  /**
   * Response Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Response Reference 문자열
   */
  this.getResponseRefString = null;
  /**
   * Request Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Request Reference 문자열
   */
  this.getRequestRefString = null;
  /**
   * Request Parameter의 Key를 String 형태로 리턴한다.<br/>
   * (ex. ParamKey1,ParamKey2,ParamKey3)
   * @type String
   * @return Request Parameter Key 문자열
   */
  this.getParameterKeyString = null;
  /**
   * Request CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getReqCharSet = null;
  /**
   * Response CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getResCharSet = null;
  /**
   * Request DataSet의 ID를 String 형태로 리턴한다.<br/>
   * (ex. dst1,dst2,dst3)
   * @type String
   * @return Request DataSet의 ID 문자열
   */
  this.getDataSetIdString = null;
  /**
   * Request Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Request Protocol Type에 해당하는 문자열
   */
  this.getReqType = null;
  /**
   * Response Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Response Protocol Type에 해당하는 문자열
   */
  this.getResType = null;
  /**
   * Request Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Request Protocol Type
   * @type void
   * @return void
   */
  this.setReqType = null;
  /**
   * Response Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Response Protocol Type
   * @type void
   * @return void
   */
  this.setResType = null;
  /**
   * wait cursor 사용 유무를 리턴한다.
   * @return wait cusor 사용 유무
   * @type Boolean
   */
  this.isWaitCursor = null;
  /**
   * request Type
   * @type String
   * @private
   */
  this.reqType = null;
  /**
   * response Type
   * @type String
   * @private
   */
  this.resType = null;
};
/**
 * @fileoverview
 * SubmissionType
 */

/**
 * Submission Type을 상수 정의하는 클래스
 * enum
 * @version 1.0
 * @constructor
 * @private
 */
eXria.protocols.SubmissionType = {
  URL_ENCODED : "urlencoded" /* request-type, response-type : urlencoded */
, JSON        : "json"       /* request-type, response-type : json */
, JSON_RPC    : "json/rpc"   /* request-type, response-type : json/rpc */
, XML         : "xml"        /* request-type, response-type : xml */
, SOAP_RPC    : "webservice" /* request-type, response-type : webservice */
, REQ_PROTOCOL_HEADER : "req-protocol"
, RES_PROTOCOL_HEADER : "res-protocol"
, MULTIPART   : "multipart/form-data"
, UNENCODED   : "unencoded"
};
/**
 * @fileoverview
 * URLEncodingBuilder
 */
/**
 * URLEncodingBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.URLEncodingBuilder = function(poSubmission) {
  if(page.metadata.useJsonInstance) {
    eXria.protocols.json.URLEncodingBuilder.call(this, poSubmission);
    return;
  }

  eXria.protocols.RequestBuilder.call(this, poSubmission);

  this.build = function() {
    //request data 생성
    var voData = new eXria.lang.StringBuilder();
    var vaValue;
    for(var vsName in this.submission.parameters.entries) {
      vaValue = this.submission.getParameter(vsName);
      for(var i = 0; i < vaValue.length; i++) {
        voData.append(encodeURIComponent(vsName));     //encode
        voData.append("=");
        voData.append(encodeURIComponent(vaValue[i])); //encode
        voData.append("&");
      }
    }

    //requestRef
    var voRefs = this.submission.getRefs();
    var voRef;
    for(var i = 0; i < voRefs.length; i++) {
      voRef = voRefs[i];
      var viInstance = this.submission.model.getInstance(voRef.getId());
      if(viInstance) {
        voData.append(this.buildInstance2Param(viInstance, voRef.getPath()));
      }
    }

    //encoding setting
    //AJAX는 utf-8로 통신한다.
    this.submission.encoding = "utf-8";
    //submit
    return this.submission.sendAction(voData.toString());
  };

  this.buildInstance2Param = function(poInstance, psPath) {
    var voNodeList = poInstance.selectNodes(psPath);
    var vsRootNodeName = psPath;
    if(vsRootNodeName.substring(vsRootNodeName.length - 1) == "/") {
      vsRootNodeName = vsRootNodeName.substring(0, vsRootNodeName.length - 1);
    }
    if(vsRootNodeName.indexOf("/") > -1) {
      vsRootNodeName = vsRootNodeName.substring(vsRootNodeName.lastIndexOf("/") + 1);
    }
    if(voNodeList && voNodeList.getLength() > 0) {
      var voParam = new eXria.lang.StringBuilder();
      var vnNodeSize = voNodeList.getLength();
      var voNode;
      for(var i = 0; i < vnNodeSize; i++) {
        voNode = voNodeList.item(i);
        if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
        } else if(voNode.getNodeType() == 3 || voNode.getNodeType() == 4) { //TEXT or CDATA Section
          voParam.append(vsRootNodeName);
          voParam.append("=");
          voParam.append(encodeURIComponent(voNode.getNodeValue())); //encode
          voParam.append("&");
        }
      }
      return voParam.toString();
    } else {
      return "";
    }
  };

  this.buildElement2Param = function(poNode) {
    var voParam = new eXria.lang.StringBuilder();
    var voNode = poNode;
    var voWhiteSpace = /\S/;

    var voNodeList = poNode.getChildNodes();
    if(voNodeList && voNodeList.getLength() > 0) {
      for(var i = 0; i < voNodeList.getLength(); i++) {
        voNode = voNodeList.item(i);
        if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
        } else if((voNode.getNodeType() == 3 || voNode.getNodeType() == 4) && voWhiteSpace.test(voNode.getNodeValue())) { //TEXT or CDATA Section
          voParam.append(poNode.getNodeName());
          voParam.append("=");
          voParam.append(encodeURIComponent(voNode.getNodeValue())); //encode
          voParam.append("&");
        }
      }
    } else {
      voParam.append(poNode.getNodeName());
      voParam.append("=");
      voParam.append("&");
    }

    return voParam.toString();
  };
};
/**
 * @fileoverview
 * URLEncodingParser
 */
/**
 * URLEncodingParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.ResponseParser
 * @constructor
 * @private
 */
eXria.protocols.URLEncodingParser = function(poSubmission) {
  eXria.protocols.ResponseParser.call(this, poSubmission);

  this.parse = function(poXMLHttpRequest) {
    var voResponseXML = poXMLHttpRequest.responseXML;
    return voResponseXML;
  };
};
/**
 * @fileoverview
 * UnEncodingBuilder
 */
/**
 * UnEncodingBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.UnEncodingBuilder = function(poSubmission) {
  eXria.protocols.RequestBuilder.call(this, poSubmission);

  this.build = function() {
    //request data 생성
    var voData = new eXria.lang.StringBuilder();
    var vaValue;
    for(var vsName in this.submission.parameters.entries) {
      vaValue = this.submission.getParameter(vsName);
      for(var i = 0; i < vaValue.length; i++) {
        voData.append(vsName);     //encode
        voData.append("=");
        voData.append(vaValue[i]); //encode
        voData.append("&");
      }
    }

    //requestRef
    var voRefs = this.submission.getRefs();
    var voRef;
    for(var i = 0; i < voRefs.length; i++) {
      voRef = voRefs[i];
      var viInstance = this.submission.model.getInstance(voRef.getId());

      if(viInstance) {
        voData.append(this.buildInstance2Param(viInstance, voRef.getPath()));
      }
    }

    //encoding setting
    //AJAX는 utf-8로 통신한다.
    this.submission.encoding = "utf-8";
    //submit
    this.submission.sendAction(voData.toString());
  };

  this.buildInstance2Param = function(poInstance, psPath) {
    var voNodeList = poInstance.selectNodes(psPath);
    var vsRootNodeName = psPath;
    if(vsRootNodeName.substring(vsRootNodeName.length - 1) == "/") {
      vsRootNodeName = vsRootNodeName.substring(0, vsRootNodeName.length - 1);
    }
    if(vsRootNodeName.indexOf("/") > -1) {
      vsRootNodeName = vsRootNodeName.substring(vsRootNodeName.lastIndexOf("/") + 1);
    }
    if(voNodeList && voNodeList.getLength() > 0) {
      var voParam = new eXria.lang.StringBuilder();
      var vnNodeSize = voNodeList.getLength();
      var voNode;
      for(var i = 0; i < vnNodeSize; i++) {
        voNode = voNodeList.item(i);
        if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
        } else if(voNode.getNodeType() == 3 || voNode.getNodeType() == 4) { //TEXT or CDATA Section
          voParam.append(vsRootNodeName);
          voParam.append("=");
          voParam.append(voNode.getNodeValue()); //encode
          voParam.append("&");
        }
      }
      return voParam.toString();
    } else {
      return "";
    }
  };

  this.buildElement2Param = function(poNode) {
    var voParam = new eXria.lang.StringBuilder();
    var voNode = poNode;

    var voNodeList = poNode.getChildNodes();
    if(voNodeList && voNodeList.getLength() > 0) {
      for(var i = 0; i < voNodeList.getLength(); i++) {
        voNode = voNodeList.item(i);
        if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
        } else if(voNode.getNodeType() == 3 || voNode.getNodeType() == 4) { //TEXT or CDATA Section
          voParam.append(poNode.getNodeName());
          voParam.append("=");
          voParam.append(voNode.getNodeValue()); //encode
          voParam.append("&");
        }
      }
    } else {
      voParam.append(poNode.getNodeName());
      voParam.append("=");
      voParam.append("&");
    }
    return voParam.toString();
  };
};
/**
 * @fileoverview
 * XMLBuilder
 */
/**
 * XMLBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.XMLBuilder = function(poSubmission) {

  eXria.protocols.RequestBuilder.call(this, poSubmission);

  this.build = function() {
    //url은 머를 넣을  것인가? xmlns? 이건 어떻게 정의되나?
    //Dom의 encoding 추가
    var voDomParser = eXria.data.DOMParserFactory.getParser(poSubmission.model.page);
    //root element name = 'root'
    var viRequestXml = voDomParser.parse("<?xml version=\"1.0\" encoding=\"" + this.submission.reqCharset + "\"?><root/>");
    var viRootNode = viRequestXml.documentElement;

    /**
     * XML Build
     * 1. request ref build
     * 2. parameter build
     */
    //request ref build
    var vaRefs = this.submission.getRefs();
    var voXPath;
    var viInstance;
    var viRefInstance;
    for(var i = 0; i < vaRefs.length; i++) {
      voXPath = vaRefs[i]; //eXria.protocols.Ref
      //Instance의 Id와 xpath는 eXria.protocols.Ref를 이용하여 가져온다. Submission의 Refs는 eXria.protocols.Ref를 배열로 관리한다.
      viInstance = this.submission.model.getInstance(voXPath.getId());

      viRefInstance = viInstance.document.selectSingleNode(voXPath.getPath()); //DOM Instance
      if(viRefInstance) {
        //safari는 clone하지 않으면 붙지 않는다.
        viRootNode.appendChild(viRefInstance.cloneNode(true));
      }
    }

    //parameter build
    var vaParamValue; //Array
    var viParamNode, viParamValueNode;
    for(var vsParamName in this.submission.parameters.entries) { //parameter search loop
      vaParamValue = this.submission.getParameter(vsParamName);
      for(var i = 0; i < vaParamValue.length; i++) { //parameter value loop
        viParamValueNode = viRequestXml.createTextNode(vaParamValue[i]); //text node
        viParamNode = viRequestXml.createElement(vsParamName); //element
        viParamNode.appendChild(viParamValueNode);
        //Root Node의 마지막에 Append
        viRootNode.appendChild(viParamNode);
      }
    }

    //document에 Root Element Append
    this.submission.sendAction(viRequestXml); /* must XMLDocument */
  };
};
/**
 * @fileoverview
 * XMLParser
 */
/**
 * XMLParser
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.ResponseParser
 * @constructor
 * @private
 */
eXria.protocols.XMLParser = function(poSubmission) {
  eXria.protocols.ResponseParser.call(this, poSubmission);

  this.textParse = function(psText) {
  var voDocument = eXria.data.xhtml.DocumentFactory.createDocument(this.submission.model.page);
    voDocument.loadTXT(psText);
    return voDocument.dom;
  }

  this.parse = function(poXMLHttpRequest) {
    var vsContentType = poXMLHttpRequest.getResponseHeader("Content-Type");
    var voResponseXML = null;
    if(vsContentType && vsContentType.indexOf("xml") > -1) {
      voResponseXML = poXMLHttpRequest.responseXML;
    } else {
      voResponseXML = this.textParse(poXMLHttpRequest.responseText);
    }
    return voResponseXML;
  };
};
/**
 * @fileoverview
 * MultipartBuilder
 */

/**
 * MultipartBuilder
 * 파일업로드를 사용하기 위한 Builder
 * @author Choe, hyeon jong
 * @param {eXria.protocols.Submission} poSubmission Submission 객체
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.MultipartBuilder = function(poSubmission) {
  /**
   * Inherit
   */
  eXria.protocols.RequestBuilder.call(this, poSubmission);

  //hidden 타입의 input 엘레멘트를 추가
  this.appendHiddenParams = function(poPageDocument, poForm, psParamKey, psParamValue) {
    //input 태그를 생성
    var voInputElement = poPageDocument.createElement("input");
    voInputElement.setAttribute("type", "hidden");
    voInputElement.setAttribute("id", psParamKey);
    voInputElement.setAttribute("name", psParamKey);
    voInputElement.setAttribute("value", psParamValue);
    //생성된 input element를 form에 append
    poForm.appendChild(voInputElement);
  };
  this.searchAndAppendInstNode = function(poNode, poForm, poPageDocument) {
    var voWhiteSpace = /\S/;

    if (poNode.hasChildNodes()) {
      var vaChildNodes = poNode.getChildNodes();
      var vnChildNodesLen = vaChildNodes.getLength();
      var voNode = null;
      var vnNodeType = null;
      var vsNodeValue = null;
      for (var i = 0; i < vnChildNodesLen; i++) {
        voNode = vaChildNodes.item(i);
        vnNodeType = voNode.getNodeType();
        vsNodeValue = voNode.getNodeValue();
        if ((vnNodeType == 3 || vnNodeType == 4)
        && (voWhiteSpace.test(vsNodeValue))) {
          this.appendHiddenParams(poPageDocument, poForm, voNode.getParentNode().getNodeName(), vsNodeValue);
        } else {
          if (vnNodeType == 1) {
            this.searchAndAppendInstNode(voNode, poForm, poPageDocument);
          }
        }
      }
    } else {
      this.appendHiddenParams(poPageDocument, poForm, poNode.getNodeName(), "");
    }
  };
  //인스턴스 추가
  this.appendInstanceData = function(poPageDocument, poInstance, psXPath, poForm) {
    var voNode = poInstance.selectSingleNode(psXPath);
    this.searchAndAppendInstNode(voNode, poForm, poPageDocument);
  };
  //디폴트로 올려야 하는 데이터
  this.appendDefaultItem = function(poUploadForm) {
    if (poUploadForm == null) return null;
    var voPage = this.submission.model.page;
    var voPageDocument = voPage.window.document;

    this.appendHiddenParams(voPageDocument, poUploadForm, "eXria-Version", voPage.metadata.version);
    this.appendHiddenParams(voPageDocument, poUploadForm, "req-protocol", this.submission.reqProtocol);
    this.appendHiddenParams(voPageDocument, poUploadForm, "res-protocol", this.submission.resProtocol);
    this.appendHiddenParams(voPageDocument, poUploadForm, "req-charset", this.submission.reqCharset);
    this.appendHiddenParams(voPageDocument, poUploadForm, "res-charset", this.submission.resCharset);
  };
  //hiddenframe 생성
  this.createHiddenFrame = function(poPage, poPageDocument, psFrameName) {
    //page에 hidden frame 생성
    var vnBrowserVer = poPage.metadata.browser.ie;

    if (vnBrowserVer > 0) {
      //ie일 경우 div 생성 후 내부에 iframe 생성
      var voDiv = poPageDocument.getElementById("hiddenFormDiv");

      //div가 없을 경우 생성 div생성 후 iframe을 innerHTML 한다.
      if (voDiv == null || voDiv == undefined) {
        var voFrameDiv = poPageDocument.createElement("DIV");
        voFrameDiv.setAttribute("id", "hiddenFormDiv");
        voFrameDiv.setAttribute("name", "hiddenFormDiv");
        voFrameDiv.innerHTML = "<iframe id='" + psFrameName + "' name='" + psFrameName + "' style='display:none'></iframe>";

        if (vnBrowserVer >= 8) {
          poPageDocument.body.appendChild(voFrameDiv);
        } else {
          poPageDocument.appendChild(voFrameDiv);
        }
      }
    } else {
      //ie이외의 브라우저일 경우 hidden frame 생성후 page에 append
      var voHiddenFrm = poPageDocument.getElementById(psFrameName);

      if (voHiddenFrm == null || voHiddenFrm == undefined) {
        var voHiddenFrame = poPageDocument.createElement("iframe");
        voHiddenFrame.setAttribute("name", psFrameName);
        voHiddenFrame.setAttribute("id", psFrameName);
        voHiddenFrame.style.display = "none";

        poPageDocument.body.appendChild(voHiddenFrame);
      }
    }
  };
  //form 생성
  this.createForm = function(poPage, poPageDocument, psTargetFrame) {
    //폼 생성
    var voUploadForm = poPageDocument.createElement("form");
    //폼 속성
    voUploadForm.setAttribute("name", this.submission.id + "_frm");
    voUploadForm.setAttribute("id", this.submission.id + "_frm");

    var vnIeVersion = poPage.metadata.browser.ie;
    if (vnIeVersion > 0 && vnIeVersion <= 7) {
      voUploadForm.setAttribute("encoding", "multipart/form-data");
    } else {
      voUploadForm.setAttribute("enctype", "multipart/form-data");
    }
    voUploadForm.setAttribute("method", this.submission.method);
    voUploadForm.setAttribute("action", this.submission.action);
    voUploadForm.setAttribute("target", psTargetFrame);

    return voUploadForm;
  };
  /**
   * build
   * 파일업로드 폼을 생성하기 위한 메소드
   * 현재 canvas에 있는 FileSelector들을 가져와 form을 생성하고 서버로 파일을 올린다.
   */
  this.build = function(poFunc) {
    var vsFrameName = "fileUpHiddenFrm";
    var voPage = this.submission.model.page;
    var voPageDocument = voPage.window.document;

    //Hidden Frame 생성
    this.createHiddenFrame(voPage, voPageDocument, vsFrameName);
    //form 생성
    var voUploadForm = this.createForm(voPage, voPageDocument, vsFrameName);
    //form에 default item 셋팅
    this.appendDefaultItem(voUploadForm);

    //submission의 parameter들을 form에 append
    var voSubmitParams = this.submission.parameters;
    var voSubmitParamIter = voSubmitParams.getKeyCollection().iterator();
    while (voSubmitParamIter.hasNext()) {
      //key와 value를 가져와 input element의 속성 셋팅
      vsParamKey = voSubmitParamIter.next();
      vsParamValue = voSubmitParams.get(vsParamKey)[0];
      this.appendHiddenParams(voPageDocument, voUploadForm, vsParamKey, vsParamValue);
    }
    //submission의 req-ref 파라미터들을 form에 append
    var voReqRefParams = this.submission.getRefs();
    var vnReqRefParamLength = voReqRefParams.length;
    var i = 0;
    for (i = 0; i < vnReqRefParamLength; i++) {
      this.appendInstanceData(voPageDocument, voPage.getInstance(voReqRefParams [i].getId()), voReqRefParams [i].getPath(), voUploadForm);
    }

    //input type file인 객체를 찾아 form에 append
    var voElement;
    var vaFileCtrlNames = this.submission.getUpLoadCtrlsMap();
    if(vaFileCtrlNames != null) vaFileCtrlNames = vaFileCtrlNames.entries;

    var voParentNodesMap = new eXria.data.Map();
    for(var i in vaFileCtrlNames){
      if(vaFileCtrlNames[i] == "") return;
      voElement = voPage.window.document.getElementById(vaFileCtrlNames[i]+"_file");
      if(voElement.value){
        voParentNodesMap.put(voElement.id, voElement.parentNode);
        voUploadForm.appendChild(voElement);
      }
    }

    //page의 body에 생성된 form을 append
    voPageDocument.body.appendChild(voUploadForm);

    var voMultipartParser = new eXria.protocols.MultipartParser(this.submission);
    var voHideFrame = voPageDocument.getElementById(vsFrameName);

    var fileUploadComplete = function(poFunc) {
      voMultipartParser.parse(voHideFrame, poFunc);
    };

    if (voPage.metadata.browser.ie > 0) {
      voPageDocument.getElementById(vsFrameName).onreadystatechange = function() {
        fileUploadComplete(poFunc);
      };
    } else {
      voPageDocument.getElementById(vsFrameName).onload = function() {
        fileUploadComplete(poFunc);
      };
    }
    //form Submit 후 reset 한다.
    voUploadForm.submit();
    voUploadForm.reset();
    //submit 된 input 노드를 복사해서 다시 붙여넣는다.
    var voParentNodesItor = new eXria.data.ArrayMap(voParentNodesMap).getKeyCollection().iterator();
    var vsKey = null;
    var voParent = null;
    var voElement = null;
    var voFile = null;
    var voFileSelector = null;
    while (voParentNodesItor.hasNext()) {
      vsKey = voParentNodesItor.next();
      voParent = voParentNodesMap.get(vsKey);
      voElement = voPageDocument.getElementById(vsKey);
      voFile = voElement.cloneNode(true);

      voFile.control = voElement.control;
      voFileSelector = voElement.control;
      
      voParent.parentNode.childNodes [0].value = ""
//      voParent.parentNode.childNodes [0].childNodes [0].childNodes [0].childNodes [0].childNodes [0].value = "";
      voFileSelector.eventManager.removeListener(voFile, "onchange", voFileSelector.mediateEvent);
      voFileSelector.eventManager.addListener(voFile, "onchange", voFileSelector.mediateEvent);
      voElement.parentNode.removeChild(voElement);
      voParent.appendChild(voFile);
    }
    //생성 되었던 form을 삭제한다.
    var voRmForm = voPageDocument.getElementById(this.submission.id + "_frm");
    voRmForm.parentNode.removeChild(voRmForm);
  };
};
/**
 * @fileoverview
 * MultipartParser
 */
/**
 * MultipartParser
 * @author Choe, hyeon jong
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.ResponseParser
 * @constructor
 * @private
 */
eXria.protocols.MultipartParser = function(poSubmission) {
  eXria.protocols.ResponseParser.call(this, poSubmission);
  this.complete = false;
  
  if(page.metadata.useJsonInstance) {
    this.textParse = function(psText) {
      try {
        var voResult =eval("(" + psText + ")");
        this.submission.redirectJsonLocation(voResult);
        this.submission.bindJsErrMsg(voResult);
        this.submission.bindJsInstance(voResult);
        if(this.submission.onSubmitDone) {
          this.submission.onSubmitDone(this.submission);
        }
      } catch(e) {
        if(this.submission.onSubmitError) {
          this.submission.onSubmitError(voResult);
        }
      }
    };
  } else {
    this.textParse = function(psText) {
      var voResponseParser = eXria.protocols.ProtocolParserFactory.getResponseParser(this.submission, this.submission.resProtocol);
      try {
        var voResult = voResponseParser.textParse(psText);
        this.submission.redirectLocation(voResult);
        this.submission.bindErrMsg(voResult);
        if(voResponseParser.bind) {
          this.submission.bindInstance(voResult);
        }
        if(this.submission.onSubmitDone) {
          this.submission.onSubmitDone(this.submission);
        }
      } catch(e) {
        if(this.submission.onSubmitError) {
          this.submission.onSubmitError(voResult);
        }
      }
    };
  }
  this.parse = function(poFrame, poFunc) {
	  var vsResult = null;
	  var voReadyState = poFrame.readyState;
    var vbSuccess;
	  if(voReadyState) {
	    if(voReadyState == "complete" && !this.complete) {
		    this.complete = true;
		    vsResult = this.submission.model.page.window.document.frames[poFrame.id].document.body;
		    if(vsResult != null) vsResult = vsResult.innerText;
		    try {
		      this.textParse(vsResult);
          vbSuccess = true;
        } catch(err) {
          vbSuccess = false;
        }
				if(poFunc != null) poFunc(vbSuccess);
	    }
	  } else {
	    try {
	    	vsResult = poFrame.contentWindow.document.body.firstChild.firstChild.nodeValue;
        vbSuccess = true;
	    } catch(e) {
	    	vsResult = "complete";
        vbSuccess = false;
	    }
	    this.textParse(vsResult);
			if(poFunc != null) poFunc(vbSuccess);
	  }
  };
};
/**
 * @fileoverview
 * eXria.protocols.xhtml package
 */
/**
 * eXria.protocols.xhtml package
 * @author Kim, Kang Seok (drkimks@tomatosystem.co.kr)
 * @version 1.0
 */

/**
 * eXria.protocols
 */
eXria.protocols.xhtml = {};

/**
 * @fileoverview
 * XHTML Mode 사용시 서버와의 data통신 프로세스를 담당.
 */

/**
 * XHTML Mode 사용시 서버와의 data통신 프로세스를 담당.
 * @version 1.0
 * @param {String} psId Submission Id
 * @param {eXria.form.Model} poModel eXria.form.Model
 * @constructor
 * @base eXria.protocols.Submission
 */
eXria.protocols.xhtml.Submission = function(psId, poModel) {
  eXria.protocols.Submission.call(this, psId, poModel);
  /**
   * private
   */
  this.crudData = "";

  this.uploadFileCtrls = new eXria.data.Map();
  this.dataSetIds = {};
  /**
   * submission Instance
   * @type eXria.protocols.Submission
   * @see eXria.protocols.Submission
   * @ignore
   */
  var submissionInstance = this;
  /**
   * request protocol 셋팅
   * @param {String} request protocol
   * @return void
   * @type void
   */
  this.setReqProtocol = function(psReqProtocol) {
    this.reqProtocol = psReqProtocol;
  };
  /**
   * response protocol 셋팅
   * @param {String} response protocol
   * @return void
   * @type void
   */
  this.setResProtocol = function(psResProtocol) {
    this.resProtocol = psResProtocol;
  };
  /**
   * request protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getReqProtocol = function() {
    return this.reqProtocol;
  };
  /**
   * response protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getResProtocol = function() {
    return this.resProtocol;
  };
  /**
   * XMLHttpRequest를 synchronized 방식으로 동작시킬지</br>
   * asynchronized로 동작시킬지를 설정한다.</br>
   * true : asynchronized, false : synchronized
   * @type Boolean
   * @default true
   * @ignore
   */
  this.async = true;
  /**
   * synchronize 유무를 결정한다.
   * @param {Boolean} pbAsync sync 유무
   * @return void
   * @type void
   * @private
   */
  this.setAsync = function(pbAsync) {
    this.async = pbAsync;
  };
  /**
   * HTTP Method (GET/POST)
   * @type String
   * @ignore
   */
  this.method = "POST"; //default POST
  /**
   * HTTP Meothod를 셋팅한다.
   * @param {String} psMethod method
   * @return void
   * @type void
   * @private
   */
  this.setMethod = function(psMethod) {
    this.method = psMethod;
  };
  /**
   * 서브미션의 action Url 지정
   * @param {String} Action
   * @return void
   * @type void
   */
  this.setAction = function(psAction) {
    var vsTmpAction = psAction;
    var vsRegAction = null;

    if(this.model.page.metadata.submitBaseUrl == null || this.model.page.metadata.submitBaseUrl == "") {
    if(eXria.util.StringUtil.startsWith(vsTmpAction, "/")) {
    vsRegAction = "." + psAction;
    } else {
    vsRegAction = psAction;
    }
    } else if(vsTmpAction.length > 4 && eXria.util.StringUtil.startsWith(vsTmpAction.toUpperCase(), "HTTP")) {
      vsRegAction = psAction;
    } else {
      if(eXria.util.StringUtil.startsWith(vsTmpAction, "/")) {
        if(eXria.util.StringUtil.endsWith(this.model.page.metadata.submitBaseUrl, "/")) {
      vsTmpAction = psAction.substring(1);
        }
        vsRegAction = this.model.page.metadata.submitBaseUrl + vsTmpAction;
    } else if(eXria.util.StringUtil.startsWith(vsTmpAction, "./")) {
    if(eXria.util.StringUtil.endsWith(this.model.page.metadata.documentBaseUrl, "/")) {
      vsTmpAction = psAction.substring(2);
        }
        vsRegAction = this.model.page.metadata.documentBaseUrl + vsTmpAction;
      } else {
        if(eXria.util.StringUtil.endsWith(this.model.page.metadata.documentBaseUrl, "/")) {
          vsRegAction = this.model.page.metadata.documentBaseUrl + psAction;
        } else {
          vsRegAction = this.model.page.metadata.documentBaseUrl + "/" + psAction;
        }
      }
    }
    this.action = vsRegAction;
  };
  /**
   * 서브미션의 action target 반환
   * @return 서브미션의 action target
   * @type String
   */
  this.getAction = function() {
    return this.action;
  };
  /**
   * Request Instance Reference Array<eXria.protocols.Ref>
   * @type Array
   * @private
   */
  this.refs = new Array();
  /**
   * Request Instance Reference Array를 리턴 한다.<br/>
   * XHTML 모드에서만 사용 가능하다.
   * @return Request Instance Reference Array
   * @type Array
   */
  this.getRefs = function() {
    return this.refs;
  };
  /**
   * Request Reference를 모두 삭제.
   * @return void
   * @type void
   */
  this.clearRef = function() {
    this.refs = [];
  };
  /**
   * Request Instance Reference Array를 추가한다.
   * @param {String} psId instance id
   * @param {String} psPath instance xpath
   * @return void
   * @type void
   */
  this.addRef = function(psId, psPath) {
    var voRef = new eXria.protocols.Ref(psId, psPath, false);
    this.refs.push(voRef);
  };
  /**
   * HttpRequest Header
   * (K : String, V : String)
   * @type eXria.data.ArrayMap
   * @private
   */
  this.headers = new eXria.data.ArrayMap();
  /**
   * HttpRequest Header 값을 리턴한다.
   * @param {String} psName Header Name
   * @return Header Value
   * @type String
   */
  this.getHeader = function(psName) {
    return this.headers.get(psName);
  };
  /**
   * HttpRequest Header를 추가한다.
   * @param {String} psName Header Name
   * @param {String} psValue Header Value
   * @return void
   * @type void
   */
  this.setHeader = function(psName, psValue) {
    this.headers.put(psName, psValue);
  };
  /**
   * HttpRequest Header를 삭제한다.
   * @param {String} psName  Header Name
   * @return header Value
   * @type String
   */
  this.removeHeader = function(psName) {
    return this.headers.remove(psName);
  };
  /**
   * HttpRequest Parameter
   * @type eXria.data.ArrayMap
   * @see eXria.data.ArrayMap
   * @private
   */
  this.parameters = new eXria.data.ArrayMap();
  /**
   * HttpRequest에 Parameter를 추가한다.
   * @param {String} psName parameter Name
   * @param {String} psValue parameter Value
   * @return void
   * @type void
   */
  this.addParameter = function(psName, psValue) {
    if(this.parameters.entries[psName]) { /* 값 추가 */
      var vaValue = this.parameters.get(psName);
      vaValue.push(psValue);
      this.parameters.remove(psName);
      this.parameters.put(psName, vaValue);
    } else {/* 값 생성 */
      this.parameters.put(psName, [psValue]);
    }
  };
  /**
   * HttpRequest에 DataSet을 추가한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.addDataSetId = function(psId){
    this.dataSetIds[psId] = psId;
  };
  /**
   * submission에 데이타셋 CRUD 문자열 정보를 추가시켜 주는 메소드
   * @param {String} psString 서브미션 전송 시 추가로 보내고자 하는 CRUD 데이터
   * @return void
   * @type void
   */
  this.addCRUDString = function(psString) {
    this.crudData += psString;
  };
  /**
   * HttpRequest에 DataSet을 추가한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.removeDataSetId = function(psId){
    if(this.dataSetIds[psId] != null) {
      delete this.dataSetIds[psId];
    }
  };
  /**
   * HttpRequest Parameter를 조회한다.</br>
   * 값이 여럿일 경우 가장 첫번째 값을 리턴
   * @param {String} psName parameter name
   * @return Parameter Values
   * @type Array
   */
  this.getParameter = function(psName) {
    return this.parameters.get(psName);
  };
  /**
   * HttpRequest Parameter를 삭제한다.
   * @param {String} psName Parameter Name
   * @return void
   * @type void
   */
  this.removeParameter = function(psName) {
    this.parameters.remove(psName);
  };
  /**
   * parameter를 모두 삭제한다.
   * @return void
   * @type void
   * @ignore
   */
  this.clearParameter = function() {
    if(this.parameters) {
      this.parameters.clear();
    }
  };
  //2009-03-31 최현종 추가 document -> this.doc
  /**
   * document Object
   * @type Object
   * @ignore
   */
  this.doc = this.model.page.window.document;
  // from document
  /**
   * Submit Request CharacterSet Encoding Type
   * @type String
   * @default IE, Opera, Safari : document.charset, Firefox : document.characterSet
   * @ignore
   */
  this.reqCharset = (this.doc.charset ? this.doc.charset : this.doc.characterSet);
  /**
   * Submit Response CharacterSet Encoding Type
   * @type String
   * @ignore
   */
  this.resCharset = (this.doc.charset ? this.doc.charset : this.doc.characterSet);
  /**
   * Submit Response CharacterSet Encoding Type을 설정한다.
   * @param {String} psCharset CharacterSet Name
   * @return void
   * @type void
   */
  this.setReqCharset = function(psCharset) {
    this.reqCharset = psCharset;
  };
  /**
   * Submit Response CharacterSet Encoding Type을 설정한다.
   * @param {String} psCharset CharacterSet Name
   * @return void
   * @type void
   */
  this.setResCharset = function(psCharset) {
    this.resCharset = psCharset;
  };
  /**
   * Response Data Instance XPath
   * @type Array
   * @ignore
   */
  this.resRefs = new Array();
  /**
   * Submission 완료 후 서버로 부터 받은 결과를 붙일 Instance를 추가한다.
   * @param {String} psId instance id
   * @param {String} psPath instance path
   * @param {Boolean} pbReplace instance replace 여부
   * @return void
   * @type void
   */
  this.addResRef = function(psId, psPath, pbReplace) {
    var voResRef = new eXria.protocols.Ref(psId, psPath, pbReplace);
    this.resRefs.push(voResRef);
  };
  /**
   * Response Ref의 Instance Path를 리턴한다.<br/>
   * XHTML 모드에서만 사용가능하다.
   * @return instance path
   * @type Array
   */
  this.getResRefs = function() {
    return this.resRefs;
  };
  /**
   * for AJAX
   * @type XMLHttpRequest
   * @ignore
   */
  var xmlHttpRequest = null;

  this.redirectJsonLocation = function(poJson) {
    if(!poJson) return;

    var voReLoc = null;
    voReLoc = poJson.root.EXRIAREDIRECT;
    //voReLoc = new eXria.data.json.Node(poJson).getNodeValue();
    try {
      if (!!voReLoc && voReLoc != "") {
        var vsPath = ""; //voReLocChild.nodeValue;
        vsPath = eXria.util.UrlUtil.getAbsoluteUrl(voReLoc);
        this.model.page.open(vsPath);
      }
    } catch(e) {}

  };
  /**
   * 서버에서 내려온 xml에 EXRIAREDIRECTION 노드가 있을 경우 현재 Page를 노드의 value에 해당하는 주소로 리다이렉션
   * @param {XMLNoe} poXml Dom Element
   * @return void
   * @type void
   * @private
   */
  this.redirectLocation = function(poXml) {
    if(!poXml) return;
    if(poXml.documentElement) poXml = poXml.documentElement;
    var voReLoc = null;
    if(this.model.page.metadata.browser.ie > 0) {
      voReLoc = poXml.selectSingleNode("/root/EXRIAREDIRECT");
    } else {
      var voXpe = new XPathEvaluator();
      var voNsResolver = voXpe.createNSResolver( poXml.ownerDocument == null ? poXml.documentElement : poXml.ownerDocument.documentElement);
      var voResults = voXpe.evaluate("/root/EXRIAREDIRECT", poXml, voNsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
      voReLoc = voResults.singleNodeValue;
    }
    try {
      if(voReLoc) {
        var voReLocChild = voReLoc.firstChild;
        if(voReLocChild) {
          var vsPath = voReLocChild.nodeValue;
          if(vsPath != "") {
            vsPath = eXria.util.UrlUtil.getAbsoluteUrl(vsPath);
            this.model.page.open(vsPath);
          }
        }
      }
    } catch(e) {}
  };

  /**
   * DOM Element를 Client Instance에 Binding한다.
   * @param {XMLNode} poXml DOM Element
   * @return void
   * @type void
   * @ignore
   */
  this.bindInstance = function(poXml) {
  if(!poXml) return;
    if(poXml.documentElement) {
      poXml = poXml.documentElement;
    }

    var voDocMap = eXria.data.DomDocumentFactory.getDomDocObj();
    if(this.model.page.metadata.browser.ie > 0) {
      var voRef = null;
      var voDomDoc = null;
      var voInstanceDom = null;
      var voResDom = null;
      var voOrgDom = null;

      for(var i = 0, vnResRefSize = this.resRefs.length ; i < vnResRefSize ; i++) {
        voRef = this.resRefs[i];
        voDomDoc = voDocMap.get(voRef.getId());

        voInstanceDom = voDomDoc.cloneNode(true);

        try {
          voResDom = poXml.selectSingleNode(voRef.getPath()).cloneNode(true);
        } catch(e) {
          var vsPath = voRef.getPath();
          vsPath = vsPath.substring(vsPath.lastIndexOf("/"), vsPath.length);
          var vsXPath = "/root" + vsPath;
          try {
            voResDom = poXml.selectSingleNode(vsXPath).cloneNode(true);
          } catch(e) {
            continue;
          }
        }

        voInstanceDom.loadXML(voResDom.xml);

        voOrgDom = new eXria.data.xhtml.Node(voDomDoc.selectSingleNode(voRef.getPath()));
        eXria.util.DomUtil.load(voOrgDom, new eXria.data.xhtml.Node(voInstanceDom.documentElement), voRef.getReplace());
      }
    } else {
      var node = new eXria.data.xhtml.Node(poXml);
      //결과 node의 childnode를 순차적으로 조회하면서
      //responseref의 path의 element nodename과 비교하여
      //일치하는 node에 붙여 넣는다.
      var voResNode = new eXria.data.xhtml.CollectionNode(node);
      var vnNodeSize = voResNode.size();
      var vnResRefSize = this.resRefs.length;
      for(var i = 0; i < vnNodeSize; i++) {
        var voNode = voResNode.get(i);
        var vsNodeName = voNode.getNodeName();
        var voOriginalInstance = null;
        var voRef = null;

        for(var j = 0; j < vnResRefSize; j++) {
          voRef = this.resRefs[j];

          if(eXria.util.StringUtil.endsWith(voRef.getPath(), "/" + vsNodeName)) {
            voOriginalInstance = this.model.getInstance(voRef.getId());
            break;
          }
        }
        if(voOriginalInstance && voOriginalInstance != null) {
          var voParent = voOriginalInstance.selectSingleNode(voRef.getPath());
        //var voOriNode = new eXria.data.xhtml.CollectionNode(voParent);
        //voOriNode.clear();
          eXria.util.DomUtil.load(voOriginalInstance.selectSingleNode(voRef.getPath()), voNode, voRef.getReplace());
        }
    }
  }
  };
  /**
   * DOM Element를 Client Instance에 Binding한다.
   * @param {XMLNode} poXml DOM Element
   * @return void
   * @type void
   * @ignore
   */
  this.bindJsInstance = function(poJson) {
    if(!poJson) return;

    var voRef = null;
    var voResInstance = new eXria.data.json.Instance(this.id + "ResInst", this.model);
    voResInstance.instObj = poJson;
    var voOrgInstance = null;
    var voResObj = null;
    var voOrgObj = null;
    var voPage = this.model.page;
    var vsRefPath = "";
    for(var i = 0, vnResRefSize = this.resRefs.length ; i < vnResRefSize ; i++) {
      voRef = this.resRefs[i];
      voOrgInstance = this.model.page.getInstance(voRef.getId());
      voOrgObj = voOrgInstance.getInstObj(voRef.getPath());
      if(!voOrgObj){
        var vsParentPath = voRef.getPath().substring(0, voRef.getPath().lastIndexOf("/"));
        var voParentObj = voOrgInstance.getInstObj(vsParentPath);
        var vsNodeName = voRef.getPath().substring(voRef.getPath().lastIndexOf("/") + 1, voRef.getPath().length);
        var voNodeObj = voParentObj.createElement(vsNodeName);
        voParentObj.appendChild(voNodeObj);
        voOrgObj = voOrgInstance.getInstObj(voRef.getPath());
      }
      vsRefPath = "/root" + voRef.getPath().substring(voRef.getPath().lastIndexOf("/"), voRef.getPath().length);
      voResObj = voResInstance.getInstObj(vsRefPath);
      if(voResObj == null || voOrgObj == null) continue;
      if(voRef.getReplace()) { //혜란수정
        voOrgObj.parentNode[voOrgObj.name] = voResObj.node;
      } else {
        if(voResObj.node instanceof Array && voOrgObj.node instanceof Array) {
          voOrgObj.parentNode[voOrgObj.name] = voOrgObj.node.concat(voResObj.node);
        } else if(voResObj.node instanceof Array) {
          voOrgObj.parentNode[voOrgObj.name] = voResObj.node;
        } else if(voOrgObj.getNodeType() == 1 && voResObj.getNodeType() == 1) {
          var voOrgObjNode = voOrgObj.node;
          var voResObjNode = voResObj.node;
          for(var attr in voResObjNode) {
            voOrgObjNode[attr] = voResObjNode[attr];
          }
        }
       }
     }

  };
  /**
   * Submission send 후 error 코드가 내려왔을 경우 error 메세지를 바인딩.
   * @return void
   * @type void
   * @private
   */
  this.bindErrMsg = function(poXml) {
  if(!poXml) return;
  if(poXml.documentElement) poXml = poXml.documentElement;

  var voDefInst = this.model.getInstance(this.model.defaultInstanceId);
    var voErr = voDefInst.selectSingleNode("/root/EXRIAERRMSG");
    var voResErr = null;

    if(this.model.page.metadata.browser.ie > 0) {
      voResErr = poXml.selectSingleNode("/root/EXRIAERRMSG");
    } else {
      var voXpe = new XPathEvaluator();
        var voNsResolver = voXpe.createNSResolver( poXml.ownerDocument == null ? poXml.documentElement : poXml.ownerDocument.documentElement);
        var voResults = voXpe.evaluate("/root/EXRIAERRMSG", poXml, voNsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        voResErr = voResults.singleNodeValue;
    }
    if(voResErr == null) return;
    var vnErrLen = voResErr.childNodes.length;
    for(var i = 0 ; i < vnErrLen ; i++) {
      voErr.appendChild((voResErr.childNodes[i]).cloneNode(true));
    }
  };
  /**
   * Submission send 후 error 코드가 내려왔을 경우 error 메세지를 바인딩.
   * @return void
   * @type void
   * @private
   */
  this.bindJsErrMsg = function(poJson) {
    var voDefInst = this.model.getInstance(this.model.defaultInstanceId);
    var voErr = voDefInst.selectSingleNode("/root/EXRIAERRMSG");
    if(voErr.hasChildNodes()) {
      voErr.parentNode["EXRIAERRMSG"] = "";
//      var voErrList = voErr.getChildNodes();
//      var vnLen = voErrList.getLength(); 
//      var voNode = null;
//      for(var i = vnLen-1 ; i >= 0 ; i--) {
//        voNode = voErrList.item(i);
//        voErr.removeChild(voNode);
//      }
    }
    if(!poJson) return;
    if(!poJson.root.EXRIAERRMSG) return;

    var voResErr = null;
    voResErr = new eXria.data.json.Node(poJson.root.EXRIAERRMSG);
//    if(this.model.page.metadata.browser.ie > 0) {
//      voResErr = new eXria.data.json.Node(poJson.root.EXRIAERRMSG);
//    } else {
//      var voXpe = new XPathEvaluator();
//      var voNsResolver = voXpe.createNSResolver( poJson.ownerDocument == null ? poJson.documentElement : poJson.ownerDocument.documentElement);
//      var voResults = voXpe.evaluate("/root/EXRIAERRMSG", poJson, voNsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
//      voResErr = voResults.singleNodeValue;
//    }
    var voResErrNode = voResErr.getChildNodes();
    var vnErrLen = voResErrNode.getLength();
    for(var i = 0 ; i < vnErrLen ; i++) {  
      voErr.appendChild((voResErrNode.item(i)).cloneNode(true));
    }
  };
  /**
   * Submission Send
   * @return Proxy
   * @type Object
   */
  this.send = function(poFunc) {
    //onSubmit callback call
    if(this.onSubmit) {
      this.onSubmit(submissionInstance);
    }
    //일반 Submission의 경우 데이터 머지 후 서버 콜
    //JSON-RPC 또는 SOAP-RPC의 경우 서버 서비스 정보 콜 또는 wsdl 다운로드 파싱 후 Proxy를 생성해서 리턴
    //Application에서는 Proxy를 받아서 Proxy의 method 실행
    //RequestBuilder
    var voRequestBuilder = eXria.protocols.ProtocolParserFactory.getRequestBuilder(this);
    //전송 타입이 JSON-RPC, SOAP-RPC일 경우 Builder에서 서버와 통신하여 Proxy를 생성하여 리턴
    //기타 경우 Builder에서는 서버에 전송할 전송데이터를 Building하여 Submission의
    //sendAction function을 call한다.
    if(poFunc == null && this.callback) poFunc = this.callback;
    var voResult = voRequestBuilder.build(poFunc);
    var vbSuccess;
    if(voResult == null) {
      vbSuccess = false;
    } else {
      vbSuccess = true;
    }
    return vbSuccess;
  };
  
  this.sendAsync = function(poFunc, psTranId) {
    var vaAsyncEventQueue = this.model.asyncEventQueue;
    if(psTranId != null) vaAsyncEventQueue = this.model.asyncEventQueueMap.get(psTranId);
    vaAsyncEventQueue.push(this);
    this.callBySendAsync = true;
    this.callback = poFunc;
    this.tranId = psTranId;
    return this.send();
  };
  /**
   * RequestBuilder 또는 Proxy에 의해 호출되는 CallBack Function
   * 실제 서버 Call이 수행된다.
   * @param poBuildData 서버로 전송할 DOMString 또는 XMLDocument
   * @return callback function
   * @type Object
   * @ignore
   */
  this.sendAction = function(poBuildData) {
    var voDs, vsCudStr = "";
    for(var m in this.dataSetIds) {
      voDs = this.model.getDataSet(m);
      vsCudStr = vsCudStr + voDs.getAutoCRUDString();
    }
    
    if((vsCudStr != "" || this.crudData != "") && this.reqProtocol == "urlencoded") {
      poBuildData = poBuildData + this.crudData + vsCudStr;
    }

    //AJAX XMLHttpRequest
    xmlHttpRequest = eXria.form.xhtml.HttpRequestFactory.create();

    var vbAsync = this.async;
    if(this.callBySendAsync) vbAsync = true;
    this.callBySendAync = null;
    xmlHttpRequest.open(this.method, this.action, vbAsync);
    
    /* HTTP REQUEST HEADER 설정 Start */
    {
      //async 방식의 callback function
      //Header put
      for(var member in this.headers.entries) {
        xmlHttpRequest.setRequestHeader(member, this.headers.entries[member]);
      }
      //content-type 설정
      xmlHttpRequest.setRequestHeader("Content-Type", eXria.protocols.ProtocolParserFactory.getContentType(this));
      //request-type 설정
      //xmlHttpRequest.setRequestHeader("Request-Type", this.type);
      xmlHttpRequest.setRequestHeader(eXria.protocols.SubmissionType.REQ_PROTOCOL_HEADER, this.reqProtocol);
      xmlHttpRequest.setRequestHeader(eXria.protocols.SubmissionType.RES_PROTOCOL_HEADER, this.resProtocol);
      //exria version 설정
      if(this.model.page.metadata.version && this.model.page.metadata.version != 'null') {
      xmlHttpRequest.setRequestHeader("eXria-Version", this.model.page.metadata.version);
      }
      //put characterset encoding type header
      //request characterset encoding type과 response characterset encoding type을 분리
      if(typeof poBuildData == 'string') { //data가 string 타입일때는 utf-8
        xmlHttpRequest.setRequestHeader("req-charset" , "UTF-8");
      } else { //data가 XMLDocument 타입일때는 정의된 인코딩 타입으로
        xmlHttpRequest.setRequestHeader("req-charset" , this.reqCharset);
      }
      xmlHttpRequest.setRequestHeader("res-charset", this.resCharset);
    }
    /* HTTP REQUEST HEADER 설정 End */
    if(vbAsync) { //asynchronized
      //EventHandler Registration
      xmlHttpRequest.onreadystatechange = this.responseCallBack;
      if(poBuildData) {
        xmlHttpRequest.send(poBuildData);
      } else {
        xmlHttpRequest.send(null);
      }
      return "";
    } else { //synchronized
      if(poBuildData) {
        xmlHttpRequest.send(poBuildData);
      } else {
        xmlHttpRequest.send(null);
      }
      //synchronized 방식일 경우 임의로 callBack function을 실행한다
      return this.responseCallBack();
    }
  };
  /**
   * 서버의 결과를 받아서 결과 값이 처리완료 이면</br>
   * ResponseParser를 생성. 서버 결과 데이터를 처리하고</br>
   * 처리 결과를 responseRef에 replace or append 시킨다
   * @return 서버에서 내려온 XML Element
   * @type XMLNode
   * @ignore
   */
  this.responseCallBack = function() {
    var voResult = null;
    if(xmlHttpRequest.readyState == 4) { /* Done */
      var vnStatus = xmlHttpRequest.status;
      if(vnStatus == 200) { /* OK */
        submissionInstance.responseState = true;
        //ResponseParser
        var vsResProtocolType = xmlHttpRequest.getResponseHeader(eXria.protocols.SubmissionType.RES_PROTOCOL_HEADER);
        if(vsResProtocolType == "" && page.metadata.useJsonInstance) vsResProtocolType = submissionInstance.resProtocol;
        var voResponseParser = eXria.protocols.ProtocolParserFactory.getResponseParser(submissionInstance, vsResProtocolType);
        //페이지 리다이렉트 2010.9.2 추가
        if(page.metadata.useJsonInstance) {
          voResult = xmlHttpRequest.responseText;
          voResult = (voResult == "") ? voResult : eval("(" + voResult + ")");
          submissionInstance.redirectJsonLocation(voResult);
          submissionInstance.bindJsErrMsg(voResult);
          if(voResponseParser.bind) {
            submissionInstance.bindJsInstance(voResult);
          }
        } else {
          voResult = voResponseParser.parse(xmlHttpRequest);
          submissionInstance.redirectLocation(voResult);
          submissionInstance.bindErrMsg(voResult);
          if(voResponseParser.bind) {
            submissionInstance.bindInstance(voResult); //Instance replace or append
          }
        }
        if(submissionInstance.onSubmitDone) { //application callback
          //application callback event handler call
          submissionInstance.onSubmitDone(submissionInstance);
        }
        submissionInstance.crudData = "";
      } else { /* Error */
        submissionInstance.responseState = false;
        try { //parse and bind
          var voResponseParser = eXria.protocols.ProtocolParserFactory.getResponseParser(submissionInstance, xmlHttpRequest.getResponseHeader(eXria.protocols.SubmissionType.RES_PROTOCOL_HEADER));
          voResult = voResponseParser.parse(xmlHttpRequest); //result of parsing(XML DOMElement)
        //페이지 리다이렉트 2010.9.2 추가
          submissionInstance.redirectLocation(voResult);
          submissionInstance.bindErrMsg(voResult);
        } catch(e) {
          voResult = xmlHttpRequest.responseText;
        }
        //Application ErrorHandler
        if(submissionInstance.onSubmitError) {
          //submissionInstance.onSubmitError(vnStatus);
          //error result data parsing and toss
          submissionInstance.onSubmitError(voResult); //event drive
        } else {
          var vsResponseMsg = xmlHttpRequest.responseText;
          //debug mode 일때 서버에서 받은 메시지를 출력해야 하는데...
          //client의 debug mode를 어디서 설정하지? TODO
          //alert(vsResponseMsg);
          //throw new Error(vsResponseMsg);
        }
      }
      var voModel = submissionInstance.model;
      var vsTranId = submissionInstance.tranId;
      var vbGonnaRunCallbacks = voModel.gonnaRunCallbacks;
      if(vsTranId) vbGonnaRunCallbacks = voModel.runningStateMap.get(vsTranId);
      if(vbGonnaRunCallbacks) {
        if(voModel.checkLastInQueue(vsTranId)) voModel.excuteAndClearCallbacks(vsTranId);
      }
    }
    
    delete xmlHttpRequest;
    return voResult;
  };
  /**
   * Header Attribute 값을 리턴한다.
   * @param {String} psAttrName 리턴 받을 Attribute Name
   * @return Attribute Value
   * @type String
   * @return Attribute Value
   */
  this.getAttrStr = function(psAttrName) {
  return null;
  };
  /**
   * Header Attribute 값을 설정한다. 만약 해당 Attribute가 있다면 해당 값으로 덮어씌운다.
   * @param {String} psAttrName 설정 Attribute Name
   * @param {String} psValue 설정할 Attribute 값
   * @type void
   * @return void
   */
  this.setAttrStr = function(psAttrName, psValue) {
  return null;
  };
  /**
   * Header의 Content-type을 재설정한다.
   * @type void
   * @return void
   */
  this.initReqType = function() {
  return null;
  };
  /**
   * Submission에서 서버로 보낼 데이터를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return Submission Send 시 서버로 보낼 데이터 문자열
   * @type String
   */
  this.getSubmitData = function() {
    throw new Error("not support method.");
  };
  /**
   * 파라미터로 넘어온 문자열을 Submission의 Response Ref에 지정한 Node에 바인딩 한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psData 바인딩하고자 하는 데이터 문자열
   * @type void
   * @return void
   */
  this.bindUserData = function(psData) {
    throw new Error("not support method.");
  };
  /**
   * 파라미터로 넘어온 데이터를 서버로 보낸다.<br/>
   * 해당 메소드를 사용할 경우 Submission에 바인딩 된 Request 데이터는 모두 무시 되며<br/>
   * 오로지 파라미터로 넘긴 문자열에 대해서만 처리한다.<br/>
   * 또한 서버로부터 내려온 데이터는 인스턴스에 바인딩 되지 않으며 문자열로 리턴 된다.<br/>
   * (Plugin Mode 에서만 사용 가능)
   * @param psData 서버로 보낼 데이터 문자열
   * @type String
   * @return 서버로부터 내려온 데이터 문자열
   */
  this.sendUserData = function(psData) {
    throw new Error("not support method.");
  };
  /**
   * Response Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Response Reference 문자열
   */
  this.getResponseRefString = function() {
    var voRef = null;
    var s = "";
    for(var i = 0, len = this.resRefs.length ; i < len ; i++) {
      voRef = this.resRefs[i];
      s = s + voRef.getId();
      s = s + ":";
      s = s + voRef.getPath();
      s = s + ";";
    }
    return s;
  };
  /**
   * Request Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Request Reference 문자열
   */
  this.getRequestRefString = function() {
    var voRef = null;
    var s = "";
    for(var i = 0, len = this.refs.length ; i < len ; i++) {
      voRef = this.refs[i];
      s = s + voRef.getId();
      s = s + ":";
      s = s + voRef.getPath();
      s = s + ";";
    }

    if(s.length > 0) {
      s = s.substring(0, s.length - 1);
    }
    return s;
  };
  /**
   * Request Parameter의 Key를 String 형태로 리턴한다.<br/>
   * (ex. ParamKey1,ParamKey2,ParamKey3)
   * @type String
   * @return Request Parameter Key 문자열
   */
  this.getParameterKeyString = function() {
    var s = "";
    var voKeys = this.parameters.getKeyCollection().iterator();
    while(voKeys.hasNext()) {
      s = s + voKeys.next();
      s = s + ",";
    }

    if(s.length > 0) {
      s = s.substring(0, s.length - 1);
    }

    return s;
  };
  /**
   * Request CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getReqCharSet = function() {
    return this.reqCharset;
  };
  /**
   * Response CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getResCharSet = function() {
    return this.resCharset;
  };
  /**
   * Request DataSet의 ID를 String 형태로 리턴한다.<br/>
   * (ex. dst1,dst2,dst3)
   * @type String
   * @return Request DataSet의 ID 문자열
   */
  this.getDataSetIdString = function() {
    var voIds = [];
    for(var m in this.dataSetIds) {
      voIds.push(m);
    }
    return voIds.join(",");
  };

  /**
   * Request Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Request Protocol Type에 해당하는 문자열
   */
  this.getReqType = function() {
    return this.reqType;
    //throw new Error("not support method.");
  };
  /**
   * Response Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Response Protocol Type에 해당하는 문자열
   */
  this.getResType = function() {
    return this.resType;
    //throw new Error("not support method.");
  };
  /**
   * Request Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Request Protocol Type
   * @type void
   * @return void
   */
  this.setReqType = function(psReqType) {
    this.reqType = psReqType;
    //throw new Error("not support method.");
  };
  /**
   * Response Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Response Protocol Type
   * @type void
   * @return void
   */
  this.setResType = function(psResType) {
    this.resType = psResType;
    //throw new Error("not support method.");
  };
  /**
   * wait cursor 사용 유무를 리턴한다.
   * @return wait cusor 사용 유무
   * @type Boolean
   */
  this.isWaitCursor = function() {
    throw new Error("not support method.");
  };
  /**
   * Server로 MultiPart 데이터를 전송할 때 파일을 설정 하는 함수로 클라이언트(Client) 파일의 절대경로를 설정한다.
   * @param {String} psFilePath Upload 대상 File Path
   * @return void
   * @type void
   */
  this.setUpLoadFileCtrls = function(psCtrlIds) {
    var vaCtrls = psCtrlIds.split(";");
    for(var i in vaCtrls){
      if(vaCtrls[i] == null) return;
      this.uploadFileCtrls.put(vaCtrls[i], vaCtrls[i]);
    }
  };

  this.getUpLoadCtrlsMap = function(){
    return this.uploadFileCtrls;
  };
  
  /**
   * 초기에 만들어진 해당 서브미션에 request-ref에 정보를 동적으로 삭제 할 때 사용한다.<br/>
   * 두번째 인자는 XPath를 넣으면 첫째 인자의 ID를 인스턴스의 아이디로 정하고 공문자열일 경우 DataSetID로 처리한다.
   * @param {String} psId 삭제할 request-ref에 등록한 InstanceID 또는 DataSetID
   * @param {String} psXPath 삭제할 reqeust-ref에 등록한 InstanceID에 XPath
   * @type void
   * @return void
   */
  this.removeRef = function(psId, psXPath) {
    var voRefs = this.getRefs();
    var vnSize = voRefs.length;
    var voRef ;
    for(var i = vnSize-1; i >= 0; i--){
      voRef = voRefs[i];
      if((voRef.getId() == psId) && (voRef.getPath() == psXPath)) {
        voRefs.splice(i, 1);
      }
    }
    
  };
    /**
   * 현재 Submission에 addCRUDString으로 설정 되어진 추가 정보를 초기화 하는 메소드.<br/>
   * add CRUDString만 하고 resetCRUDString을 사용하지 않으면 초기화 되지 않고 계속 서브미션을 수행 할 때 마다. 설정한 값이 전송 되어 진다.
   * @return void
   * @type void
   */
  this.resetCRUDString = function() {
    this.crudData = "";
  };
};

/**
 * @fileoverview
 * eXria.protocols.plugin package
 */
/**
 * eXria.protocols.plugin package
 * @author Choe, hyeon jong.
 * @version 1.0
 */

/**
 * eXria.protocols
 */
eXria.protocols.plugin = {};

/**
 * @fileoverview
 * Plugin Mode 사용시 서버와의 data통신 프로세스를 담당.
 */

/**
 * Plugin Mode 사용시 서버와의 data통신 프로세스를 담당.
 * @version 1.0
 * @param {String} psId Submission Id
 * @param {eXria.form.Model} poModel eXria.form.Model
 * @param {eXria.form.Submission} poSubmission Submission Object
 * @constructor
 * @base eXria.protocols.Submission
 */
eXria.protocols.plugin.Submission = function(psId, poModel, poSubmission) {
  eXria.protocols.Submission.call(this, psId, poModel);
  /**
   * id
   * @type String
   */
  this.id = psId;
  /**
   * Submission Object
   * @private
   */
  this.submission = poSubmission;
  /**
   * use decode
   * @return void
   * @type Number
   * @private
   */
  this.isEncodeData = false;
  try {
    this.isEncodeData = (this.model.plugin.getJREVersionNumber() >= 1.7 && this.model.page.metadata.browser.ie == 0);
  } catch(e) {
    this.isEncodeData = false;
  }
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다.<br/>
   * 이때 POST데이터는 Request Reference를 통해 생성되거나 Submission Tag의 Parameter를 통해 생성된다.
   * 이때 사용되는 HTTP request Parameter값을 추가적으로 입력하는 기능으로 <br/>
   * Key와 Value로 분리하여 입력한다. 복수개가 설정 가능하다.
   * @param {String} psName 추가할 Parameter 이름
   * @param {String} psValue 추가할 Parameter 값
   * @return void
   * @type void
   */
  this.addParameter = function(psName, psValue){
    this.submission.addParameter(psName, psValue);
  };
  /**
   * HttpRequest에 DataSet을 추가한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.addDataSetId = function(psId){
    if(!psId) return;
    this.submission.addDataSetId(psId);
  };
  /**
   * HttpRequest에 설정된 DataSet을 삭제한다.(Plugin Mode에서만 사용 가능)
   * @param {String} psId DataSet Id
   * @return void
   * @type void
   */
  this.removeDataSetId = function(psId){
    if(!psId) return;
    this.submission.removeDataSetId(psId);
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다.<br/>
   * 이때 POST데이터는 Request Reference를 통해 생성되거나 Submission Tag의 Parameter를 통해 생성된다.<br/>
   * 이 Request Reference를 추가하는 기능으로 Instance ID 와 Reference할 Node의 path 정보를<br/>
   * 추가적으로 입력한다. 복수개가 설정 가능하다.
   * @param {String} psId 값을 설정하기 위한 Instance Id
   * @param {String} psPath Node Path 정보
   * @return void
   * @type void
   */
  this.addRef = function(psId, psPath) {
    this.submission.appendRef(psId, psPath);
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다. 이때 POST데이터는 Request Reference를 통해<br/>
   * 생성되거나 Submission Tag의 Parameter를 통해 생성된다. 이 HTTP request Parameter값을 모두 지워주는 기능을 한다.
   * @return void
   * @type void
   */
  this.clearParameter = function() {
    this.submission.clearParameter();
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다. 이때 POST데이터는 Request Reference를 통해<br/>
   * 생성되거나 Submission Tag의 Parameter를 통해 생성된다.<br/>
   * 이 Request Reference을 모두 지워주는 기능을 한다.
   * @return void
   * @type void
   */
  this.clearRef = function() {
    this.submission.clearRef();
  };
  /**
   * PlugIn과 Server가 ASync통신할 때 송수신된 정보의 진행율을 표시할 수 있는 기능에 사용되어 지며<br/>
   * currentPos는 진행된 사이즈이며 LONG형의 수치값이 반환된다.
   * @return 현재 진행 값
   * @type void
   */
  this.getCurrentPos = function() {
    return this.submission.currentPos();
  };
  /**
   * HTTP통신시 Request Header에 전송될 정보를 반환 받는다.<br/>
   * Parameter로 입력한 Key값에 따른 값을 반환한다.
   * @param {String} psName 조회대상의 Header Name
   * @return 조회된 Header 문자열 값
   * @type String
   */
  this.getHeader = function(psName) {
    var vsHeader = this.submission.getHeader(psName);
    if(this.isEncodeData) {
      vsHeader = decodeURIComponent(vsHeader);
      if(vsHeader == "null") return null;
    }
    return vsHeader;
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다.<br/>
   * 이때 POST데이터는 Request Reference를 통해 생성되거나 Submission Tag의 Parameter를 통해 생성된다.<br/>
   * 이때 사용되는 HTTP request Parameter값을 입력한 Key값에 해당되는 Value를 반환한다.
   * @param {String} psName 조회 대상의 Parameter name
   * @return 조회된 Parameter 문자열 값
   * @type String
   */
  this.getParameter = function(psName) {
    var vsParam = this.submission.getParameter(psName);

    if(this.isEncodeData) {
      vsParam = decodeURIComponent(vsParam);
      if(vsParam == "null") return null;
    }

    return vsParam;
  };
  /**
   * Server와 통신후 반환된 HTTP Error Code를 반환
   * @return Number Type의 오류코드 숫자값
   * @type Number
   */
  this.getResultCode = function() {
    return this.submission.getResultCode();
  };
  /**
   * PlugIn과 Server가 HTTP ASync통신할 때 송수신된 정보의 진행율을 표시할 수 있는 기능에<br/>
   * 사용되어 지며 currentPos는 진행된 사이즈이며 maxPos는 수신될 데이터의 전체 크기이며 수치값이 반환된다.
   * @return 수신될 데이터의 전체 크기
   * @type Number
   */
  this.getMaxPos = function() {
    return this.submission.maxPos();
  };
  /**
   * PlugIn과 Server가 HTTP ASync통신할 때 현재 송수신된 데이터 크기의 수치값이 반환된다.
   * @return 현재 진행된 데이터의 크기
   * @type Number
   */
  this.currentPos = function() {
  return this.submission.currentPos();
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다.<br/>
   * 이때 POST데이터는 Request Reference를 통해 생성되거나 Submission Tag의 Parameter를 통해 생성된다.<br/>
   * 이 HTTP request Parameter값을 입력된 Key값에 해당되는 Parameter를 제거한다.
   * @param {String} psName 삭제대상의 Parameter Name
   * @return void
   * @type void
   */
  this.removeParameter = function(psName) {
    this.submission.removeParameter(psName);
  };
  /**
   * Submission Tag에 설정되어 있는 정보에 의해 송신 데이터를 서버로 송신하고 서버의 처리 결과를<br/>
   * 받아 Instance에 저장하는 기능을 담당하며 반환값은 성공과 실패인 Boolean값이 반환된다.
   * @return void
   * @type void
   */
  this.send = function() {
    if(this.isWaitCursor()) this.model.page.waitingSend = true;
    var vbSuccess = this.submission.send();
    this.model.page.waitingSend = false;
    if(vbSuccess == 0) {
      vbSuccess = false;
    } else {
      vbSuccess = true;
    }
    var voDefInstance = this.model.getInstance(this.model.plugin.getDefInstanceID());
    var voRedirectNode = voDefInstance.selectSingleNode("/root/EXRIAREDIRECT");
//    voDefInstance.print("/");
    if(voRedirectNode) {
      var vsPath = String(voRedirectNode.getNodeValue());
      if(vsPath != "") {
        vsPath = eXria.util.UrlUtil.getAbsoluteUrl(vsPath);
        this.model.page.open(vsPath);
      } else {
        return vbSuccess;
      }
    } else {
      return vbSuccess;
    }
  };
  /**
   * HTTP통신시 Request Header에 전송될 정보를 설정 한다.<br/>
   * Parameter는 Key와 Value의 쌍으로 입력한다. 복수개가 설정 가능하다.
   * @param {String} psName 설정 대상의 Header Name
   * @param {String} psValue 설정 할 Header Value
   * @return void
   * @type void
   */
  this.setHeader = function(psName, psValue) {
    this.submission.setHeader(psName, psValue);
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 POST데이터를 송신한다. <br/>
   * 이때 전송될 POST Data의 문자셑(Character Set)을 설정한다.
   * @param {String} psCharset 설정할 Character Set
   * @return void
   * @type void
   */
  this.setReqCharset = function(psCharset) {
    this.submission.setReqCharset(psCharset);
  };
  /**
   * PlugIn과 Server가 HTTP통신할 때 서버로부터 수신된 데이터의 문자셑(Character Set)을 설정한다.
   * @param {String} psCharset 설정할 Character Set
   * @return void
   * @type void
   */
  this.setResCharset = function(psCharset) {
    this.submission.setResCharset(psCharset);
  };
  /**
   * Submission 완료 후 서버로 부터 받은 결과를 붙일 Instance를 추가한다.
   * </br>plugin 사용시 Arguement와 상관 없이 Replace : True로 동작.<br/>
   * @param {String} psId instance id
   * @param {String} psPath instance path
   * @param {Boolean} pbReplace instance replace 여부 (Plugin 모드 사용시 생략 가능)
   * @return void
   * @type void
   */
  this.addResRef = function(psId, psPath, pbReplace) {
    if(!(pbReplace === true)) {
      pbReplace = false;
    }
    this.submission.setResponseRef(psId, psPath, pbReplace);
  };
  /**
   * Server로 MultiPart 데이터를 전송할 때 파일을 설정 하는 함수로 클라이언트(Client) 파일의 절대경로를 설정한다.
   * @param {String} psFilePath Upload 대상 File Path
   * @return void
   * @type void
   */
  this.setUpLoadFileNames = function(psFilePath) {
    this.submission.setUpLoadFileNames(psFilePath);
  };
  /**
   * 현재 Submission에 설정 되어진 action URL을 동적으로 변경 하고자 할 때 사용하는 메소드.
   * @param {String} psActionTarget 변경하고자 하는 URL
   * @return void
   * @type void
   */
  this.changeAction = function(psActionTarget) {
    this.submission.changeAction(psActionTarget);
  };
  /**
   * submission에 데이타셋 CRUD 문자열 정보를 추가시켜 주는 메소드
   * @param {String} psString 서브미션 전송 시 추가로 보내고자 하는 CRUD 데이터
   * @return void
   * @type void
   */
  this.addCRUDString = function(psString) {
    this.submission.addCRUDString(psString);
  };
  /**
   * 현재 Submission에 addCRUDString으로 설정 되어진 추가 정보를 초기화 하는 메소드.<br/>
   * add CRUDString만 하고 resetCRUDString을 사용하지 않으면 초기화 되지 않고 계속 서브미션을 수행 할 때 마다. 설정한 값이 전송 되어 진다.
   * @return void
   * @type void
   */
  this.resetCRUDString = function() {
    this.submission.resetCRUDString();
  };
  /**
   * 초기에 만들어진 해당 서브미션에 request-ref에 정보를 동적으로 삭제 할 때 사용한다.<br/>
   * 두번째 인자는 XPath를 넣으면 첫째 인자의 ID를 인스턴스의 아이디로 정하고 공문자열일 경우 DataSetID로 처리한다.
   * @param {String} psId 삭제할 request-ref에 등록한 InstanceID 또는 DataSetID
   * @param {String} psXPath 삭제할 reqeust-ref에 등록한 InstanceID에 XPath
   * @type void
   * @return void
   */
  this.removeRef = function(psId, psXPath) {
    if(psXPath == null) psXPath = "";
    this.submission.removeRef(psId, psXPath);
  };
  /**
   * 서브미션의 action Url 지정
   * @param {String} psUrl action target으로 지정될 url
   * @return void
   * @type void
   */
  this.setAction = function(psUrl) {
    this.submission.setAction(psUrl);
  };
  /**
   * 서브미션의 action target 반환
   * @return 서브미션의 action target
   * @type String
   */
  this.getAction = function() {
    return this.submission.getAction();
  };
  /**
   * Header Attribute 값을 리턴한다.
   * @param {String} psAttrName 리턴 받을 Attribute Name
   * @return Attribute Value
   * @type String
   * @return Attribute Value
   */
  this.getAttrStr = function(psAttrName) {
  return this.submission.getAttrStr(psAttrName);
  };
  /**
   * Header Attribute 값을 설정한다. 만약 해당 Attribute가 있다면 해당 값으로 덮어씌운다.
   * @param {String} psAttrName 설정 Attribute Name
   * @param {String} psValue 설정할 Attribute 값
   * @type void
   * @return void
   */
  this.setAttrStr = function(psAttrName, psValue) {
  this.submission.setAttrStr(psAttrName, psValue);
  };
  /**
   * Header의 Content-type을 재설정한다.
   * @type void
   * @return void
   */
  this.initReqType = function() {
  this.submission.initReqType();
  };
  /**
   * Submission에서 서버로 보낼 데이터를 리턴한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @return Submission Send 시 서버로 보낼 데이터 문자열
   * @type String
   */
  this.getSubmitData = function() {
    return this.submission.getSubmitData();
  };
  /**
   * 파라미터로 넘어온 문자열을 Submission의 Response Ref에 지정한 Node에 바인딩 한다.<br/>(Plugin Mode 에서만 사용 가능)
   * @param {String} psData 바인딩하고자 하는 데이터 문자열
   * @type void
   * @return void
   */
  this.bindUserData = function(psData) {
    if(!psData || psData == "") return;
    this.submission.bindUserData(psData);
  };
  /**
   * 파라미터로 넘어온 데이터를 서버로 보낸다.<br/>
   * 해당 메소드를 사용할 경우 Submission에 바인딩 된 Request 데이터는 모두 무시 되며<br/>
   * 오로지 파라미터로 넘긴 문자열에 대해서만 처리한다.<br/>
   * 또한 서버로부터 내려온 데이터는 인스턴스에 바인딩 되지 않으며 문자열로 리턴 된다.<br/>
   * (Plugin Mode 에서만 사용 가능)
   * @param psData 서버로 보낼 데이터 문자열
   * @type String
   * @return 서버로부터 내려온 데이터 문자열
   */
  this.sendUserData = function(psData) {
    return this.submission.sendUserData(psData);
  };
  /**
   * Response Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Response Reference 문자열
   */
  this.getResponseRefString = function() {
    return this.submission.getResponseRefString();
  };
  /**
   * Request Reference를 String 형태로 리턴한다.<br/>
   * (ex. instaceId:XPath;instanceId2:XPath;)
   * @type String
   * @return Request Reference 문자열
   */
  this.getRequestRefString = function() {
    return this.submission.getRequestRefString();
  };
  /**
   * Request Parameter의 Key를 String 형태로 리턴한다.<br/>
   * (ex. ParamKey1,ParamKey2,ParamKey3)
   * @type String
   * @return Request Parameter Key 문자열
   */
  this.getParameterKeyString = function() {
    return this.submission.getParameterKeyString();
  };
  /**
   * Request CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getReqCharSet = function() {
    return this.submission.getReqCharSet();
  };
  /**
   * Response CharSet을 리턴한다.<br/>
   * @type String
   * @return Request CharSet
   */
  this.getResCharSet = function() {
    return this.submission.getResCharSet();
  };
  /**
   * Request DataSet의 ID를 String 형태로 리턴한다.<br/>
   * (ex. dst1,dst2,dst3)
   * @type String
   * @return Request DataSet의 ID 문자열
   */
  this.getDataSetIdString = function() {
    return this.submission.getDataSetIdString();
  };
  /**
   * Request Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Request Protocol Type에 해당하는 문자열
   */
  this.getReqType = function() {
    return this.submission.getReqType();
  };
  /**
   * Response Protocol Type을 String 형태로 리턴한다.<br/>
   * (ex. zip;base64)
   * @type String
   * @return  Response Protocol Type에 해당하는 문자열
   */
  this.getResType = function() {
    return this.submission.getResType();
  };
  /**
   * Request Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Request Protocol Type
   * @type void
   * @return void
   */
  this.setReqType = function(psResType) {
    this.submission.setReqType(psResType);
  };
  /**
   * Response Protocol Type을 지정한다.<br/>
   * (ex. zip;base64)
   * @param {String} psResType Response Protocol Type
   * @type void
   * @return void
   */
  this.setResType = function(psResType) {
    this.submission.setResType(psResType);
  };

  /**
   * request protocol을 셋팅한다.<br/>
   * @param {String} psReqProtocol request protocol
   * @return void
   * @type void
   */
  this.setReqProtocol = function(psReqProtocol) {
    this.submission.setReqProtocol(psReqProtocol);
  };
  /**
   * request protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getReqProtocol = function() {
    return this.submission.getReqProtocol();
  };
  /**
   * response protocol을 셋팅한다.<br/>
   * @param {String} psResProtocol response protocol
   * @return void
   * @type void
   */
  this.setResProtocol = function(psResProtocol) {
    this.submission.setResProtocol(psResProtocol);
  };
  /**
   * response protocol을 리턴한다.
   * @type {String}
   * @return request protocol
   */
  this.getResProtocol = function() {
    return this.submission.getResProtocol();
  };
  /**
   * wait cursor 사용 유무를 리턴한다.
   * @return wait cusor 사용 유무
   * @type Boolean
   */
  this.isWaitCursor = function() {
    return this.submission.isWaitCursor();
  }
};

/**
 * @fileoverview
 * eXria.protocols.json package
 */
/**
 * eXria.protocols.json package
 * @version 1.0
 */

/**
 * eXria.protocols
 */
eXria.protocols.json = {};

/**
 * @fileoverview
 * URLEncodingBuilder
 */
/**
 * URLEncodingBuilder
 * @version 1.0
 * @param {eXria.protocols.Submission} poSubmission Submission Object
 * @base eXria.protocols.RequestBuilder
 * @constructor
 * @private
 */
eXria.protocols.json.URLEncodingBuilder = function(poSubmission) {
  eXria.protocols.RequestBuilder.call(this, poSubmission);

  this.build = function() {
    //request data 생성
    var voData = new eXria.lang.StringBuilder();
    var vaValue;
    for(var vsName in this.submission.parameters.entries) {
      vaValue = this.submission.getParameter(vsName);
      for(var i = 0; i < vaValue.length; i++) {
        voData.append(encodeURIComponent(vsName));     //encode
        voData.append("=");
        voData.append(encodeURIComponent(vaValue[i])); //encode
        voData.append("&");
      }
    }

    //requestRef
    var voRefs = this.submission.getRefs();
    var voRef;
    for(var i = 0; i < voRefs.length; i++) {
      voRef = voRefs[i];
      var viInstance = this.submission.model.getInstance(voRef.getId());
      if(viInstance) {

        voData.append(this.buildInstance2Param(viInstance, voRef.getPath()));
      }
    }

    //encoding setting
    //AJAX는 utf-8로 통신한다.
    this.submission.encoding = "utf-8";
    //submit
    return this.submission.sendAction(voData.toString());
  };

  this.buildInstance2Param = function(poInstance, psPath) {
    var voNodeList = poInstance.selectNodes(psPath, true);
    var vsRootNodeName = psPath;
    if(vsRootNodeName.substring(vsRootNodeName.length - 1) == "/") {
      vsRootNodeName = vsRootNodeName.substring(0, vsRootNodeName.length - 1);
    }
    if(vsRootNodeName.indexOf("/") > -1) {
      vsRootNodeName = vsRootNodeName.substring(vsRootNodeName.lastIndexOf("/") + 1);
    }
    if(voNodeList && voNodeList.getLength() > 0) {
      var voParam = new eXria.lang.StringBuilder();
      var vnNodeSize = voNodeList.getLength();
      var voNode;
      var vsId;
      for(var i = 0; i < vnNodeSize; i++) {
        voNode = voNodeList.item(i);
        if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
        } else if(voNode.getNodeType() == 3 || voNode.getNodeType() == 4) { //TEXT or CDATA Section
          vsId = vsRootNodeName;
          if(typeof(vsId) != "string") vsId = voNodeList.name;
          voParam.append(vsId);
          voParam.append("=");
          voParam.append(encodeURIComponent(voNode.getNodeValue())); //encode
          voParam.append("&");
        }
      }
      return voParam.toString();
    } else {
      return "";
    }
  };

  this.buildElement2Param = function(poNode) {
    var voParam = new eXria.lang.StringBuilder();
    var voNode = poNode;
    var voWhiteSpace = /\S/;

    var voNodeList = poNode.getChildNodes();
    if(voNodeList && voNodeList.getLength() > 0) {
      var vsId = null;
      for(var i = 0; i < voNodeList.getLength(); i++) {
        voNode = voNodeList.item(i);

        if(eXria.protocols.json.ReservedType[voNode.getNodeName()] != "") {
          if(voNode.getNodeType() == 1) {
          voParam.append(this.buildElement2Param(voNode)); //TODO
          } else if((voNode.getNodeType() == 3 || voNode.getNodeType() == 4)) { //TEXT or CDATA Section
//          voParam.append(poNode.getNodeName());
            vsId = poNode.getNodeName();
            if(typeof(vsId) != "string") vsId = voNodeList.name;
            if(voWhiteSpace.test(voNode.getNodeValue())) {
              voParam.append(vsId);
              voParam.append("=");
              voParam.append(encodeURIComponent(voNode.getNodeValue())); //encode
              voParam.append("&");
            } else {
              voParam.append(vsId);
              voParam.append("=");
              voParam.append("&");
            }
          }
        }
      }
    } else {
//      voParam.append(poNode.getNodeName());
      voParam.append(voNode.getNodeName());
      voParam.append("=");
      voParam.append("&");
    }

    return voParam.toString();
  };
};
/**
 * @fileoverview
 * JSON buildElement2Param 시 제외할 타입의 상수 클래스</br>
 * enum list</br>
 * - eXria.protocols.json.ReservedType.PARENT : JSON Instance 생성시 사용되어지는 예약어</br>
 * - eXria.protocols.json.ReservedType.NODENAME : JSON Instance 생성시 사용되어지는 예약어</br>
 */
/**
 * JSON buildElement2Param 시 제외할 타입의 상수 클래스
 * @author
 * @version 1.0
 * @constructor
 */
eXria.protocols.json.ReservedType = {
  parent : "parent",
  nodeName : "nodeName"
};
/**
 * @fileoverview
 * Concreate xhtml package
 * @author 김경태
 * @version 2.0
 */

/**
 * eXria.controls.xhtml package
 */
eXria.controls.xhtml = {};


/**
 * @fileoverview
 * XHTML Util
 * @author Youngjin Cho
 */

/**
 * XHTML Util
 * @version 2.0
 * @type eXria.controls.xhtml.Util
 * @constructor
 */
eXria.controls.xhtml.Util = {
  createInheritance : function(parentClass, childClass) {
    var parentProto = parentClass.prototype;
    var childProto = childClass.prototype;
    var psAttr = null;
    for(psAttr in parentProto) {
      childProto[psAttr] = parentProto[psAttr];
    }
  },
  // 조영진선임 전달받은 내용 : map에 $로 시작되는 keycode를 정의해서 그 값을 eval처리하여
  // 다국어 지원하기로 되어있었는데 현재 그렇게 처리할 경우는 없는 걸로 결론 지었음.
  // TODO : 향후 컨트롤별 사용되는 곳을 찾아서 지워줘야 함
  parseLang : function(psStr) {
    var vsRet = psStr;
    if(vsRet != null) {
      vsRet = "" + vsRet;
      if(vsRet.indexOf('$') == 0) {
        vsRet = vsRet.substring(1);
        try { vsRet = eval(vsRet); } catch(err) { return psStr; }
      }
    }
    if(vsRet == null) vsRet = psStr;
    return vsRet;
  },

  /**
   * 웹 페이지에 로딩된 지정된 클래스명을 포함한 css 파일의 경로 반환
   * @param {String} psClassName 지정된 클래스명
   * @param {HTMLDocument} poDocument css 파일을 로딩 한 Document
   * @return css 파일의 경로
   * @type String
   */
  getCssRef : function(psClassName, poDocument) {
    if(psClassName == null) return null;
    var vsCssRef = null;
    var bBreak = false;
    var vaClassName = psClassName.split(" ");
    for (var s = 0; s < poDocument.styleSheets.length; s++) {
      if (vaClassName.length >= 2) {
        for(var i = 1; i < vaClassName.length; i++) {
          if(vaClassName[i].substring(0, 1) != ".") vaClassName[i] = vaClassName[i].toUpperCase();
        }
        psClassName = vaClassName.join(" ");
      }
      try {
        if(poDocument.styleSheets[s].rules) {                       // IE와 Safari
          for(var r = 0; r < poDocument.styleSheets[s].rules.length; r++) {
            if (poDocument.styleSheets[s].rules[r].selectorText == '.' + psClassName) {
              vsCssRef = poDocument.styleSheets[s].href
              bBreak = true;
              break;
            }
          }
        }
        else if(poDocument.styleSheets[s].cssRules) {               // FireFox와 Opera
          if(vaClassName.length >= 2) {
            for(var i = 1; i < vaClassName.length; i++) {
              if(vaClassName[i].substring(0, 1) != ".") vaClassName[i] = vaClassName[i].toLowerCase();
            }
            psClassName = vaClassName.join(" ");
          }
          for (var r = 0; r < poDocument.styleSheets[s].cssRules.length; r++) {
            if (poDocument.styleSheets[s].cssRules[r].selectorText == '.' + psClassName) {
              vsCssRef = poDocument.styleSheets[s].href;
              bBreak = true;
              break;
            }
          }
        }
      } catch(err) {}
      if(bBreak) break;
    }
    return vsCssRef;
  },
  /**
   * @private
   */
  convertImagePathToXrf : function(psClassName, psCssImage, poDocument) {
    if(psCssImage == null || psCssImage == "") return psCssImage;
    var vsPath = psCssImage.replace(/(url\()/, "");
    vsPath = vsPath.replace(/\"/gi, "");
    //vsPath = this.df.backgroundImage.replace(/(\)$)/, "");
    if(vsPath.indexOf("http://") == 0) return psCssImage;
    if(vsPath.indexOf("/") == 0) return psCssImage;
    var vaRef = this.getCssRef(psClassName, poDocument).split("/");
    vaRef.splice(vaRef.length - 1, 1);
    var vsParentPath = vaRef.join("/");
    if(vsParentPath != "") vsParentPath += "/";
    vsPath = vsParentPath + vsPath;
    vsPath = "url(" + vsPath;
    return vsPath;
  },

  /**
   * @ignore
   */
  getBackgroundImagePath : function(psPath, poWindow) {
    if(psPath == null || psPath == "" || psPath == "none") return "";
    psPath = psPath.replace(/\'/gi, "");
    var vsGlobalContextPath = page.globalContextPath;
    if(vsGlobalContextPath) {
      psPath = psPath.replace(new RegExp("^" + vsGlobalContextPath), "/");
    }
    var vsBaseUrl = poWindow.page.metadata.resourceBaseUrl;
    if((psPath.indexOf("/") == 0 && psPath.indexOf(vsBaseUrl) != 0) || psPath.indexOf(".") == -1) psPath = vsBaseUrl + psPath.substring(1);
    if(psPath.indexOf("url(") == -1) psPath = "url(" + psPath + ")";

    return psPath;
  },

  /**
   * @ignore
   */
  getImagePath : function(psPath, poWindow) {
    if(psPath == null || psPath == "") return "";
    else if(psPath == "none") return psPath;
    var vsGlobalContextPath = page.globalContextPath;
    if(vsGlobalContextPath) {
      psPath = psPath.replace(new RegExp("^" + vsGlobalContextPath), "/");
    }
    psPath = psPath.replace(/\'/gi, "");
    if(psPath.indexOf("http://") == 0 || psPath.indexOf(".") == 0) return psPath;
    var vsBaseUrl = poWindow.page.metadata.resourceBaseUrl;
    if(psPath.indexOf("/") == 0 && psPath.indexOf(vsBaseUrl) != 0) psPath = vsBaseUrl + psPath.substring(1);

    return psPath;
  },

  /**
   * @ignore
   */
  getAttrToApply : function(psAttrName, poObject, poCssStyle) {
    var vsAttrValue = null;
    var vaAttrName = psAttrName.split(".");
    var voAttr = poObject;
    for(var i = 0; i < vaAttrName.length; i++) {
      voAttr = voAttr[vaAttrName[i]];
    }
    vsAttrValue = voAttr;
    if(vsAttrValue != null) return vsAttrValue;

    if(vsAttrValue == null) {
      if(poCssStyle) vsAttrValue = poCssStyle[vaAttrName[vaAttrName.length - 1]];
    }
    if(vsAttrValue == null || vsAttrValue == "") {
      if(poObject.getSpecificDefaultValue) vsAttrValue = poObject.getSpecificDefaultValue(psAttrName);
    }
    return vsAttrValue;
  },

  /**
   * @ignore
   */
  getTemplateIndexMap : function(paTemplate) {
    var voArrayMap = new eXria.data.ArrayMap();
    var vnIndex = 0;
    for(var i = 0; i < paTemplate.length; i++) {
      if(typeof paTemplate[i] == "string") {
        var t = paTemplate[i].indexOf("@");
        if(paTemplate[i].indexOf("@") == 0) voArrayMap.put(vnIndex++, i);
      }
    }
    return voArrayMap;
  },

  /**
   * @ignore
   */
  getXmlString : function(psStr) {
    if(psStr == null) return null;
    var vsStr = psStr.replace(/\&/g,"&amp;").replace(/\</g,"&lt;").replace(/"/g,"&quot;").replace(/\n/g,"&#x0A;");
    return vsStr;
  },
  /*
  //IE 6.0 이하 투명 png 처리 Method
  //template_xhtml.xml 에 이하 스타일 추가 필요
  <style>
  .png24 {
    tmp:expression(eXria.controls.xhtml.Util.setPng(this));
  }
  </style>

  setPng : function(poImg) {
    poImg.width=poImg.height=1;
    poImg.className=poImg.className.replace(/\bpng24\b/i,'');
    poImg.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + poImg.src + "',sizingMethod='image');";
    poImg.src='';
    return '';
  }
  */


  //2009-04-06 ehj
  colorNames : {
      ALICEBLUE            : "#F0F8FF"
      , ANTIQUEWHITE         : "#FAEBD7"
      , AQUA                 : "#00FFFF"
      , AQUAMARINE           : "#7FFFD4"
      , AZURE                : "#F0FFFF"
      , BEIGE                : "#F5F5DC"
      , BISQUE               : "#FFE4C4"
      , BLACK                : "#000000"
      , BLANCHEDALMOND       : "#FFEBCD"
      , BLUE                 : "#0000FF"
      , BLUEVIOLET           : "#8A2BE2"
      , BROWN                : "#A52A2A"
      , BURLYWOOD            : "#DEB887"
      , CADETBLUE            : "#5F9EA0"
      , CHARTREUSE           : "#7FFF00"
      , CHOCOLATE            : "#D2691E"
      , CORAL                : "#FF7F50"
      , CORNFLOWERBLUE       : "#6495ED"
      , CORNSILK             : "#FFF8DC"
      , CRIMSON              : "#DC143C"
      , CYAN                 : "#00FFFF"
      , DARKBLUE             : "#00008B"
      , DARKCYAN             : "#008B8B"
      , DARKGOLDENROD        : "#B8860B"
      , DARKGRAY             : "#A9A9A9"
      , DARKGREEN            : "#006400"
      , DARKKHAKI            : "#BDB76B"
      , DARKMAGENTA          : "#8B008B"
      , DARKOLIVEGREEN       : "#556B2F"
      , DARKORANGE           : "#FF8C00"
      , DARKORCHID           : "#9932CC"
      , DARKRED              : "#8B0000"
      , DARKSALMON           : "#E9967A"
      , DARKSEAGREEN         : "#8FBC8F"
      , DARKSLATEBLUE        : "#483D8B"
      , DARKSLATEGRAY        : "#2F4F4F"
      , DARKTURQUOISE        : "#00CED1"
      , DARKVIOLET           : "#9400D3"
      , DEEPPINK             : "#FF1493"
      , DEEPSKYBLUE          : "#00BFFF"
      , DIMGRAY              : "#696969"
      , DODGERBLUE           : "#1E90FF"
      , FIREBRICK            : "#B22222"
      , FLORALWHITE          : "#FFFAF0"
      , FORESTGREEN          : "#228B22"
      , FUCHSIA              : "#FF00FF"
      , GAINSBORO            : "#DCDCDC"
      , GHOSTWHITE           : "#F8F8FF"
      , GOLD                 : "#FFD700"
      , GOLDENROD            : "#DAA520"
      , GRAY                 : "#808080"
      , GREEN                : "#008000"
      , GREENYELLOW          : "#ADFF2F"
      , HONEYDEW             : "#F0FFF0"
      , HOTPINK              : "#FF69B4"
      , INDIANRED            : "#CD5C5C"
      , INDIGO               : "#4B0082"
      , IVORY                : "#FFFFF0"
      , KHAKI                : "#F0E68C"
      , LAVENDER             : "#E6E6FA"
      , LAVENDERBLUSH        : "#FFF0F5"
      , LAWNGREEN            : "#7CFC00"
      , LEMONCHIFFON         : "#FFFACD"
      , LIGHTBLUE            : "#ADD8E6"
      , LIGHTCORAL           : "#F08080"
      , LIGHTCYAN            : "#E0FFFF"
      , LIGHTGOLDENRODYELLOW : "#FAFAD2"
      , LIGHTGREY            : "#D3D3D3"
      , LIGHTGREEN           : "#90EE90"
      , LIGHTPINK            : "#FFB6C1"
      , LIGHTSALMON          : "#FFA07A"
      , LIGHTSEAGREEN        : "#20B2AA"
      , LIGHTSKYBLUE         : "#87CEFA"
      , LIGHTSLATEGRAY       : "#778899"
      , LIGHTSTEELBLUE       : "#B0C4DE"
      , LIGHTYELLOW          : "#FFFFE0"
      , LIME                 : "#00FF00"
      , LIMEGREEN            : "#32CD32"
      , LINEN                : "#FAF0E6"
      , MAGENTA              : "#FF00FF"
      , MAROON               : "#800000"
      , MEDIUMAQUAMARINE     : "#66CDAA"
      , MEDIUMBLUE           : "#0000CD"
      , MEDIUMORCHID         : "#BA55D3"
      , MEDIUMPURPLE         : "#9370D8"
      , MEDIUMSEAGREEN       : "#3CB371"
      , MEDIUMSLATEBLUE      : "#7B68EE"
      , MEDIUMSPRINGGREEN    : "#00FA9A"
      , MEDIUMTURQUOISE      : "#48D1CC"
      , MEDIUMVIOLETRED      : "#C71585"
      , MIDNIGHTBLUE         : "#191970"
      , MINTCREAM            : "#F5FFFA"
      , MISTYROSE            : "#FFE4E1"
      , MOCCASIN             : "#FFE4B5"
      , NAVAJOWHITE          : "#FFDEAD"
      , NAVY                 : "#000080"
      , OLDLACE              : "#FDF5E6"
      , OLIVE                : "#808000"
      , OLIVEDRAB            : "#6B8E23"
      , ORANGE               : "#FFA500"
      , ORANGERED            : "#FF4500"
      , ORCHID               : "#DA70D6"
      , PALEGOLDENROD        : "#EEE8AA"
      , PALEGREEN            : "#98FB98"
      , PALETURQUOISE        : "#AFEEEE"
      , PALEVIOLETRED        : "#D87093"
      , PAPAYAWHIP           : "#FFEFD5"
      , PEACHPUFF            : "#FFDAB9"
      , PERU                 : "#CD853F"
      , PINK                 : "#FFC0CB"
      , PLUM                 : "#DDA0DD"
      , POWDERBLUE           : "#B0E0E6"
      , PURPLE               : "#800080"
      , RED                  : "#FF0000"
      , ROSYBROWN            : "#BC8F8F"
      , ROYALBLUE            : "#4169E1"
      , SADDLEBROWN          : "#8B4513"
      , SALMON               : "#FA8072"
      , SANDYBROWN           : "#F4A460"
      , SEAGREEN             : "#2E8B57"
      , SEASHELL             : "#FFF5EE"
      , SIENNA               : "#A0522D"
      , SILVER               : "#C0C0C0"
      , SKYBLUE              : "#87CEEB"
      , SLATEBLUE            : "#6A5ACD"
      , SLATEGRAY            : "#708090"
      , SNOW                 : "#FFFAFA"
      , SPRINGGREEN          : "#00FF7F"
      , STEELBLUE            : "#4682B4"
      , TAN                  : "#D2B48C"
      , TEAL                 : "#008080"
      , THISTLE              : "#D8BFD8"
      , TOMATO               : "#FF6347"
      , TURQUOISE            : "#40E0D0"
      , VIOLET               : "#EE82EE"
      , WHEAT                : "#F5DEB3"
      , WHITE                : "#FFFFFF"
      , WHITESMOKE           : "#F5F5F5"
      , YELLOW               : "#FFFF00"
      , YELLOWGREEN          : "#9ACD32"

  },

   /**
   * getColor(psColorName);
   * ex) eXria.controls.xhtml.Util.getColor("Red"); -> "#FF0000"
   */
  getColor : function(psColorName) {
  var vsColorName = psColorName.toUpperCase();
  var vsColor = (this.colorNames[vsColorName] == undefined) ? psColorName : this.colorNames[vsColorName];
    return vsColor;
  },

 /**
  * 색상정보 조회(16진수)
  * @param {Number} psRed 16진수로 변환될 Red 10진수 || 'rgb(###,###,###)'형태의 컬러 값 || '#FFFFFF'/'FFFFFF'형태의 16진수 컬러값
  * @param {Number} psRed 16진수로 변환될 Green 10진수. psRed가 10진수가 아닐 경우에는 null로 할당 할 것.
  * @param {Number} psRed 16진수로 변환될 Blue 10진수. psRed가 10진수가 아닐 경우에는 null로 할당 할 것.
  * @return '#FFFFFF' 형태의 6자리 16진수로 표현된 컬러 값
  * @type String
  */
  getRGBToHex : function(psRed, psGreen, psBlue) {
    if(typeof(psRed) == "string" && psGreen == null && psBlue == null) {
      if(/#?[a-zA-Z0-9]{6}/.test(psRed)) {
        if(psRed.indexOf("#") == -1) return psRed = "#" + psRed;
        return psRed;
      } else {
        var vaRgb = psRed.replace(/[^0-9,]/g, "");
        var vaRgb = vaRgb.split(",");
        if(vaRgb[0] != null) psRed = parseInt(vaRgb[0]);
        if(vaRgb[1] != null) psGreen = parseInt(vaRgb[1]);
        if(vaRgb[2] != null) psBlue = parseInt(vaRgb[2]);
      }
    }
    var vsR = (psRed < 0 || isNaN(psRed)) ? 0 : ((psRed > 255) ? 255 : psRed);
    var vsB = (psBlue < 0 || isNaN(psBlue)) ? 0 : ((psBlue > 255) ? 255 : psBlue);
    var vsG = (psGreen < 0 || isNaN(psGreen)) ? 0 : ((psGreen > 255) ? 255 : psGreen);

    vsR = vsR.toString(16);
    vsG = vsG.toString(16);
    vsB = vsB.toString(16);

    if (vsR.length == 1) vsR = '0' + vsR;
    if (vsG.length == 1) vsG = '0' + vsG;
    if (vsB.length == 1) vsB = '0' + vsB;

    return '#' + vsR + vsG + vsB;
  },

  /**
   * getPage(psId)
   */
  getPage : function(psId, poWindow) {
    if(poWindow == null) poWindow = window.top;
    var voDocument = poWindow.document;
    var voFrames = voDocument.getElementsByTagName("frame");
    var vnLen = voFrames.length;
    var voFrame = null;
    var voWindow = null;
    var voPage =  null;
    for(var i = 0; i < vnLen; i++) {
      voFrame = voFrames[i];
      voWindow = voFrame.contentWindow;
      if(voWindow) {
        voPage = voWindow.page;
        if(voPage) {
          if(voPage.id == psId) return voPage;
          voPage = null;
        } else {
          voPage = this.getPage(psId, voWindow);
        }
        if(voPage) return voPage;
      }
    }
    voFrames = voDocument.getElementsByTagName("iframe");
    vnLen = voFrames.length;
    for(var i = 0; i < vnLen; i++) {
      voFrame = voFrames[i];
      voWindow = voFrame.contentWindow;
      if(voWindow) {
        voPage = voWindow.page;
        if(voPage) {
          if(voPage.id == psId) return voPage;
          voPage = null;
        } else {
          voPage = this.getPage(psId, voWindow)
        }
        if(voPage) return voPage;
      }
    }
    return null;
  },

    /**
     * css를 동적으로 로드한다.
     * @param {String} psCSSFilePath 경로가 포함된 로딩될 CSS
     * @return {boolean}
     * @type String
     */
    loadCSSFile: function(psCSSFilePath){
        var voRtnVal = false
        var poWindow = window;
        var voDocument = poWindow.document;
        var voDocumentElement = voDocument.documentElement;
        var voLink = voDocument.documentElement.getElementsByTagName("link");

        if (!!psCSSFilePath) {
            for (var i = 0; i < voLink.length; i++) {
                if (voLink[i].rel.toLowerCase() == "stylesheet" && voLink[i].href && voLink[i].href.indexOf(psCSSFilePath) >= 0)
                    break;
            }

            //TODO : CSS 파일 존재 여부 확인 로직추가
            if (true) {
                var voCreateElement = voDocument.createElement("link");
                voCreateElement.href = psCSSFilePath;
                voCreateElement.rel = "Stylesheet";
                voCreateElement.type = "text/css"

                var voHead = voDocumentElement.getElementsByTagName("head")[0];
                if (!voHead) {
                    voHead = voDocument.createElement("head");
                    voDocumentElement.insertBefore(voHead, voDocument.body);
                }
                voHead.insertBefore(voCreateElement, voHead.firstChild);
                voRtnVal = true;
            }

        }
        return voRtnVal;
    },

    /**
     * XML 로딩
     * @param {String} psXML 경로가 포함된 로딩될 xml
     * @return {XML DOM object}
     * @type String
     */
    loadXML: function(psXML){
        var voRtnVal = {
            xmlDox: null,
            success: false
        };

        var voXHTTP = eXria.form.xhtml.HttpRequestFactory.create();

        //TODO : XML파일 존재 여부 확인 로직 추가 및 String 형태의 XML을 받을수 있게 수정
        if (psXML) {
            voXHTTP.open("GET", psXML, false);
            voXHTTP.send(null);
            voRtnVal.xmlDox = voXHTTP.responseXML;
            voRtnVal.success = true;
        }
        else {
            voRtnVal.success = false;
        }

        return voRtnVal;
    },

    /**
     * DEFALUT LOCALE 정보 로딩
     */
    getDefaultLocale: function(){

        var poWindow = window;
        var vsLocale = "kor";

        if (poWindow.page.metadata.useMultilingual != null && poWindow.page.metadata.language != null) {
            if (poWindow.page.metadata.useMultilingual == true) {
                var vsDefaultLocale = poWindow.page.metadata.eXriaLocale.toUpperCase();
                if (vsDefaultLocale == "KO_KR")
                    vsLocale = "kor";
                else
                    if (vsDefaultLocale == "JA_JP")
                        vsLocale = "jpn";
                    else
                        if (vsDefaultLocale.search(/ZH/) != -1)
                            vsLocale = "chn";
                        else
                            vsLocale = "eng";
            }
            else {
                if (poWindow.page.metadata.language.toUpperCase() == "KO")
                    vsLocale = "kor";
                else
                    vsLocale = "eng";
            }
        }
        return vsLocale;
    },

  /**
   *
   * @param {String, String}
   * @return {String}
   * @type String
   */
  getValueFromInputMode : function(psData, psInputMode) {
    if (!psData) return psData;
    if (!psInputMode) return psData;
    var vsReturnValue = "";
    var vsRegType = "";

    switch (psInputMode) {
      case "uppercase" :
      vsReturnValue = psData.toUpperCase();
      break;
      case "lowercase" :
      vsReturnValue = psData.toLowerCase();
      break;
      case "number" :
      vsRegType = /^[+-]?\d*(\.?\d*)$/;
      vsReturnValue = psData.match(vsRegType);
      if(!vsReturnValue) vsReturnValue = "";
      else vsReturnValue = vsReturnValue[0];
      break;
      case "alpha" :
      vsRegType = /[^\sA-Za-z._$-]/gi;
      vsReturnValue = psData.replace(vsRegType, '');
      break;
      case "alphanumeric" :
     vsRegType = /[^\sA-Za-z0-9._$-]/gi;
      vsReturnValue = psData.replace(vsRegType, '');
      break;
    }

    return vsReturnValue;
  },
  escapeJSONChar : function(pcChar) {
    if(pcChar == "\"" || pcChar == "\\") return "\\" + pcChar;
    else if(pcChar == "\b") return "\\b";
    else if(pcChar == "\f") return "\\f";
    else if(pcChar == "\n") return "\\n";
    else if(pcChar == "\r") return "\\r";
    else if(pcChar == "\t") return "\\t";
    var hex = pcChar.charCodeAt(0).toString(16);
    if(hex.length == 1) return "\\u000" + hex;
    else if(hex.length == 2) return "\\u00" + hex;
    else if(hex.length == 3) return "\\u0" + hex;
    else return "\\u" + hex;
  },
  escapeJSONString : function(psString) {
    //Rather inefficient way to do it
    var parts = psString.split("");
    for(var i = 0; i < parts.length; i++) {
      var c =parts[i];
      if(c == '"' || c == '\\' || c.charCodeAt(0) < 32 || c.charCodeAt(0) >= 128) {
        parts[i] = this.escapeJSONChar(parts[i]);
      }
    }
    return "\"" + parts.join("") + "\"";
  },
  toJSONString : function(poNodeObj) {
    var voNode = poNodeObj;
    if(poNodeObj instanceof eXria.data.json.Node || poNodeObj instanceof eXria.data.xhtml.Node) voNode = poNodeObj.node;

    if(voNode == null) {
      return "null";
    } else if(voNode.constructor == String) {
      return this.escapeJSONString(voNode);
    } else if(voNode.constructor == Number) {
      return voNode.toString();
    } else if(voNode.constructor == Boolean) {
      return voNode.toString();
    } else if(voNode.constructor == Date) {
      return '{javaClass: "java.util.Date", time: ' + voNode.valueOf() +'}';
    } else if(voNode.constructor == Array) {
      var v = [];
      for(var i = 0; i < voNode.length; i++) {
        v.push(this.toJSONString(voNode[i]));
      }
      return "[" + v.join(", ") + "]";
    } else {
      var v = [];
      for (attr in voNode) {
        if (voNode [attr] == null) {
          v.push("\"" + attr + "\": null");
        }else if (typeof voNode [attr] == "function" || eXria.protocols.json.ReservedType[attr]) {
          // TODO function일 경우도 파싱
          // skip
        } else {
          v.push(this.escapeJSONString(attr) + ": " + this.toJSONString(voNode [attr]));
        }
      }
      var vsStr = v.join(", ");
      if (!vsStr) return "\"\"";
      else return "{" + v.join(", ") + "}";
    }
  }

};

function getScrollBarWidth() {
  var inner = document.createElement('p');
  inner.style.width = "100%";
  inner.style.height = "200px";

  var outer = document.createElement('div');
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.appendChild (inner);

  document.body.appendChild (outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 == w2) w2 = outer.clientWidth;

  document.body.removeChild (outer);

  return (w1 - w2);
};

/**
* 폼엘리먼트의 value 가 변화되면 keyup 이벤트 발생시키기
* [출처] 모질라계열(파이어폭스 등)에서 한글 입력시에 onKeyUp 이벤트 잡기 흉내|작성자 지멋대루
* @author hooriza at nhncorp.com
* @version 0.1
*
* @created Nov.8.2007.
*/

var Observe = function(oEl) {
  this._o = oEl;
  this._value = oEl.value;
  this._bindEvents();

};

Observe.prototype._bindEvents = function() {
  var cnt = 0;
  var cnt2 = 0;
  var self = this;
  var bind = function(oEl, sEvent, pHandler) {
    if (oEl.attachEvent) oEl.attachEvent('on' + sEvent, pHandler);
    else oEl.addEventListener(sEvent, pHandler, false);
  };

  bind(this._o, 'focus', function() {
    if (self._timer) clearInterval(self._timer);
    self._timer = setInterval(function() {

      // window.console.debug('compare : ' + self._value + ' == ' + self._o.value);
      if (self._o.getAttribute("trimValue") != self._o.value) {
        self._fireEvent();
      }

    }, 50);

  });

  bind(this._o, 'blur', function() {
    if (self._timer) clearInterval(self._timer);
    self._timer = null;
  });

};

Observe.prototype._fireEvent = function() {
  if (document.createEvent) {
    var e;
    if (window.KeyEvent) {
      e = document.createEvent('KeyEvents');
      e.initKeyEvent('keyup', true, true, window, false, false, false, false, 65, 0);
    } else {
      e = document.createEvent('UIEvents');
      e.initUIEvent('keyup', true, true, window, 1);
      e.keyCode = 65;
    }
    this._o.dispatchEvent(e);

  } else {
    var e = document.createEventObject();
    e.keyCode = 65;
    this._o.fireEvent('onkeyup', e);

  }

};

/**
 * @fileoverview
 * Abstract Data Reference(데이타 레퍼런스 기본 클래스).
 * @author 조동일
 */

/**
 * @class Abstract Data Reference classs<br>
 * 데이타 레퍼런스 기본 클래스
 * @version 2.0
 * @constructor
 * @return 새로운 eXria.controls.DataRef 객체
 * @type eXria.controls.DataRef
 */
eXria.controls.DataRef = function() {
};
/**
 * Control에 Instance의 특정 node를 매핑한다.<br>
 * Studio를 이용하여 개발 할때는 서버 파서에 의해 스크립트 변환과정 중에
 * 자동 호출되고, 동적으로 control을 생성하는 container(repeater, treeview,...)
 * 에서는 자체 컨트롤 구현을 통해 호출되도록 한다.
 * @param {String} psInstanceId Page에서 Unique한 InstanceId
 * @param {String} psPath 해당 Instance에서의 태그명<br>
 *   ex psPath)
 *     실제 노드의 XPath가 /simple_data 일때
 *     psPath는 simple_data
 * @param {String} psParentPath control이 repeater나 tree view등
 *   container control안에 포함되어 있는 경우 container control의
 *   node XPath. container control에 포함되지 않을 경우는
 *   넘기지 않는다.<br>
 *   node의 인덱스가 필요한 경우 index도 포함한다.
 *   ex)
 *     /root/main_list/list[1]
 */
eXria.controls.DataRef.prototype.setRef = function(psInstanceId, psPath, psParentPath) {};
/**
 * page에 접근해서 instance를 찾아서
 * ValueNode로 instance의 데이타를 wrapping하여 리턴.
 * @return ValueNode로 wrapping된 instance의 데이타
 * @type eXria.data.xhtml.ValueNode
 */
eXria.controls.DataRef.prototype.getNodeData = function() {};
/**
 * page에 접근해서 instance를 찾아서 리턴.
 * @return 페이지 instance
 * @type eXria.data.Instance
 */
eXria.controls.DataRef.prototype.getInstance = function() {};
/**
 * Control에 매핑된 Data Instance의 nodeValue를 리턴한다.
 * @return Control에 매핑된 Data Instance의 TextNode의 nodeValue
 * @type String|Array(String)
 */
eXria.controls.DataRef.prototype.getData = function() {};
/**
 * Control에 매핑된 Data Instance에 넘겨진 값을 입력한다.
 * @param {String} psData Data Instance에 입력할 String Value
 */
eXria.controls.DataRef.prototype.setData = function() {};
/**
 * 다른 페이지의 인스턴스 참조 시 해당 페이지 참조 속성을 설정하기 위한 메소드
 * @param {eXria.form.Page} poPage 인스턴스를 참조할 페이지 객체
 */
 eXria.controls.DataRef.prototype.setPage = function() {};
/**
 * @fileoverview
 * Node Data Reference class(노드 데이타 레퍼런스 기본 클래스)
 * @author 조동일
 */

/**
 * @class Node Data Reference classs.<br>
 * 노드 데이타 레퍼런스 기본 클래스.
 * @version 1.0
 * @constructor
 * @base eXria.controls.DataRef
 * @param {Object} poControl page의 Instance가 참조 가능한 컨트롤 객체
 * @return 새로운 eXria.controls.DataRefNode 객체
 * @type eXria.controls.DataRefNode
 */
eXria.controls.DataRefNode = function(poControl) {
  if(page.metadata.useJsonInstance) {
    eXria.controls.JsDataRefNode.call(this, poControl);
    return;
  }

  eXria.controls.DataRef.call(this);
  /**
   * DataRefNode를 연결할 Control
   * @type Object
   */
  this.control = poControl;
  /**
   * Control에 연결된 Instance의 ID
   * @type String
   */
  this.instanceId;
  /**
   * 해당 Instance에서 Control이 사용하는 Node의 XPath
   * @type String
   */
  this.instancePath;
  /**
   * 한번 가져온 Instance를 보관하기 위한 Map
   * @type eXria.data.Map
   * @private
   */
  this.instanceMap = new eXria.data.Map();
  /**
   * setData 발생 시 상위 노드에 업데이트 플래그를 설정할 지 여부
   * @type Boolean
   * @private
   */
  this.markUpdateAbove = false;
  /**
   * 다른 페이지의 인스턴스 공유 시 해당 인스턴스를 갖는 페이지를 참조하기 위한 속성
   * @type eXria.form.Page;
   * @private
   */
  this.instPage = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.DataRef, eXria.controls.DataRefNode);
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.setPage = function(poPage) {
  this.instPage = poPage;
  if(this.control && this.control.controls) {
    var voCollection = this.control.controls;
    var vcCtl = null;
    var vnSize = voCollection.size();
    for(var i = 0; i < vnSize; i++) {
      vcCtl = voCollection.get(i);
      if(vcCtl.data) {
        vcCtl.data.setPage(poPage);
      }
    }
  }
};
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.setRef = function(psInstanceId, psPath, psParentPath) {
  this.instanceId = psInstanceId;
  if(psPath == null) {
    this.instancePath = null;
    return;
  }
  if(psParentPath) {
    this.instancePath = psParentPath + "/" + psPath;
  } else {
    this.instancePath = psPath;
  }
};
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.getNodeData = function() { /* helper function */
  var viInstance = this.getInstance();
  if(viInstance) {
    var voInstanceNode = viInstance.selectSingleNode(this.instancePath);
    if(voInstanceNode) return new eXria.data.xhtml.ValueNode(voInstanceNode);
    else return null;
  } else {
    return null;
  }
};
/**
 * 설정된 노드의 상위 노드 DOM 객체 리턴.
 * @type Object
 * @private
 */
eXria.controls.DataRefNode.prototype.getParentNode = function() { /* helper function */
  var viInstance = this.getInstance();
  var voParent = null;
  if(viInstance) {
    var vsInstancePath = this.instancePath;
    if(vsInstancePath != null && vsInstancePath != "/") {
      vsInstancePath = vsInstancePath.substr(0, vsInstancePath.lastIndexOf("/"));
    }
    voParent = viInstance.selectSingleNode(vsInstancePath);
  }
  return voParent;
};
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.getInstance = function() {
  var voPage = this.instPage;
  var voNode = null;
  if(voPage) {
    voNode = voPage.getInstance(this.instanceId);
  } else {
    voNode = this.instanceMap.get(this.instanceId);
  }
  if(voNode == null) {
    if(voPage == null) voPage = this.control.canvas.page;
    voNode = voPage.getInstance(this.instanceId);
    this.instanceMap.put(this.instanceId, voNode);
  }
  return voNode;
};
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.getData = function() {
  if(this.instancePath == null) return "";
  var voParentNode = this.getParentNode();
  if(voParentNode == null) return "";
  var vaPath = this.instancePath.split("/");
  var vsTagName = vaPath[vaPath.length - 1];
  var voChildren = voParentNode.getElementsByTagNameFromChildNodes(vsTagName);

  var vaData = [];
  var voChild = 0;
  var vnChildLength = voChildren.size();
  for(var i = 0; i < vnChildLength; i++) {
    voChild = voChildren.get(i);
    vaData.push(String(voChild.getNodeValue())); //20100406
  }
  if(vaData.length > 1) return vaData;
  else return vaData[0];
};
/**
 * @ignore
 */
eXria.controls.DataRefNode.prototype.setData = function(psData) {
  if(this.instancePath == null) return;
  if(psData == null) psData = "";

  var voParentNode = this.getParentNode();
  if(voParentNode == null) return;
  var voDocument = voParentNode;
  var vaPath = this.instancePath.split("/");
  var vsTagName = vaPath[vaPath.length - 1];
  var voChild = null;

  var voChildNodes = voParentNode.getElementsByTagNameFromChildNodes(vsTagName);
  for(var i = 0, vnLen = voChildNodes.size() ; i < vnLen ; i++) {
    voParentNode.removeChild(voChildNodes.get(i));
  }

  var voFirstChild = voParentNode.getFirstChild();
  var voPage = this.instPage;
  if(voPage == null) voPage = this.control.canvas.page;
  var vnModelType = voPage.metadata.modelType;
  var vnXHTMLType = eXria.form.ModelType.XHTML;

  if(psData instanceof Array == false) {
    if(typeof(psData) == "string") {
      psData = psData.split("\r\n").join("\n");
    }
    if(vnModelType == vnXHTMLType) {
      voChild = voDocument.createElement(vsTagName);
      voChild.appendChild(voDocument.createTextNode(psData));
    } else {
      voChild = voDocument.createElement(vsTagName, psData);
    }
    if(voFirstChild != null) {
      voParentNode.insertBefore(voChild, voFirstChild);
      voFirstChild = voChild;
    } else {
      voParentNode.appendChild(voChild);
    }
  } else {
    if(psData.length == 0) psData.push("");
    var vsData = null;
    for(var j = 0, vnSubLen = psData.length; j < vnSubLen; j++) {
      vsData = psData[j];
      if(typeof(vsData) == "string") {
        vsData = vsData.split("\r\n").join("\n");
      }
      if(vnModelType == vnXHTMLType) {
        voChild = voDocument.createElement(vsTagName);
        voChild.appendChild(voDocument.createTextNode(vsData));
      } else {
        voChild = voDocument.createElement(vsTagName, vsData);
      }
      if(voFirstChild != null) {
        voParentNode.insertBefore(voChild, voFirstChild);
        voFirstChild = voChild;
      } else {
        voParentNode.appendChild(voChild);
      }
    }
  }
  if(this.markUpdateAbove) {
    var vsStatus = voParentNode.getAttribute("status");
    if(vsStatus == null) vsStatus = "";
    if(vsStatus.indexOf("U") == -1) voParentNode.setAttribute("status", vsStatus + "U");
  }
};
/**
 * Control이 단일 값을 가질 경우 넘겨진 값을 매핑된 Data Instance에 값으로 차환하는 메소드.
 * 멀티 값을 갖는 컨트롤은 setData를 사용해야 함.
 * @param psData Data Instance에 입력할 String Value
 */
eXria.controls.DataRefNode.prototype.replaceData = function(psData) {
  var voNodeData = this.getNodeData();
  voNodeData.setValue(psData);
};
/**
 * 인스턴스 패스가 절대 패스 인지 여부 리턴.
 * @return 인스턴스 패스가 절대 패스 인지 여부
 * @type Boolean
 */
eXria.controls.DataRefNode.prototype.isRelativeRef = function() {
  var vbRelative = false;
  if(this.instancePath.indexOf("/") != 0) vbRelative = true;

  return vbRelative;
};

/**
 * @fileoverview
 * Nodeset Data Reference class(노드 데이타 레퍼런스 기본 클래스)
 * @author 조동일
 */

/**
 * @class Nodeset Data Reference class.<br>
 * 노드 데이타 레퍼런스 기본 클래스.
 * @version 1.0
 * @constructor
 * @base eXria.controls.DataRefNode
 * @param {Object} poControl page의 Instance가 참조 가능한 컨트롤 객체
 * @return 새로운 eXria.controls.DataRefNodeset 객체
 * @type eXria.controls.DataRefNodeset
 */
eXria.controls.DataRefNodeset = function(poControl) {
  if(page.metadata.useJsonInstance) {
    eXria.controls.JsDataRefNodeset.call(this, poControl);
    return;
  }

  eXria.controls.DataRefNode.call(this, poControl);
  /**
   * page의 nodeset instance id
   * @type String
   */
  this.nodesetInstanceId = null;
  /**
   * instance 내부의 nodeset path
   * @type String
   */
  this.nodesetInstancePath = null;
  /**
   * Collection에 반복되는 Tag명
   * @type String
   */
  this.loopTag = "list";
  /**
   * addData 시 Field 스키마를 유지하기 위한 반복 노드 템플릿 객체
   * @type eXria.data.xhtml.Node
   * @private
   */
  this.cloneRefer = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.DataRefNode, eXria.controls.DataRefNodeset);
/**
 * 모든 Row 상태 중 입력한 상태를 가지고 있는 Row를 배열로 리턴한다.
 * @param {String} psType 조회대상 CRUDTYPE (ex."U", "IU", "D", "DU")
 * @return 입력 상태를 가진 Row의 index값
 * @type Array
 */
eXria.controls.DataRefNodeset.prototype.getStatusIndexList = function(psType){
  var voNodeList = this.getNodesetData2();
  var vnSize = voNodeList.getLength();
  var vsStatus;
  var voIdxArray = new Array();
  for(var i=0; i<vnSize; i++){
    vsStatus = voNodeList.item(i).getAttribute("status");
    if(psType == vsStatus){
      voIdxArray.push(i+1);
    }
  }
  return voIdxArray;
};
/**
 * 모든 Row 상태 중 입력한 상태를 가지고 있는 Row에 index 값을 구분자로 연결하여 리턴한다.
 * @param {String} psType 조회대상 CRUDTYPE (ex."U", "IU", "D", "DU")
 * @param {String} psDelimeter 연결할 구분자, 생략할 경우 ',' 기본 설정
 * @return 입력 상태를 가진 Row의 index값
 * @type String
 */
eXria.controls.DataRefNodeset.prototype.getStatusIndex = function(pnType, psDelimeter){
  psDelimeter = psDelimeter == null ? "," : psDelimeter;

  var voIdxArray = this.getStatusIndexList(pnType);
  var vnSize = voIdxArray.length;
  var vsResult = new String();
  for(var i = 0; i < vnSize; i++){
    vsResult += voIdxArray[i] + psDelimeter;
  }
  return vsResult;
};
/**
 * Nodeset reference를 설정한다.
 * @param {String} psNodesetInstanceId Page에서 Unique한 InstanceId
 * @param {String} psNodesetPath 해당 Instance에서의 태그명
 * @param {String} psParentPath control이 repeater나 tree view등
 *   container control안에 포함되어 있는 경우 container control의
 *   node XPath. container control에 포함되지 않을 경우는
 *   넘기지 않는다.
 */
eXria.controls.DataRefNodeset.prototype.setNodesetRef = function(psNodesetInstanceId, psNodesetPath, psParentPath) {
  this.nodesetInstanceId = psNodesetInstanceId;
  if(psNodesetPath == null) return;
  if(psParentPath) {
    this.nodesetInstancePath = psParentPath + "/" + psNodesetPath;
  } else {
    this.nodesetInstancePath = psNodesetPath;
  }
  var vaPath = psNodesetPath.split("/");
  this.loopTag = vaPath[vaPath.length - 1];

  //xhtml autocrud
  var voPage = this.instPage;
  if(voPage == null) voPage = page;
  var voIns = voPage.getInstance(this.nodesetInstanceId);
  var voRow = voIns.selectSingleNode(this.nodesetInstancePath);
  if(voRow) {
    this.cloneRefer = voRow.cloneNode(true);
    var voMapNode = new eXria.data.xhtml.MapNode(this.cloneRefer);
    var voKeyCollection = voMapNode.getKeyCollection();
    var vnSize = voKeyCollection.size();
    var vsCol = null;
    for(var i = 0; i < vnSize; i++) {
      vsCol = voKeyCollection.get(i);
      voMapNode.put(vsCol, "");
    }
  }
};
/**
 * page에 접근해서 nodeset의 instance를 찾아서 리턴
 * @return page의 해당 nodeset의 instance
 * @type eXria.data.xhtml.Instance
 */
eXria.controls.DataRefNodeset.prototype.getNodesetInstance = function() {
  var voPage = this.control.canvas.page;
  if(this.instPage) voPage = this.instPage;
  return voPage.getInstance(this.nodesetInstanceId);
};
/**
 * page에 접근해서 instance를 찾아서
 * CollectionNode로 instance를 wrapping하여 리턴
 * @param {Number} pnIdx 특별한 인덱스의 값이 필요한 경우 조회 하고자 하는 인덱스 값을 전달한다.
 * @return pnIdx값이 넘어온 경우 eXria.data.xhtml.CollectionNode.<br>
 *         pnIdx값이 넘어오지 않은 경우 eXria.data.xhtml.MapNode.
 * @type Object
 */
eXria.controls.DataRefNodeset.prototype.getNodesetData = function(pnIdx) { /* helper function */
  if(this.nodesetInstanceId == null)
     return null;

  var viInstance = this.getNodesetInstance();

 var vaPath = this.nodesetInstancePath.split("/");
 var vsNodesetInstancePath = "";
  for(var i = 0; i < vaPath.length - 1; i++) {
    vsNodesetInstancePath += vaPath[i];
    if(i < vaPath.length - 2) vsNodesetInstancePath += "/";
  }

  var voInstanceNode = null;
  try { voInstanceNode = viInstance.selectSingleNode(vsNodesetInstancePath); } catch(err) {}
  if(voInstanceNode == null) return null;
  if(pnIdx != null) {
    return new eXria.data.xhtml.MapNode(voInstanceNode.getChildNodes().item(pnIdx));
  } else {
    return new eXria.data.xhtml.CollectionNode(voInstanceNode);
  }
};
/**
 * page에 접근해서 instance를 찾아서
 * NodeList로 instance를 wrapping하여 리턴(xpath연산 적용가능)
 * @param {Number} pnIdx 특별한 인덱스의 값이 필요한 경우 조회 하고자 하는 인덱스 값을 전달한다.
 * @return pnIdx값이 넘어온 경우 eXria.data.ListNode.<br>
 *         pnIdx값이 넘어오지 않은 경우 eXria.data.xhtml.MapNode.
 * @type Object
 */
eXria.controls.DataRefNodeset.prototype.getNodesetData2 = function(pnIdx) { /* helper function */
  var viInstance = this.getNodesetInstance();

  var vsNodesetInstancePath = this.nodesetInstancePath;

  var voInstanceNodes = null;
  try { voInstanceNodes = viInstance.selectNodes(vsNodesetInstancePath); } catch(err) {}
  if(voInstanceNodes == null) return null;
  if(pnIdx != null) {
    return new eXria.data.xhtml.MapNode(voInstanceNodes.item(pnIdx));
  } else {
    return voInstanceNodes;
  }
};
/**
 * page에 접근해서 instance를 찾아서 instance path의 데이타를 json형태의 문자열로 반환해주는 메소드
 * @type String
 */
eXria.controls.DataRefNodeset.prototype.getNodesetStr = function(psInstanceId, psRef) { /* helper function */
  if(psInstanceId == null) psInstanceId = this.nodesetInstanceId;
  if(psRef == null) psRef = this.nodesetInstancePath;
  if(psInstanceId == null) return null;
  var voPage = this.control.canvas.page;
  if(this.instPage) voPage = this.instPage;
  var viInstance = voPage.getInstance(psInstanceId);
  var vsNodesetStr = null;
  try { vsNodesetStr = viInstance.selectNodesStr(psRef); } catch(err) {}
  return vsNodesetStr;
};
/**
 * Collection Instance에 MapNode를 추가한다.<br>
 * Select Tag의 경우 Label과 Value
 * <select>
 * <option value="value">label</option>
 * </select>
 * @param {String} label에 해당하는 Value값
 * @param {String} value에 해당하는 Value값
 * @param {Number} pnIdx 데이타를 끼워넣고자 하는 위치(생략가능)
 */
eXria.controls.DataRefNodeset.prototype.addData = function(psLabel, psValue, pnIdx) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = null;
  if(this.cloneRefer) {
    voMapNode = new eXria.data.xhtml.MapNode(this.cloneRefer.cloneNode(true));
  } else {
    voMapNode = this.getNodesetInstance().createMapNode(this.loopTag);
  }
  //Attribute에서 labalNode로 지정된 Tag명 조회
  var vsLabelNode = this.control.getAttrValue("labelTagName");
  //Attribute에서 valueNode로 지정된 Tag명 조회
  var vsValueNode = this.control.getAttrValue("valueTagName");
  //MapNode에 Label Element추가
  if(psLabel != null) voMapNode.put(vsLabelNode, psLabel);
  //MapNode에 Value Element추가
  if(psValue != null) voMapNode.put(vsValueNode, psValue);
  if(pnIdx != null) {
    //Control Data에 MapNode를 끼워넣기
    voCollectionNode.insert(pnIdx, voMapNode.node);
  } else {
    //Control Data에 MapNode 추가
    voCollectionNode.add(voMapNode.node);
  }
};
/**
 * Collection Node에 MapNode를 추가한다.<br>
 * Select Tag의 경우 Label과 Value
 * @param {Object} poMap Map 형식의 데이터
 */
eXria.controls.DataRefNodeset.prototype.addMap = function(poMap, pnIndex) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = this.getNodesetInstance().createMapNode(this.loopTag);
  for(var vsName in poMap) {
    voMapNode.put(vsName, poMap[vsName]);
  }
  //Collection에 추가
  if(pnIndex != null) {
    voCollectionNode.insert(pnIndex, voMapNode.node);
  } else {
    voCollectionNode.add(voMapNode.node);
  }
};
/**
 * 특정 Row를 삭제
 * @param {Number} pnIdx Row 인덱스
 */
eXria.controls.DataRefNodeset.prototype.deleteNode = function(pnIdx) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  voCollectionNode.remove(pnIdx);
};
/**
 * 특정 Row의 데이터를 갱신
 * @param {Number} pnIdx Row 인덱스
 * @param {String} psLabel 라벨 데이타
 * @param {String} psValue value 데이타
 */
eXria.controls.DataRefNodeset.prototype.update = function(pnIdx, psLabel, psValue) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.get(pnIdx));
  if(voMapNode) {
    //Attribute에서 labalNode로 지정된 Tag명 조회
    var vsLabelNode = this.control.getAttribute("labelTagName");
    //Attribute에서 valueNode로 지정된 Tag명 조회
    var vsValueNode = this.control.getAttribute("valueTagName");
    //Label Element 갱신
    if(psLabel != null) voMapNode.put(vsLabelNode, psLabel);
    //Value Element 갱신
    if(psValue != null) voMapNode.put(vsValueNode, psValue);
  } else {
    //해당 인덱스가 없으면 Insert
    this.addData(psLabel, psValue, pnIdx);
  }
};
/**
 * 특정 Row의 데이터를 갱신
 * @param {Number} pnIdx Row 인덱스
 * @param {String} psNode 노드명
 * @param {String} psValue value 데이타
 */
eXria.controls.DataRefNodeset.prototype.update2 = function(pnIdx, psNode, psValue) {
  psValue = "" + psValue;
  if(psNode == null || psValue == null) return;
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.get(pnIdx));
  if(voMapNode) {
    voMapNode.put(psNode, psValue);
  }
};
/**
 * 특정 Row의 모든 데이터 갱신
 * @param {Number} pnIdx Row 인덱스
 * @param {Object} poMap 데이타 저장 Map
 */
eXria.controls.DataRefNodeset.prototype.updateMap = function(pnIdx, poMap) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.get(pnIdx));
  if(voMapNode) {
    voMapNode.clear();
    for(var vsName in poMap) {
      voMapNode.put(vsName, poMap[vsName]);
    }
  } else {
    this.addMap(poMap);
  }
};
/**
 * XPath를 이용하여 Instance Source를 Filtering 해서 조회한다.
 * @param {String} psPath DOM Instance를 Filtering하기 위한 XPath 구문
 * @return CollectionNode
 * @type Object
 */
eXria.controls.DataRefNodeset.prototype.filtering = function(psPath) {
  return this.getNodesetInstance().selectNodes(psPath);
};
/**
 * 정해진 컬럼을 기준으로 Collection을 Sort한다.
 * @param {String} psSortNode Sort할 기준값이 되는 Element Node Name
 * @param {Boolean} pbIsAsc true or null 일경우 Ascending, false일 경우 Descending
 * @return CollectionNode
 * @type Object
 * @ignore
 */
eXria.controls.DataRefNodeset.prototype.sort = function(psSortNode, pbIsAsc) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  return voCollectionNode.sort(psSortNode);
};

/**
 * @fileoverview
 * Node Data Reference class(노드 데이타 레퍼런스 기본 클래스)
 * @author 조동일
 */

/**
 * @class Node Data Reference classs.<br>
 * 노드 데이타 레퍼런스 기본 클래스.
 * @version 1.0
 * @constructor
 * @base eXria.controls.DataRef
 * @param {Object} poControl page의 Instance가 참조 가능한 컨트롤 객체
 * @return 새로운 eXria.controls.JsDataRefNode 객체
 * @type eXria.controls.JsDataRefNode
 */
eXria.controls.JsDataRefNode = function(poControl) {
  eXria.controls.DataRef.call(this);
  /**
   * DataRefNode를 연결할 Control
   * @type Object
   */
  this.control = poControl;
  /**
   * Control에 연결된 Instance의 ID
   * @type String
   */
  this.instanceId;
  /**
   * 해당 Instance에서 Control이 사용하는 Node의 XPath
   * @type String
   */
  this.instancePath;
  /**
   * 한번 가져온 Instance를 보관하기 위한 Map
   * @type eXria.data.Map
   * @private
   */
  this.instanceMap = new eXria.data.Map();
  /**
   * setData 발생 시 상위 노드에 업데이트 플래그를 설정할 지 여부
   * @type Boolean
   * @private
   */
  this.markUpdateAbove = false;
  /**
   * xpath의 경로 요소를 저장하기 위한 배열
   * @type Array(String)
   */
  this.paths = [];
  /**
   * 다른 페이지의 인스턴스 공유 시 해당 인스턴스를 참조하기 위한 속성
   * @type eXria.form.Page;
   * @private
   */
  this.instPage = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.DataRef, eXria.controls.JsDataRefNode);
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.setPage = function(poPage) {
  this.instPage = poPage;
  if(this.control && this.control.controls) {
    var voCollection = this.control.controls;
    var vcCtl = null;
    var vnSize = voCollection.size();
    for(var i = 0; i < vnSize; i++) {
      vcCtl = voCollection.get(i);
      if(vcCtl.data) {
        vcCtl.data.setPage(poPage);
      }
    }
  }
};
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.setRef = function(psInstanceId, psPath, psParentPath) {
  this.instanceId = null;
  this.instanceId = psInstanceId;
  if(psPath == null) {
    this.instancePath = null;
    return;
  }
  if(psParentPath) {
    this.instancePath = psParentPath + "/" + psPath;
  } else {
    this.instancePath = psPath;
  }

  var vaPath = this.instancePath.match(/\/[^\/]*/g);
  if(vaPath == null) vaPath = [];
  var vnCnt = vaPath.length;
  var vaRoBrk = null;
  var vaLoBrk = null;
  var vnRoCnt = 0;
  for (var i = 0; i < vnCnt; i++) {
    if (!vaPath[i]) continue;
    vaRoBrk = vaPath[i].match(/\[/g);
    if(vaRoBrk == null) vaRoBrk = [];
    vaLoBrk = vaPath[i].match(/\]/g);
    if(vaLoBrk == null) vaLoBrk = [];
    if(vnRoCnt > 0) {
      vaPath[i] = vaPath[i - 1] + vaPath[i];
      vaPath[i - 1] = "";
    }
    vnRoCnt += vaRoBrk.length;
    vnRoCnt -= vaLoBrk.length;
    if(vnRoCnt > 0) continue;

//    if (/^\/[^\/]*\[([0-9]+)\]/.test(vaPath[i])) {
//      if(page.metadata.useDomPath) {
//        vaPath[i] = eval(RegExp.$1);
//        vaPath[i]--;
//        vaPath[i] = "[" + vaPath[i] + "]";
//      }
//    } else if(/^\/[^\/]*(\[.+\])/.test(vaPath[i])) {
//      var vsQuery = "" + RegExp.$1;
//      if(page.metadata.useDomPath) vaPath[i] = vsQuery;
//    }
  }
  this.paths = [];
  for (var i = 0; i < vnCnt; i++) {
    if (!vaPath[i]) continue;
    this.paths.push(vaPath[i]);
  }
};
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.getNodeData = function() { /* helper function */
  var viInstance = this.getInstance();
  if(viInstance) {
    var voInstanceNode = viInstance.selectSingleNode(this.instancePath);
    if(voInstanceNode) return new eXria.data.xhtml.ValueNode(voInstanceNode);
    else return null;
  } else {
    return null;
  }
};
/**
 * 설정된 노드의 상위 노드 DOM 객체 리턴.
 * @type Object
 * @private
 */
eXria.controls.JsDataRefNode.prototype.getParentNode = function() { /* helper function */
  var viInstance = this.getInstance();
  var voParent = null;
  if(viInstance) {
    var vsInstancePath = this.instancePath;
    if(vsInstancePath != null && vsInstancePath != "/") {
      vsInstancePath = vsInstancePath.substr(0, vsInstancePath.lastIndexOf("/"));
    }
    voParent = viInstance.selectSingleNode(vsInstancePath);
  }
  return voParent;
};
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.getInstance = function() {
  var voPage = this.instPage;
  var voNode = null;
  if(voPage) {
    voNode = voPage.getInstance(this.instanceId);
  } else {
    voNode = this.instanceMap.get(this.instanceId);
  }
  if(voNode == null) {
    if(voPage == null) voPage = page;
    voNode = voPage.getInstance(this.instanceId);
    this.instanceMap.put(this.instanceId, voNode);
  }
  return voNode;
};
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.getData = function() {
  if(this.instancePath == null) return "";
	if(this.paths.length == 0) return "";
  var vaPath = this.paths;
  var voNode = this.getInstance().selectSingleNode(vaPath.join(""));
//  if(voNode == null) voNode = this.getInstance().selectSingleNode(vaPath.join("") + "@es");
  if(voNode) voNode = voNode.node;
  return voNode;
};
/**
 * @ignore
 */
eXria.controls.JsDataRefNode.prototype.setData = function(psData) {
  if(this.instancePath == null) return;
	if(psData === null) psData = "";
  
  var voInst = this.getInstance();
  var voParentNode = voInst.selectSingleNode(this.paths.slice(0, this.paths.length - 1).join(""));
  if(voParentNode == null) return;
  var vsLastPath = this.paths[this.paths.length - 1].replace("/", "");
  var vbChanged = false;
  if(voParentNode.node[vsLastPath] != psData) vbChanged = true;
  voParentNode.node[vsLastPath] = psData;
  if(this.markUpdateAbove) {
    var vsStatus = voParentNode.node["status"];
    if(vsStatus == null) vsStatus = "";
    if(vsStatus.indexOf("U") == -1 && vbChanged) voParentNode.node["status"] = vsStatus + "U"; 
    if(voInst.copyInstObj != null) {
      var vbResult = this.compareRecord(voParentNode.name);
      if(vbResult) voParentNode.node["status"] = "";
    }
  }
};
/**
 * 인스턴스 패스가 절대 패스 인지 여부 리턴.
 * @return 인스턴스 패스가 절대 패스 인지 여부
 * @type Boolean
 */
eXria.controls.JsDataRefNode.prototype.isRelativeRef = function() {
  var vbRelative = false;
  if(this.instancePath.indexOf("/") != 0) vbRelative = true;

  return vbRelative;
};

//수정
/**
 * copyInstance 사용하여 백업된 Instance와 현재 Instance 값을 비교한다.
 * @param {Integer} 해당 컨트롤의 rowIndex(InstIdx)
 * @param {String} 해당 컨트롤의 nodeName
 * @param {String} 해당 컨트롤의 마지막 nodeName
 * @return boolean
 */
eXria.controls.JsDataRefNode.prototype.compareRecord = function(pnIndex) {
  var vbResult = false;
  var vsInstPath = null;
  var voInstance = null;
  var vsControlType = this.control.toString();

  if(vsControlType != "GridEx") {
    vsInstPath = this.paths.slice(0, this.paths.length - 1).join("");
    voInstance = this.getInstance();
  } else {
    vsInstPath = this.nodesetInstancePath;
    voInstance = this.getNodesetInstance();
  }
  
  var vsOriginInst = voInstance.copyInstObj;
  var vsOriginAttr = null;
  var vsJsonData = null;
  var vsOriginData = null;
  
  for(var vsAttr in vsOriginInst) {
    vsOriginAttr = vsAttr;
    break;
  }
  
  if(vsControlType != "GridEx") {
    vsJsonData = voInstance.getJSON(vsInstPath);
    vsOriginData = voInstance.toJSONString(vsOriginInst[vsOriginAttr][pnIndex]);
  } else {
    vsJsonData = voInstance.getJSON(vsInstPath + "["+ pnIndex + "]");
    vsOriginData = voInstance.toJSONString(vsOriginInst[vsOriginAttr][pnIndex]);
  }
  
  var regexpFirst = /{"status\":\s\"[UDRA]+\",\s/g; 
  var regexpMiddle = /,\s"status\":\s\"[UDRA]+\"/g;
  var regexpLast = /,\s"status\":\s\"[UDRA]+\"}/g;
  
  vsJsonData = vsJsonData.replace(regexpFirst, "{");
  vsJsonData = vsJsonData.replace(regexpMiddle, "");
  vsJsonData = vsJsonData.replace(regexpLast, "}");

  if(vsOriginData == vsJsonData) vbResult = true;
  return vbResult;
}
/**
 * @fileoverview
 * Nodeset Data Reference class(노드 데이타 레퍼런스 기본 클래스)
 * @author 조동일
 */

/**
 * @class Nodeset Data Reference class.<br>
 * 노드 데이타 레퍼런스 기본 클래스.
 * @version 1.0
 * @constructor
 * @base eXria.controls.DataRefNode
 * @param {Object} poControl page의 Instance가 참조 가능한 컨트롤 객체
 * @return 새로운 eXria.controls.JsDataRefNodeset 객체
 * @type eXria.controls.JsDataRefNodeset
 */
eXria.controls.JsDataRefNodeset = function(poControl) {
  eXria.controls.JsDataRefNode.call(this, poControl);
  /**
   * page의 nodeset instance id
   * @type String
   */
  this.nodesetInstanceId = null;
  /**
   * instance 내부의 nodeset path
   * @type String
   */
  this.nodesetInstancePath = null;
  /**
   * Collection에 반복되는 Tag명
   * @type String
   */
  this.loopTag = "row";
  /**
   * addData 시 Field 스키마를 유지하기 위한 반복 노드 템플릿 객체
   * @type eXria.data.xhtml.Node
   * @private
   */
  this.cloneRefer = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.JsDataRefNode, eXria.controls.JsDataRefNodeset);
/**
 * Nodeset reference를 설정한다.
 * @param {String} psNodesetInstanceId Page에서 Unique한 InstanceId
 * @param {String} psNodesetPath 해당 Instance에서의 태그명
 * @param {String} psParentPath control이 repeater나 tree view등
 *   container control안에 포함되어 있는 경우 container control의
 *   node XPath. container control에 포함되지 않을 경우는
 *   넘기지 않는다.
 */
eXria.controls.JsDataRefNodeset.prototype.setNodesetRef = function(psNodesetInstanceId, psNodesetPath, psParentPath) {
  this.nodesetInstance = null;
  this.nodesetInstanceId = psNodesetInstanceId;
  if(psNodesetPath == null) return;
  if(psParentPath) {
    this.nodesetInstancePath = psParentPath + "/" + psNodesetPath;
  } else {
    this.nodesetInstancePath = psNodesetPath;
  }
  var voNode = this.getNodesetInstance().selectNodes(psNodesetPath);
  voNode = (voNode) ? voNode.nodeList : null;
  if(voNode == null) return;
  
  //xhtml autocrud
  var voRow = voNode[0];
  if(voRow) {
    if(voRow instanceof eXria.data.json.Node || voRow instanceof eXria.data.xhtml.Node) voRow = voRow.node;
    voNode = {};
    for(var attr in voRow) {
      voNode[attr] = "";
    }
    this.cloneRefer = new eXria.data.json.Node(voNode);
  }
};
/**
 * page에 접근해서 nodeset의 instance를 찾아서 리턴
 * @return page의 해당 nodeset의 instance
 * @type eXria.data.xhtml.Instance
 */
eXria.controls.JsDataRefNodeset.prototype.getNodesetInstance = function() {
  if(this.nodesetInstance == null) {
    var voPage = this.instPage;
    if(voPage == null) voPage = page;
    this.nodesetInstance = voPage.getInstance(this.nodesetInstanceId);
  }
  return this.nodesetInstance;
};
/**
 * page에 접근해서 instance를 찾아서
 * CollectionNode로 instance를 wrapping하여 리턴
 * @param {Number} pnIdx 특별한 인덱스의 값이 필요한 경우 조회 하고자 하는 인덱스 값을 전달한다.
 * @return pnIdx값이 넘어온 경우 eXria.data.xhtml.CollectionNode.<br>
 *         pnIdx값이 넘어오지 않은 경우 eXria.data.xhtml.MapNode.
 * @type Object
 */
eXria.controls.JsDataRefNodeset.prototype.getNodesetData = function(pnIdx) { /* helper function */
  if(this.nodesetInstance == null) return null;
  var voNodesetObj = this.getNodesetObj();
//  if(!(voNodesetObj instanceof Array)) return null;
  if(voNodesetObj == null) return;
  if(pnIdx != null) {
    var voNode = new eXria.data.json.Node(voNodesetObj.nodeList[pnIdx]);
    return new eXria.data.json.MapNode(voNode);
  }
  return new eXria.data.json.CollectionNode(voNodesetObj);
};

eXria.controls.JsDataRefNodeset.prototype.getNodesetData2 = function(pnIdx) { /* helper function */
  if(this.nodesetInstance == null) return null;
  var voNodesetObj = this.getNodesetObj();
//  if(!(voNodesetObj instanceof Array)) return null;
  if(voNodesetObj == null) return;
  if(pnIdx != null) {
    var voNode = new eXria.data.json.Node(voNodesetObj.nodeList[pnIdx]);
    return new eXria.data.json.MapNode(voNode);
  }
  return new eXria.data.json.NodeList(voNodesetObj);
};
/**
 * Collection Node에 MapNode를 추가한다.<br>
 * Select Tag의 경우 Label과 Value
 * @param {Object} poMap Map 형식의 데이터
 */
eXria.controls.JsDataRefNodeset.prototype.addMap = function(poMap, pnIndex) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = this.cloneRefer.slice(0);
  for(var vsName in poMap) {
    voMapNode[vsName] = poMap[vsName];
  }
  //Collection에 추가
  if(pnIndex != null) {
    this.loopNode.splice(pnIndex, 0, voMapNode);
  } else {
    voCollectionNode.push(voMapNode);
  }
};
/**
 * 특정 Row를 삭제
 * @param {Number} pnIdx Row 인덱스
 */
eXria.controls.JsDataRefNodeset.prototype.deleteNode = function(pnIdx) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  voCollectionNode.splice(pnIdx, 1);
};
/**
 * 특정 Row의 데이터를 갱신
 * @param {Number} pnIdx Row 인덱스
 * @param {String} psNode 노드명
 * @param {String} psValue value 데이타
 */
eXria.controls.JsDataRefNodeset.prototype.update = function(pnIdx, psLabel, psValue) {
  psValue = "" + psValue;
  if(psLabel == null || psValue == null) return;
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = voCollectionNode[pnIdx];
  if(voMapNode) {
    voMapNode[psLabel] = psValue;
  }
};
/**
 * 특정 Row의 모든 데이터 갱신
 * @param {Number} pnIdx Row 인덱스
 * @param {Object} poMap 데이타 저장 Map
 */
eXria.controls.JsDataRefNodeset.prototype.updateMap = function(pnIdx, poMap) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = voCollectionNode[pnIdx];
  if(voMapNode) {
    for(var vsName in voMapNode) {
      delete voMapNode[vsName];
    }
    for(var vsName in poMap) {
      voMapNode[vsName] = poMap[vsName];
    }
  } else {
    this.addMap(poMap);
  }
};
/**
 * XPath를 이용하여 Instance Source를 Filtering 해서 조회한다.
 * @param {String} psPath DOM Instance를 Filtering하기 위한 XPath 구문
 * @return CollectionNode
 * @type Object
 */
eXria.controls.JsDataRefNodeset.prototype.filtering = function(psPath) {
  return this.getNodesetInstance().selectNodes(psPath);
};
/**
 * 정해진 컬럼을 기준으로 Collection을 Sort한다.
 * @param {String} psSortNode Sort할 기준값이 되는 Element Node Name
 * @param {Boolean} pbIsAsc true or null 일경우 Ascending, false일 경우 Descending
 * @return CollectionNode
 * @type Object
 * @ignore
 */
eXria.controls.JsDataRefNodeset.prototype.sort = function(psSortNode, pbIsAsc) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  return voCollectionNode.sort(psSortNode);
};

eXria.controls.JsDataRefNodeset.prototype.getNodesetObj = function() {
//  var voInstObj = this.getNodesetInstance().instObj;
//  var vaPath = this.nodesetPaths;
//  var vnSize = vaPath.length;
//  var voObj = voInstObj;
//
//  for(var i = 0; i < vnSize; i++) {
//    voObj = voObj[vaPath[i]];
//    if(voObj == null) break;
//  }
//  return voObj;
  var vsPath = this.nodesetInstancePath;
  var voNode = this.getNodesetInstance().selectNodes(vsPath);
  if(voNode == null)return;
  return voNode;
//  return voNode.nodeList;
};
/**
 * Collection Instance에 MapNode를 추가한다.<br>
 * Select Tag의 경우 Label과 Value
 * <select>
 * <option value="value">label</option>
 * </select>
 * @param {String} label에 해당하는 Value값
 * @param {String} value에 해당하는 Value값
 * @param {Number} pnIdx 데이타를 끼워넣고자 하는 위치(생략가능)
 */
eXria.controls.JsDataRefNodeset.prototype.addData = function(psLabel, psValue, pnIdx) {
  //NodeData 조회
  var voCollectionNode = this.getNodesetData();
  //MapNode 생성
  var voMapNode = null;
  if(this.cloneRefer) {
    voMapNode = new eXria.data.xhtml.MapNode(this.cloneRefer.cloneNode(true));
  } else {
    voMapNode = this.getNodesetInstance().createMapNode(this.loopTag);
  }
  //Attribute에서 labalNode로 지정된 Tag명 조회
  var vsLabelNode = this.control.getAttrValue("labelTagName");
  //Attribute에서 valueNode로 지정된 Tag명 조회
  var vsValueNode = this.control.getAttrValue("valueTagName");
  //MapNode에 Label Element추가
  if(psLabel != null) voMapNode.put(vsLabelNode, psLabel);
  //MapNode에 Value Element추가
  if(psValue != null) voMapNode.put(vsValueNode, psValue);
  if(pnIdx != null) {
    //Control Data에 MapNode를 끼워넣기
    voCollectionNode.insert(pnIdx, voMapNode.node);
  } else {
    //Control Data에 MapNode 추가
    voCollectionNode.add(voMapNode.node);
  }
};
/**
 * @fileoverview
 * Abstract Data Reference(데이타 레퍼런스 기본 클래스).
 * @author 조동일
 */

/**
 * @class Abstract Data Reference classs<br>
 * 데이타 레퍼런스 기본 클래스
 * @version 1.0
 * @constructor
 * @return 새로운 eXria.controls.DataProxy 객체
 * @type eXria.controls.DataProxy
 * @private
 */
eXria.controls.DataProxy = function(poDataSet, psDataSetId, psRef, pnRow) {
  this.isProxy = true;
  this.dataset = poDataSet;
  this.instancePath = psRef;
  this.rowIndex = pnRow;
  this.instanceId = psDataSetId;
  this.data = null;
  this.nodesetInstanceId = null;
  this.nodesetInstancePath = null;
};
/**
 * Control에 매핑된 Data Instance에 넘겨진 값을 얻어온다.
 * @return Control에 매핑된 Data Instance에 넘겨진 값
 * @type String
 */
eXria.controls.DataProxy.prototype.getData = function() {
  if(this.instanceId == null) return "";
  var vsData = this.dataset.get(this.rowIndex + 1, this.instancePath);
  if(vsData == null) vsData = "";

  return vsData;
};
/**
 * Control에 매핑된 Data Instance에 넘겨진 값을 입력한다.
 * @param {String} psData Data Instance에 입력할 String Value
 */
eXria.controls.DataProxy.prototype.setData = function(psData) {
  if(this.instanceId == null) return;
  if(psData == null) psData = "";
  this.dataset.set(this.rowIndex + 1, this.instancePath, psData);
};
/**
 * 컨트롤이 nodeset을 가질 경우 해당 nodeset의 참조 노드 리스트를 반환하는 메소드
 * @private
 */
eXria.controls.DataProxy.prototype.getNodesetData2 = function() {
  var voData = this.data;
  voData.nodesetInstanceId = this.nodesetInstanceId;
  voData.nodesetInstancePath = this.nodesetInstancePath;
  return voData.getNodesetData2();
};
/**
 * page에 접근해서 instance를 찾아서 instance path의 데이타를 json형태의 문자열로 반환해주는 메소드
 * @type String
 */
eXria.controls.DataProxy.prototype.getNodesetStr = function() { /* helper function */
  var voData = this.data;
  voData.nodesetInstanceId = this.nodesetInstanceId;
  voData.nodesetInstancePath = this.nodesetInstancePath;
  return voData.getNodesetStr();
};
/**
 * 인스턴스 패스가 절대 패스 인지 여부 리턴.
 * @return 인스턴스 패스가 절대 패스 인지 여부
 * @type Boolean
 */
eXria.controls.DataProxy.prototype.isRelativeRef = function() {
  return false;
};
/**
 * Nodeset reference를 설정한다.
 * @param {String} psNodesetInstanceId Page에서 Unique한 InstanceId
 * @param {String} psNodesetPath 해당 Instance에서의 태그명
 * @param {String} psParentPath control이 repeater나 tree view등
 *   container control안에 포함되어 있는 경우 container control의
 *   node XPath. container control에 포함되지 않을 경우는
 *   넘기지 않는다.
 */
eXria.controls.DataProxy.prototype.setNodesetRef = function(psNodesetInstanceId, psNodesetPath, psParentPath) {
  this.nodesetInstanceId = psNodesetInstanceId;
  if(psNodesetPath == null) return;
  if(psParentPath) {
    this.nodesetInstancePath = psParentPath + "/" + psNodesetPath;
  } else {
    this.nodesetInstancePath = psNodesetPath;
  }
  this.data.nodesetInstanceId = this.nodesetInstanceId;
  this.data.nodesetInstancePath = this.nodesetInstancePath;
};


/** 캔버스나 컨트롤에 덮어씌워져 window이벤트를 대신 처리하기 위한 오브젝트 클래스.<br>
 * @version 1.0
 * @param {eXria.form.xhtml.Canvas|eXria.controls.xhtml.UIControl} poParent GlassPane적용 대상
 * @return 새로운 eXria.controls.xhtml.GlassPane 객체
 * @type eXria.controls.xhtml.GlassPane
 * @constructor
 */
eXria.controls.xhtml.GlassPane = function(poParent) {
  /**
   * GlassPane이 덧씌워질 Canvas혹은 컨트롤
   * @type eXria.controls.xhtml.Canvas|eXria.controls.xhtml.UIControl
   */
  this.parent = poParent;
  /**
   * 실체화 객체 생성에 사용되는 document객체 저장
   * @type HTMLDocument
   */
  this.document = null;
  /**
   * 실체화 객체의 배경색 설정 값
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 실체화 객체의 배경 투명도 설정 값
   * @type Number
   */
  this.opacity = null;
  /**
   * 컨트롤의 실체화 객체에 반영될 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
/**
 * Ctrl(실체화 컨트롤)을 생성한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치할 Doucment에 대한 참조
 * @return 실체화 컨트롤에 대한 참조
 * @type object
 */
eXria.controls.xhtml.GlassPane.prototype.create = function(poDocument) {
  var voCtrl = this.createCtrl(poDocument);
  this.setDefaults(voCtrl, poDocument);
  this.setAttrs(voCtrl, poDocument);
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * Main Ctrl 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return Div 객체
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.GlassPane.prototype.createCtrl = function(poDocument) {
  var voParent = this.parent;
  if(poDocument == null) poDocument = voParent.document;
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * 속성값 설정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.GlassPane.prototype.setDefaults = function(poCtrl, poDocument) {
  if(this.backgroundColor == null) this.backgroundColor = "#FFFFFF";
  if(this.opacity == null) this.opacity = 0;
};
/**
 * 속성값을 실체화 컨트롤에 반영
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.GlassPane.prototype.setAttrs = function(poCtrl, poDocument) {
  var voParent = this.parent;
  var voDf = this.df;
  var voPage = voParent.page || voParent.window.page;

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;position:absolute;border-style:none;background-color:" + this.backgroundColor + ";");
  vaCssStrBuf.push("position:absolute;");
//  var vnZIndex = voParent.zIndex;
//  if(vnZIndex == null || vnZIndex == "") vnZIndex = 0;
//  vnZIndex++;
  var vnZIndex = 1000000;
  vaCssStrBuf.push("z-index:");
  vaCssStrBuf.push(vnZIndex + ";");
  vaCssStrBuf.push("left:");
  vaCssStrBuf.push(voParent.left + "px;");
  vaCssStrBuf.push("top:");
  vaCssStrBuf.push(voParent.top + "px;");
  vaCssStrBuf.push("width:");
  vaCssStrBuf.push(voParent.width + "px;");
  vaCssStrBuf.push("height:");
  vaCssStrBuf.push(voParent.height + "px;");
  if(voPage.metadata.browser.ie > 0) {
    vaCssStrBuf.push("filter:alpha(opacity=" + this.opacity + ");");
  } else {
    vaCssStrBuf.push("opacity:" + (this.opacity / 100) + ";");
  }
  poCtrl.style.cssText = vaCssStrBuf.join("");
  vaCssStrBuf = null;
};
/**
 * GlassPane에 발생된 이벤트로 이벤트가 전달될 컨트롤을 찾는 메소드
 * @param {eXria.event.Event} poEvent 컨트롤을 검색하기 위한 eXria 이벤트 객체
 * @return 이벤트가 전달될 컨트롤
 * @type eXria.form.xhtml.Canvas|eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.GlassPane.prototype.getControlByEvent = function(poEvent) {
  var voParent = this.parent;
  var voRet = null;
  var voControl = null;
  var voCollection = null;
  if(voParent.controls) {
    if(voParent.controls.getValueCollection) voCollection = voParent.controls.getValueCollection();
    else voCollection = voParent.controls;
  } else {
    voCollection = new eXria.data.ArrayCollection();
    voCollection.add(voParent);
  }
  var vnSize = voCollection.size();
  var vnX = poEvent.clientX;
  var vnY = poEvent.clientY;
  var voPage = null;
  for(var i = 0; i < vnSize; i++) {
    voControl = voCollection.get(i);
    if((vnX >= voControl.left && vnX <= voControl.left + voControl.width) &&
       (vnY >= voControl.top && vnY <= voControl.top + voControl.height)) {
      voRet = voControl;
      if(voControl.toString() == "SubPage" && (voPage = voControl.getPage(this.document))) {
        vnX -= voControl.left;
        vnY -= voControl.top;
        poEvent.clientX = vnX;
        poEvent.clientY = vnY;
        voRet = this.getControlByPos(vnX, vnY, voPage.canvas, poEvent);
      } else if(voControl.controls) {
        vnX -= voControl.left;
        vnY -= voControl.top;
        poEvent.clientX = vnX;
        poEvent.clientY = vnY;
        voRet = this.getControlByPos(vnX, vnY, voControl, poEvent);
      } else if(voControl.toString() == "Tab" || voControl.toString() == "SlideTab") {
        vnX -= voControl.left;
        vnY -= voControl.top;
        var voTagPage = voControl.getPage(voControl.selectedIndex);
        if(voTagPage && (vnX >= voTagPage.left && vnX <= voTagPage.left + voTagPage.width) &&
           (vnY >= voTagPage.top && vnY <= voTagPage.top + voTagPage.height)) {
          vnX -= voTagPage.left;
          vnY -= voTagPage.top;
          poEvent.clientX = vnX;
          poEvent.clientY = vnY;
          voRet = this.getControlByPos(vnX, vnY, voTagPage, poEvent);
        }
      }
      break;
    }
  }
  if(voRet == null) voRet = voParent;
  return voRet;
};
/**
 * x,y좌표값을 이용하여 컨트롤을 찾는 메소드
 * @param {Number} pnX 컨트롤 검색에 이용될 x좌표
 * @param {Number} pnY 컨트롤 검색에 이용될 y좌표
 * @param {eXria.event.Event} poEvent 컨트롤을 검색하기 위한 eXria 이벤트 객체
 * @return 검색된 컨트롤
 * @type eXria.form.xhtml.Canvas|eXria.controls.xhtml.UIControl
 * @private
 */
eXria.controls.xhtml.GlassPane.prototype.getControlByPos = function(pnX, pnY, poContainer, poEvent) {
  var voRet = null;
  var voControl = null;
  var voCollection = poContainer.controls;
  if(voCollection.getValueCollection) voCollection = voCollection.getValueCollection();

  var vnSize = voCollection.size();
  for(var i = 0; i < vnSize; i++) {
    voControl = voCollection.get(i);
    if((pnX >= voControl.left && pnX <= voControl.left + voControl.width) &&
       (pnY >= voControl.top && pnY <= voControl.top + voControl.height)) {
      voRet = voControl;
      if(voControl.toString() == "SubPage" && (voPage = voControl.getPage(this.document))) {
        pnX -= voControl.left;
        pnY -= voControl.top;
        poEvent.clientX = pnX;
        poEvent.clientY = pnY;
        voRet = this.getControlByPos(pnX, pnY, voPage.canvas, poEvent);
      } else if(voControl.controls) {
        pnX -= voControl.left;
        pnY -= voControl.top;
        poEvent.clientX = pnX;
        poEvent.clientY = pnY;
        voRet = this.getControlByPos(pnX, pnY, voControl, poEvent);
      } else if(voControl.toString() == "Tab" || voControl.toString() == "SlideTab") {
        pnX -= voControl.left;
        pnY -= voControl.top;
        var voTagPage = voControl.getPage(voControl.selectedIndex);
        if(voTagPage && (pnX >= voTagPage.left && pnX <= voTagPage.left + voTagPage.width) &&
           (pnY >= voTagPage.top && pnY <= voTagPage.top + voTagPage.height)) {
          pnX -= voTagPage.left;
          pnY -= voTagPage.top;
          poEvent.clientX = pnX;
          poEvent.clientY = pnY;
          voRet = this.getControlByPos(pnX, pnY, voTagPage, poEvent);
        }
      }
      break;
    }
  }
  if(voRet == null) voRet = poContainer;
  return voRet;
};
/**
 * GlassPane 실체화 객체를 제거하기 위한 메소드.
 */
eXria.controls.xhtml.GlassPane.prototype.removeCtrl = function() {
  var voParentNode = this.ctrl.parentNode;
  this.ctrl.style.display = "none";
  if(voParentNode) voParentNode.removeChild(this.ctrl);
};
/**
 * @fileoverview
 * Abstract UIControl(Control 컨트롤에 대한 xhtml 기본 클래스)
 * @author 김경태
 */

/**
 * @class Concreate xhtml Control.<br>
 * Control 컨트롤에 대한 xhtml 기본 클래스.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Control 객체
 * @type eXria.controls.xhtml.Control
 * @constructor
 * @base eXria.controls.Control
 */
eXria.controls.xhtml.Control = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  eXria.controls.Control.call(this, psId);
  this.initGeneral();
}; // End of Control
eXria.controls.xhtml.Util.createInheritance(eXria.controls.Control, eXria.controls.xhtml.Control);
/**
 * 공통 속성을 설정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.setGeneralAttrs = function(poCtrl) {
  poCtrl.setAttribute("lang", this.lang);
};
/**
 * 공통 이벤트를 설정한다.
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.setGeneralEvents = null;
/**
 * 속성 값을 설정.
 * 그러나 값만 설정할 뿐 해당 속성의 관련된 UI 갱신작업까지 수행하지는 않음.
 * @param {String} psFullName 속성명
 * @param {String} psAttrValue 속성값
 */
eXria.controls.xhtml.Control.prototype.setAttr = function(psFullName, psAttrValue) {
  var vsAttrName = psFullName.split('.');

  if(vsAttrName.length == 1) {
    if (this[vsAttrName[0]] !== undefined) this[vsAttrName[0]] = psAttrValue;
    else {
      //throw new Error("정의되지 않은 속성 값에 대한 설정입니다.");
    }
  } else if (vsAttrName.length == 2) {
//    if(this[vsAttrName[0]][vsAttrName[1]] !== undefined) {
    this[vsAttrName[0]][vsAttrName[1]] = psAttrValue;
//    } else {
      //throw new Error("정의되지 않은 속성 값에 대한 설정입니다.");
//    }
  } else if (vsAttrName.length == 3) {
//    if(this[vsAttrName[0]][vsAttrName[1]][vsAttrName[2]] !== undefined)
    this[vsAttrName[0]][vsAttrName[1]][vsAttrName[2]] = psAttrValue;
  } else if (vsAttrName.length == 4) {
//    if(this[vsAttrName[0]][vsAttrName[1]][vsAttrName[2]][vsAttrName[3]] !== undefined)
    this[vsAttrName[0]][vsAttrName[1]][vsAttrName[2]][vsAttrName[3]] = psAttrValue;
  } else {
    throw new Error("속성 값 설정에 대한 형식이 잘못 구성되어 있습니다.");
  }
};
/**
 * 속성 값을 설정하고 바로 적용.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.Control.prototype.applyAttr = function(psAttrName, psAttrValue, poDocument) {
//  try {
//    var voNotify = new eXria.controls.Notify();
//    voNotify.type = eXria.controls.CommonDefine.Notice.APPLY_ATTRIBUTE;
//    voNotify.datas.put(psAttrName, psAttrValue);
//    this.observerHandler.notify(voNotify, poDocument);
//    delete voNotify;
//    voNotify = null;
//  } catch(err) {
//    throw new Error("Notify 처리 시에 오류가 발생하였습니다");
//    return false;
//  }
//  return true;
  if(poDocument == null) poDocument = this.document;
    if(this.applyAttrSimple) {
      if(this.applyAttrSimple(psAttrName, psAttrValue, poDocument) == true) return; // 속성 설정으로 끝나는 경우
    }
    if(this.applyAttrRebuild) {
      this.applyAttrRebuild(psAttrName, psAttrValue, poDocument); // 재계산이 필요한 경우
    } else if(this.applyAttrRefresh) {
      this.applyAttrRefresh(psAttrName, psAttrValue, poDocument); // Refresh가 필요한 경우
    }
};
/**
 * 속성 적용이 속성 설정으로 끝나는 경우의 속성 설정 메소드.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @private
 */
eXria.controls.xhtml.Control.prototype.applyAttrSimple = function(psAttrName, psAttrValue) {
  var voCtrl = this.getCtrl();

  if(psAttrName == "tooltip") {
    this.setAttr(psAttrName, psAttrValue);
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    return true;
  }
  //이미지컨트롤의 커서속성은 이미지컨트롤내에서 처리
  if(psAttrName == "cursor" && this.toString() != "Image") {
    this.setAttr(psAttrName, psAttrValue);
//    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    if(this.setCursor) this.setCursor(voCtrl, psAttrValue);
    return true;
  }
  return false;
};
/**
 * 속성 값을 반환.
 * @param {String} psAttrName 속성명
 * @return 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.getAttrValue = function(psAttrName) {
  if(this[psAttrName] != null)
    return this[psAttrName];
  else
    return null;
};
/**
 * 속성을 제거.
 * @param {String} psAttrName 속성명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 성공여부
 * @type Boolean
 */
eXria.controls.xhtml.Control.prototype.removeAttr = function(psAttrName, poDocument) {
  if(this[psAttrName] == undefined) {
    throw new Error("속성이 존재하지 않습니다.");
    return false;
  }  else {
    try {
      var voNotify = new eXria.controls.Notify();
      voNotify.type = eXria.controls.CommonDefine.Notice.REMOVE_ATTRIBUTE;
      voNotify.datas.put(psAttrName, null);
      this.observerHandler.notify(voNotify, poDocument);
      delete voNotify;
      voNotify = null;
      this[psAttrName] = null;
    } catch(err) {
      throw new Error("Notify 처리 시에 오류가 발생하였습니다");
      return false;
    } finally {
      return true;
    }
  }
};
/**
 * 컨트롤의 정보를 문자열로 반환.
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.toString = null;
/**
 * 해당 ID를 갖는 실체화 컨트롤을 반환.
 * @param {String} psId 컨트롤 식별자
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 실체화컨트롤
 * @type Object
 */
eXria.controls.xhtml.Control.prototype.lookup = function(psId, poDocument) {
  if(poDocument == null) poDocument = this.document;
  if(poDocument == null) return null;
  /*var voCtrl = null;
  if(idMap != null) voCtrl = idMap.get(psId);*/
  //var voCtrl = poDocument.getElementById(psId);
  var voRet = null;
  if(this.ctrl) {
    var voCtrl = this.ctrl;
    if(voCtrl["id"] == psId) {
      voRet = voCtrl;
    } else if(voCtrl.all && voCtrl.all[psId]) {
      voRet = voCtrl.all[psId];
      if(voRet[0]) voRet = voRet[0];
    } else {
      if(poDocument.getElementById(psId)) voRet = poDocument.getElementById(psId);
    }
  } else {
    if(poDocument.getElementById(psId)) voRet = poDocument.getElementById(psId);
  }
  return voRet;
};
/**
 * 하위 노드를 추가.
 * @param {HTMLElement} poCtrl 실체화 객체
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.Control.prototype.appendChild = function(poCtrl, poDocument) {
  this.getCtrl(poDocument).appendChild(poCtrl);
};
/**
 * 하위 노드를 제거.
 * @param {HTMLElement} poCtrl 실체화 객체
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.Control.prototype.removeChild = function(poCtrl, poDocument) {
  this.getCtrl(poDocument).removeChild(poCtrl);
};
/**
 * Template 정보를 새로고침.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Control.prototype.refreshTemplate = function(poCtrl, poDocument) {
  if(this.setTemplate) this.setTemplate(poCtrl, poDocument);
};
/**
 * Control에 설정된 공통 정보(css예외 속성)를 새로고침.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Control.prototype.refreshGeneralAttrs = function(poCtrl, poDocument) {
  this.setGeneralAttrs(poCtrl, poDocument);
};
/**
 * 옵저버로써 수신된 변경내용을 반영한다.
 * @param {eXria.controls.Notify} poNotify
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Control.prototype.update = function(poNotify, poDocument) {
  if(poDocument == null) poDocument = this.document;
  var vb = false;          // 각 처리 결과의 수행 여부
  var NOTICE = eXria.controls.CommonDefine.Notice;
  var voIterator = poNotify.datas.getKeyCollection().iterator();
  var vsKey = null;
  var vsValue = null;

  while(voIterator.hasNext()) {
    vsKey = voIterator.next();
    vsValue = poNotify.datas.get(vsKey);
  }

  switch(poNotify.type) {
    case NOTICE.APPLY_ATTRIBUTE :
      if(this.applyAttrSimple) {
        if(this.applyAttrSimple(vsKey, vsValue, poDocument) == true) break; // 속성 설정으로 끝나는 경우
      }
      if(this.applyAttrRebuild) {
        if(this.applyAttrRebuild(vsKey, vsValue, poDocument) == true) break; // 재계산이 필요한 경우
      }
      if(this.applyAttrRefresh) {
        if(this.applyAttrRefresh(vsKey, vsValue, poDocument) == true) break; // Refresh가 필요한 경우
      }
      break;
    case NOTICE.REMOVE_ATTRIBUTE :
      if(this.removeAttrSimple) this.removeAttrSimple(vsKey, poDocument);     // 속성 설정으로 끝나는 경우
      if(this.removeAttrRebuild) this.removeAttrRebuild(vsKey, poDocument);    // 재계산이 필요한 경우
      if(this.removeAttrRefresh) this.removeAttrRefresh(vsKey, poDocument);   // Refresh가 필요한 경우
      break;
    case NOTICE.REFRESH :
      this.refresh(poDocument);
      break;
  }
};
/**
 * eventManager에 등록된 이벤트를 제거
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.clearEvents = function(poDocument) {
  if(this.ctrl == null) return;
  var vaId = [];
  var vaEventType = [];
  var voIterator = this.eventManager.events.getKeyCollection().iterator();
  var vsId = null;
  var vsEventId = null;
  var vsEventType = null;
  var vaStr = null;
  while(voIterator.hasNext()) {
    vsEventId = voIterator.next();
    vaStr = vsEventId.split(".");
    vsId = vaStr.slice(0, vaStr.length - 1).join(".");
    vsEventType = vaStr[vaStr.length - 1];
    vaId.push(vsId);
    vaEventType.push(vsEventType);
  }
  var voCtrl = null;
  for(var i = 0; i < vaId.length; i++) {
    voCtrl = this.lookup(vaId[i], poDocument);
    if(voCtrl == null) continue;
    vsEventId = vaId[i] + "." + vaEventType[i];
    this.eventManager.removeListener(voCtrl, vaEventType[i], this.eventManager.events.get(vsEventId));
  }
};
/**
 * Ctrl을 제거.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @private
 */
eXria.controls.xhtml.Control.prototype.clearCtrl = function(poDocument) {
  this.clearEvents(poDocument);
  var voCtrl = this.getCtrl(poDocument);
//  if(this.ctrl) this.ctrl = null;
  if (voCtrl != null) {
    //this.clearCtrlNode(voCtrl);
    if(this.setDisable) this.setDisable(voCtrl, false);
    if(voCtrl.parentNode) voCtrl.parentNode.removeChild(voCtrl);
  }
};
/**
 * 노드에 연결된 함수를 제거.
 * @param {HTMLElement} poElement 실체화 객체
 * @private
 */
eXria.controls.xhtml.Control.prototype.clearCtrlNode = function(poElement) {
  var voAttrs = poElement.attributes;
  if (voAttrs) {
    var vnLength = voAttrs.length;
    for (var i = 0; i < vnLength; i++) {
      var vsName = voAttrs[i].name;
      if (typeof poElement[vsName] === "function") {
        poElement[vsName] = null;
      }
    }
  }

  var voNodes = poElement.childNodes;
  if (voNodes) {
    var vnLength = voNodes.length;
    for (var i = 0; i < vnLength; i++) {
      this.clearCtrlNode(poElement.childNodes[i]);
    }
  }
};
/**
 * 공통 초기화 수행
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.initGeneral = function() {
  this.observerHandler = new eXria.controls.ObserverHandler();   // ObserverHandler 생성
  this.observerHandler.addObserver(this.id, this);              // Observer 등록
  this.eventManager = new eXria.event.EventManager();            // EventManager 생성 => TODO : 향후 변경될 코드, 테스트를 위해 삽입됨
};
/**
 * 멀티라인 텍스트 설정.
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {String} psText
 * @private
 */
eXria.controls.xhtml.Control.prototype.setText = function(poCtrl, psText) {
  if(psText == null) psText = "";
  psText = eXria.controls.xhtml.Util.parseLang(psText);
  psText = psText.replace(/</g, "&lt;");
  psText = psText.replace(/>/g, "&gt;");
  psText = psText.replace(/\n/g, "<br>");
  psText = psText.replace(/\s/g, "&nbsp;");
  poCtrl.innerHTML = psText;
};

/**
 * dom element가 브라우저를 기준으로 한 절대 좌표를 접하거나 포함하고 있는지 여부 확인
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.isContain = function(poCtrl, pnX, pnY) {
  var vbContain = false;
//  var voStyle = poCtrl.style;

  var vnBorderLeft = 0, vnBorderRight = 0, vnBorderTop = 0, vnBorderBottom = 0;

  if(!!this.getStyleCurrentValue) {
    vnBorderLeft = parseInt(this.getStyleCurrentValue(poCtrl, "border-left-width", "borderLeftWidth"), 10);
    vnBorderRight = parseInt(this.getStyleCurrentValue(poCtrl, "border-right-width", "borderRightWidth"), 10);
    vnBorderTop = parseInt(this.getStyleCurrentValue(poCtrl, "border-top-width", "borderTopWidth"), 10);
    vnBorderBottom = parseInt(this.getStyleCurrentValue(poCtrl, "border-bottom-width", "borderBottomWidth"), 10);
  }

  var vnWidth = parseInt(poCtrl.offsetWidth) - vnBorderLeft - vnBorderRight;
  var vnHeight = parseInt(poCtrl.offsetHeight) - vnBorderTop - vnBorderBottom;

  var vnLeft = 0;
  var vnTop = 0;
  var voElement = poCtrl;
  while(voElement.offsetParent) {
    vnLeft += voElement.offsetLeft;
    vnTop += voElement.offsetTop;
    voElement = voElement.offsetParent ;
  };
  if(pnX >= vnLeft && pnX < vnLeft + vnWidth && pnY >= vnTop && pnY < vnTop + vnHeight) {
    vbContain = true;
  }

  return vbContain;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Control.prototype.setUserAttr = function(psUserAttr) {
  this.userAttr = psUserAttr;
  if(psUserAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(psUserAttr)) this.userAttrObj = eval(psUserAttr);
  }
};
/**
 * @fileoverview
 * UIControl 컨트롤에 대한 xhtml 기본 클래스
 * @author 김경태
 */

/**
 * @class 컨트롤에 대한 xhtml 기본 클래스입니다.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.UIControl 객체
 * @type eXria.controls.xhtml.UIControl
 * @constructor
 * @base eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.UIControl = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  eXria.controls.xhtml.Control.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * 툴팁에 표시될 문자열.
   * @type String
   */
  this.tooltip = null;
  /**
   * 컨텍스트 메뉴 컨트롤에 대한 id
   * @type String
   */
  this.contextMenuId = null;
  /**
   * 컨트롤에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 컨트롤의 최외곽 DIV 보더 스타일을 지정하는 css의 class 이름.
   * @type String
   */
  this.outerClassName = null;
  /**
   * 컨트롤 탭 인덱스.<br>
   * 폼에서 탭키에 의한 컨트롤 이동 시 이용됨.
   * @type Number
   */
  this.tabIndex = null;
  /**
   * 컨트롤을 비활성화 여부.
   * @type Boolean
   */
  this.disabled = false;
  /**
   * 컨트롤 포커싱 키보드 단축키.
   * @type String
   */
  this.accessKey = "";
  /**
   * 포커스가 위치했을 때의 색상 변경 적용 여부.
   * @type Boolean
   */
  this.focusDisplay = false;
  /**
   * 툴팁 표시 여부.
   * @type Boolean
   */
  this.tooltipDisplay = null;
  /**
   * 컨트롤 이동시의 pane 객체의 불투명도.
   * @type Number
   * @private
   */
  this.paneOpacity = 30;     // TODO : 현재 스펙에서 외부에 노출되어 있지 않음
  /**
   * 마우스 드래그에 의한 컨트롤 이동 가능 여부.<br>
   * this.setMove메소드에 의해서만 값 설정.
   * @type Boolean
   * @private
   */
  this.movable = false;       // @private this.setMove메소드에 의해서만 값 설정
  /**
   * 프린트를 위한 프린트 동작 상태 여부.
   * @type Boolean
   * @ignore
   */
  this.printMode = false;
  /**
   * 컨트롤 화면 디스플레이 여부.
   * @type Boolean
   */
  this.visible = null;
  /**
   * 폼에서 컨트롤의 겹침 순서 지정.<br>
   * @type Number
   */
  this.zIndex = null;
  /**
   * TableLayout 사용시 들어갈 열 인덱스.<br>
   * @type Number
   */
  this.rowNum = null;
  /**
   * TableLayout 사용시 들어갈 행 인덱스.<br>
   * @type Number
   */
  this.colNum = null;
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).<br>
   * absolute : 상위 컨트롤의 좌상단 점을 원점으로 left, top 지정.<br>
   * relative : 상위 컨트롤이 컨트롤을 자동 위치시킨 상태에서의 left, top 이동값 지정.<br>
   * @type String
   */
  this.position = null;
  /**
   * 컨트롤에 표시될 텍스트 색상 값.<br>
   * @type String
   */
  this.color = null;
  /**
   * 컨트롤의 배경색.<br>
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 컨트롤 외곽 보더의 두께.<br>
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 컨트롤 외곽 상단보더의 두께.<br>
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 컨트롤 외곽 우측보더의 두께.<br>
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 컨트롤 외곽 하단보더의 두께.<br>
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 컨트롤 외곽 좌측보더의 두께.<br>
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 컨트롤 외곽 보더 스타일.<br>
   * "none" | "hidden" | "dotted" | "dashed" | "solid" | "double" | "groove" | "ridge" | "inset" | "outset" (초기값 : solid)
   * @type String
   */
  this.borderStyle = null;
  /**
   * 컨트롤 외곽 보더 색상.<br>
   * @type String
   */
  this.borderColor = null;
  /**
   * 컨트롤 위에 마우스 위치시에 마우스 커서 타입.<br>
   * "all-scroll" | "col-resize" | "crosshair" | "default" | "help" | "move" | "no-drop" | "not-allowed" | "row-resize" | "text" | "url" | "vertical-text" | "wait" | "NW-resize" | "NE-resize" | "progerss" | "pointer" (초기값 : default)
   * @type String
   */
  this.cursor = "default";
  /**
   * 컨트롤에 포커스 위치 시 외곽 보더의 두께.<br>
   * 포커스 효과 관련
   * @type Number
   */
  this.focusBorderWidth = null;
  /**
   * 컨트롤에 포커스 위치 시 외곽 보더의 색상.<br>
   * 포커스 효과 관련
   * @type String
   */
  this.focusBorderColor = null;
  /**
   * 컨트롤에 포커스 위치 시 외곽 보더 스타일.
   * @type String
   */
  this.focusBorderStyle = null;
  /**
   * dataset id
   * @type String
   */
  this.datasetId = null;
  /**
   * 포커싱에 의해 컨트롤 외곽 보더 두께 변경 시 원본 값 저장.
   * @type Number
   * @private
   */
  this.oldBorderWidth = null;
  /**
   * 포커싱에 의해 컨트롤 외곽 보더 색상 변경 시 원본 값 저장.
   * @type String
   * @private
   */
  this.oldBorderColor = null;
  /**
   * 포커싱에 의해 컨트롤 외곽 보더 스타일 변경 시 원본 값 저장.
   * @type String
   * @private
   */
  this.oldBorderStyle = null;
  /**
   * 컨트롤 disabled 상태에서의 폰트 색상.
   * @type String
   */
  this.disabledColor = null;
  /**
   * 컨트롤이 폼에 attach 된 후 load 작업이 수행되었는지 여부.<br>
   * 유의사항으로 isLoaded()는 attach 되었는지 여부 만을 체크.
   * @type Boolean
   */
  this.loaded = false;


  /**
   * 컨트롤 좌상단 점의 x좌표.
   * @type Number
   */
  this.left = pnLeft == null ? 0 : pnLeft;
  /**
   * 컨트롤 좌상단 점의 y좌표.
   * @type Number
   */
  this.top = pnTop == null ? 0 : pnTop;
  /**
   * 컨트롤의 가로 길이.
   * @type Number
   */
  this.width = pnWidth == null ? 100 : pnWidth;
  /**
   * 컨트롤의 세로 길이.
   * @type Number
   */
  this.height = pnHeight == null ? 100 : pnHeight;


  /**
   * 컨트롤 위치 이동 시 마우스 위치를 기준으로 left 경계와의 거리
   * @type Number
   * @private
   */
  this.leftOffset = -1;
  /**
   * 컨트롤 위치 이동 시 마우스 위치를 기준으로 top 경계와의 거리
   * @type Number
   * @private
   */
  this.topOffset = -1;
  /**
   * 컨트롤 위치 이동 시 마우스 위치를 기준으로 right 경계와의 거리
   * @type Number
   * @private
   */
  this.rightOffset = -1;
  /**
   * 컨트롤 위치 이동 시 마우스 위치를 기준으로 bottom 경계와의 거리
   * @type Number
   * @private
   */
  this.bottomOffset = -1;
  /**
   * @ignore
   */
  this.divOffsetHeight;

  this.initUIGeneral();
}; // End of Control
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Control, eXria.controls.xhtml.UIControl);
/**
 * Main Ctrl을 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 컨트롤을 둘러싸는 최외곽 Div 객체
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.createCtrl = function(poDocument) {};
/**
 * 컨트롤을 구성하기 위한 HTML 레이아웃을 문자열 버퍼에 설정하는 메소드.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setTemplate = function(poCtrl, poDocument) {};
/**
 * Composite Child Ctrl을 생성합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.createSubCtrl = function(poCtrl, poDocument) {};
/**
 * Main Style을 적용합니다.
 * @param {HTMLDiv} voCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
//  var vsClassName = this.getSpecificAttrValue("className", this.className);
//  var vsOuterClassName = this.getSpecificAttrValue("className", this.outerClassName);
//  var vsJoinedClassName = this.getCtrlClassName(vsClassName, vsOuterClassName);
//  if(vsJoinedClassName != " ") this.setAttrCtrl("className", vsJoinedClassName, poCtrl);

  poCtrl.className = this.getCSSClass(this, 0);
};
/**
 * Composite Child Style을 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setSubCtrlStyles = function(poCtrl, poDocument) {};
/**
 * 개별 초기값을 설정합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setSpecificDefaults = function(poCtrl, poDocument) {};
/**
 * 공통 속성들에 속성값을 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setGeneralAttrs = function(poCtrl, poDocument) {};
/**
 * 컨트롤 별 속성들에 속성값을 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setSpecificAttrs = function(poCtrl, poDocument) {};
/**
 * 공통 Events를 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setGeneralEvents = function(poCtrl) {};
/**
 * 컨트롤 별 Events를 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setSpecificEvents = function(poCtrl) {};
/**
 * 컨트롤 별 초기값으로 지정된 속성값을 제거합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {};
/**
 * Composite Child Style을 새로고침 합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshSubStyles = function(poCtrl, poDocument) {};
/**
 * 공통 속성들에 대한 새로고침을 수행합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshGeneralAttrs = function(poCtrl, poDocument) {};

/**
 * 컨트롤 별 속성들에 대한 새로고침을 수행합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {};
/**
 * Data를 재로딩합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.reloadData = function(poCtrl, poDocument) {};
/**
 * Data관련 UI를 새로고침 합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.UIControl.prototype.refreshData = function(poCtrl, poDocument) {
  if(this.reloadData) this.reloadData(poCtrl, poDocument);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getSpecificDefaultValue = function(psAttrName) {};
/**
 * 웹 페이지에 로딩된 스타일 클래스를 참조합니다.
 * @param {String} psClassName 참조 대상 클래스명
 * @param {HTMLDocument} poDocument 참조 대상 클래스 파일을 로딩 한 Document
 * @return 참조된 css 클래스 오브젝트
 * @type StyleObject
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getCssStyle = function(psClassName, poDocument) {
  return this.canvas.getCssStyle(psClassName, poDocument);
};
/**
 * HTML element의 className 속성에 할당 가능한 형태의 문자열을 반환해주는 메소드.
 * @param {String} psClassName 반환될 문자열 내에서 내부 css 요소를 결정할 css 클래스 명
 * @param {String} psOuterClassName 반환될 문자열 내에서 외부 css 요소를 결정할 css 클래스 명
 * @return HTML element의 className 속성에 할당 가능한 형태의 문자열
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getCtrlClassName = function(psClassName, psOuterClassName) {
  var vsClassName = "";
  if(psClassName == null) psClassName = "";
  if(psOuterClassName == null) psOuterClassName = "";
  vsClassName = psClassName + " " + psOuterClassName;
  vsClassName = eXria.util.StringUtil.trim(vsClassName);

  return vsClassName;
};
/**
 * 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @param {String} psAttrName 속성명
 * @param {String} psCtrlAttrName psAttrName에 대응되면 실체화 객체 속성명
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeUIGeneralAttrValue = function(poCtrl, poCssStyle, psAttrName, psCtrlAttrName) {
  if(this[psAttrName] != null) {  // 사용자 지정 속성값이 있을 경우
    return this[psAttrName]; // this.setAttrCtrl(psCtrlAttrName, this[psAttrName], poCtrl);
  } else {  // 사용자 지정 속성값이 없을 경우
    if(poCssStyle != null) {  // 지정된 CSS가 있을 경우
      if(poCssStyle[psCtrlAttrName] !== undefined && poCssStyle[psCtrlAttrName] != null && poCssStyle[psCtrlAttrName] != "") { // CSS에 해당 속성 값이 있을 경우
        return poCssStyle[psCtrlAttrName];  // this.setAttrCtrl(psCtrlAttrName, poCssStyle[psCtrlAttrName], poCtrl);
      } else {  // CSS에 해당 속성 값이 없을 경우
        return this.getUIControlAttrValue(psAttrName, null);  // this.setAttrCtrl(psCtrlAttrName, this.getUIControlAttrValue(psAttrName, null), poCtrl);
      }
    } else {  // 지정된 CSS가 없을 경우
      return this.getUIControlAttrValue(psAttrName, null);  // this.setAttrCtrl(psCtrlAttrName, this.getUIControlAttrValue(psAttrName, null), poCtrl);
    }
  }
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @param {String} psAttrName 속성명
 * @param {String} psCtrlAttrName psAttrName에 대응되면 실체화 객체 속성명
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeSpecificAttrValue = function(poCtrl, poCssStyle, psAttrName, psCtrlAttrName, psClassName) {
  var vaAttrName = psAttrName.split(".");
  var voAttr = this;
  for(var i = 0; i < vaAttrName.length; i++) {
    voAttr = voAttr[vaAttrName[i]];
    if(voAttr == null) {
      break;
    }
  }

  if(voAttr != null) {  // 사용자 지정 속성값이 있을 경우
    return voAttr;
  } else {  // 사용자 지정 속성값이 없을 경우
    if(poCssStyle != null) {  // 지정된 CSS가 있을 경우
      if(psCtrlAttrName == null) psCtrlAttrName = vaAttrName[vaAttrName.length - 1];
      if(poCssStyle[psCtrlAttrName] != null && poCssStyle[psCtrlAttrName] != "") {
        voAttr = poCssStyle[psCtrlAttrName];
        if(psCtrlAttrName == "backgroundImage") {
          if(psClassName) voAttr = eXria.controls.xhtml.Util.convertImagePathToXrf(psClassName, voAttr, this.document);
        }
        return voAttr;
      } else {  // CSS에 해당 속성 값이 없을 경우
        return this.getAttrValue(psAttrName, null);
      }
    } else {  // 지정된 CSS가 없을 경우
      return this.getAttrValue(psAttrName, null);
    }
  }
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 visible 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 visible 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeVisibleValue = function(poCtrl, poCssStyle) {
  if(this.visible != null) {
    return this.visible;
  } else {
    if(poCssStyle != null) {
      if(poCssStyle["display"] != "" && poCssStyle["display"] != null) {
        if(poCssStyle["display"] == "none") return false;
        else return true;
      } else {
        return this.getUIControlAttrValue("visible", null);
      }
    } else {
      return this.getUIControlAttrValue("visible", null);
    }
  }
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 zIndex 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 zIndex 속성값
 * @type Number
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeZIndexValue = function(poCtrl, poCssStyle) {
  var vnValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "zIndex", "zIndex");
  return vnValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 position 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 position 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makePositionValue = function(poCtrl, poCssStyle) {
  return "absolute";
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 color 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 color 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeColorValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "color", "color");
  return vsValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 backgroundColor 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 backgroundColor 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeBackgroundColorValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "backgroundColor", "backgroundColor");
  return vsValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 cursor 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 cursor 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeCursorValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "cursor", "cursor");
  return vsValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 borderWidth 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 borderWidth 속성값
 * @type Number
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeBorderWidthValue = function(poCtrl, poCssStyle) {
  var vnValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "borderWidth", "borderWidth");
  this.innerWidth = this.width - (2 * parseInt(vnValue));
  this.innerHeight = this.height - (2 * parseInt(vnValue));
  return vnValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 borderStyle 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 borderStyle 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeBorderStyleValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "borderStyle", "borderStyle");
  return vsValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 borderColor 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 borderColor 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeBorderColorValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, poCssStyle, "borderColor", "borderColor");
  return vsValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific에서 우선순위에 따라 tabIndex 속성값을 가져오는 메소드.
 * @param {HTMLDiv} poCtrl 컨트롤 최외곽 DIV Element
 * @param {HTMLStyle} poCssStyle 값을 검색할 Css style 객체
 * @return 사용자 할당 값,css, canvas, UIDefault에서 우선순위에 따라 결정된 tabIndex 속성값.(디폴트 값 : 0)
 * @type Number
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.makeTabIndexValue = function(poCtrl, poCssStyle) {
  var vsValue = this.makeUIGeneralAttrValue(poCtrl, null, "tabIndex", "tabIndex");
  if(vsValue == null) vsValue = 0;
  return vsValue;
};
/**
 * 컨트롤에 적용될 공통속성(css 스타일 적용가능 속성)의 초기값을 설정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setUIGeneralDefaults = function(poCtrl, poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(); }

   // CSS 적용가능한 속성
  var voDf = this.df;
  var voCssStyle = this.canvas.getCssStyle(this.className, poDocument);
  //var voCtrlValueMaker = this.ctrlValueMaker;
  this["visible"] = this.makeVisibleValue(poCtrl, voCssStyle);
  this["zIndex"] = this.makeZIndexValue(poCtrl, voCssStyle);
//  this["position"] = this.makePositionValue(poCtrl, voCssStyle);
//  voDf["color"] = this.makeColorValue(poCtrl, voCssStyle);
//  voDf["backgroundColor"] = this.makeBackgroundColorValue(poCtrl, voCssStyle);
//  voDf["cursor"] = this.makeCursorValue(poCtrl, voCssStyle);
  this["tooltip"] = this.makeUIGeneralAttrValue(poCtrl, null, "tooltip", "tooltip");
  this["tooltipDisplay"] = this.makeUIGeneralAttrValue(poCtrl, null, "tooltipDisplay", "tooltipDisplay");
  // border CSS가 적용가능한 속성
//  voCssStyle = this.canvas.getCssStyle(this.outerClassName, poDocument);
//  voDf["borderWidth"] = this.makeBorderWidthValue(poCtrl, voCssStyle);
//  voDf["borderStyle"] = this.makeBorderStyleValue(poCtrl, voCssStyle);
//  voDf["borderColor"] = this.makeBorderColorValue(poCtrl, voCssStyle);

  // CSS가 적용되지 않는 속성
  this["tabIndex"] = this.makeTabIndexValue(poCtrl, voCssStyle);
  this["disabledColor"] = this.makeUIGeneralAttrValue(poCtrl, null, "disabledColor", "disabledColor");
//  voDf["debug"] = this.makeUIGeneralAttrValue(poCtrl, null, "debug", "debug");
  if(this["debug"] == null) this["debug"] = this.canvas.getFormDefaultValue("debug");
};

///**
// * 컨트롤에 적용될 공통속성(css 예외 속성)의 초기값을 설정한다.
// * @param {HTMLDiv} poCtrl 실체화 컨트롤
// * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
// * @private
// */
//eXria.controls.xhtml.UIControl.prototype.setUIGeneralAttrs = function(poCtrl, poDocument) {
//  var voMainCtrl = null;
//  if (this.getMainCtrl) { voMainCtrl = this.getMainCtrl(poDocument); };
//  if(voMainCtrl == null) voMainCtrl = poCtrl;
//
//  this.setAttrCtrl("tooltip", this.tooltip, poCtrl);
//  this.setAttrCtrl("tabIndex", this.tabIndex, poCtrl);
//  this.setAttrCtrl("disabled", this.disabled, poCtrl);
//  this.setAttrCtrl("accessKey", this.accessKey, poCtrl);
//  this.visible == false ? this.setAttrCtrl("display", "none", poCtrl) : this.setAttrCtrl("display", "", poCtrl);
//  this.setAttrCtrl("zIndex", this.zIndex, poCtrl);
//  this.setAttrCtrl("position", this.position, poCtrl);
//  this.setAttrCtrl("color", this.color, poCtrl);
//  this.setAttrCtrl("backgroundColor", this.backgroundColor, poCtrl);
//  this.setAttrCtrl("borderWidth", this.borderWidth, poCtrl);
//  this.setAttrCtrl("borderStyle", this.borderStyle, poCtrl);
//  this.setAttrCtrl("borderColor", this.borderColor, poCtrl);
//  this.setAttrCtrl("left", this.left, poCtrl);
//  this.setAttrCtrl("top", this.top, poCtrl);
////  this.setAttrCtrl("width", this.innerWidth, poCtrl);
////  this.setAttrCtrl("height", this.innerHeight, poCtrl);
//  this.setAttrCtrl("cursor",this.cursor, poCtrl);
//};

/**
 * 컨트롤에서 수행할 이벤트 처리를 지정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setUIGeneralEvents = function(poCtrl) {
  // Ctrl에서 발생한 이벤트를 2차적으로 처리하는 사용자용 메소드
//  this.onfocus = null;  // button, div, iframe, img, input, label, object, select, span, table, textarea
//  this.onblur = null; // button, div, iframe, img, input, label, object, select, table, span, window
//  this.onclick = null; // body, button, div, img, input, label, object, select, span, table, textarea
//  this.ondblclick = null; // body, button, div, img, input, label, object, select, span, table, textarea
//  this.onkeydown = null; // body, button, div, input, label, object, select, span, table, textarea
//  this.onkeypress = null; // body, button, div, input, label, object, select, span, table, textarea
//  this.onkeyup = null; // body, button, div, input, label, object, select, span, table, textarea
//  this.onmousedown = null; // body, button, div, img, input, label, select, span, table, textarea
//  this.onmousemove = null; // body, button, div, img, input, label, select, span, table, textarea
//  this.onmouseout = null; // body, button, div, img, input, label, select, span, table, textarea
//  this.onmouseover = null; // body, button, div, img, input, label, select, span, table, textarea
//  this.onmouseup = null; // body, button, div, img, input, label, select, span, table, textarea
//  this.onresize = null; // body, button, div, img, input, label, object, select, table, textarea
  var voEventManager = this.eventManager;
  voEventManager.addListener(poCtrl, "onclick", this.mediateEvent);
  voEventManager.addListener(poCtrl, "ondblclick", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onmousedown", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onmouseup", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onmouseover", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onmousemove", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onmouseout", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onkeypress", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onkeydown", this.mediateEvent);
  voEventManager.addListener(poCtrl, "onkeyup", this.mediateEvent);
  voEventManager.addListener(poCtrl, "oncontextmenu", this.mediateEvent);
  poCtrl.control = this;

//UI 컨트롤의 우클릭 시 표시되는 브라우저 기본 메뉴를 제한
//  document.oncontextmenu = function() {
//    return false;
//  };

//  poCtrl.oncontextmenu = function() {
//    return false;
//  };
};
/**
 * 마우스버튼 우클릭을 체크합니다.
 * @param {eXria.event.Event} poEvent 윈도우 이벤트
 * @return 우클릭이 발생하였는지의 여부
 * @type Boolean
 */
eXria.controls.xhtml.UIControl.prototype.isRClick = function(poEvent) {
  return (poEvent.mousebutton == 2) ? true : false;
};
/**
 * 해당 컨트롤에서 이벤트가 발생하였는지 체크합니다.
 * @param {eXria.event.Event} poEvent 윈도우 이벤트
 * @param {String} psControlId 해당컨트롤 아이디
 * @return 해당컨트롤에서 이벤트가 발생하였는지의 여부
 * @type Boolean
 */
eXria.controls.xhtml.UIControl.prototype.inElement = function(poEvent, psControlId) {
  var voCtrl = poEvent.target;
  while (voCtrl) {
    if(voCtrl.id == psControlId) {
      return true;
    } else if(voCtrl.parentNode) {
      voCtrl = voCtrl.parentNode;
    } else {
      return false;
    }
  }
};
/**
 * 컨텍스트메뉴를 원하는 좌표값에 보이게 합니다.
 * @param {Number} pnLeft 컨트롤 좌상단점의 left 위치
 * @param {Number} pnTop 컨트롤 좌상단점의 top 위치
 */
eXria.controls.xhtml.UIControl.prototype.showContextMenu = function(pnLeft, pnTop) {
  this.canvas.showContextMenu(this.id, this.contextMenuId, pnLeft, pnTop);
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.cofocus = function(e) {
  if(this.tooltip != "" && this.tooltip != null) {
    this.tooltipHandler.hide(e);
    //if(this.displayTooltip) this.displayTooltip();
  }
  if(this.afFocusAct) {
    var voObj = this.afFocusAct;
    voObj.func.apply(this, voObj.args);
    this.afFocusAct = null;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.coclick = function(e) {
  if(this.canvas) {
    var voCanvas = this.canvas;
    if(voCanvas.focusedControl != this && voCanvas.getControl(this.id) != null) voCanvas.setFocusByControl(this, null, e.target);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.finalclick = function(e) {
  if(this.canvas) {
    var voCanvas = this.canvas;
    if(!this.isRClick(e)) voCanvas.hideContextMenu();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.comousedown = function(e) {
  if(this.document == null) return;
  var voCanvas = this.canvas;
  // 컨트롤 이동을 처리
  if(this.movable) {
    if(this.document.ondragstart !== "undefined")
    {
      this.document.ondragstart = function() { return false; };
    }
    this.startMove(e);
    e.stopEvent();
  } else if(this.dragDrop) {
    if(this.document.ondragstart !== "undefined")
    {
      this.document.ondragstart = function() { return false; };
    }
    this.startDrag(e);
    e.stopEvent();
  }else {
    if(voCanvas.page.metadata.browser.opera) {
    } else {
      this.document.ondragstart = function() { this.body.dragDrop(); };
    }
  }
//  // 컨텍스트 메뉴를 처리
//  if (!this.inElement(e, this.id))
//     return true;
//  if (!this.isRClick(e)) {
//     return true;
//  } else {
//    var posx=0,posy=0;
//    if(e.pageX || e.pageY) {
//      posx=e.pageX; posy=e.pageY;
//    } else if(e.clientX || e.clientY) {
//      if(document.documentElement.scrollTop) {
//        posx=e.clientX+document.documentElement.scrollLeft;
//        posy=e.clientY+document.documentElement.scrollTop;
//      } else {
//        posx=e.clientX+document.body.scrollLeft;
//        posy=e.clientY+document.body.scrollTop;
//      }
//    }
//    this.showContextMenu(posx,posy);
//    if(this.contextMenuId) e.stopEvent();       // TODO : 향후 변경할것
//  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.comouseup = function(e) {
///// 2010.12.20 yjcho edit start
// GlassPane을 이용한 dragDrop 처리 시에 더 이상 불필요하여 주석 처리
//  if(this.dragDrop && this.sourceItem) {
//    var voCanvas = this.canvas;
//    this.dragDropHandler.hide(e);
//    voCanvas.dragDrop = false;
//    voCanvas.dragDropObject = null;
//    var voCanvasCtrl = voCanvas.getCtrl();
//    if(voCanvasCtrl) {
//      voCanvasCtrl.control = null;
//      voCanvasCtrl.onmousemove = voCanvas.oldmousemove;
//      voCanvasCtrl.onmouseup = voCanvas.oldmouseup;
//      voCanvas.oldmousemove = null;
//      voCanvas.oldmouseup = null;
//    }
//  }
///// 2010.12.20 yjcho edit end
};

/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.finalmouseup = function(e) {
  // 컨텍스트 메뉴를 처리
  var voCanvas = this.canvas;
  var voDocument = this.document;
  voCanvas.doCollapseForAllFrame();
  if (!this.inElement(e, this.id))
     return;
  if (!this.isRClick(e)) {
     return;
  } else {
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    this.showContextMenu(posx,posy);
    if(this.contextMenuId) e.stopEvent();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.comouseover = function(e) {
  if(this.tooltipDisplay) {
    var voDocument = this.document;
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    var vnBottom = this.top + this.height;
    var vnRight = this.left + this.width;
    if(posy > this.top && posy < vnBottom && posx < vnRight && posx > this.left) {
      if(this.canvas.focusedControl === null)
      this.tooltipHandler.hide(e);
    else
        this.tooltipHandler.show(e);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.comouseout = function(e) {
  if(this.tooltipDisplay) this.tooltipHandler.hide(e);
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.comousemove = function(e) {
  if(!this.tooltipDisplay || this.canvas.focusedControl === this)
      this.tooltipHandler.hide(e, this.document);
  else
      this.tooltipHandler.show(e);
};

/**
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.cokeydown = function(e) {
    //this.tooltipHandler.hide(e);
};

/**
 * 이벤트 연결 브릿지 메소드.
 * @param {HTMLEvent} e 브라우저 이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.mediateEvent = function(e) {
  if(this.control == null) return;
//  try {
    var voControl = this.control;
    if(e != null || page.metadata.browser.ie != 0) voControl.runEvent(e, voControl);
//  } catch(err) {}
};
/**
 * 실체화 컨트롤의 속성을 지정합니다(클래스 속성 값에 대한 갱신은 하지 않음).
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤(생략가능)
 */
eXria.controls.xhtml.UIControl.prototype.setAttrCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(); }
  var voStyle = poCtrl.style;

  if(psAttrValue == null) return;
  if(psAttrName == "visible") {
    if(psAttrValue == true) {
      voStyle.display = "block"
      if(this.cover) this.cover.style.display = "block";
    } else {
      voStyle.display = "none";
      if(this.cover) this.cover.style.display = "none";
    }
  } else if(psAttrName == "tooltip") {
    this.tooltipHandler.setCtrl();
  } else if(psAttrName == "cursor") {
    voStyle["cursor"] = psAttrValue;
  } else if(psAttrName == "borderWidth") {
    if(psAttrValue == "" || psAttrValue == null) {
      voStyle[psAttrName] = psAttrValue;
    } else {
      voStyle[psAttrName] = psAttrValue + "px";
    }
  } else if(psAttrName == "left" || psAttrName == "top" || psAttrName == "width" || psAttrName == "height") {
    if(psAttrValue == "" || psAttrValue == null) {
      voStyle[psAttrName] = psAttrValue;
    } else {
      if(psAttrValue < 0) psAttrValue = 0;
      voStyle[psAttrName] = psAttrValue + "px";
    }
  } else if(psAttrName == "fontSize") {
    if(psAttrValue != null && psAttrValue != "") {
      voStyle[psAttrName] = psAttrValue + "pt";
    } else if(psAttrValue == "") {
      voStyle[psAttrName] = "";
    }
  } else if(psAttrName == "color") {
    if(psAttrValue != null) {
      voStyle[psAttrName] = psAttrValue;
    }
  } else if(psAttrName == "backgroundPosition") {
    if(psAttrValue != null && psAttrValue != "") {
      voStyle[psAttrName] = psAttrValue + "pt";
    }
  } else if(psAttrName == "backgroundImage") {
    // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
    // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
    if(psAttrValue.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = psAttrValue.split("\'");
      if(vsSplit[0] == "url(")
        voStyle["filter"] = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[2] + "')";
      else
        voStyle["filter"] = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[1] + "')";
    } else {
      voStyle[psAttrName] = psAttrValue;
    }
  } else if(voStyle[psAttrName] == undefined) {
    poCtrl[psAttrName] = psAttrValue;
  } else {
    voStyle[psAttrName] = psAttrValue;
  }
  if(poCtrl[psAttrName] != undefined) { poCtrl[psAttrName] = psAttrValue; }

  // Sub Ctrl이 있어 속성 값을 하위로 전달해야 되는 경우
  if(this.setAttrSubCtrl) { this.setAttrSubCtrl(psAttrName, psAttrValue, poCtrl); }
};
/**
 * 실체화 컨트롤에 설정된 속성값(style 속성값 포함)을 참조.
 * @param {String} psAttrName 속성명
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 실체화 컨트롤에 설정된 속성값
 * @type String
 */
eXria.controls.xhtml.UIControl.prototype.getAttrValueCtrl = function(psAttrName, poCtrl, poDocument) {
  var vsAttrValue = null;
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  if(poCtrl.style[psAttrName] == undefined) {
    vsAttrValue = poCtrl[psAttrName];
  } else {
    vsAttrValue = poCtrl.style[psAttrName];
  }
  if(vsAttrValue == undefined) { vsAttrValue = null; }

  return vsAttrValue;
};
/**
 * 실체화 컨트롤의 속성을 제거.
 * @param {String} psAttrName 속성명
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.UIControl.prototype.removeAttrCtrl = function(psAttrName, poCtrl, poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  if(this[psAttrName] != null) { this[psAttrName] = null; }
  poCtrl.removeAttribute(psAttrName);
};
/**
 * 기존에 설정된 UI의 공통 초기값을 제거.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.removeUIGeneralDefaults = function(poCtrl, poDocument) {
    //this.setAttrCtrl("display", "", poCtrl);
    //this.setAttrCtrl("zIndex", "", poCtrl);
    //this.setAttrCtrl("position", "", poCtrl);
    //this.setAttrCtrl("color", "", poCtrl);
    //this.setAttrCtrl("backgroundColor", "", poCtrl);
    //this.setAttrCtrl("borderWidth", "", poCtrl);
    //this.setAttrCtrl("borderStyle", "", poCtrl);
    //this.setAttrCtrl("borderColor", "", poCtrl);
    //this.setAttrCtrl("cursor", "", poCtrl);

    this.oldBorderWidth = null;
    this.oldBorderStyle = null;
    this.oldBorderColor = null;
};
/**
 * 컨트롤의 메인 css 스타일 클래스를 새로고침 하기 위한 메소드
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshMainStyles = function(poCtrl, poDocument) {
  this.setMainCtrlStyles(poCtrl, poDocument);
};
/**
 * 컨트롤에 적용될 공통속성(css 스타일 적용가능 속성)의 초기값 설정을 새로고침.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshUIGeneralDefaults = function(poCtrl, poDocument) {
  this.setUIGeneralDefaults(poCtrl, poDocument);
};
/**
 * 컨트롤별로 특화된 속성 설정을 새로고침.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  if(this.setSpecificDefaults)this.setSpecificDefaults(poCtrl, poDocument);
};

///**
// * 컨트롤에 적용될 공통속성(css 예외 속성)의 초기값 설정을 새로고침.
// * @param {HTMLDiv} poCtrl 실체화 컨트롤
// * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
// * @private
// */
//eXria.controls.xhtml.UIControl.prototype.refreshUIGeneralAttrs = function(poCtrl, poDocument) {
//  this.setUIGeneralAttrs(poCtrl);
//};

/**
 * 컨트롤에서 수행할 이벤트 처리를 재설정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.refreshUIGeneralEvents = function(poCtrl, poDocument) {
  this.setUIGeneralEvents(poCtrl);
};
/**
 * 컨트롤 활성화 여부 설정.
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {Boolean} psValue 컨트롤 disabled설정
 */
//eXria.controls.xhtml.UIControl.prototype.setDisable = function(poCtrl, psValue) {
//  this.disabled = psValue;
//  if(psValue == true){
//    if(poCtrl.disabled != undefined) poCtrl.disabled = psValue;
//
//    if(poCtrl.childNodes) {
//      var voChild = null;
//      for(var i = 0; i < poCtrl.childNodes.length; i++) {
//        voChild = poCtrl.childNodes[i];
//        this.setDisable(voChild, psValue);
//      }
//    }
//  }else{
//    if(poCtrl.disabled != undefined) poCtrl.removeAttribute("disabled");
//
//    if(poCtrl.childNodes) {
//      var voChild = null;
//      for(var i = 0; i < poCtrl.childNodes.length; i++) {
//        voChild = poCtrl.childNodes[i];
//        this.setDisable(voChild, psValue);
//      }
//    }
//  }
//};
eXria.controls.xhtml.UIControl.prototype.setDisable = function(poCtrl, psValue) {
  this.disabled = psValue;
  var voDocument = this.document;
  var voParent = poCtrl.parentNode;
  var vnLeft = 0;

  if(psValue == true){
    var voDiv = this.lookup(this.id + "_cover");
    var voStyle = null;
    if(this.type === "radio" || this.type === "checkbox"){
      if(voDiv == null) {
        var voIterator = this.frontItems.getValueCollection().iterator();
        var voDiv2 = null;
        var voStyle2 = null;
        
        while(voIterator.hasNext()){
          var voItem = voIterator.next();
          voDiv = voDocument.createElement("div");
          voDiv.className = "Default_Cover_OuterClass";
          voDiv.setAttribute("id", voItem.id + "_cover");
          voStyle = voDiv.style;
          if(this.position == null) this.position = this.getStyleCurrentValue(poCtrl, "position", "position");
    
          var vnZIndex = this.getAttrValue("zIndex", this.zIndex);
          if(vnZIndex == null) vnZIndex = this.getUIControlAttrValue("zIndex", this.zIndex);
          if(vnZIndex == null) vnZIndex = 0;
          voStyle.zIndex = vnZIndex + 1;
          voParent.appendChild(voDiv);
          this.cover = voDiv;
          
          voStyle = voDiv.style;
          voStyle.position = this.position;
          voStyle.left = this.left + voItem.left + 3 +"px";
          voStyle.top = this.top + voItem.top - 1 + "px";
          voStyle.width = "18px";
          voStyle.height = voItem.height + 2 + "px";
          if(this.visible == false) voStyle.display = "none";
          
          voDiv2 = voDocument.createElement("div");
          voDiv2.setAttribute("id", voItem.id + "_cover_2");
          voStyle2 = voDiv2.style;
          voStyle2.backgroundColor = "#ffffff";
          if(this.position == null) this.position = this.getStyleCurrentValue(poCtrl, "position", "position");
          
          var vnZIndex = this.getAttrValue("zIndex", this.zIndex);
          if(vnZIndex == null) vnZIndex = this.getUIControlAttrValue("zIndex", this.zIndex);
          if(vnZIndex == null) vnZIndex = 0;
          voStyle2.zIndex = vnZIndex + 1;
          voParent.appendChild(voDiv2);
          this.cover = voDiv2;
          
          voStyle2 = voDiv2.style;
          voStyle2.position = this.position;
          voStyle2.left = parseInt(voStyle.left) - 4 + "px";
          voStyle2.top = parseInt(voStyle.top)  - 1 + "px";
          voStyle2.width = voItem.width + 5 + "px";
          voStyle2.height = parseInt(voStyle.height) + 2 + "px";
          voStyle2.opacity = 0.1;
          if(this.visible == false) voStyle2.display = "none";
        }
      }
    }else{
      if(voDiv == null) {
        voDiv = voDocument.createElement("div");
        voDiv.className = "Default_Cover_OuterClass";
        voDiv.setAttribute("id", this.id + "_cover");
        voStyle = voDiv.style;
        if(this.position == null) this.position = this.getStyleCurrentValue(poCtrl, "position", "position");
  
  //      voStyle.backgroundColor = eXria.controls.xhtml.Default.Cover["backgroundColor"];
        var vnZIndex = this.getAttrValue("zIndex", this.zIndex);
        if(vnZIndex == null) vnZIndex = this.getUIControlAttrValue("zIndex", this.zIndex);
        if(vnZIndex == null) vnZIndex = 0;
        voStyle.zIndex = vnZIndex + 1;
  //      this.setOpacity(voDiv, eXria.controls.xhtml.Default.Cover["filter"], eXria.controls.xhtml.Default.Cover["opacity"]);
        voParent.appendChild(voDiv);
        this.cover = voDiv;
      }
      voStyle = voDiv.style;
  
      if(this.toString() === "Tab_TabHeader_TabButtons"){
        voStyle.position = "absolute";
        var vnTmpCnt = this.parent.parent.getIndexById(this.pageId);
        var vnTmp = poCtrl.style.borderLeftWidth.replace('px','') * 1 * 2 * vnTmpCnt;
        vnLeft = (poCtrl.style.width.replace('px','') * 1 * vnTmpCnt) + vnTmp;
      }else{
       voStyle.position = this.position;
      }
      voStyle.left = (vnLeft||this.left)+"px";
  
      voStyle.top = this.top + "px";
      voStyle.width = this.width + "px";
      voStyle.height = this.height + "px";
      if(this.visible == false) voStyle.display = "none";  
    }
  }else{
    //voDiv = this.lookup(this.id + "_cover");
    voDiv = this.cover;
    this.cover = null;
    if(voDiv != null && voParent) voParent.removeChild(voDiv);
  }
};
/**
 * 실체화 객체의 커서 변경 하위 노드까지 포함.
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {String} psValue 커서 타입 구분 문자열
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setCursor = function(poCtrl, psValue) {
  var voStyle = poCtrl.style;
  if(voStyle) voStyle.cursor = psValue;

  if(poCtrl.childNodes) {
    var voChild = null;
    for(var i = 0; i < poCtrl.childNodes.length; i++) {
      voChild = poCtrl.childNodes[i];
      this.setCursor(voChild, psValue);
    }
  }
};
/**
 * 불투명도를 설정.
 * @param {HTMLElement} poCtrl 실체화 객
 * @param {String} psFilter IE에 적용될 형식의 알파필터 스트링.<br>
 * ex) alpha(opacity:50)
 * @param {String} psOpacity 값의 범위 0 ~ 1.0
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setOpacity = function(poCtrl, psFilter, psOpacity) {
  var voStyle = poCtrl.style;
  if(psOpacity) {
    var vnNumber = parseInt(parseFloat(psOpacity) * 100);
    var vsFilter = "alpha(opacity=\"" + vnNumber + "\");";
    voStyle.filter = vsFilter;
  }
  if(psOpacity) voStyle.KHTMLOpacity = psOpacity;
  if(psOpacity) voStyle.MozOpacity = psOpacity;
  if(psOpacity) voStyle.opacity = psOpacity;
};
/**
 * 스트링 버퍼에 불투명도 값을 설정하는 메소드.
 * @param {HTMLElement} poCtrl 실체화 객
 * @param {String} psFilter IE에 적용될 형식의 알파필터 스트링.<br>
 * ex) alpha(opacity:50)
 * @param {String} psOpacity 값의 범위 0 ~ 1.0
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setOpacityToCssStrBuf = function(paCssStrBuf, psFilter, psOpacity) {
//2013.7.19 수정 IE10 부터 DX 필터 호환안됨.(filter -> opacity) 수정 박상찬 
  if(this.canvas.page.metadata.browser.ie < 10) {
    paCssStrBuf.push("filter:");
    paCssStrBuf.push(psFilter);
    paCssStrBuf.push(";");
  } else {
    //paCssStrBuf.push("KHTMLOpacity:");
    //paCssStrBuf.push(psOpacity);
    //paCssStrBuf.push(";");
    //paCssStrBuf.push("MozOpacity:");
    //paCssStrBuf.push(psOpacity);
    //paCssStrBuf.push(";");
    paCssStrBuf.push("opacity:");
    paCssStrBuf.push(psOpacity);
    paCssStrBuf.push(";");
  }
};
/**
 * 수직정렬 처리.
 * @param {HTMLElement} poCtrl 수직정렬 대상 Element
 * @param {HTMLElement} poParent 수직정렬 대상 Element 의 상위 Element
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setVerticalAlign = function(poCtrl, poParent, psVAlign) {

  if(poCtrl.offsetHeight !== 0)
   this.divOffsetHeight = poCtrl.offsetHeight;

  if(!this.divOffsetHeight)
   this.divOffsetHeight = 0;


  var vnHeight = this.divOffsetHeight;

  if(psVAlign == null) psVAlign = "middle";
  var vnParentHeight = poParent.style.height;
  if(vnParentHeight == "") vnParentHeight = "0";
  vnParentHeight = parseInt(vnParentHeight);
  var vnPBorderTopWidth = poParent.style.borderTopWidth;
  if(vnPBorderTopWidth == "") vnPBorderTopWidth = poParent.style.borderWidth;
  if(vnPBorderTopWidth == "") vnPBorderTopWidth = "0"
  vnPBorderTopWidth = parseInt(vnPBorderTopWidth);
  var vnPBorderBottomWidth = poParent.style.borderBottomWidth;
  if(vnPBorderBottomWidth == "") vnPBorderBottomWidth = poParent.style.borderWidth;
  if(vnPBorderBottomWidth == "") vnPBorderBottomWidth = "0"
  vnPBorderBottomWidth = parseInt(vnPBorderBottomWidth);
  vnParentHeight -= vnPBorderTopWidth + vnPBorderBottomWidth;
  var vnPadding = vnParentHeight - vnHeight;
  if(vnPadding < 0) vnPadding = 0;
  switch(psVAlign) {
  case "top" :
    poCtrl.style.top = "0px";
    poCtrl.style.bottom = "";
    break;
  case "bottom" :
    poCtrl.style.top = ""; //(vnParentHeight - vnPadding)
    poCtrl.style.bottom = "0px";
    break;
  case "middle" :
    var vnPadding = vnPadding / 2;
    if(vnParentHeight < vnHeight) vnPadding = 0;
    poCtrl.style.top = vnPadding + "px";
    poCtrl.style.bottom = "";
    break;
  }
};

/////////////////////////////////////////////////////////////////////////////
/**
 * @class Tooltip 처리 오브젝트 생성 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.UIControl} poParent Tooltip이 표시될 UI컨트롤 객체
 * @return Tooltip 처리 오브젝트
 * @type eXria.controls.xhtml.UIControl_tooltipHandler
 * @constructor
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler = function(poParent) {
  this.parent = poParent;
  this.rightBottomImage = null;//poParent.getTooltipAttrValue("rightBottomImage", this.rightBottomImage);
  this.leftBottomImage = null;//poParent.getTooltipAttrValue("leftBottomImage", this.leftBottomImage);
  this.rightTopImage = null;//poParent.getTooltipAttrValue("rightTopImage", this.rightTopImage);
  this.leftTopImage = null;//poParent.getTooltipAttrValue("leftTopImage", this.leftTopImage);
  this.borderWidth = null;
  this.borderStyle = null;
  this.borderColor = null;
  this.backgroundColor = null;
  this.fontSize = null;
  this.filter = null;
  this.opacity = null;
  this.width = null;
  this.height = null;
  this.data = new eXria.controls.DataRefNode(this.parent);
  this.fontFamily      = null;
  this.fontStyle       = null;
  this.fontWeight      = null;
  this.padding         = null;
  this.paddingLeft     = null;
  this.paddingRight    = null;
  this.paddingTop      = null;
  this.paddingBottom   = null;
  this.backgroundImage = null;
  this.backgroundPosition = null;
  this.backgroundRepeat = null;

};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler.prototype.setCtrl = function() {    // 툴팁을 설정한다.
  var voDocument = this.document
  var voParent = this.parent;
  var voTooltipCtrl = null;
  var voTooltipArrow = null;
  var voTooltipContent = null;

  var voData = this.data;
  var vsInstanceId = voData.instanceId;
  var vsRef = voData.instancePath;
//  if(voParent.id == "btn3") debugger
  if((voParent.tooltip != null && voParent.tooltip.length != 0) || (vsInstanceId && vsRef)) {    // 툴팁으로 사용할 내용이 있는 경우
    var voOldTooltip = null;
    voOldTooltip = voDocument.getElementById(voParent.id + "_Tooltip");
    var vsTooltip = null;

    if(vsInstanceId && vsRef) {
      vsTooltip = voData.getData();
    } else {
      vsTooltip = eXria.controls.xhtml.Util.parseLang(voParent.tooltip);
    }

    if(!voOldTooltip) {  // 기존에 생성한 툴팁이 없는 경우 새롭게 생성
      voTooltipCtrl = voDocument.createElement("DIV");  // Create tooltip ctrl
      voTooltipCtrl.id = voParent.id + "_Tooltip";
      var voStyle = voTooltipCtrl.style;
      voTooltipCtrl.style.position = "absolute";
      voTooltipCtrl.style.zIndex = 1000005;
      //var voTooltipArrow = voDocument.createElement("IMG");
      //voTooltipArrow.id = voParent.id + "_TooltipArrow";
      //if(this.rightBottomImage) voTooltipArrow.src  = this.rightBottomImage;
      //voStyle = voTooltipArrow.style;
      voStyle.position = "absolute";
      voStyle.zIndex = 1000005;
      //voTooltipCtrl.appendChild(voTooltipArrow);

      var voTempImage = new Image();
    //this.rightBottomImage null check 최현종
    if(this.rightBottomImage) { voTempImage.src = this.rightBottomImage; }

      voTooltipContent = voDocument.createElement("SPAN"); // Create content div */
      voStyle = voTooltipContent.style;
      voTooltipContent.id = voParent.id + "_TooltipContent";
      //voTooltipContent.className = "tooltip_content";
      //var tooltipCSS = voParent.getCSSClass("ToolTip", 0);
      var tooltipCSS = "Default_UIControl_OuterClass Default_Form_ToolTip_OuterClass Default_Form_ToolTip_Class";
      voTooltipContent.className = tooltipCSS;

      //alert("시작 : " + voStyle["fontSize"] + "" + voStyle["padding"]);
      var voCanvas = voParent.canvas;

      voParent.setAttrCtrl("fontFamily", voCanvas.tooltipHandler.fontFamily, voTooltipContent);
      voParent.setAttrCtrl("fontStyle", voCanvas.tooltipHandler.fontStyle, voTooltipContent);
      voParent.setAttrCtrl("fontWeight", voCanvas.tooltipHandler.fontWeight, voTooltipContent);
      voParent.setAttrCtrl("padding", voCanvas.tooltipHandler.padding, voTooltipContent);
      voParent.setAttrCtrl("paddingRight", voCanvas.tooltipHandler.paddingRight, voTooltipContent);
      voParent.setAttrCtrl("paddingTop", voCanvas.tooltipHandler.paddingTop, voTooltipContent);
      voParent.setAttrCtrl("paddingBottom", voCanvas.tooltipHandler.paddingBottom, voTooltipContent);
      voParent.setAttrCtrl("borderWidth", voCanvas.tooltipHandler.borderWidth, voTooltipContent);
      voParent.setAttrCtrl("backgroundColor", voCanvas.tooltipHandler.backgroundColor, voTooltipContent);
      voParent.setAttrCtrl("fontSize", voCanvas.tooltipHandler.fontSize, voTooltipContent);
      voParent.setAttrCtrl("borderColor", voCanvas.tooltipHandler.borderColor, voTooltipContent);
      voParent.setAttrCtrl("borderStyle", voCanvas.tooltipHandler.borderStyle, voTooltipContent);
      voParent.setAttrCtrl("filter", voCanvas.tooltipHandler.filter, voTooltipContent);
      voParent.setAttrCtrl("opacity", voCanvas.tooltipHandler.opacity, voTooltipContent);
      voParent.setAttrCtrl("width", voCanvas.tooltipHandler.width, voTooltipContent);
      voParent.setAttrCtrl("height", voCanvas.tooltipHandler.height, voTooltipContent);
      voParent.setAttrCtrl("backgroundImage", voCanvas.tooltipHandler.backgroundImage, voTooltipContent);
      voParent.setAttrCtrl("backgroundPosition", voCanvas.tooltipHandler.backgroundPosition, voTooltipContent);
      voParent.setAttrCtrl("backgroundRepeat", voCanvas.tooltipHandler.backgroundRepeat, voTooltipContent);

      voStyle.position = "absolute";
      voStyle.overflow = "visible";
      voStyle.wordBreak = "keep-all";
      voStyle.whiteSpace = "nowrap";
      voStyle.top = "3px";
      voStyle.zIndex = 1000001;

      if(voTempImage) voStyle.left = voTempImage.width;
      if(voStyle.borderWidth) voStyle.left = voStyle.left - parseInt(voStyle.borderWidth);

    //else voStyle.left = voTempImage.width;


      voParent.setText(voTooltipContent, vsTooltip);
      voTooltipCtrl.appendChild(voTooltipContent);

      //voParent.setOpacity(voTooltipArrow, this.filter, this.opacity);
      voParent.setOpacity(voTooltipContent, this.filter,  voCanvas.tooltipHandler.opacity);

      voDocument.getElementById(voParent.canvas.id).appendChild(voTooltipCtrl);

      //this.width = voTooltipArrow.offsetWidth + voTooltipContent.offsetWidth;
      //this.height = voTooltipArrow.offsetHeight + voTooltipContent.offsetHeight;

      voTooltipCtrl.style.display = "none";
    } else {
      var voSpan = voParent.getSubCtrl("span", voOldTooltip);
      voParent.setText(voSpan, vsTooltip);
    }
  } else {  // 툴팁으로 사용할 내용이 없는 경우
    var voOldTooltip = voDocument.getElementById(voParent.id + "_Tooltip");
    if(voOldTooltip) {  // 기존에 생성한 툴팁이 있는 경우 이를 삭제
      voDocument.getElementById(voParent.canvas.id).removeChild(voOldTooltip);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler.prototype.modifyPosition = function(poTooltip) {
  var voDocument = this.document;
  var voParent = this.parent;

  //var voTooltipArrow = voDocument.getElementById(voParent.id + "_TooltipArrow");
  var voTooltipContent = voDocument.getElementById(voParent.id + "_TooltipContent");
  //voTooltipArrow.style.left = "0px";
  //voTooltipArrow.style.top = "0px";
  voTooltipContent.style.left = "1px";
  voTooltipContent.style.top = "1px";

//  alert(
//  "voParent.canvas.width : " + voParent.canvas.width
//  +"\n" + "poTooltip.offsetLeft : " + poTooltip.offsetLeft
//  +"\n" + "voTooltipContent.offsetWidth : " + voTooltipContent.offsetWidth
//  +"\n" + "voTooltipContent.offsetLeft : " + voTooltipContent.offsetLeft
//  +"\n" + "voParent.canvas.height : " + voParent.canvas.height
//  +"\n" + "poTooltip.offsetTop : " + poTooltip.offsetTop
//  +"\n" + "voTooltipContent.offsetHeight : " + voTooltipContent.offsetHeight
//  +"\n" + "voTooltipContent.offsetTop : " + voTooltipContent.offsetTop
//  +"\n" + "==============================="
//  +"\n" + "viewportWidth : " + viewportWidth
//  +"\n" + "viewportHeight : " + viewportHeight
//  +"\n" + "horizontalScroll : " + horizontalScroll
//  +"\n" + "verticalScroll : " + verticalScroll
//  )
//
//  //poTooltip.style.left == poTooltip.offsetLeft
//  //voTooltipContent.style.left == voTooltipContent.offsetLeft
//  //debugger;
//  //window;

  // HTML 문서가 표시되는 화상 표시 영역인 뷰포트(viewport)의 크기
  // 이것은 브라우저 창 크기에서 메뉴바, 툴바, 스크롤바 등의 크기를 뺀 나머지
  var viewportWidth;
  var viewportHeight;

  // 다음의 값들은 수평, 수직 스크롤바의 위치를 나타내며, 문서 좌표와 창
  // 좌표를 상호 변환하는데 사용된다. 이 값들은 화면의 좌측 상단
  // 모서리에 문서의 어느 부분이 위치하는지 나타낸다.
  //var horizontalScroll;
  //var verticalScroll;

  if(voParent.canvas.page.metadata.browser.ie){
    viewportWidth = this.document.documentElement.clientWidth;
    viewportHeight = this.document.documentElement.clientHeight;
    //horizontalScroll = this.document.documentElement.scrollLeft;
    //verticalScroll = this.document.documentElemnet.scrollTop;
  }else{
    viewportWidth = window.innerWidth;
    viewportHeight = window.innerHeight;
    //horizontalScroll = window.pageXOffset;
    //verticalScroll = window.pageYOffset;
  }

  //check horizontal position
  if(viewportWidth < poTooltip.offsetLeft+voTooltipContent.offsetWidth){
//    alert(
//    "poTooltip.offsetLeft : " + poTooltip.offsetLeft
//    +"\n" + "voTooltipContent.offsetWidth : " + voTooltipContent.offsetWidth
//    +"\n" + "poTooltip.offsetLeft-voTooltipContent.offsetWidth : " + parseInt(poTooltip.offsetLeft-voTooltipContent.offsetWidth));
    poTooltip.style.left = parseInt(poTooltip.offsetLeft-voTooltipContent.offsetWidth-12)+"px";
  }
  // check vertical position
  if(viewportHeight < poTooltip.offsetTop+voTooltipContent.offsetHeight){
//    alert(
//    "poTooltip.offsetTop : " + poTooltip.offsetTop
//    +"\n" + "voTooltipContent.offsetHeight : " + voTooltipContent.offsetHeight
//    +"\n" + "poTooltip.offsetTop-voTooltipContent.offsetHeight : " + parseInt(poTooltip.offsetTop-voTooltipContent.offsetHeight));
    poTooltip.style.top = parseInt(poTooltip.offsetTop-voTooltipContent.offsetHeight-10)+"px";
  }

};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler.prototype.show = function(e) {
//  if(posy < this.top && posy > this.bottom && posx < this.right && posx > this.left) {
//     return false;
//  }
  if(!this.document) this.document = this.parent.document;
  var voDocument = this.document;
  var voParent = this.parent;
  var voTooltip = voDocument.getElementById(voParent.id + "_Tooltip");
  if(voTooltip) {
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    voTooltip.style.top = posy + 15 + "px";
    voTooltip.style.left = posx + 10 + "px";
    if(voTooltip.style.display == "none") {
      voTooltip.style.display = "block";
    }
    this.modifyPosition(voTooltip);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler.prototype.hide = function(e, poDocument) {
  var voDocument = this.document;
  if(poDocument) voDocument = poDocument;
  if(voDocument == null) return;
  var voTooltip = voDocument.getElementById(this.parent.id + "_Tooltip");
  if(voTooltip) {
    if(voTooltip.style.display == "block") {
      voTooltip.style.display = "none";
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_tooltipHandler.prototype.move = function(e) {
  var voDocument = this.document;
  var voTooltip = voDocument.getElementById(this.parent.id + "_Tooltip");
  if(voTooltip) {
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    voTooltip.style.top = posy + 15 + "px";
    voTooltip.style.left = posx + 10 + "px";

    this.modifyPosition(voTooltip);
  }
};

/////////////////////////////////////////////////////////////////////////////
/**
 * @class 컨트롤의 이동 또는 크기 변경시에 윤곽선을 나타내주는 DIV 객체 생성 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.UIControl} poParent 이동할 UI컨트롤 객체
 * @return 컨트롤의 이동 또는 크기 변경시에 윤곽선을 나타내주는 DIV 객체
 * @type eXria.controls.xhtml.UIControl_paneHandler
 * @constructor
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler = function(poParent) {
  this.parent = poParent;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.createPane = function(pnLeft, pnTop, pnWidth, pnHeight, poDocument) {
  var voDocument = poDocument;
  if(voDocument == null) voDocument = this.document;
  var voParent = this.parent;
  var voCtrl = voParent.getCtrl();
//  var voParentNode = voCtrl.parentNode;
  var voParentNode = voParent.glassPane.ctrl;
  var thisStyle = voCtrl.style;
  var voPane = voDocument.createElement("div");
  voPane.setAttribute("id", voParent.id + "_dragDrop");

  if(pnLeft == null && pnLeft !== 0) pnLeft = thisStyle.left;
  else pnLeft += "px";
  if(pnTop == null && pnTop !== 0) pnTop = thisStyle.top;
  else pnTop += "px";
  if(pnWidth == null && pnWidth !== 0) pnWidth = voParent.width;
  if(pnHeight == null && pnHeight !== 0) pnHeight = voParent.height;

  var voStyle = voPane.style;
  voStyle.position = "absolute";
  voStyle.left = pnLeft;
  voStyle.top = pnTop;
  var vnBorderWidth = voParent.borderWidth;
  if(voParent.borderStyle == null || voParent.borderStyle == "none") vnBorderWidth = 0;
  voStyle.width = (pnWidth - 2 * 1) + "px";
  voStyle.height = (pnHeight - 2 * 1) + "px";
  voStyle.backgroundColor = "yellow";
  voStyle.opacity = voParent.paneOpacity / 100;
  voStyle.filter = "alpha(opacity=" + voParent.paneOpacity + ")";
  voStyle.zIndex = 1000010; //Number(thisStyle.zIndex) + 1;
  voStyle.borderColor ="black";
  voStyle.borderStyle ="dotted";
  voStyle.borderWidth = "1px";
  // TODO : voStyle.display = "none";
  this.ctrl = voPane;
  voParentNode.appendChild(voPane);
  return voPane;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.getStyle = function() {
  return this.ctrl.style;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.getCtrl = function() {
  return this.ctrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.removePane = function() {
  var voParent = this.parent;
  voParentNode = voParent.glassPane.ctrl;
  var voPaneCtrl = this.ctrl;
  voPaneCtrl.style.display = "none";
  voParentNode.removeChild(voPaneCtrl);
  if(this.scrAreaLeft) {
    this.scrAreaLeft.onmouseover = null;
    this.scrAreaLeft.style.display = "none";
    voParentNode.removeChild(this.scrAreaLeft);
  }
  if(this.scrAreaRight) {
    this.scrAreaRight.onmouseover = null;
    this.scrAreaRight.style.display = "none";
    voParentNode.removeChild(this.scrAreaRight);
  }
  if(this.scrAreaTop) {
    this.scrAreaTop.onmouseover = null;
    this.scrAreaTop.style.display = "none";
    voParentNode.removeChild(this.scrAreaTop);
  }
  if(this.scrAreaBottom) {
    this.scrAreaBottom.onmouseover = null;
    this.scrAreaBottom.style.display = "none";
    voParentNode.removeChild(this.scrAreaBottom);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.applyAttrCtrl = function(psAttrName, psAttrValue) {
  var voPaneCtrl = this.ctrl;
  if(voPaneCtrl.style[psAttrName] == undefined) {
    voPaneCtrl.setAttribute(psAttrName, psAttrValue);
  } else {
    voPaneCtrl.style[psAttrName] = psAttrValue;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_dragDropHandler.prototype.createScrollArea = function(pnLeft, pnTop, pnWidth, pnHeight, pnDropWidth, pnDropHeight, psPos, poDocument) {
  var voParent = this.parent;
  var voCtrl = voParent.getCtrl();
//  var voParentNode = voCtrl.parentNode;
  var voParentNode = voParent.glassPane.ctrl;
  var thisStyle = voCtrl.style;
  var voScrollArea = poDocument.createElement("div");
  voScrollArea.setAttribute("id", voParent.id + "_scrollArea_" + psPos);

  var voStyle = voScrollArea.style;
  voStyle.position = "absolute";
  voStyle.zIndex = 1000010; //Number(thisStyle.zIndex) + 1;
  var vnBorderWidth = voParent.borderWidth;
  if(voParent.borderStyle == null || voParent.borderStyle == "none") vnBorderWidth = 0;
  switch(psPos) {
  case "top" :
    voStyle.left = pnLeft;
    voStyle.top = pnTop;
    voStyle.width = (pnWidth - 2 * 1) + "px";
    voStyle.height = pnDropHeight + "px";
    this.scrAreaTop = voScrollArea;
    break;
  case "bottom" :
    voStyle.left = pnLeft;
    voStyle.top = (pnTop + pnHeight - pnDropHeight) + "px";
    voStyle.width = (pnWidth - 2 * 1) + "px";
    voStyle.height = pnDropHeight + "px";
    this.scrAreaBottom = voScrollArea;
    break;
  case "left" :
    voStyle.left = pnLeft + "px";
    voStyle.top = pnTop + "px";
    voStyle.width = pnDropWidth + "px";
    voStyle.height = (pnHeight - 2 * 1) + "px";
    this.scrAreaLeft = voScrollArea;
    break;
  case "right" :
    voStyle.left = (pnLeft + pnWidth - pnDropWidth) + "px";
    voStyle.top = pnTop + "px";
    voStyle.width = pnDropWidth + "px";
    voStyle.height = (pnHeight - 2 * 1) + "px";
    this.scrAreaRight = voScrollArea;
    break;
  }
//  voStyle.backgroundColor = "yellow";
//  voStyle.opacity = voParent.paneOpacity / 100;
//  voStyle.filter = "alpha(opacity=" + voParent.paneOpacity + ")";
//  voStyle.borderColor ="black";
//  voStyle.borderStyle ="dotted";
//  voStyle.borderWidth = "1px";
// TODO : voStyle.display = "none";
  voParentNode.appendChild(voScrollArea);
  return voScrollArea;
};
/////////////////////////////////////////////////////////////////////////////
/**
 * @class 컨트롤의 이동 또는 크기 변경시에 윤곽선을 나타내주는 DIV 객체 생성 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.UIControl} poParent 이동할 UI컨트롤 객체
 * @return 컨트롤의 이동 또는 크기 변경시에 윤곽선을 나타내주는 DIV 객체
 * @type eXria.controls.xhtml.UIControl_paneHandler
 * @constructor
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler = function(poParent) {
  this.parent = poParent;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler.prototype.createPane = function() {
  var voDocument = this.document;
  var voParent = this.parent;
  var voCtrl = voParent.getCtrl();
//  var voParentNode = voCtrl.parentNode;
  var voParentNode = voParent.glassPane.ctrl;
  var thisStyle = voCtrl.style;
  var voPane = voDocument.createElement("div");
  voPane.setAttribute("id", voParent.id + "_pane");

  var voStyle = voPane.style;
  voStyle.position = "absolute";
  voStyle.left = thisStyle.left;
  voStyle.top = thisStyle.top;
  var vnBorderWidth = voParent.borderWidth;
  if(voParent.borderStyle == null || voParent.borderStyle == "none") vnBorderWidth = 0;
  voStyle.width = (voParent.width - 2 * 1) + "px";
  voStyle.height = (voParent.height - 2 * 1) + "px";
  voStyle.backgroundColor = "yellow";
  voStyle.opacity = voParent.paneOpacity / 100;
  voStyle.filter = "alpha(opacity=" + voParent.paneOpacity + ")";
  voStyle.zIndex = 1000010; //Number(thisStyle.zIndex) + 1;
  voStyle.borderColor ="black";
  voStyle.borderStyle ="dotted";
  voStyle.borderWidth = "1px";
  // TODO : voStyle.display = "none";
  voParentNode.appendChild(voPane);
  return voPane;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler.prototype.getStyle = function() {
  var voPane = this.document.getElementById(this.parent.id + "_pane");
  return voPane.style;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler.prototype.getCtrl = function() {
  var voPaneCtrl = this.document.getElementById(this.parent.id + "_pane");
  return voPaneCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler.prototype.removePane = function() {
  var voParent = this.parent;
//  var voParentNode = voParent.getCtrl().parentNode;
  voParentNode = voParent.glassPane.ctrl;
  var voPaneCtrl = voParent.paneHandler.getCtrl();
  voPaneCtrl.style.display = "none";
  voParentNode.removeChild(voPaneCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.UIControl_paneHandler.prototype.applyAttrCtrl = function(psAttrName, psAttrValue) {
  var voPaneCtrl = this.parent.paneHandler.getCtrl();
  if(voPaneCtrl.style[psAttrName] == undefined) {
    voPaneCtrl.setAttribute(psAttrName, psAttrValue);
  } else {
    voPaneCtrl.style[psAttrName] = psAttrValue;
  }
};
/**
 * 공통 초기화 수행 메소드
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.initUIGeneral = function() {
  //this.tooltipHandler.parent = this;    // tooltipHandler에 컨트롤 참조를 설정
  this.tooltipHandler = new eXria.controls.xhtml.UIControl_tooltipHandler(this);
  this.paneHandler = new eXria.controls.xhtml.UIControl_paneHandler(this);
  this.dragDropHandler = new eXria.controls.xhtml.UIControl_dragDropHandler(this);
};
/**
 * Style 속성 스트링 버퍼에 속성 추가 메소드
 * @param {Array} paCssStrBuf Style 스트링 버퍼
 * @param {String} psName 스타일 속성명
 * @param {String} psValue 스타일 속성값
 * @parem {String} psUnit 수치형 속성값의 단위
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setCssStrBuf = function(paCssStrBuf, psName, psValue, psUnit) {
  if(psValue != null) {
    paCssStrBuf.push(psName);
    paCssStrBuf.push(":");
    paCssStrBuf.push(psValue);
    if(psUnit) paCssStrBuf.push(psUnit);
    paCssStrBuf.push(";");
  }
};
/**
 * Element 속성 스트링 버퍼에 속성 추가 메소드
 * @param {Array} paAttStrBuf Element 속성 스트링 버퍼
 * @param {String} psName Element 속성명
 * @param {String} psValue Element 속성값
 * @parem {String} psUnit 수치형 속성값의 단위
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setAttStrBuf = function(paAttStrBuf, psName, psValue, psUnit) {
  if(psValue != null) {
    paAttStrBuf.push(psName);
    paAttStrBuf.push("=\"");
    paAttStrBuf.push(psValue);
    if(psUnit) paAttStrBuf.push(psUnit);
    paAttStrBuf.push("\" ");
  }
};
/**
 * 이벤트 핸들러를 정의하는 문자열을 반환합니다.
 * @param {String} psId 컨트롤 id
 * @param {String} psFuncName 이벤트 핸들러 내부에서 호출되는 working 메소드 명
 * @return 이벤트 핸들러를 정의하는 문자열
 * @type String
 */
eXria.controls.xhtml.UIControl.prototype.getEHandler = function(psId, psFuncName) {
  var vaStrBuf = [];
  //vaStrBuf.push("var e=null;");
  //vaStrBuf.push("if(arguments[0]) e=arguments[0];");
  vaStrBuf.push("page.getControl('");
  vaStrBuf.push(psId);
  vaStrBuf.push("').");
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(event);");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};

/**
 * 이벤트 핸들러를 정의하는 문자열을 반환합니다.
 * @param {String} psId 컨트롤 id
 * @param {String} psItemId 컨트롤에 속해있는 ItemList중 선택된 Item Id
 * @param {String} psFuncName 이벤트 핸들러 내부에서 호출되는 working 메소드 명
 * @return 이벤트 핸들러를 정의하는 문자열
 * @type String
 */
eXria.controls.xhtml.UIControl.prototype.getEItemHandler = function(psId, psItemId, psFuncName) {
  var vaStrBuf = [];
  //vaStrBuf.push("var e=null;");
  //vaStrBuf.push("if(arguments[0]) e=arguments[0];");

  vaStrBuf.push("page.getControl('");
  vaStrBuf.push(psId);
  vaStrBuf.push("').");
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(event,'");
  vaStrBuf.push(psItemId);
  vaStrBuf.push("');");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * 컨트롤 이동 관련
 * @return  0
 * @type Number
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.getClientAbsLeft = function() { return 0; };
/**
 * 컨트롤 이동 관련
 * @return  0
 * @type Number
 * @ignore
 */
eXria.controls.xhtml.UIControl.prototype.getClientAbsTop = function() { return 0; };
/**
 * 컨트롤의 동적 위치 이동 허용여부를 지정합니다.
 * @param {Boolean} pbMove 위치이동 가능 여부
 */
eXria.controls.xhtml.UIControl.prototype.setMove = function(pbMove) {
  var voCtrl = this.getCtrl();
  if(voCtrl == null) return;

  if(pbMove) {
    this.movable = true;
  } else {
    this.movable = false;
  }
};
/**
 * startMove<br>
 * 컨트롤 동적 위치 이동이 가능한 경우 컨트롤에 mousedown이벤트 발생 시 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.startMove = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voParent = this.parent;
  if(voParent == null) voParent = this.canvas;
  var voCtrl = this.getCtrl();

  var voGlassPane = new eXria.controls.xhtml.GlassPane(voParent);
  this.glassPane = voGlassPane;
  voGlassPane.opacity = 10;
  voParent.ctrl.parentNode.appendChild(voGlassPane.create(voDocument));

  var voPane = this.paneHandler.createPane();
  var voPaneStyle = voPane.style;

  var voEvent = e;
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;

  this.clientAbsLeft = this.getClientAbsLeft();
  this.clientAbsTop = this.getClientAbsTop();

  var vnMouseX = voEvent.e.clientX - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY - this.clientAbsTop;

  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;

  this.backupCtrlCsr = this.getCtrl().style.cursor;
  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "move";
  this.getCtrl().style.cursor = "move";

  voPane.control = this;
  voPane.onmousemove = function(e) {
    this.control.onMove(e);
  };
  voPane.onmouseup = function(e) {
    this.control.stopMove(e);
  };
  voDocument.control = this;
  voDocument.onmousemove = function(e) {
    //this.getEHandler(this.id, "onMove");
    this.control.onMove(e);
  };
  voDocument.onmouseup = function(e) {
    //this.getEHandler(this.id, "stopMove");
    this.control.stopMove(e);
  };
  if (typeof voPane.onselectstart != "undefined") {
    voPane.onselectstart = function(e) {
      return false;
    };
  } else {
    voPane.onmousedown = function(e) {
      return false;
    };
  }
};
/**
 * 컨트롤 동적 위치 이동 시 마우스 드래그 상태에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.onMove = function(e) {
  var voCtrl = this.getCtrl();
  var voParentNode = voCtrl.parentNode;
  var voPaneCtrl = this.paneHandler.getCtrl();
  if(voCtrl == null || voPaneCtrl == null) {
      return;
  }

  var voStyle = voPaneCtrl.style;

  var voEvent = new eXria.event.Event(e, this.window);
  var voTarget = voEvent.target;
  if(voTarget == voPaneCtrl || voTarget == voPaneCtrl.parentNode) {
  } else {
    return;
  }
  var vnMouseX = voEvent.e.clientX; // - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY; // - this.clientAbsTop;

  var vnNewLeft = vnMouseX + this.leftOffset;
  var vnNewTop = vnMouseY + this.topOffset;

  if(voParentNode.style.left == null || voParentNode.style.left == "") voParentNode.style.left = 0;
  if(voParentNode.style.top == null || voParentNode.style.top == "") voParentNode.style.top = 0;
//  voStyle.left = vnNewLeft - parseInt(voParentNode.style.left) + "px";
//  voStyle.top = vnNewTop - parseInt(voParentNode.style.top) + "px";
  voStyle.left = vnNewLeft + "px";
  voStyle.top = vnNewTop + "px";
};
/**
 * 컨트롤 동적 위치 이동 시 mouseup 이벤트에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.stopMove = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voCtrl = this.getCtrl();
  var voPane = this.paneHandler.getCtrl();
  var voPaneStyle = voPane.style;

  this.left = parseInt(voPaneStyle.left);
  this.top = parseInt(voPaneStyle.top);
  
  this.applyAttr("left", this.left);
  this.applyAttr("top", this.top);
  
  this.paneHandler.removePane();
  this.glassPane.removeCtrl();
  // Check
  voDocument.body.style.cursor = "auto";
  voCtrl.style.cursor = this.backupCtrlCsr;

  voPane.onmousemove = null;
  voPane.onmouseup = null;
  voDocument.onmousemove = null;
  voDocument.onmouseup = null;
  if (typeof voPane.onselectstart != "undefined") {
    voPane.onselectstart = null;
  } else {
    voPane.onmousedown = null;
  }

  this.mode = null;
  this.leftOffset = -1;
  this.topOffset = -1;
  this.rightOffset = -1;
  this.bottomOffset = -1;
};
/**
 * startDrag<br>
 * 컨트롤 Drag&Drop이 가능한 경우 컨트롤에 mousedown이벤트 발생 시 처리 수행
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.startDrag = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voParent = this.parent;
  if(voParent == null) voParent = this.canvas;
  var voCtrl = this.ctrl;

  var voGlassPane = new eXria.controls.xhtml.GlassPane(voParent);
  this.glassPane = voGlassPane;
  voGlassPane.opacity = 50;
  voParent.ctrl.parentNode.appendChild(voGlassPane.create(voDocument));

  this.dragDropHandler.srcObject = this;
  this.dragDropHandler.srcObjectType = null;
  var voPaneCtrl = this.dragDropHandler.createPane();
  var voPaneStyle = voPaneCtrl.style;

  var voEvent = e;
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;

  this.clientAbsLeft = this.getClientAbsLeft();
  this.clientAbsTop = this.getClientAbsTop();

  var vnMouseX = voEvent.e.clientX - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY - this.clientAbsTop;

  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;

  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "move";
  this.getCtrl().style.cursor = "move";

  voPaneCtrl.control = this;
  voPaneCtrl.onmousemove = function(e) {
    this.control.onDrag(e);
  };
  voPaneCtrl.onmouseup = function(e) {
    this.control.stopDrag(e);
  };
  voDocument.control = this;
  voDocument.onmousemove = function(e) {
    this.control.onDrag(e);
  };
  voDocument.onmouseup = function(e) {
    this.control.stopDrag(e);
  };
  if (typeof voPaneCtrl.onselectstart != "undefined") {
    voPaneCtrl.onselectstart = function(e) {
      return false;
    };
  } else {
    voPaneCtrl.onmousedown = function(e) {
      return false;
    };
  }
};
/**
 * 컨트롤 Drag&Drop 시 마우스 드래그 상태에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.onDrag = function(e) {
  var voCtrl = this.getCtrl();
  var voPaneCtrl = this.dragDropHandler.ctrl;
  if(voCtrl == null || voPaneCtrl == null) {
      return;
  }

  var voStyle = voPaneCtrl.style;
  var voEvent = new eXria.event.Event(e, voPaneCtrl.document.parentWindow);
  var voTarget = voEvent.target;
  if(voTarget == voPaneCtrl || voTarget == voPaneCtrl.parentNode) {
  } else {
    return;
  }
  var vnMouseX = voEvent.e.clientX; // - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY; // - this.clientAbsTop;

  var vnNewLeft = vnMouseX + this.leftOffset;
  var vnNewTop = vnMouseY + this.topOffset;

  voStyle.left = vnNewLeft + "px";
  voStyle.top = vnNewTop + "px";
};
/**
 * 컨트롤 Drag&Drop 시 mouseup 이벤트에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.stopDrag = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voCtrl = this.ctrl;
  var voPaneCtrl = this.dragDropHandler.ctrl;
  voDocument = voPaneCtrl.document;
  var voEvent = new eXria.event.Event(e, voDocument.parentWindow);
  this.dragDropHandler.removePane();
  this.glassPane.removeCtrl();
  // Check
  voDocument.body.style.cursor = "auto";
  voCtrl.style.cursor = "auto";

  voPaneCtrl.onmousemove = null;
  voPaneCtrl.onmouseup = null;
  voDocument.onmousemove = null;
  voDocument.onmouseup = null;
  if (typeof voPaneCtrl.onselectstart != "undefined") {
    voPaneCtrl.onselectstart = null;
  } else {
    voPaneCtrl.onmousedown = null;
  }

  this.mode = null;
  this.leftOffset = -1;
  this.topOffset = -1;
  this.rightOffset = -1;
  this.bottomOffset = -1;

  var vcCtl = this.glassPane.getControlByEvent(voEvent);
  if(vcCtl == null) return;
  var voEventObject = vcCtl;
  if(vcCtl.getItemByPos) {
    voEventObject = vcCtl.getItemByPos(voEvent.clientX, voEvent.clientY);
    if(voEventObject) voEvent.objectType = "item";
  }
  if(vcCtl.onDrop) {
    voEvent.srcObject = this.dragDropHandler.srcObject;
    voEvent.srcObjectType = this.dragDropHandler.srcObjectType;
    voEvent.object = voEventObject;
    vcCtl.onDrop(voEvent);
  }
  this.dragDropHandler.srcObject = null;
  this.dragDropHandler.srcObjectType = null;
};
/**
 * 포커스 변경에 따른 style 변경 처리
 * @param {Boolean} pbFocus 포커스 in/out 여부
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setFocusStyle = function(pbFocus) {
  var voCtrl = this.getCtrl();
  var voStyle = voCtrl.style;
  if(this.oldBorderWidth == null) {
    this.oldBorderWidth = voStyle.borderWidth;
    this.oldBorderStyle = voStyle.borderStyle;
    this.oldBorderColor = voStyle.borderColor;
  }
  if(pbFocus && this.focusDisplay) {
    var vsFocusBorderWidth = this.getUIControlAttrValue("focusBorderWidth", this.focusBorderWidth);
    if(vsFocusBorderWidth != null) {
      if(vsFocusBorderWidth == "auto") {
        voStyle.borderWidth = this.getUIControlAttrValue("borderWidth", this.borderWidth);
//        voStyle.borderWidth = this.oldBorderWidth;
      } else {
        voStyle.borderWidth = vsFocusBorderWidth + "px";
      }
    }
    voStyle.borderStyle = this.getUIControlAttrValue("focusBorderStyle", this.focusBorderStyle);
    voStyle.borderColor = this.getUIControlAttrValue("focusBorderColor", this.focusBorderColor);
  } else {
    voStyle.borderWidth = "";
    voStyle.borderStyle = "";
    voStyle.borderColor = "";
    if(this.oldBorderWidth) voStyle.borderWidth = this.oldBorderWidth;
    if(this.oldBorderStyle) voStyle.borderStyle = this.oldBorderStyle;
    if(this.oldBorderColor) voStyle.borderColor = this.oldBorderColor;
  }
};
/**
 * UI 공통 속성의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성의 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getUIControlDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.UIControl[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 사용자 할당 값,css, canvas, UISpecific, UIDefault에서 우선순위에 따라 속성값을 가져오는 메소드.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 디폴트 속성값
 * @type String
 */
eXria.controls.xhtml.UIControl.prototype.getAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = null;
    //if(this.canvas)  vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
    if(vsAttrValue != null) {
      return vsAttrValue;
    } else {
      vsAttrValue = this.getSpecificDefaultValue(psAttrName);  // TODO : 위의 소스로 교체할것
      if(vsAttrValue == null) vsAttrValue = this.getUIControlDefaultValue(psAttrName);
      return vsAttrValue;
    }
  }
};
/**
 * UI 공통 속성에 적용되는 실제값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성에 적용되는 실제값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getUIControlAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
    if(vsAttrValue != null) {
      return vsAttrValue;
    } else {
      return this.getUIControlDefaultValue(psAttrName);
    }
  }
};
/**
 * 개별 UI 속성에 적용되는 실제값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성에 적용되는 실제값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getSpecificAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
    if(vsAttrValue != null) {
      return vsAttrValue;
    } else {
      return this.getSpecificDefaultValue(psAttrName);  // TODO : 위의 소스로 교체할것
    }
  }
};
/**
 * toolip의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 toolip 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getTooltipAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) return psAttrValue;
  else return this.getTooltipDefaultValue(psAttrName);
};
/**
 * toolip의 공통 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성의 toolip 공통 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getTooltipDefaultValue = function(psAttrName) {
  //var vsDefaultValue = eXria.controls.xhtml.Default.ToolTip[psAttrName];
  var vsDefaultValue = eXria.controls.xhtml.Default.Form.Tooltip[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * dragDrop의 속성 값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 toolip 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getDragDropAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) return psAttrValue;
  else return this.getDragDropDefaultValue(psAttrName);
};
/**
 * dragDrop의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성의 toolip 공통 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getDragDropDefaultValue = function(psAttrName) {
  if(eXria.controls.xhtml.Default.UIControl.dragDrop == null) return null;
  var vsDefaultValue = eXria.controls.xhtml.Default.UIControl.dragDrop[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 컨트롤이 page에 load 될때의 처리 수행.
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.load = function(poDocument) {
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  if(this.data && this.loadData) this.loadData(poDocument);
  if(this.loadComplete) this.loadComplete(poDocument);
  this.loaded = true;

  var voCtrl = this.getCtrl(poDocument);
  if(this.disabled) this.setDisable(voCtrl, this.disabled);
//  this.hideFocusLine(voCtrl, true);
};
/**
 * 컨트롤에 데이타 로딩 작업 수행.
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.loadData = function() {};
/**
 * 컨트롤이 page에 load 될때 Canvas 객체의 속성을 참조해야될 작업 수행
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.loadCanvasConfig = function() {
  var voDocument = this.document;
  var voTooltipHandler = this.tooltipHandler;
  voTooltipHandler.document = voDocument;
  this.paneHandler.document = voDocument;
  this.dragDropHandler.document = voDocument;

  if(this.canvas && ((this.tooltip != null && this.tooltip.length != 0) || (voTooltipHandler.data.instanceId && voTooltipHandler.data.instancePath))) {
    this.tooltipHandler.setCtrl();
//    this.tooltipHandler.backgroundImage = "url('" + this.canvas.page.metadata.resourceBaseUrl + this.getTooltipAttrValue("backgroundImage", this.tooltipHandler.backgroundImage) + "')";
//    document.getElementById(this.id + "_TooltipArrow").style.backgroundImage = "url('" + this.canvas.page.metadata.resourceBaseUrl + "eXria/controls/xhtml/images/arrow.gif')";
  }
};
/**
 * 새로고침 최종 처리
 * @param {HTMLDiv} voCtrl 실체화 객체 최외곽 Div
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.refreshComplete = function(poCtrl, poDocument) {
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};

/**
 * 서브 컨트롤 실체화 객체를 얻어온다.
 * @param {String} psTagName
 * @return subControl
 * @type HTMLElement
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getSubCtrl = function(psTagName, poCtrl, poDocument, pnIndex) {
  if(poCtrl == null) { poCtrl = this.getCtrl(poDocument); }
  var vnIndex = 0;
  if(pnIndex != null) vnIndex = pnIndex;
  var voSubCtrl = null;
  voSubCtrl = poCtrl.getElementsByTagName(psTagName)[vnIndex];
  return voSubCtrl;
};

/**
 * 지정된 속성 값을 갖는 dom element를 저장하는 배열 객체를 반환하는 메소드
 * @param {Array(HTMLElement)} paCtrl 검색 대상 dom elements
 * @param {String} psAttr 검색할 속성명
 * @param {String} psValue 검색할 값
 * @return 검색 대상 속성값을 갖는 dom elements
 * @type Array(HTMLElement)
 * public
 */
eXria.controls.xhtml.UIControl.prototype.getElementsByAttr = function(paCtrl, psAttr, psValue) {
  var vaRet = [];
  var vnSize = paCtrl.length;
  var voCtrl = null;
  for(var i = 0; i < vnSize; i++) {
    voCtrl = paCtrl[i];
    if(voCtrl.getAttribute(psAttr) == psValue) {
      vaRet.push(voCtrl);
    }
  }
  return vaRet;
};
/**
 * 실체화 객체 focus시 점선제거
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.hideFocusLine = function(poCtrl, pbSubElement) {
  pbSubElement = pbSubElement || false;

  if(poCtrl.tabIndex != undefined){
    poCtrl.hideFocus = true;
    poCtrl.style.outlineStyle = "none";
  }

  if(pbSubElement === true && poCtrl.childNodes) {
    var voChild = null;
    for(var i = 0; i < poCtrl.childNodes.length; i++) {
      voChild = poCtrl.childNodes[i];
      this.hideFocusLine(voChild, true);
    }
  }
};
/**
 * CSS Class 명을 반환한다.
 * @param poCtrl
 * @param pnType 0 : OuterClass, 1 : Class, 2 : OuterClass & Class
 * @return String
 */
eXria.controls.xhtml.UIControl.prototype.getCSSClass = function(poCtrl, pnType, psSubClass){
  var vsPreFix = "Default";
  var vsType = "";
  if(poCtrl !== null) vsType = "_" + poCtrl.toString();
  if(pnType === null || pnType === undefined) pnType = 0;
  var vsSubClass = "";
  var voClassObj = this;
  var vaSubObj = null;
  if(psSubClass){
    voClassObj = voClassObj[psSubClass];
    vsSubClass = "_" + psSubClass.split(".").join("_");
  }

  var vsUIControlClass = "";
  if(pnType == 2) {
    vsUIControlClass = vsPreFix + "_UIControl_OuterClass " + vsPreFix + "_UIControl_Class";
  } else {
    vsUIControlClass = vsPreFix + "_UIControl_" + ["OuterClass", "Class"][pnType];
  }
  var vsControlClass = "";
  if(this.control){
    if(pnType == 2) {
      vsControlClass = vsPreFix + "_" + this.control.toString() + vsType + "s" + vsSubClass + "_OuterClass "
                    + vsPreFix + "_" + this.control.toString() + vsType + "s" + vsSubClass + "_Class"
    } else {
      vsControlClass = vsPreFix + "_" + this.control.toString() + vsType + "s" + vsSubClass + "_" + ["OuterClass", "Class"][pnType];
    }
  }else{
    if(pnType == 2) {
      vsControlClass = vsPreFix + vsType + vsSubClass + "_OuterClass "
                    + vsPreFix + vsType + vsSubClass + "_Class";
    } else {
      vsControlClass = vsPreFix + vsType + vsSubClass + "_" + ["OuterClass", "Class"][pnType];
    }
  }

  var vsUserClass = null;
  if(pnType === 0 && voClassObj != null){
    if(voClassObj.outerClassName) vsUserClass = voClassObj.outerClassName;
  } else if(pnType === 1 && voClassObj != null) {
    if(voClassObj.className) vsUserClass = voClassObj.className;
  } else if(pnType === 2 && voClassObj != null) {
    if(voClassObj.outerClassName) vsUserClass = voClassObj.outerClassName;
    if(voClassObj.className) {
      if(vsUserClass != null) vsUserClass += " " + voClassObj.className;
      else vsUserClass = voClassObj.className;
    }
  }


  if(vsUserClass == null){
    vsUserClass = "";
  }

  if(vsUserClass == (vsControlClass + " ") || vsUserClass == vsControlClass) {
    vsUserClass = null; vsUserClass = "";
  }
  return vsSubClass == "" ? vsUIControlClass + " " + vsControlClass + " " + vsUserClass : vsControlClass + " " + vsUserClass;
};
/**
 * CSS로 적용된 style의 값을 반환한다.
 * @param {Object} poElement HTMLElement
 * @param {Object} psProp Style Property
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.getStyleCurrentValue = function(poElement, psCSSProp, psJSProp){
  if(poElement.currentStyle){ // IE, Opera
    return poElement.currentStyle[psJSProp];
  }else if(window.getComputedStyle && poElement.tagName != null){
    if(this.window.document.defaultView){ // Firefox, Mozilla, Navigator
      try {
        return this.window.document.defaultView.getComputedStyle(poElement, null).getPropertyValue(psCSSProp);
      } catch(err) {
        return null;
      }
    }else{ // Safari
      var vsClassName = poElement.className;
      vsClassName = eXria.util.StringUtil.trim(vsClassName);
      vsClassName = vsClassName.split(" ");
      vsClassName = vsClassName[vsClassName.length - 1];
      var voCssStyle = this.getCssStyle(vsClassName);
      if(voCssStyle == null) {
        var voStyleSheets = window.document.styleSheets;
        if(voStyleSheets.length > 0){
          for(var i=voStyleSheets.length-1; i>=0; i--){
            var voRules = voStyleSheets[i].rules;
            for(var j=voRules.length-1; j>=0; j--){
              if(voRules[j].selectorText == "." + vsClassName){
                this.canvas.cssClassMap.put("." + vsClassName, voRules[j].style); //this.canvas.cssClassMap의 캐시 처리하고 있는 부분을 사용시 고려할 것
                return voRules[j].style[psJSProp];
              }
            }
          }
        }
      } else {
        return voCssStyle[psJSProp];
      }
    }
  } else {
    var vsClassName = poElement.className;
    vsClassName = eXria.util.StringUtil.trim(vsClassName);
    vsClassName = vsClassName.split(" ");
    vsClassName = vsClassName[vsClassName.length - 1];
    var voCssStyle = this.getCssStyle(vsClassName);
    if(voCssStyle == null) {
      var voStyleSheets = window.document.styleSheets;
      if(voStyleSheets.length > 0){
        for(var i=voStyleSheets.length-1; i>=0; i--){
          var voRules = voStyleSheets[i].rules;
          if(voRules == null) voRules = voStyleSheets[i].cssRules;
          for(var j=voRules.length-1; j>=0; j--){
            if(voRules[j].selectorText == "." + vsClassName){
              this.canvas.cssClassMap.put("." + vsClassName, voRules[j].style); //this.canvas.cssClassMap의 캐시 처리하고 있는 부분을 사용시 고려할 것
              return voRules[j].style[psJSProp];
            }
          }
        }
      }
    } else {
      return voCssStyle[psJSProp];
    }
  }
  return null;
};
/**
 * CSS로 적용된 Border의 값을 속성에 할당한다.
 * @param {Object} poCtrl HTMLElement
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setStyleCurrentBorderValue = function(poControl){
  var voCtrl = poControl.getCtrl();

  // yhkim 2009.10.08 borderWidth값이 설정된 경우에 그 설정을  배분해서 넣어주기
  if(poControl.borderWidth != null) {
    if(poControl.borderLeftWidth == null) poControl.borderLeftWidth = poControl.borderWidth;
    if(poControl.borderRightWidth == null) poControl.borderRightWidth = poControl.borderWidth;
    if(poControl.borderTopWidth == null) poControl.borderTopWidth = poControl.borderWidth;
    if(poControl.borderBottomWidth == null) poControl.borderBottomWidth = poControl.borderWidth;
  }

  if(poControl.borderTopWidth == null) {
    if(poControl.getStyleCurrentValue(voCtrl, "border-top-width", "borderTopWidth") == null)
      poControl.borderTopWidth = null;
    else
      poControl.borderTopWidth = parseInt(poControl.getStyleCurrentValue(voCtrl, "border-top-width", "borderTopWidth"), 10);
  }
  if(poControl.borderRightWidth == null) {
    if(poControl.getStyleCurrentValue(voCtrl, "border-right-width", "borderRightWidth") == null)
      poControl.borderRightWidth = null;
    else
      poControl.borderRightWidth = parseInt(poControl.getStyleCurrentValue(voCtrl, "border-right-width", "borderRightWidth"), 10);
  }
  if(poControl.borderBottomWidth == null) {
    if(poControl.getStyleCurrentValue(voCtrl, "border-bottom-width", "borderBottomWidth") == null)
      poControl.borderBottomWidth = null;
    else
      poControl.borderBottomWidth = parseInt(poControl.getStyleCurrentValue(voCtrl, "border-bottom-width", "borderBottomWidth"), 10);
  }
  if(poControl.borderLeftWidth == null) {
    if(poControl.getStyleCurrentValue(voCtrl, "border-left-width", "borderLeftWidth") == null)
      poControl.borderLeftWidth = null;
    else
      poControl.borderLeftWidth = parseInt(poControl.getStyleCurrentValue(voCtrl, "border-left-width", "borderLeftWidth"), 10);
  }
};

/**
 * Border의 상세 값을 설정한다
 * @param {Object} poCtrl HTMLElement
 * @private
 */
eXria.controls.xhtml.UIControl.prototype.setDetailBorder = function(poControl){
  if(poControl.borderTopWidth == null) poControl.borderTopWidth = poControl.borderWidth;
  if(poControl.borderRightWidth == null) poControl.borderRightWidth = poControl.borderWidth;
  if(poControl.borderBottomWidth == null) poControl.borderBottomWidth = poControl.borderWidth;
  if(poControl.borderLeftWidth == null) poControl.borderLeftWidth = poControl.borderWidth;
};
/**
 * 컨트롤 위치 및 크기를 재설정하기 위한 메소드
 * @param {Boolean} pbChildRefresh 하위 컨트롤의 refresh 여부(생략시 true) ex)true -> 새로고침 O, false -> 새로고침 X
 */
eXria.controls.xhtml.UIControl.prototype.resize = function(pbChildRefresh) {
  if(pbChildRefresh == null || pbChildRefresh == undefined) pbChildRefresh = true;
  if(this.isResize === false) this.refreshPos();
  else this.refresh(null, pbChildRefresh);
};
/**
 * left, top 속성 설정에 의해 변경된 컨트롤 위치 값을 실체화 객체에 반영하는 메소드
 */
eXria.controls.xhtml.UIControl.prototype.refreshPos = function() {
  var voCtrl = this.ctrl;
  voCtrl.style.left = this.left + "px";
  voCtrl.style.top = this.top + "px";
};
/**
 * @fileoverview
 * Construct Default
 * @author 김경태
 * @version 2.0
 * @ignore
 */

/**
 * Const
 * 컨트롤에서 사용하는 기본값에 대한 정의 클래스
 */
eXria.controls.xhtml.Default = {
  version : "1.0"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.UIControl = {
  position : "absolute",
  backgroundColor : "white",
  color : "black",
  visible :  true,
  disabled :  false,
  zIndex :  0,
  movable : false,
  cursor : "default",
  tooltip : null,
  tooltipDisplay : true,
  dir : "ltr",
  tabIndex : 0,
  borderColor : "#A5BACC",
  borderStyle : "solid",
  borderWidth :  1,
  focusBorderColor : "#006600",
  focusBorderStyle : "solid",
  focusBorderWidth : "auto",
  debug : true
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.UIControl.tooltip = {
  rightBottomImage : "eXria/controls/xhtml/images/arrow_rb.gif",   // arrowImage
  leftBottomImage : "eXria/controls/xhtml/images/arrow_lb.gif",   // arrowImage
  rightTopImage : "eXria/controls/xhtml/images/arrow_rt.gif",   // arrowImage
  leftTopImage : "eXria/controls/xhtml/images/arrow_lt.gif",   // arrowImage
  borderColor : "#317082",
  borderStyle : "solid",
  borderWidth : 2,
  color : null,
  backgroundColor : "#FFFFFF",
  fontSize : 10,
  filter : "alpha(opacity:70)",
  opacity : "0.70"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.UIControl.dragDrop = {
  backgroundImage : "eXria/controls/xhtml/images/bigWaiting.gif",   // dragDropImage
  borderColor : "#317082",
  borderStyle : "solid",
  borderWidth : 2,
  color : null,
  backgroundColor : "#FFFFFF",
  fontSize : 10,
  filter : "alpha(opacity:10)",
  opacity : "0.10"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.InputBox = {
  value : null,
  maxLength : null,
  readOnly : false,
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  textAlign : "left",
  verticalAlign : "middle",
  textDecoration : "none",
  textTransform : "none"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Button = {
  value : "",
  backgroundImage : null,
  imageFocused : null,
  imagePushed : null,
  imageMouseover : null,
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  padding : 2,
  borderWidth : 1,
  borderStyle : "outset",
  borderColor : "#1475C5",
  color : "white",
  backgroundColor : "#1683D7",
  cursor : "pointer",
  backgroundRepeat : "no-repeat",
  backgroundPosition : "center center"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.SecretBox = {
  value : null,
  maxLength : null,
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  textAlign : "left",
  verticalAlign : "middle",
  textDecoration : "none"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Label = {
  backgroundColor : "transparent",  // TODO : 스튜디오와 동기화 된 이후에 white로 변경할것. kkt
  borderWidth: 1,
  overflow : "hidden",
  value : "",
  wordWrap : true,
  textDecoration : "none",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  textAlign : "center",
  verticalAlign : "middle"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.DateInput = {
  value : null,
  calendarEnable : true,
  dateFormat : "YYYY-MM-DD",
  maskPrompt : "_",
  minDate : "19000101",
  maxDate : "38001231",
  calendarImageUrl : "eXria/controls/xhtml/images/calendar.jpg",
  readOnly : false,
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  fontFamily : "Arial",
  textDecoration : "none",
  textAlign : "left",
  verticalAlign : "middle",
  btnCursor : "pointer"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Output = {
  value : "",
  format : null,
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  textAlign : "left",
  verticalAlign : "middle",
  textDecoration : "none",
  letterSpacing : "normal",
  lineHeight : "normal"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.TextArea = {
  rows : 20,
  cols : 20,
  readOnly : false,
  value : null,
  maxLength : null,
  overflow : "auto",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  textAlign : "left",
  textDecoration : "none"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Image = {
  src : null,
  imageOpacity : 100,
  borderStyle : "ridge"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Object = {
  archive : null,
  classid : null,
  codebase : null,
  dataUrl : null,
  declare : null,
  standby : null,
  type : null,
  codetype : null,
  color : "white",
  backgroundColor : "black",
  borderWidth : 3,
  borderStyle : "ridge",
  borderColor : "green"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Select = {
  displayMode : "horizontal",
  displayNum : 2,
  value : null,
  horizontalGap : 0,
  verticalGap : 0,
  offsetLeft : 0,
  offsetTop : 0,
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  itemgroup : {
      labelPos : "right",
      height : 30,
      width : 100,
      textAlign : "left",
      verticalAlign : "middle",
      fontFamily : "Arial",
      fontSize : 10,
      fontWeight : "normal",
      fontStyle : "normal",
      color : "#000000",
      backgroundColor : "transparent",
      borderWidth : 0,
      borderStyle : "none",
      borderColor : "#000000",
      cursor : "pointer"
  },
  labelTagName : "labelNode",
  valueTagName : "valueNode"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.ComboBox = {
  value : null,
  readOnly : false,
  selectedIndex : -1,
  heightBySize : false,
  verticalAlign : "middle",
  textAlign : "left",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  btnWidth : 20,
  btnBackgroundColor : "#E7E7EB",
  btnColor : "black",
  collapseImage : null,
  expandImage : null,
  btnCursor : "pointer",
  itemgroup : {
    className : null,
    optionWidth : 20,
    selectorWidth : null,
    overflow : "hidden",
    borderWidth : 0,
    borderStyle : "dotted",
    borderColor : "black",
    height : 20,
    verticalAlign : "middle"
  },
  listarea : {
    className : null,
    appearance : "normal",
    multiSelect : false,
    size : 5,
    heightBySize : false,
    widthByMaxLength : true,
    color : "black",
    focusColor : "#000000",
    overflowY : "auto",
    overflowX : "visible",
    backgroundColor : "#FFFFFF",
    focusBackgroundColor : "#0000FF",
    borderWidth : 1,
    borderStyle : "solid",
    borderColor : "black",
    cellSpacing : 0,
    height : 200
  },
  labelTagName : "labelNode",
  valueTagName : "valueNode"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.ListBox = {
  value : null,
  selectedIndex : -1,
  overflow : "auto",
  overflowX : "hidden",
  overflowY : "auto",
  textAlign : "left",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  appearance : null,
  multiSelect : true,
  size : 5,
  heightBySize : false,
  focusColor : "#FFFFFF",
  focusBackgroundColor : "#0000FF",
  cellSpacing : 0,
  itemgroup : {
    className : null,
    selectorWidth : 20,
    overflow : "hidden",
    borderWidth : 0,
    borderStyle : "dotted",
    borderColor : "black",
    height : 20,
    verticalAlign : "middle"
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.EditMask = {
  maskType : "string",
  mask : "xxxxx",
  maskPrompt : "_",
  value : "",
  verticalAlign : "middle",
  spinWidth : 20,
  spinNum : 1,
  useSpin : false,
  readOnly : false,
  maxLength : null,
  calendarImageUrl : "eXria/controls/xhtml/images/calendar.jpg",
  calendarEnable : "true",
  textDecoration : "none",
  textTransform : "none",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  btnCursor : "pointer"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Group = {
  overflow : "hidden",
  borderColor : "silver",
  borderStyle : "none",
  borderWidth : 0,
  backgroundColor : "transparent"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.TabHeader = {
  backgroundColor : "white",
  fontFamily : "Arial",
  fontSize : 12,
  fontStyle : "normal",
  fontWeight : "normal",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "black",
  scrollBtnWidth : 30,
  tabbuttons : {
    cellSpacing : 1,
    borderWidth : 1,
    borderStyle : "outset",
    borderColor : "#688BA1",
    width : 100,
    backgroundImage : null,
    imageFocused : null,
    backgroundColor : "white",
    color : "black",
    focusBackgroundColor : "#76A7C1",
    focusColor : "white",
    fontSize : 12
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Tab = {
  headerHeight : 50,
  tabPageZindex : 0,
  headerPos : "top",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "gray",
  backgroundColor : "#FFFFFF",
  tabpages : {
    className : null,
    outerClassName : null,
    backgroundColor : "transparent",
    borderWidth : 1,
    borderStyle : "solid",
    borderColor : "#000000"
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.MDIButtons = {
  backgroundColor : "white",
  fontFamily : "Arial",
  fontSize : 12,
  fontStyle : "normal",
  fontWeight : "normal",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "black",
  scrollBtnWidth : 30,
  cellSpacing : 1,
  borderWidth : 1,
  borderStyle : "outset",
  borderColor : "#688BA1",
  width : 100,
  height : 20,
  backgroundImage : null,
  imageFocused : null,
  backgroundColor : "white",
  color : "black",
  focusBackgroundColor : "#76A7C1",
  focusColor : "white",
  fontSize : 12
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.MDIGroup = {
  titleBarHeight : 25,
  mdiPageZindex : 0,
  minimizePos : "top",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "#c0c0c0",
  backgroundColor : "transparent",
  mdipages : {
    className : null,
    outerClassName : null,
    backgroundColor : "#FFFFFF",
    borderWidth : 1,
    borderStyle : "solid",
    borderColor : "#76a7c1",
    mdipage : {
      minimize : false,
      maximize : false,
      restore : true
    }
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.MDIPages = {
  className : null,
  outerClassName : null,
  backgroundColor : "#FFFFFF",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "#76a7c1",
  mdipage : {
    minimize : false,
    maximize : false,
    restore : true
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Timer = {
  interval : 1000,
  stopCount : 0
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Progress = {
  step : 1,
  startPos : 0,
  interval : 100,
  min : 0,
  max : 1000,
  progressColor : "#6AA8E3",
  //borderColor : "#736A5E",
  backgroundColor : "#D4D0C9"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.TreeView = {
  expandAll : false,
  selectionMode : "single",
  iconDir : "eXria/controls/xhtml/images",
  iconWidth : 19,
  iconHeight : 16,
  overflow : "auto",
  backgroundColor : "#E4EEF3",
  borderColor : "#98BBD1",
  borderStyle : "solid",
  fontFamily : "Arial",
  fontSize : 12,
  fontStyle : "normal",
  fontWeight : "normal",
  itemgroup : {
    className : null,
    backgroundColor : "#E4EEF3",
    color : "black",
    selectedBackgroundColor : "navy",
    selectedColor : "#FFFFFF",
    cursor : "pointer",
    fontFamily : "Arial",
    fontSize : 10,
    fontStyle : "normal",
    fontWeight : "normal",
    textAlign : "left",
    verticalAlign : "middle"
  },
  iconFiles : {
    blank : "blank.png", //0
    verticalLine : "vertical_line.png", //1
    closedLastnode : "closed_lastnode.png", //2
    closedNode : "closed_node.png", //3
    openedLastnode : "opened_lastnode.png", //4
    openedNode : "opened_node.png", //5
    lastnode : "lastnode.png", //6
    node : "node.png", //7
    closedFolder : "closed_default_folder.png", //8
    openedFolder : "opened_default_folder.png", //9
    leafItem : "leaf_item_rend.gif", //10
    selectedLeafItem : "selectedleaf_item_rend.gif" //11
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Calendar = {
  selectedColor : "#CCCCCC",
  headerBackgroundColor : "#F2F2F2",
  bodyBackgroundColor : "#FFFFFF",
  backgroundColor : "white",
  backgroundImage : null,
  backgroundRepeat : "no-repeat",
  backgroundPosition : "center center",
  borderWidth : 1,
  borderTopWidth : 0,
  borderLeftWidth : 0,
  borderRightWidth : 1,
  borderBottomWidth : 1,
  borderStyle : "solid",
  borderColor : "#777777",
  fontFamily : "Arial",
  fontSize : 10,
  fontWeight : "normal",
  fontStyle : "normal",
  toLastImage : null,
  toNextImage : null,
  innerBorderWidth : 1,
  innerBorderStyle : "solid",
  innerBorderColor : "#CCCCCC"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.FreeForm = {
/* TODO 추후예정 */
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Grid = {
/* TODO 추후예정 */
  multiSelect : false,
  sortable : false
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.GridHeader = {
/* TODO 추후예정 */
  backgroundColor : null,
  color : null,
  textAlign : null,
  textDecoration : null,
  fontSize : null,
  fontStyle : null,
  fontWeight : null
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.GridBody = {
/* TODO 추후예정 */
  backgroundColor : null,
  oddBackgroundColor : null,
  selectedBackgroundColor : null,
  color : null,
  selectedColor : null,
  borderColor : null,
  borderStyle : null,
  borderWidth : null,
  selectedBorderColor : null,
  selectedBorderStyle : null,
  selectedBorderWidth : null,
  focusCellBorderColor : null,
  focusCellBorderStyle : null,
  focusCellBorderWidth : null,
  textAlign : null,
  textDecoration : null,
  fontSize : null,
  fontStyle : null,
  fontWeight : null
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.HeadColumn = {
/* TODO 추후예정 */
  backgroundColor : null,
  color : null,
  textAlign : null,
  fontFamily : null,
  fontSize : null,
  fontStyle : null,
  fontWeight : null
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.BodyColumn = {
/* TODO 추후예정 */
  backgroundColor : null,
  color : null,
  textAlign : null,
  readOnly : false,
  fontFamily : null,
  fontSize : null,
  fontStyle : null,
  fontWeight : null
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.GridEx = {
    backgroundImage : null,
    fontFamily : "Arial",
    fontSize : 10,
    fontWeight : "normal",
    fontStyle : "normal",
    cursor : "auto",
    backgroundRepeat : "no-repeat",
    backgroundPosition : "center center",
    defaultFileName : "/eXria/lib/gridex/Defaults.xml",
    textFileName : "/eXria/lib/gridex/Text.xml"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Shape = {
  position : "absolute",
  visible : true,
  movable : false,
  zIndex : 0,
  cursor : "auto",
  tooltip : null,
  tooltipDisplay : true,
  penCap : "round",
  penStyle : "solid",
  penWeight :1,
  penColor : "#938B81",
  penOpacity : 100,
  joinType : "round",
  angle : 0,
  cursor : "default",
  focusBorderColor : "#006600",
  focusBorderStyle : "solid",
  focusBorderWidth : "auto"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Line = {
  startPosition : "top",
  penColor : "#736A5E"
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Rectangle = {
  fillStartColor : "#E4EEF3",
  fillEndColor : "white",
  fillType : "solid",
  fillAngle : 0,
  fillOpacity : 100
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Roundrect = {
  round : 20,
  fillStartColor : "#FAEBD7",
  fillEndColor : "white",
  fillType : "solid",
  fillAngle : 0,
  fillOpacity : 100
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Ellipse = {
  fillStartColor : "#D6E3B1",
  fillEndColor : "white",
  fillType : "solid",
  fillAngle : 0,
  fillOpacity : 100
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.SlideTab = {
  expandDirection : "top",
  selectedIndex : 0,
  renderAll : false,
  slideButtons : {
    className : null,
    outerClassName : null,
    height : 50,
    borderStyle : "outset",
    borderWidth : 1,
    borderColor : "#1475C5",
    //backgroundImage : "url(http://img.yahoo.co.kr/spirit/pyramid/2008/08/08/nw1a1_img1_1218157383.jpg)",
    backgroundImage : null,
    imageFocused : null,
    backgroundColor : "#1683D7",
    focusBackgroundColor : "#76A7C1",
    color : "black",
    focusColor : "white",
    fontSize : 12
  },
  slidePages : {
    className : null,
    outerClassName : null,
    borderStyle : "none",
    borderWidth : 0,
    borderColor : "white",
    backgroundColor : "white"
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.ContextMenu = {
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "#1475C5",
  backgroundColor : "white",
  zIndex :  100000,
  shadowEnable : true,
//  iconarea : {
//    width : 20,
//    backgroundColor : "#A5BACC"
//  },
  itemgroup : {
      iconWidth : 20,
      iconBackgroundColor : "#A5BACC",
      separatorColor : "#1683D7",
      separatorHeight : 2,
      textIndent : 10,
      height : 30,
      width : 100,
      textAlign : "left",
      verticalAlign : "middle",
      fontFamily : "Arial",
      fontSize : 10,
      fontWeight : "normal",
      fontStyle : "normal",
      color : "#000000",
      backgroundColor : "#D4D0C9",
      focusColor : "white",
      focusBackgroundColor : "blue"
  },
  shadow : {
      backgroundColor : "#777777",
      borderWidth : 0,
      borderStyle : "solid",
      borderColor : "#CCCCCC",
      filter : "alpha(opacity:50)",
      opacity : "0.50",
      left : "3px",
      top : "3px"
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.FileSelector = {
  backgroundColor : "#FFFFFF",
  borderWidth : 1,
  borderStyle : "solid",
  borderColor : "#A5BACC",
  color : "#000000",
  fontFamily : "Arial",
  fontSize : 10,
  fontStyle : "normal",
  fontWeight : "normal",

  browseBtn : {
    className : null,
    borderWidth : 2,
    borderColor : "#CCCCCC",
    borderStyle : "outset",
//    backgroundImage : "css/theme1/btn/btnBig_orange.gif",
    backgroundRepeat : "no-repeat",
    backgroundPosition : "center center",
    backgroundColor : "#E7E7EB",
    color : "#000000",
    fontFamily : "Arial",
    fontSize : 9,
    fontStyle : "normal",
    fontWeight : "bold",
    width : 58,
    value : "Browse"
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Print = {
  css : "print.css",
  marginLeft : 10,
  marginTop : 10,
  marginRight : 10,
  marginBottom : 10,
  formSpacing : 10,

  HeaderFooter : {
    borderWidth : 1,
    borderStyle : "solid",
    borderColor : "black",
    backgroundColor : "",
    backgroundImage : "",
    height : 100
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Canvas = {

};

/**
* @ignore
*/
eXria.controls.xhtml.Default.Cover = {
  backgroundColor : "#000000",
  filter : "alpha(opacity:10)",
  opacity : "0.10"
};
/**
 * @fileoverview
 * Concreate xhtml Group(XHTML Group 컨트롤)
 * @author 조영진
 */

/**
 * @class Concreate xhtml Group.<br>
 * XHTML Group 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Group 객체
 * @type eXria.controls.xhtml.Group
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @base eXria.controls.Group
 */
eXria.controls.xhtml.Group = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pbTableLayout) {
  if(pbTableLayout != true && page.tableLayoutMap && page.tableLayoutMap[psId] != null) {
    this.inheritTableLayout(psId, pnLeft, pnTop, pnWidth, pnHeight);
    return;
  }
  
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight =  pnHeight == null ? 300 : pnHeight;

  eXria.controls.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 스크롤 처리.
   * @type String
   */
  this.overflow = null;
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 횡 스크롤 처리.
   * @type String
   */
  this.overflowX = null;
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 종 스크롤 처리.
   * @type String
   */
  this.overflowY = null;
  /**
   * 하위 컨트롤들의 readOnly 여부 설정
   * @type Boolean
   */
  this.readOnly = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 하위 컨트롤 id에 붙일 suffix 문자열
   * @type String
   * @private
   */
  this.idSuffix = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};

  this.cursor = null;
  /**
  * @private
  */
  this.impList = new eXria.data.Collection();
  
  /**
   * 그룹 컨트롤의 하위컨트롤에 대한 refresh여부
   * @type Boolean
   */
   this.childRefresh = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Group);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.Group, eXria.controls.xhtml.Group);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.Group.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;
//if(vsType == "change")debugger
  switch(vsType) {
  case "mousedown" :
    break;
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

eXria.controls.xhtml.Group.prototype.atmousedown = function(e) {
  if(!e.target || !e.target.control) return;
  var voCanvas = e.target.control.canvas;
  eXria.form.xhtml.Canvas.prototype.doCollapseControl(voCanvas);
};

eXria.controls.xhtml.Group.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;

  this.ctrl = voCtrl;
  this.document = poDocument;
  return voCtrl;
};

eXria.controls.xhtml.Group.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
};

eXria.controls.xhtml.Group.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;

  var voDf = this.df;
  var vaCssStrBuf = null;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.10.12 동적인 코드에서는 disabled를 제어하지 않으며 FF에서는 없는 속성이다
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "tooltip", this.tooltip);
  vfcSetCssStrBuf(vaCssStrBuf, "disabled", this.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = null;
};

eXria.controls.xhtml.Group.prototype.refreshTemplate = function(poCtrl, poDocument, pbChildRefresh) {
  if(this.setTemplate) this.setTemplate(poCtrl, poDocument);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.refreshTemplate && pbChildRefresh == true) voChild.refreshTemplate(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.Group.prototype.refreshSpecificDefaults = function(poCtrl, poDocument, pbChildRefresh) {
  this.setSpecificDefaults(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(pbChildRefresh == true) voChild.refreshSpecificDefaults(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.Group.prototype.refreshSpecificAttrs = function(poCtrl, poDocument, pbChildRefresh) {
  this.setSpecificAttrs(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(pbChildRefresh == true) voChild.refreshSpecificAttrs(voChild.ctrl, voChild.document);
  }
};

 eXria.controls.xhtml.Group.prototype.reloadData = function(poCtrl, poDocument, pbChildRefresh) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.reloadData && pbChildRefresh == true) voChild.reloadData(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.Group.prototype.refreshComplete = function(poCtrl, poDocument, pbChildRefresh) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(pbChildRefresh == true) voChild.refreshComplete(voChild.ctrl, voChild.document);
  }
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};

eXria.controls.xhtml.Group.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.Group.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTable = poCtrl.childNodes[0];

  switch(psAttrName) {
    case "disabled" :
      poCtrl.disabled = psAttrValue;
      this.applyAttrToChildren("disabled", psAttrValue);
      break;
    //case "borderWidth" :
    //  this.innerWidth = this.width - 2 * this.borderWidth;
    //  this.innerHeight = this.height - 2 * this.borderWidth;
    //  poCtrl.style.width = this.innerWidth + "px";
    //  poCtrl.style.height = this.innerHeight + "px";
    //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Group.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
  case "overflow" :
    this.refresh(poDocument);
    break;
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue)
    this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
    var voChild = null;
    var voIterator = this.controls.iterator();
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      if(voChild.refreshVerticalAlign) {
        voChild.refreshVerticalAlign();
      }
    }
    break;
  case "readOnly" :
    this.setReadOnly(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};

eXria.controls.xhtml.Group.prototype.clear = function() {
  this.removeChildren();
  this.clearCtrl();
  this.clearControl();
};
/**
 * @ignore
 */
eXria.controls.xhtml.Group.prototype.loadComplete = function() {
  this.createChildren();
  if(this.readOnly != null) this.setReadOnly(this.readOnly);
};
/**
 * 컨트롤에 하위 컨트롤를 추가합니다.
 * @param {eXria.controls.xhtml.Control} poControl 추가 대상 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 */
eXria.controls.xhtml.Group.prototype.addChild = function(poControl, poDocument) {
  if(poDocument == null) poDocument = this.document;
  var voCanvas = this.canvas;
  poControl.parent = this;
  poControl.canvas = voCanvas;
  poControl.window = this.window;
  poControl.document = this.document;
  this.addItem(poControl);
  if(voCanvas) voCanvas.registerControl(poControl);
  var voCtrl = this.getCtrl(poDocument);
  if((this.visible || this.visible == null) && voCtrl) {
    voCtrl.appendChild(poControl.create(poDocument));
    poControl.load(poDocument);
  // TODO 추후 수정
    var name = poControl.toString();
    if(name == "Rectangle" || name == "Roundrect" || name == "Ellipse" ) {poControl.getCtrl(poDocument).blur();};
  }
};
/**
 * 하위 컨트롤을 제거 시킵니다.
 * @param {String} psId 제거대상 컨트롤 id
 */
eXria.controls.xhtml.Group.prototype.removeChild = function(psId) {
  var vnIndex = this.getIndex(psId);
  var voControl = this.controls.remove(vnIndex);
  voControl.clear();
};
/**
 * 하위 컨트롤 id에 매칭되는 컨트롤 식별 인덱스 번호를 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 하위 컨트롤 식별 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.Group.prototype.getIndex = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vnIndex = -1;
  while(voIterator.hasNext()) {
    vnIndex++;
    voControl = voIterator.next();
    if (voControl.id == psId) break;
  }
  return vnIndex;
};
/**
 * 지정된 id에 해당하는 하위 컨트롤을 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 지정된 id에 해당하는 하위 컨트롤 객체
 * @type eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.Group.prototype.get = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    if (voControl.id == psId) { return voControl; }
  }
  return null;
};
/**
 * 포함된 하위 컨트롤의 실체화 객체를 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {String} psIdSuffix 실체화된 컨트롤 id에 따라붙을 문자열
 * @private
 */
eXria.controls.xhtml.Group.prototype.createChildren = function(poDocument, psIdSuffix) {
  if(poDocument == null) poDocument = this.document;
  if(psIdSuffix == null && this.idSuffix) psIdSuffix = this.idSuffix;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    vsId = voControl.id;
    if(psIdSuffix != null) voControl.id += psIdSuffix;
    if(voControl.canvas == null) {
      voControl.canvas = this.canvas;
      voControl.window = this.window;
      voControl.document = this.document;
      this.canvas.registerControl(voControl);
    }
    if(voControl.toString() != "Timer") {
      this.appendChild(voControl.create(poDocument), poDocument);
      //voControl.refresh(poDocument);
      voControl.load(this.document);
    }
    voControl.id = vsId;
  }
};
/**
 * 하위 컨트롤에 일괄적으로 속성을 적용합니다.
 * @param {String} psAttrValue 지정된 속성값
 * @param {String} psAttrName 속성명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.Group.prototype.applyAttrToChildren = function(psAttrName, psAttrValue, poDocument) {
  if(this.getCtrl(poDocument) == null) return;

  var voIterator = this.controls.iterator();
  var voControl = null;
  var voCtrl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    voCtrl = voControl.getCtrl(poDocument);
    if(voCtrl) voControl.applyAttr(psAttrName, psAttrValue, poDocument);
  }
};
/**
 * 모든 하위 컨트롤을 제거 시킵니다.
 */
eXria.controls.xhtml.Group.prototype.removeChildren = function() {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    this.canvas.unregisterControl(voControl.id);
    if(voControl.toString() == "SubPage") {
//      var voWindow = voControl.ctrl.contentWindow;
//      if(voWindow) {
//        voWindow.close();
//      }
        voControl.setSrc("javascript:false");
    }
    voControl.clear();
  }
  this.controls.clear();
};

eXria.controls.xhtml.Group.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Group[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 하위 컨트롤의 readOnly속성을 설정
 * @param {String} pbEnable readOnly속성을 활성화할지 여부
 */
eXria.controls.xhtml.Group.prototype.setReadOnly = function(pbEnable) {
  var voIterator = this.controls.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.readOnly !== undefined) voChild.applyAttr("readOnly", pbEnable);
  }
};
/*
 * @ignore
 */
eXria.controls.xhtml.Group.prototype.resize = function() {
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.ctrl.style["left"] = this.left + "px";
  this.ctrl.style["top"] = this.top + "px";
  this.ctrl.style["width"] = this.innerWidth + "px";
  this.ctrl.style["height"] = this.innerHeight + "px";
};
/**
 * 클래스 명을 반환합니다.
 * @return "Group"
 * @type String
 */
eXria.controls.xhtml.Group.prototype.toString = function() {
  return "Group";
};
/**
 * TableLayout 상속.
 * @private
 */
eXria.controls.xhtml.Group.prototype.inheritTableLayout = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  eXria.controls.xhtml.TableLayout.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  var parentProto = eXria.controls.xhtml.TableLayout.prototype;
  for(psAttr in parentProto) {
    this[psAttr] = parentProto[psAttr];
  }
};
/**
 * @fileoverview
 * Concreate Shape UIControl(ShapeControl 컨트롤에 대한 xhtml 기본 클래스)
 * @author 이종녕
 */

/**
 * @class Concreate Shape UIControl.<br>
 * ShapeControl 컨트롤에 대한 xhtml 기본 클래스.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.ShapeControl 객체
 * @type eXria.controls.xhtml.ShapeControl
 * @constructor
 * @base eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.ShapeControl = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  /**
   * 컨트롤 아이디.
   * @type String
   */
  this.id = psId;
  //this.left = pnLeft;
  //this.top =  pnTop;
  //this.width = pnWidth;
  //this.height = pnHeight;

  eXria.controls.xhtml.Control.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  ////////////////////////////////////////////////////////////////////////////////////
  // 속성
  /**
   * @ignore
   */
  this.disabled = null //적용안됨...
  /**
   * 툴팁 문자열.
   * @type String
   */
  this.tooltip = null;
  /**
   * tooltip 표시 여부.
   * @type Boolean
   */
  this.tooltipDisplay = null;
  /**
   * 컨트롤 이동 시 사용될 pane의 불투명도.
   * @type Number
   */
  this.paneOpacity = 30;
  /**
   * 컨트롤 이동가능 여부.<br>
   * this.setMove메소드에 의해서만 값 설정.
   * @type Boolean
   * @private
   */
  this.movable = null;
  /**
   * 컨트롤 화면 디스플레이 여부.
   * @type Boolean
   */
  this.visible = null;
  /**
   * 폼에서 컨트롤의 겹침 순서 지정.<br>
   * @type Number
   */
  this.zIndex = null;
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).<br>
   * absolute : 상위 컨트롤의 좌상단 점을 원점으로 left, top 지정.<br>
   * relative : 상위 컨트롤이 컨트롤을 자동 위치시킨 상태에서의 left, top 이동값 지정.<br>
   * @type String
   */
  this.position = "absolute";
  /**
   * 컨트롤 위에 마우스 위치시에 마우스 커서 타입.<br>
   * "all-scroll" | "col-resize" | "crosshair" | "default" | "hand" | "help" | "move" | "no-drop" | "not-allowed" | "row-resize" | "text" | "url" | "vertical-text" | "wait" | "NW-resize" | "NE-resize" | "progerss" | "pointer" (초기값 : default)
   * @type String
   */
  this.cursor = "default";
  /**
   * 라인 양 끝단의 타입 지정.<br>
   * "flat" | "round" | "square"  (default:round)
   * @type String
   */
  this.penCap = null;
  /**
   * 라인 스타일.<br>
   * "solid" | "dot" | "dash"  (default:solid)
   * @type String
   */
  this.penStyle = null;
  /**
   * 라인 두께.
   * @type Number
   */
  this.penWeight = null;
  /**
   * 라인 색상.
   * @type String
   */
  this.penColor = null;
  /**
   * 라인의 불투명도.
   * @type unknown
   */
  this.penOpacity = null;
  /**
   * 선과 선이 만났을 때 만나는 부분 처리 유형.<br>
   * "miter" | "round" | "bevel"  (default:round)
   * @type String
   */
  this.joinType = null;
  /**
   * 도형 회전 각.
   * @type Number
   */
  this.angle = null;
  /**
   * left 좌표.
   * @type Number
   */
  this.left = pnLeft;
  /**
   * top 좌표.
   * @type Number
   */
  this.top = pnTop;
  /**
   * 가로 길이.
   * @type Number
   */
  this.width = pnWidth;
  /**
   * 세로 길이.
   * @type Number
   */
  this.height = pnHeight;
  /**
   * 마우스 위치를 기준으로 left 경계와의 거리.
   * @type Number
   * @private
   */
  this.leftOffset = -1;
  /**
   * 마우스 위치를 기준으로 top 경계와의 거리.
   * @type Number
   * @private
   */
  this.topOffset = -1;
  /**
   * 마우스 위치를 기준으로 right 경계와의 거리.
   * @type Number
   * @private
   */
  this.rightOffset = -1;
  /**
   * 마우스 위치를 기준으로 bottom 경계와의 거리.
   * @type Number
   * @private
   */
  this.bottomOffset = -1;
  /**
   * 경계 부근에서 무시되는 거리.
   * @type Number
   * @ignore
   */
  this.adjustOffset = 20;
  /**
   * 포커스가 위치했을 때의 색상 변경 적용 여부.
   * @type Boolean
   */
  this.focusDisplay = false;
  /**
   * 컨트롤에 포커스 위치 시 라인 두께.<br>
   * 포커스 효과 관련
   * @type Number
   */
  this.focusPenWeight = null;
  /**
   * 컨트롤에 포커스 위치 시 라인 색상.<br>
   * 포커스 효과 관련
   * @type String
   */
  this.focusPenColor = null;
  /**
   * 컨트롤에 포커스 위치 시 라인 스타일.
   * @type String
   */
  this.focusPenStyle = null;
  /**
   * 포커싱에 의해 컨트롤 라인 두께 변경 시 원본 값 저장.
   * @private
   * @type Number
   */
  this.oldPenWeight = null;
  /**
   * 포커싱에 의해 컨트롤 라인 색상 변경 시 원본 값 저장.
   * @private
   * @type String
   */
  this.oldPenColor = null;
  /**
   * 포커싱에 의해 컨트롤 라인 스타일 변경 시 원본 값 저장.
   * @private
   * @type String
   */
  this.oldPenStyle = null;

  this.initUIGeneral();

};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Control, eXria.controls.xhtml.ShapeControl);
///////////////////////////////////////////////////////////////////////////
// 메소드
/**
 * Ctrl(실체화 컨트롤)을 생성한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치할 Doucment에 대한 참조
 * @return 실체화 컨트롤에 대한 참조
 * @type object
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.create = function(poDocument, poDiv) {
  if(poDocument == null) poDocument = this.document;
  this.documentMode = poDocument.documentMode;
  if(this.documentMode == null) this.documentMode = 0;
  var voCtrl = null;

  if(this.createCtrl) { voCtrl = this.createCtrl(poDocument); };                                      // 1. Main Ctrl 생성
  if(this.createSubCtrl && voCtrl) { this.createSubCtrl(voCtrl, poDocument); };                       // 2. Composite Child Ctrl 생성

  if(this.setMainCtrlStyles && voCtrl) { this.setMainCtrlStyles(voCtrl, poDocument); };               // 3. Main Style 적용
  if(this.setSubCtrlStyles && voCtrl) { this.setSubCtrlStyles(voCtrl, poDocument); };                 // 4. Composite Child Style 적용

  if(this.setFormDefaults && voCtrl) { this.setFormDefaults(voCtrl, poDocument); };
  if(this.setUIGeneralDefaults && voCtrl) { this.setUIGeneralDefaults(voCtrl, poDocument); };         // 5. 공통 초기값 설정
  if(this.setSpecificDefaults && voCtrl) { this.setSpecificDefaults(voCtrl, poDocument); };           // 6. 개별 초기값 설정

  if(this.setFormAttrs && voCtrl) { this.setFormAttrs(voCtrl, poDocument); };
  if(this.setGeneralAttrs && voCtrl) { this.setGeneralAttrs(voCtrl, poDocument); };                   // 7. 공통 Attrs 적용
  if(this.setUIGeneralAttrs && voCtrl) { this.setUIGeneralAttrs(voCtrl, poDocument); }                // 8. UI 공통 Attrs 적용
  if(this.setSpecificAttrs && voCtrl) { this.setSpecificAttrs(voCtrl, poDocument); }                  // 9. 개별 Attrs 적용

  if(!this.printMode) {
    if(this.setGeneralEvents && voCtrl) { this.setGeneralEvents(voCtrl); }                            // 10. 공통 Events 적용
    if(this.setUIGeneralEvents && voCtrl) { this.setUIGeneralEvents(voCtrl); }                        // 11. UI 공통 Events 적용
    if(this.setSpecificEvents && voCtrl) { this.setSpecificEvents(voCtrl); }                          // 12. 개별 Events 적용
  }

  return voCtrl;
};
/**
 * Main Ctrl을 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 컨트롤을 둘러싸는 최외곽 Div 객체
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.createCtrl = function(poDocument) {};
/**
 * setUIGeneralDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setUIGeneralDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;
  voDf.position = this.getShapeAttrValue("position",this.position);
  voDf.visible =  this.getShapeAttrValue("visible",this.visible);
  voDf.movable =  this.getShapeAttrValue("movable",this.movable);
  voDf.zIndex =  this.getShapeAttrValue("zIndex", this.zIndex);
  voDf.cursor = this.getShapeAttrValue("cursor", this.cursor);
  voDf.tooltip = this.getShapeAttrValue("tooltip", this.tooltip);
  voDf.tooltipDisplay = this.getShapeAttrValue("tooltipDisplay",this.tooltipDisplay);
  voDf.penCap = this.getShapeAttrValue("penCap",this.penCap);
  voDf.penStyle = this.getShapeAttrValue("penStyle", this.penStyle);
  voDf.penWeight = this.getShapeAttrValue("penWeight",this.penWeight);
  voDf.penColor = this.getShapeAttrValue("penColor",this.penColor);
  voDf.penOpacity = this.getShapeAttrValue("penOpacity",this.penOpacity);
  voDf.joinType = this.getShapeAttrValue("joinType",this.joinType);
  voDf.angle = this.getShapeAttrValue("angle",this.angle);
};
/**
 * setUIGeneralAttrs.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setUIGeneralAttrs = function(poCtrl, poDocument) {
  this.setAttrCtrl("visible",this.df.visible, poCtrl);
//  this.setAttrCtrl("tooltip", this.df.tooltip, poCtrl);
  this.setAttrCtrl("zIndex", this.df.zIndex, poCtrl);
  this.setAttrCtrl("position", this.df.position, poCtrl);
  this.setAttrCtrl("left", this.left, poCtrl);
  this.setAttrCtrl("top", this.top, poCtrl);
  this.setAttrCtrl("width", this.width, poCtrl);
  this.setAttrCtrl("height", this.height, poCtrl);
  this.setAttrCtrl("cursor",this.df.cursor, poCtrl);
};
/**
 * setUIGeneralEvents.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setUIGeneralEvents = function(poCtrl) {
  var voShapeCtrl = poCtrl.childNodes[0].childNodes[0].childNodes[0];
  this.eventManager.addListener(voShapeCtrl, "onclick", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "ondblclick", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "onmousedown", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "onmouseup", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "onmouseover", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "onmousemove", this.mediateEvent);
  this.eventManager.addListener(voShapeCtrl, "onmouseout", this.mediateEvent);
  voShapeCtrl.control = this;
};
/**
 * 개별 초기값을 설정합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setSpecificDefaults = function(poCtrl, poDocument) {};
/**
 * 컨트롤 별 속성들에 속성값을 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setSpecificAttrs = function(poCtrl, poDocument) {};
/**
 * 컨트롤 별 Events를 적용합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setSpecificEvents = function(poCtrl) {};
/**
 * 컨트롤 별 초기값으로 지정된 속성값을 제거합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {};
/**
 * 컨트롤(Control)에 설정된 최신 정보로 실체화 컨트롤(Ctrl)을 새로고침한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.ShapeControl.prototype.refresh = function(poDocument) {
  if(poDocument == null) poDocument = this.document;
  voCtrl = this.getCtrl(poDocument);

  if(this.removeUIGeneralDefaults) { this.removeUIGeneralDefaults(voCtrl, poDocument); };           // 공통 초기값으로 지정된 속성값을 제거
  if(this.removeSpecificDefaults) { this.removeSpecificDefaults(voCtrl, poDocument); };             // 개별 초기값으로 지정된 속성값을 제거

  if(this.refreshTemplate) { this.refreshTemplate(voCtrl, poDocument); };
  if(this.refreshMainStyles) { this.refreshMainStyles(voCtrl, poDocument); };                       // Main Style 새로고침
  if(this.refreshSubStyles) { this.refreshSubStyles(voCtrl, poDocument); };                         // Composite Child Style 새로고침

  if(this.refreshUIGeneralDefaults) { this.refreshUIGeneralDefaults(voCtrl, poDocument); };         // 공통 초기값으로 새로고침
  if(this.refreshSpecificDefaults) { this.refreshSpecificDefaults(voCtrl, poDocument); };           // 개별 초기값으로 새로고침

  if(this.refreshUIGeneralAttrs) { this.refreshUIGeneralAttrs(voCtrl, poDocument); };
  if(this.refreshSpecificAttrs) { this.refreshSpecificAttrs(voCtrl, poDocument); };                 // 개별 속성으로 새로고침

  if(this.refreshUIGeneralEvents) { this.refreshUIGeneralEvents(voCtrl); };                       // UI 공통 Events로 새로고침
  if(this.refreshSpecificEvents) { this.refreshSpecificEvents(voCtrl); };                           // 개별 Events로 새로고침

  if(this.reloadData) { this.reloadData(voCtrl, poDocument); };                                   // Data 새로고침
  if(this.refreshComplete) {this.refreshComplete(voCtrl, poDocument); };                            // 새로고침 최종 처리
};
/**
 * 컨트롤 별 속성들에 대한 새로고침을 수행합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {};
/**
 * 새로고침 최종 처리
 * @param {HTMLDiv} voCtrl 실체화 객체 최외곽 Div
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshComplete = function(poCtrl, poDocument) {
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
};
/**
 * checks if a right-click occurred
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.isRClick = function(e) {
  return (e.mousebutton == 2) ? true : false;
};
/**
 * check if the event happened in the selected element
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.inElement = function(e, psControlId) {
  var voCtrl = e.target;
  while (voCtrl) {
    if(voCtrl.id == psControlId) {
      return true;
    } else if(voCtrl.parentNode) {
      voCtrl = voCtrl.parentNode;
    } else {
      return false;
    }
  }
};


/**
 * positions and shows the context menu
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.showContextMenu = function(x,y) {
  this.canvas.showContextMenu(this.id, this.contextMenuId, x, y);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.atfocus = function(e) {
  if(this.tooltip != "" && this.tooltip != null) {
    if(this.displayTooltip) this.displayTooltip();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.coclick = function(e) {
  if(this.canvas) this.canvas.setFocusByControl(this, null, e.target);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.comousedown = function(e) {
  if(this.document == null) return;
  var voCanvas = this.canvas;
  // 컨트롤 이동을 처리
  if(this.movable) {
    if(this.document.ondragstart !== "undefined")
    {
      this.document.ondragstart = function() { return false; };
    }
    this.startMove(e);
    e.stopEvent();
  } else {
    if(voCanvas.page.metadata.browser.opera) {
    } else {
      this.document.ondragstart = function() { this.body.dragDrop(); };
    }
  }
////컨텍스트 메뉴를 처리
//  if (!this.inElement(e, this.id))
//     return true;
//  if (!this.isRClick(e)) {
//     return true;
//  } else {
//    var posx=0,posy=0;
//    if(e.pageX || e.pageY) {
//      posx=e.pageX; posy=e.pageY;
//    } else if(e.clientX || e.clientY) {
//      if(document.documentElement.scrollTop) {
//        posx=e.clientX+document.documentElement.scrollLeft;
//        posy=e.clientY+document.documentElement.scrollTop;
//      } else {
//        posx=e.clientX+document.body.scrollLeft;
//        posy=e.clientY+document.body.scrollTop;
//      }
//    }
//    this.showContextMenu(posx,posy);
//    if(this.contextMenuId) e.stopEvent();       // TODO : 향후 변경할것
//  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.finalmouseup = function(e) {
  // 컨텍스트 메뉴를 처리
  var voDocument = this.document;
  var voCanvas = this.canvas;
  voCanvas.doCollapseForAllFrame();
  if (!this.inElement(e, this.id))
     return;
  if (!this.isRClick(e)) {
     return;
  } else {
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    this.showContextMenu(posx,posy);
    if(this.contextMenuId) e.stopEvent();       // TODO : 향후 변경할것
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.comouseover = function(e) {
  if(this.df.tooltipDisplay) {
    this.tooltipHandler.show(e);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.comouseout = function(e) {
  if(this.df.tooltipDisplay) this.tooltipHandler.hide(e);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.comousemove = function(e) {
  if(this.df.tooltipDisplay) this.tooltipHandler.show(e);
};
/**
 * 이벤트를 연결한다.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.mediateEvent = function(e) {
  //base.runEvent(e, base);
  var vcCtl = this.control;
  if(vcCtl == null || (e == null && page.metadata.browser.ie == 0)) return;
  vcCtl.runEvent(e, vcCtl);
};
/**
 * Ctrl의 속성 값을 설정한다.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setAttrCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(); }

  if(psAttrValue == null) return;
  if(psAttrName == "visible") {
    psAttrValue == true ? poCtrl.style.display = "block" : poCtrl.style.display = "none"
  } else if(psAttrName == "tooltip") {
    this.tooltipHandler.setCtrl();
  } else if(psAttrName == "cursor") {
    poCtrl.style["cursor"] = psAttrValue;
  } else if(poCtrl.style[psAttrName] == undefined) {
    poCtrl[psAttrName] = psAttrValue;
  } else if(psAttrName == "left" || psAttrName == "top" || psAttrName == "width" || psAttrName == "height") {
    if(psAttrValue == "" || psAttrValue == null) {
      poCtrl.style[psAttrName] = psAttrValue;
    } else {
      if(psAttrValue < 0) psAttrValue = 0;
      poCtrl.style[psAttrName] = psAttrValue + "px";
    }
  } else {
    poCtrl.style[psAttrName] = psAttrValue;
  }
  if(poCtrl[psAttrName] != undefined) { poCtrl[psAttrName] = psAttrValue; }

  // Sub Ctrl이 있어 속성 값을 하위로 전달해야 되는 경우
  if(this.setAttrSubCtrl) { this.setAttrSubCtrl(psAttrName, psAttrValue, poCtrl); }
};
/**
 * Ctrl의 속성 값을 구한다.
 * @param {String} psAttrName 속성명
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return Ctrl의 속성 값.
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.getAttrValueCtrl = function(psAttrName, poCtrl, poDocument) {
  var vsAttrValue = null;
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  if(poCtrl.style[psAttrName] == undefined) {
    vsAttrValue = poCtrl.getAttribute(psAttrName);
  } else {
    vsAttrValue = poCtrl.style[psAttrName];
  }
  if(vsAttrValue == undefined) { vsAttrValue = null; }

  return vsAttrValue;
};
/**
 * Ctrl의 속성을 제거한다.
 * @param {String} psAttrName 속성명
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return void
 * @type void
 */
eXria.controls.xhtml.ShapeControl.prototype.removeAttrCtrl = function(psAttrName, poCtrl, poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  if(this[psAttrName] != null) { this[psAttrName] = null; }
  poCtrl.removeAttribute(psAttrName);
};
/**
 * 기존에 설정된 UI의 공통 초기값을 제거한다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.removeUIGeneralAtrrDefault = function(poCtrl, poDocument) {
    this.setAttrCtrl("display", "", poCtrl);
    this.setAttrCtrl("zIndex", "", poCtrl);
    this.setAttrCtrl("position", "", poCtrl);
    this.setAttrCtrl("cursor", "", poCtrl);
};
/**
 * setMainCtrlStyles.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
  poCtrl.className = this.getCSSClass(this, 0);
};
/**
 * refreshMainStyles.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshMainStyles = function(poCtrl, poDocument) {
  this.setMainCtrlStyles(poCtrl, poDocument);
};
/**
 * refreshUIGeneralDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshUIGeneralDefaults = function(poCtrl, poDocument) {
  this.setUIGeneralDefaults(poCtrl, poDocument);
};
/**
 * refreshSpecificDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  if(this.setSpecificDefaults)this.setSpecificDefaults(poCtrl, poDocument);
};
/**
 * Control에 설정된 공통 UI 정보로 Ctrl을 새로고침한다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshUIGeneralAttrs = function(poCtrl, poDocument) {
  this.setUIGeneralAttrs(poCtrl);
};
/**
 * refreshUIGeneralEvents.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshUIGeneralEvents = function(poCtrl, poDocument) {
  this.setUIGeneralEvents(poCtrl);
};
/**
* 서브 컨트롤 실체화 객체를 반환.
* @param {String} psTagName 서브 영역 실체화 객체 TabName
* @param {HTMLDiv} poCtrl 실체화 컨트롤
* @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
* @return {Object} 해당 TagName을 갖는 서브 영역 실체화 객체 TabName
* @private
*/
eXria.controls.xhtml.ShapeControl.prototype.getSubCtrl = function(psTagName, poCtrl, poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.getSpecificDefaultValue = function(psAttrName) {};
/**
 * 투명도 퍼센트 계산 메소드.
 * @param {Number} pnPercent 투명도 퍼센트
 * @return 투명도 퍼센트
 * @type Number
 */
eXria.controls.xhtml.ShapeControl.prototype.toPercent = function(pnPercent) {
  var vnFloat = pnPercent/100;
  return vnFloat;
};
/**
 * 지정된 라인 끝단 스타일을 속성 지정이 가능한 Number형 값으로 변환하는 메소드.
 * @param {String} psAttrName 속성명
 * @return unknown
 * @type Number
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.toConstPencap = function(psAttrName) {
  switch(psAttrName) {
    case "flat":
      return 0;
    case "round":
      return 1;
    case "square":
      return 2;
    default:
      return 1;
  }
};
/**
 * 지정된 라인 스타일을 속성 지정이 가능한 Number형 값으로 변환하는 메소드.
 * @param {String} psAttrName 속성명
 * @return unknown
 * @type Number
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.toConstPenstyle = function(psAttrName) {
  switch(psAttrName) {
    case "solid":
      return 0;
    case "dot":
      return 1;
    case "dash":
      return 2;
    default:
      return 0;
  }
};
/**
 * 지정된 라인 접합부분 스타일을 속성 지정이 가능한 Number형 값으로 변환하는 메소드.
 * @param {String} psAttrName 속성명
 * @return unknown
 * @type Number
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.toConstJointype = function(psAttrName) {
  switch(psAttrName) {
    case "miter":
      return 0;
    case "round":
      return 1;
    case "bevel":
      return 2;
    default:
      return 1;
  }
};
/**
 * Shape Control의 속성명을 일반 Control의 속성명으로 변경.
 * @param {String} psAttrName 속성명
 * @return 변경된 속성명
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.convertAttrName = function(psAttrName) {
  switch(psAttrName) {
    case "focusPenWeight" :
      return "focusBorderWidth";
    case "focusPenColor" :
      return "focusBorderColor";
    case "focusPenStyle" :
      return "focusBorderStyle";
    default :
      return psAttrName;
  }
};


/**
 * Control의 속성값을 Shape Control의 속성값으로 변경.
 * @param {String} psAttrValue 속성값
 * @return 변경된 속성값
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.convertAttrValue = function(psAttrValue) {
  vsAttrValue = psAttrValue;
  switch(psAttrValue) {
    case "dotted" :
      if(gCore.browser.msie && this.documentMode < 9) vsAttrValue = "dot";
      else vsAttrValue = "1, " + parseInt(this.getShapeAttrValue("focusPenWeight",this.focusPenWeight)) * 2;
      return vsAttrValue;
    case "dashed" :
      if(gCore.browser.msie && this.documentMode < 9) vsAttrValue = "dash";
      else vsAttrValue = "15, " + parseInt(this.getShapeAttrValue("focusPenWeight",this.focusPenWeight)) * 2;
      return vsAttrValue;
    default :
      return vsAttrValue;
  }
};
/**
 * 불투명도를 설정한다.
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {String} psFilter 필터종류
 * @param {String} psOpacity 불투명도
 * @return void
 * @type void
 */
eXria.controls.xhtml.ShapeControl.prototype.setOpacity = function(poCtrl, psFilter, psOpacity) {
  var voStyle = poCtrl.style;
  voStyle.filter = psFilter;
  voStyle.KHTMLOpacity = psOpacity;
  voStyle.MozOpacity = psOpacity;
  voStyle.opacity = psOpacity;
};

/**
 * 컨트롤의 이동 또는 크기 변경시에 윤곽선을 나타내주는 DIV 객체.
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler = function(poParent) {
  this.parent = poParent;
 };
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler.prototype.createPane = function() {
  var voParent = this.parent;
  var voDocument = voParent.window.document;
  var voCtrl = voParent.getCtrl();
  var voParentNode = voCtrl.parentNode;
  var thisStyle = voCtrl.style;
  var voPane = voDocument.createElement("div");
  voPane.setAttribute("id", voParent.id + "_pane");

  var voStyle = voPane.style;
  voStyle.position = "absolute";
  voStyle.left = thisStyle.left;
  voStyle.top = thisStyle.top;
  var vnBorderWidth = voParent.borderWidth;
  if(voParent.borderStyle == null || voParent.borderStyle == "none") vnBorderWidth = 0;
  voStyle.width = (voParent.width + 2 * vnBorderWidth) + "px";
  voStyle.height = (voParent.height + 2 * vnBorderWidth) + "px";
  voStyle.backgroundColor = "yellow";
  voStyle.opacity = voParent.paneOpacity / 100;
  voStyle.filter = "alpha(opacity=" + voParent.paneOpacity + ")";
  voStyle.zIndex = 1000010; //Number(thisStyle.zIndex) + 1;
  voStyle.borderColor ="black";
  voStyle.borderStyle ="dotted";
  voStyle.borderWidth = "1px";
  // TODO : voStyle.display = "none";
  voParentNode.appendChild(voPane);
  return voPane;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler.prototype.getStyle = function() {
  var voParent = this.parent;
  var voDocument = voParent.document;
  var voPane = voDocument.getElementById(voParent.id + "_pane");
  return voPane.style;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler.prototype.getCtrl = function() {
  var voParent = this.parent;
  var voDocument = voParent.document;
  var voPaneCtrl = voDocument.getElementById(voParent.id + "_pane");
  return voPaneCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler.prototype.removePane = function() {
  var voParent = this.parent;
  var voParentNode = voParent.getCtrl().parentNode;
  var voPaneCtrl = voParent.paneHandler.getCtrl();
  voPaneCtrl.style.display = "none";
  voParentNode.removeChild(voPaneCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl_paneHandler.prototype.applyAttrCtrl = function(psAttrName, psAttrValue) {
  var voParent = this.parent;
  var voPaneCtrl = voParent.paneHandler.getCtrl();
  if(voPaneCtrl.style[psAttrName] == undefined) {
    voPaneCtrl.setAttribute(psAttrName, psAttrValue);
  } else {
    voPaneCtrl.style[psAttrName] = psAttrValue;
  }
};

/**
 * 공통 초기화 수행
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.initUIGeneral = function() {
  this.tooltipHandler = new eXria.controls.xhtml.UIControl_tooltipHandler(this);                            // tooltipHandler에 컨트롤 참조를 설정
  this.paneHandler = new eXria.controls.xhtml.ShapeControl_paneHandler(this);
  this.dragDropHandler = new eXria.controls.xhtml.UIControl_dragDropHandler(this);
};
/**
 * 컨트롤 이동 관련
 * @return 0
 * @type Number
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.getClientAbsLeft = function() { return 0; };
/**
 * 컨트롤 이동 관련
 * @return 0
 * @type Number
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.getClientAbsTop = function() { return 0; };
/**
 * 컨트롤의 동적 위치 이동 허용여부 지정.
 * @param {Boolean} pbMove 위치이동 가능 여부
 * @return void
 */
eXria.controls.xhtml.ShapeControl.prototype.setMove = function(pbMove) {
  var voDocument = this.document;
  var voCtrl = this.getCtrl();
  if(voCtrl == null) return;

  if(pbMove) {
    this.movable = true;
  } else {
    this.movable = false;
    voDocument.onmousemove = null;
    voDocument.onmouseup = null;
  }
};
/**
 * startMove<br>
 * 컨트롤 동적 위치 이동이 가능한 경우 컨트롤에 mousedown이벤트 발생 시 처리 수행
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.startMove = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voCtrl = this.getCtrl();
  var voParentNode = voCtrl.parentNode;
  var voPane = this.paneHandler.createPane();
  var voPaneStyle = voPane.style;
  var voParentStyle = voParentNode.style;

  var voEvent = new eXria.event.Event(e, this.window);
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;

  this.clientAbsLeft = this.getClientAbsLeft();
  this.clientAbsTop = this.getClientAbsTop();

  var vnMouseX = voEvent.e.clientX - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY - this.clientAbsTop;

  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;

  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "move";
  this.getCtrl().style.cursor = "move";

  voPane.onmousemove = function(e) { this.control.onMove(e); };
  voPane.onmouseup = function(e) { this.control.stopMove(e); };
  voPane.control = this;
  voDocument.onmousemove =  function(e) { this.control.onMove(e); };
  voDocument.onmouseup =  function(e) { this.control.stopMove(e); };
  voDocument.control = this;
};
/**
 * 컨트롤 동적 위치 이동 시 마우스 드래그 상태에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.onMove = function(e) {
  var voCtrl = this.getCtrl();
  var voParentNode = voCtrl.parentNode;
  var voPaneCtrl = this.paneHandler.getCtrl();
  if(voCtrl == null || voPaneCtrl == null) {
      return;
  }

  var voStyle = voPaneCtrl.style;

  var voEvent = new eXria.event.Event(e, this.window);
  var vnMouseX = voEvent.e.clientX; // - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY; // - this.clientAbsTop;

  var vnNewLeft = vnMouseX + this.leftOffset;
  var vnNewTop = vnMouseY + this.topOffset;

/*
  var vnWidth = parseInt(voStyle.width);
  var vnHeight = parseInt(voStyle.height);

  var voClientStyle = voCtrl.style;
  var vnClientWidth = parseInt(voClientStyle.width);
  var vnClientHeight = parseInt(voClientStyle.height);

  if (vnNewLeft < this.adjustOffset) {
      vnNewLeft = 0;
  } else {
      vnNewLeft = vnClientWidth - vnWidth;
  }

  if (vnNewTop < this.adjustOffset) {
      vnNewTop = 0;
  } else {
      vnNewTop = vnClientHeight - vnHeight;
  }
*/
if(voParentNode.style.left == null || voParentNode.style.left == "") voParentNode.style.left = 0;
if(voParentNode.style.top == null || voParentNode.style.top == "") voParentNode.style.top = 0;
  voStyle.left = vnNewLeft - parseInt(voParentNode.style.left) + "px";
  voStyle.top = vnNewTop - parseInt(voParentNode.style.top) + "px";
};
/**
 * 컨트롤 동적 위치 이동 시 mouseup 이벤트에서의 처리 수행.
 * @param {HTMLEvent} e 윈도우이벤트
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.stopMove = function(e) {
  if (this.disabled == true) { return; }

  var voDocument = this.document;
  var voCtrl = this.getCtrl();
  var voParentNode = voCtrl.parentNode;
  var voPane = this.paneHandler.getCtrl();
  var voPaneStyle = voPane.style;
  var voParentStyle = voParentNode.style;

  this.left = parseInt(voPaneStyle.left);
  this.top = parseInt(voPaneStyle.top);
  // TODO : this.width = parseInt(voPaneStyle.width);
  // TODO : this.height = parseInt(voPaneStyle.height);
  this.refresh();
  this.paneHandler.removePane();

  // Check
  voDocument.body.style.cursor = "auto";
  voCtrl.style.cursor = "auto";

  voPane.onmousemove = null;
  voPane.onmouseup = null;
  voDocument.onmousemove = null;
  voDocument.onmouseup = null;

  this.mode = null;
  this.leftOffset = -1;
  this.topOffset = -1;
  this.rightOffset = -1;
  this.bottomOffset = -1;
};
/**
 * 포커스 변경에 따른 style 변경 처리.
 * @param {Boolean} pbFocus 포커스 in/out 여부
 * @return void
 * @type void
 */
eXria.controls.xhtml.ShapeControl.prototype.setFocusStyle = function(pbFocus) {
  var voCtrl = this.getCtrl();
  var voShapeCtrl = voCtrl.childNodes[0].childNodes[0].childNodes[0];

  var vsStrokeWeight = null;
  var vsStrokeColor = null;
  var vsStrokeStyle = null;

  if(gCore.browser.msie && this.documentMode < 9){
    var voStrokeColorObj = null;
    var voStrokeStyleObj = null;
    if(gCore.browser.msie < 8.0) {
      vsStrokeWeight = voShapeCtrl.getAttribute("strokeweight");
      voStrokeColorObj = voShapeCtrl.getAttribute("strokecolor");
      vsStrokeWeight = (vsStrokeWeight == null) ? voShapeCtrl["strokeweight"] : vsStrokeWeight;
      voStrokeColorObj = (voStrokeColorObj == null) ? voShapeCtrl["strokecolor"] : voStrokeColorObj;
    } else {
      vsStrokeWeight = voShapeCtrl["strokeweight"];
      voStrokeColorObj = voShapeCtrl["strokecolor"];
    }
    voStrokeStyleObj = voShapeCtrl.stroke.dashstyle;
    vsStrokeColor = voStrokeColorObj.value;
    vsStrokeStyle = voStrokeStyleObj.value;
  }else{
    vsStrokeWeight = voShapeCtrl.getAttribute("stroke-width");
    vsStrokeColor = voShapeCtrl.getAttribute("stroke");
    vsStrokeStyle = voShapeCtrl.getAttribute("stroke-dasharray");
  }

  if(this.oldPenWeight == null) {
    this.oldPenWeight = vsStrokeWeight;
    this.oldPenColor = vsStrokeColor;
    this.oldPenStyle = vsStrokeStyle;
  }

  if(pbFocus && this.focusDisplay) {
    var vsFocusBorderWidth = this.getShapeAttrValue("focusPenWeight",this.focusPenWeight);
    if(vsFocusBorderWidth) {
      if(vsFocusBorderWidth == "auto") {
        vsStrokeWeight = this.getShapeAttrValue("penWeight", this.penWeight) + "px";
      } else {
        vsStrokeWeight = vsFocusBorderWidth + "px";
      }
    }
    vsStrokeColor = this.getShapeAttrValue("focusPenColor", this.focusPenColor);
    vsStrokeStyle = this.getShapeAttrValue("focusPenStyle", this.focusPenStyle);

    if(gCore.browser.msie && this.documentMode < 9){
      if(vsStrokeStyle == "none" || vsFocusBorderWidth == 0) voShapeCtrl.stroke.on = "false";
      else voShapeCtrl.stroke.on = "true";
      voShapeCtrl.strokeweight = vsStrokeWeight;
      voShapeCtrl.strokecolor = vsStrokeColor;
      voShapeCtrl.stroke.dashstyle = vsStrokeStyle;
    }else{
      if(vsStrokeStyle == "none" || vsFocusBorderWidth == 0) vsStrokeWeight = "0";
      voShapeCtrl.setAttribute("stroke-width", vsStrokeWeight);
      voShapeCtrl.setAttribute("stroke", vsStrokeColor);
      voShapeCtrl.setAttribute("stroke-dasharray", vsStrokeStyle);
    }
  } else {
    vsStrokeWeight = "";
    vsStrokeStyle = "";
    vsStrokeColor = "";
    if(gCore.browser.msie && this.documentMode < 9){
      if(this.oldPenStyle == "none" || this.oldPenWeight == 0) voShapeCtrl.stroke.on = "false";
      else voShapeCtrl.stroke.on = "true";
      voShapeCtrl.strokeweight = this.oldPenWeight ? this.oldPenWeight : vsStrokeWeight;
      voShapeCtrl.strokecolor = this.oldPenColor ? this.oldPenColor : vsStrokeColor;
      voShapeCtrl.stroke.dashstyle = this.oldPenStyle ? this.oldPenStyle : vsStrokeStyle;
    }else{
      voShapeCtrl.setAttribute("stroke-width", this.oldPenWeight ? this.oldPenWeight : vsStrokeWeight);
      voShapeCtrl.setAttribute("stroke", this.oldPenColor ? this.oldPenColor : vsStrokeColor);
      voShapeCtrl.setAttribute("stroke-dasharray", this.oldPenStyle ? this.oldPenStyle : vsStrokeStyle);
    }
  }
};
/**
 * 디폴트 속성값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 디폴트 속성값
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.getAttrValue = function(psAttrName, psAttrValue) {
  psAttrName = this.convertAttrName(psAttrName);

  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = null;
    if(this.canvas)  vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
    if(vsAttrValue != null) {
      vsAttrValue = this.convertAttrValue(vsAttrValue);
      return vsAttrValue;
    } else {
      vsAttrValue = this.getSpecificDefaultValue(psAttrName);
      if(vsAttrValue == null) vsAttrValue = this.getShapeDefaultValue(psAttrName);
      return vsAttrValue;
    }
  }

};
/**
 * 도형 속성의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 UI관련 속성의 디폴트 값
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.getShapeAttrValue = function(psAttrName, psAttrValue) {
  psAttrName = this.convertAttrName(psAttrName);

  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = this.canvas.getFormExtendAttrValue(psAttrName);
    if(vsAttrValue != null) {
      vsAttrValue = this.convertAttrValue(vsAttrValue);
      return vsAttrValue;
    } else {
      vsAttrValue = this.getSpecificDefaultValue(psAttrName);  // TODO : 위의 소스로 교체할것
      if(vsAttrValue == null) vsAttrValue = this.getShapeDefaultValue(psAttrName);
      return vsAttrValue;
    }
  }
};
/**
 * 도형의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성의 공통 디폴트 값
 * @type String
 */
eXria.controls.xhtml.ShapeControl.prototype.getShapeDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.ShapeControl[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * toolip의 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 toolip 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.getTooltipAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) return psAttrValue;
  else return this.getTooltipDefaultValue(psAttrName);
};
/**
 * toolip의 공통 디폴트 값을 구함.
 * @param {String} psAttrName 속성명
 * @return 해당 속성의 toolip 공통 디폴트 값
 * @type String
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.getTooltipDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.ToolTip[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 컨트롤에 데이타 로딩 작업 수행.
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.load = function() {
  if(this.loadCanvasConfig) this.loadCanvasConfig();
  if(this.data && this.loadData) this.loadData(this.document);
  if(this.loadComplete) this.loadComplete(this.document);
};
/**
 * 컨트롤이 page에 load 될때 Canvas 객체의 속성을 참조해야될 작업 수행
 * @private
 */
eXria.controls.xhtml.ShapeControl.prototype.loadCanvasConfig = function() {
  var voDocument = this.document;
  this.tooltipHandler.document = voDocument;
  this.paneHandler.document = voDocument;
  this.dragDropHandler.document = voDocument;

  if(this.canvas && this.tooltip != null && this.tooltip.length != 0) {
//    this.tooltipHandler.arrowImage = "url('" + this.canvas.page.metadata.resourceBaseUrl + "eXria/controls/xhtml/images/arrow.gif')";
//    this.document.getElementById(this.id + "_TooltipArrow").style.backgroundImage = "url('" + this.canvas.page.metadata.resourceBaseUrl + "eXria/controls/xhtml/images/arrow.gif')";
    this.tooltipHandler.setCtrl();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ShapeControl.prototype.applyAttrSimple = null;
/**
 * CSS Class 명을 반환한다.
 * @param poCtrl
 * @param pnType 0 : OuterClass, 1 : Class
 * @return String
 */
eXria.controls.xhtml.ShapeControl.prototype.getCSSClass = function(poCtrl, pnType, psSubClass){
  var vsPreFix = "Default";
  var vsType = this.toString();
  if(pnType === null || pnType === undefined) pnType = 0;
  var vsSubClass = "";
  var voClassObj = this;
  var vaSubObj = null;
  if(psSubClass){
    voClassObj = voClassObj[psSubClass];
    vsSubClass = "_" + psSubClass.split(".").join("_");
  }

  var vsUIControlClass = vsPreFix + "_ShapeControl_" + ["OuterClass", "Class"][pnType];
  var vsControlClass = "";
  if(this.control){
    vsControlClass = vsPreFix + "_" + this.control.toString() + "_" +  vsType + "s" + vsSubClass + "_" + ["OuterClass", "Class"][pnType];
  }else{
    vsControlClass = vsPreFix + "_" + vsType + vsSubClass + "_" + ["OuterClass", "Class"][pnType];
  }

  var vsUserClass = null;
  if(pnType === 0 && voClassObj != null){
    if(voClassObj.outerClassName) vsUserClass = voClassObj.outerClassName;
  }else if(pnType === 1 && voClassObj != null){
    if(voClassObj.className) vsUserClass = voClassObj.className;
  }
  if(vsUserClass == null){
    vsUserClass = "";
  }
  return vsSubClass == "" ? vsUIControlClass + " " + vsControlClass + " " + vsUserClass : vsControlClass + " " + vsUserClass;
};
/**
 * 컨트롤 위치 및 크기를 재설정하기 위한 메소드
 */
eXria.controls.xhtml.ShapeControl.prototype.resize = function() {
  if(this.isResize === false) this.refreshPos();
  else this.refresh();
};
/**
 * left, top 속성 설정에 의해 변경된 컨트롤 위치 값을 실체화 객체에 반영하는 메소드
 */
eXria.controls.xhtml.ShapeControl.prototype.refreshPos = function() {
  var voCtrl = this.ctrl;
  voCtrl.style.left = this.left + "px";
  voCtrl.style.top = this.top + "px";
};
// End of Control
/**
 * @fileoverview
 * Concreate xhtml Item(XHTML Item 컨트롤)
 * @author 김경태
 */

/**
 * @class CheckBox와 RadioButton의 체크아이템을 실체화시키는 class입니다.<br />
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.Item 객체
 * @type eXria.controls.Item
 * @constructor
 * @base eXria.controls.Item
 * @private
 */

eXria.controls.xhtml.Item = function(psId, poParent, psLabelText, psValue, pnLeft, pnTop, pnWidth, pnHeight){

  vnLeft = pnLeft == null ? 0 : pnLeft;
  vnTop = pnTop == null ? 0 : pnTop;
  vnWidth = pnWidth == null ? 200 : pnWidth;
  vnHeight = pnHeight == null ? 20 : pnHeight;

  eXria.controls.Item.call(this, psId, poParent, psLabelText, psValue, vnLeft, vnTop, vnWidth, vnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * Radio, Checkbox Button 클래스의 라벨 속성 저장 오브젝트.
   * @type Object
   */
  this.label = new eXria.controls.xhtml.Select_label();
  /**
   * Radio, Checkbox Button 클래스의 선택버튼 속성 저장 오브젝트.
   * @type Object
   */
  this.selector = new eXria.controls.xhtml.Select_selector();
  /**
   * 아이템의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   * @private
   */
  this.data = new eXria.controls.DataRefNode(this.parent);
};
//eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Item);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.Item, eXria.controls.xhtml.Item);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.Item.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  var voStyle = voCtrl.style;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  voCtrl.setAttribute("id", this.id);
  voStyle.position = "absolute";
  voStyle.overflow = "hidden";       // 컨트롤 영역을 벗어난 하위 요소를 안보이게 처리
  voStyle.left = this.left + "px";
  voStyle.top = this.top + "px";
  voStyle.color = this.color;
  voStyle.backgroundColor = this.backgroundColor;
  if(this.borderWidth) voStyle.borderWidth = this.borderWidth + "px";
  if(this.borderStyle) voStyle.borderStyle = this.borderStyle;
  if(this.borderColor) voStyle.borderColor = this.borderColor;
  voCtrl.disabled = this.disabled;

  if(this.verticalAlign == null) this.verticalAlign = this.getSpecificDefaultValue("verticalAlign");

  this.createSubCtrl(voCtrl, poDocument);
  //this.setMainCtrlStyles(voCtrl, poDocument);
  return voCtrl;
};
/**
 * item을 구성하기 위한 HTML 문자열을 얻어오는 메소드.
 * @return item을 구성하기 위한 HTML 문자열 값.
 * @type String
 * @private
 */
eXria.controls.xhtml.Item.prototype.getInnerHTML = function() {
  this.setSpecificDefaults();

  var voDf = this.df;
  this.template = [];
  var vaTemplate = this.template;
  vaTemplate.push("<div id='");
  vaTemplate.push(this.id);
  vaTemplate.push("' ");
  vaTemplate.push("@attStrBuf");
  vaTemplate.push(" style='position:absolute;overflow:hidden;");
  vaTemplate.push("@cssStrBuf");  // 5
  vaTemplate.push("'>");
  var vsClass = this.parent.getCSSClass(this.parent, 1, "itemgroup");
  vaTemplate.push("<table cellSpacing=0 cellPadding=0 style='");
  vaTemplate.push("@cssStrBuf"); // 8
  vaTemplate.push("'><tbody><tr><td ");
  vaTemplate.push("@attStrBuf"); //10
  vaTemplate.push(" style='");
  vaTemplate.push("@cssStrBuf"); // 12

  var vsLabelCtrl = this.label.getInnerHTML(this);
  var vsSelectorCtrl = this.selector.getInnerHTML(this);
   switch(this.labelPos) {
    case "left" :
        // yhkim 기존코드
//      vaTemplate.push("'><div style='border-style:none;border-width:0px;overflow:hidden;"); // 위에꺼
//      vaTemplate.push("@cssStrBuf");  // 14                                                 // 위에꺼
//      vaTemplate.push("'>");                                                                // 위에꺼
//      vaTemplate.push(vsLabelCtrl);
//      vaTemplate.push(vsSelectorCtrl);
//      vaTemplate.push("</div>");                                                            // 아래꺼

    // yhkim 2009.07.23 라이오 체크 vertival문제
    vaTemplate.push("'><table cellspacing='0' cellpadding='0' ");
    vaTemplate.push("@attStrBuf");
    //vaTemplate.push("><tbody><tr><td>")
    // yhkim2009.09.21 table td내에 span이 브라어저 내에서 위치가 바뀌는 현상
    if(this.parent.canvas.page.metadata.browser.ie > 0 && this.parent.canvas.page.metadata.browser.ie < 8)
      vaTemplate.push("><tbody><tr><td style=\"padding-top:3px;\">")
    else if(this.parent.canvas.page.metadata.browser.ie > 7 || this.parent.canvas.page.metadata.browser.gecko > 0)
      vaTemplate.push("><tbody><tr><td style=\"padding-bottom:3px;\">")
    vaTemplate.push(vsLabelCtrl);
    vaTemplate.push("</td><td style='vertical-align:top;'>");
    vaTemplate.push(vsSelectorCtrl);
    vaTemplate.push("</td></tr></tbody></table>");

      //분기문에서 vaTemplate의 인덱스를 맞춰주기 위해 빈 문자열을 배열에 추가하는 것도 고려
      break;
    case "right":
        // yhkim 기존코드
//      vaTemplate.push("'><div style='border-style:none;border-width:0px;overflow:hidden;");
//      vaTemplate.push("@cssStrBuf");  // 14
//      vaTemplate.push("'>");
//      vaTemplate.push(vsSelectorCtrl);
//      vaTemplate.push(vsLabelCtrl);
//      vaTemplate.push("</div>");
        // yhkim 2009.07.23 라이오 체크 vertival문제
    vaTemplate.push("'><table cellspacing='0' cellpadding='0' ");
    vaTemplate.push("@attStrBuf");
    vaTemplate.push("><tbody><tr><td style='vertical-align:top;'>")
    vaTemplate.push(vsSelectorCtrl);
    //vaTemplate.push("</td><td >");
    // yhkim2009.09.21 table td내에 span이 브라어저 내에서 위치가 바뀌는 현상
    if(this.parent.canvas.page.metadata.browser.ie > 0 && this.parent.canvas.page.metadata.browser.ie < 8)
      vaTemplate.push("</td><td style=\"padding-top:3px;\">")
    else if(this.parent.canvas.page.metadata.browser.ie > 7 || this.parent.canvas.page.metadata.browser.gecko > 0)
      vaTemplate.push("</td><td style=\"padding-bottom:3px;\">")
    vaTemplate.push(vsLabelCtrl);
    vaTemplate.push("</td></tr></tbody></table>");
      break;

    case "top" :
      vaTemplate.push("'><div style='border-style:none;border-width:0px;overflow:hidden;");
      vaTemplate.push("@cssStrBuf");  // 14
      vaTemplate.push("'>");
      vaTemplate.push(vsLabelCtrl);
      vaTemplate.push("</div>");
      vaTemplate.push("<div style='border-style:none;border-width:0px;overflow:hidden;");
      vaTemplate.push("@cssStrBuf"); //19
      vaTemplate.push("'>");
      vaTemplate.push(vsSelectorCtrl);
      vaTemplate.push("</div>");
      break;

    case "bottom" :
      vaTemplate.push("'><div style='border-style:none;border-width:0px;overflow:hidden;");
      vaTemplate.push("@cssStrBuf");  // 14
      vaTemplate.push("'>");
      vaTemplate.push(vsSelectorCtrl);
      vaTemplate.push("</div>");
      vaTemplate.push("<div style='border-style:none;border-width:0px;overflow:hidden;");
      vaTemplate.push("@cssStrBuf"); //19
      vaTemplate.push("'>");
      vaTemplate.push(vsLabelCtrl);
      vaTemplate.push("</div>");
      break;
    default :
      throw new Error("labelPos 속성 값에 오류가 있습니다.");
      break;
  }
  //yhkim 기존코드
  //vaTemplate.push("</div>");
  vaTemplate.push("</td>");
  vaTemplate.push("</tr>");
  vaTemplate.push("</tbody>");
  vaTemplate.push("</table>");
  vaTemplate.push("</div>");

  this.setSpecificAttrs();

  var vsRet = vaTemplate.join("");
  vaTemplate = null;
  this.template = null;
  return vsRet;
};
/**
 * Main Style 적용
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Item.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
  //var voTable = poCtrl.childNodes[0];
  //this.parent.setAttrCtrl("className", this.parent.className, voTable);
};

///*
//eXria.controls.xhtml.Item.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
//  var vsTextAlign = null;
//  var vsVerticalAlign = null;
//  var voStyle = poCtrl.style;
//
//  // CSS가 적용되지 않는 속성에 대한 초기값 설정(main 컨트롤)
//  var vsLabelPos = this.getAttrValue("labelPos", this.labelPos);
//  var vnWidth = this.getAttrValue("width", this.width);
//  var vnHeight = this.getAttrValue("height", this.height);
//  voStyle.height = vnHeight + "px";
//  voStyle.width = vnWidth + "px";
//
//  // 고정값 설정
//  voStyle.position = "absolute";
//  voStyle.overflow = "hidden";      // 컨트롤 영역을 벗어난 하위 요소를 안보이게 처리
//  voStyle.left = this.left + "px";
//  voStyle.top = this.top + "px";
//  poCtrl.disabled = this.disabled;
//
//  var voTable = poCtrl.childNodes[0];
//  voTable.cellPadding = "0";             // IE 와 Firefox의 동작방식이 틀려서 0으로 고정
//  voTable.cellSpacing = "0";
//  var voTBody = voTable.childNodes[0];
//  var voTr1 = null;
//  var voTd1 = null;
//  var voItemDiv1 = null;
//  var voItemDiv2 = null;
//
//  switch(vsLabelPos) {
//    case "left" :
//      voTr1 = voTBody.childNodes[0];
//      voTd1 = voTr1.childNodes[0];
//
//      voTr1.style.width = vnWidth + "px";
//      voStyle = voTd1.style;
//      voStyle.backgroundColor = this.backgroundColor;
//      voStyle.height = vnHeight + "px";
//
//      voItemDiv1 = voTd1.childNodes[0];
//      voStyle = voItemDiv1.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv1.textAlign = vsTextAlign;
//      break;
//    case "right" :
//      voTr1 = voTBody.childNodes[0];
//      voTd1 = voTr1.childNodes[0];
//
//      voStyle = voTd1.style;
//      voStyle.width = vnWidth + "px";
//      voStyle.backgroundColor = this.backgroundColor;
//      voStyle.height = vnHeight + "px";
//
//      if(vsVerticalAlign == "middle") {
//        voStyle.verticalAlign = "middle";
//      } else if(vsVerticalAlign == "top") {
//        voStyle.verticalAlign = "top";
//      } else if(vsVerticalAlign == "bottom") {
//        voTd1.vAlign="bottom";
//        voStyle.height = vnHeight + "px";
//        voTable.height = vnHeight + "px";
//      }
//
//      voItemDiv1 = voTd1.childNodes[0];
//      voStyle = voItemDiv1.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv1.textAlign = vsTextAlign;
//      break;
//    case "top" :
//      voTr1 = voTBody.childNodes[0];
//      voTd1 = voTr1.childNodes[0];
//
//      voStyle = voTd1.style;
//      voStyle.backgroundColor = this.backgroundColor;
//      voStyle.height = vnHeight + "px";
//
//      if(vsVerticalAlign == "middle") {
//        voStyle.verticalAlign = "middle";
//      } else if(vsVerticalAlign == "top") {
//        voStyle.verticalAlign = "top";
//      } else if(vsVerticalAlign == "bottom") {
//        voTd1.vAlign="bottom";
//        voTr1.style.height = vnHeight + "px";
//        voTable.height = vnHeight + "px";
//      }
//
//      voItemDiv1 = voTd1.childNodes[0];
//      voStyle = voItemDiv1.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv1.textAlign = vsTextAlign;
//
//      voItemDiv2 = voTd1.childNodes[1];
//      voStyle = voItemDiv2.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv2.textAlign = vsTextAlign;
//      break;
//    case "bottom" :
//      voTr1 = voTBody.childNodes[0];
//      voTd1 = voTr1.childNodes[0];
//
//      voStyle = voTd1.style;
//      voStyle.backgroundColor = this.backgroundColor;
//      voStyle.height = vnHeight + "px";
//
//      if(vsVerticalAlign == "middle") {
//        voStyle.verticalAlign = "middle";
//      } else if(vsVerticalAlign == "top") {
//        voStyle.verticalAlign = "top";
//      } else if(vsVerticalAlign == "bottom") {
//        voTd1.vAlign="bottom";
//        voTr1.style.height = vnHeight + "px";
//        voTable.height = vnHeight + "px";
//      }
//      voItemDiv1 = voTd1.childNodes[0];
//      voStyle = voItemDiv1.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv1.textAlign = vsTextAlign; //"center";
//
//      voItemDiv2 = voTd1.childNodes[1];
//      voStyle = voItemDiv2.style;
//      voStyle.overflow = "hidden";
//      voStyle.width = vnWidth + "px";
//      voItemDiv2.textAlign = vsTextAlign; //"center";
//      break;
//    default :
//      throw new Error("labelPos 속성 값에 오류가 있습니다.");
//      break;
//  }
//  return poCtrl;
//};
//*/
/**
 * 개별 초기값 설정
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return poCtrl
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.Item.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;
  this["color"] = this.getAttrValue("color", this.color);
  this["backgroundColor"] = this.getAttrValue("backgroundColor", this.backgroundColor);
  this["borderColor"] = this.getAttrValue("borderColor", this.borderColor);
  this["borderStyle"] = this.getAttrValue("borderStyle", this.borderStyle);
  this["borderLeftWidth"] = this.getAttrValue("borderLeftWidth", this.borderLeftWidth);
  this["borderRightWidth"] = this.getAttrValue("borderRightWidth", this.borderRightWidth);
  this["borderTopWidth"] = this.getAttrValue("borderTopWidth", this.borderTopWidth);
  this["borderBottomWidth"] = this.getAttrValue("borderBottomWidth", this.borderBottomWidth);
  this["fontFamily"] = this.getAttrValue("fontFamily", this.fontFamily);
  this["fontSize"] = this.getAttrValue("fontSize", this.fontSize);
  this["fontStyle"] = this.getAttrValue("fontStyle", this.fontStyle);
  this["fontWeight"] = this.getAttrValue("fontWeight", this.fontWeight);
  this["labelPos"] = this.getAttrValue("labelPos", this.labelPos);
  this["verticalAlign"] = this.getAttrValue("verticalAlign", this.verticalAlign);
  this["textAlign"] = this.getAttrValue("textAlign", this.textAlign);
  //TODO
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  var voData = this.data;
  if(voData.instanceId && voData.instancePath) {
    this.text = voData.getData();
  }
};
///*
//eXria.controls.xhtml.Item.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
//  var voTable = poCtrl.childNodes[0];
//  var voTd = voTable.rows[0].cells[0];
//  var voDiv = voTd.childNodes[0];
//  var voParentItemgroupDf = this.parent.itemgroup.df;
//
//  poCtrl.setAttribute("id", this.id);
//  this.parent.setAttrCtrl("borderColor", voParentItemgroupDf.borderColor, poCtrl);
//  this.parent.setAttrCtrl("borderStyle", voParentItemgroupDf.borderStyle, poCtrl);
//  this.parent.setAttrCtrl("borderLeftWidth", voParentItemgroupDf.borderLeftWidth, poCtrl);
//  this.parent.setAttrCtrl("borderRightWidth", voParentItemgroupDf.borderRightWidth, poCtrl);
//  this.parent.setAttrCtrl("borderTopWidth", voParentItemgroupDf.borderTopWidth, poCtrl);
//  this.parent.setAttrCtrl("borderBottomWidth", voParentItemgroupDf.borderBottomWidth, poCtrl);
//  this.parent.setAttrCtrl("color", voParentItemgroupDf.color, poCtrl);
//  this.parent.setAttrCtrl("backgroundColor", voParentItemgroupDf.backgroundColor, poCtrl);
//  this.parent.setAttrCtrl("fontFamily", voParentItemgroupDf.fontFamily, poCtrl);
//  this.parent.setAttrCtrl("fontSize", voParentItemgroupDf.fontSize, poCtrl);
//  this.parent.setAttrCtrl("fontStyle", voParentItemgroupDf.fontStyle, poCtrl);
//  this.parent.setAttrCtrl("fontWeight", voParentItemgroupDf.fontWeight, poCtrl);
//
//  this.parent.setAttrCtrl("textAlign", voParentItemgroupDf.textAlign, voDiv);
//  this.parent.setAttrCtrl("verticalAlign", voParentItemgroupDf.verticalAlign, voTd);
//};
//*/
/**
 * 개별 Attrs 적용
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Item.prototype.setSpecificAttrs = function() {
  var voParent = this.parent;
  var voDf = this.df;
  var vaTemplate = this.template;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vfcSetAttStrBuf = voParent.setAttStrBuf;
  var vfcSetCssStrBuf = voParent.setCssStrBuf;

  vaAttStrBuf = [];
  if(this.disabled) vaAttStrBuf.push("disabled");
  vaTemplate[3] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
//  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
//  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.width, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.height, "px");
  if(this.disabled) vfcSetCssStrBuf(vaCssStrBuf, "color", voParent.disabledColor);
  else vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vaTemplate[5] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  // yhkim2009.09.31 table은기본적으로  위아래 2px씩 가진다.
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight-2, "px");
  vaTemplate[8] = vaCssStrBuf.join(""); //table

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "valign", this.verticalAlign);
  //vfcSetCssStrBuf(vaCssStrBuf, "align", this.textAlign);
  //yhkim 2009.07.23 라이오 체크 vertival문제
  vfcSetAttStrBuf(vaAttStrBuf, "align", this.textAlign);
  vaTemplate[10] = vaAttStrBuf.join(""); //td

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  // yhkim2009.09.31 table의 하위 table 은 위아래 합이4px 가진다.
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight-4, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  if(this.textAlign == "left" || this.textAlign == null) vfcSetCssStrBuf(vaCssStrBuf, "padding-left", "2px");
  if(this.textAlign == "right") vfcSetCssStrBuf(vaCssStrBuf, "padding-right", "2px");
//  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.verticalAlign);
  vaTemplate[12] = vaCssStrBuf.join(""); //td

  vaCssStrBuf = [];
  switch(this.labelPos) {
  case "left" :
  case "right" :
//    vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
//    vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
//    vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
    //vaTemplate[14] = vaCssStrBuf.join(""); //div1
    // yhkim 2009.07.23 라이오 체크 vertival문제
    vaTemplate[14] = vaTemplate[10];
    break;
  case "top" :
  case "bottom" :
//    vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.width, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
//    vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
    vaTemplate[19] = vaCssStrBuf.join(""); //div1
    break;
  }

  vaCssStrBuf = null;
};
/**
 * 아이템 새로고침
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Item.prototype.refresh = function(poDocument) {
  //this.createCtrl();
};
/**
 * 아이템의 실체화 객체를 반환합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 * @return 아이템 실체화 객체
 * @type HTMLInput(radio|checkbox)
 * @private
 */
eXria.controls.xhtml.Item.prototype.getItemCtrl = function(poDocument) {
  var voParent = this.parent;
  if(poDocument == null) poDocument = voParent.document;
  var voCtrl = poDocument.getElementById(this.id);
  var voTable = voCtrl.childNodes[0];
  var vaDiv = voTable.rows[0].cells[0].childNodes;
  var voDiv = null;
  var voSubCtrl = null;
  for(var i = 0; i < vaDiv.length; i++) {
    //voSubCtrl = vaDiv[i].childNodes[0];
    //if(voSubCtrl.nodeType == 1) {
    //  break;
    //}
    voDiv = vaDiv[i];
    voSubCtrl = voDiv.getElementsByTagName("input")[0];
    if(voSubCtrl) {
      break;
    }
  }

  return voSubCtrl;
};
/**
 * 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 디폴트 속성값
 * @type String
 * @private
 */
eXria.controls.xhtml.Item.prototype.getAttrValue = function(psAttrName, psAttrValue) {
  if (psAttrValue != null) return psAttrValue;
  else return this.getSpecificDefaultValue(psAttrName);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Item.prototype.getSpecificDefaultValue = function(psAttrName) {
  var voDf = null;
  switch(psAttrName) {
  case "fontFamily" :
  case "fontStyle" :
  case "color" :
  case "fontSize" :
  case "fontWeight" :
    voDf = this.parent;
    break;
  default :
    voDf = this.parent.itemgroup;
  }
  var vsDefaultValue = voDf[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 아이템의 스타일 속성값을 일괄적으로 변경합니다.
 * @param {Object} poStyleObject 변경될 속성값을 담은 오브젝트
 * @private
 */
eXria.controls.xhtml.Item.prototype.setItemStyle = function(poStyleObject) {
  var vsAttr = null;
  for(vsAttr in poStyleObject) {
    this[vsAttr] = poStyleObject[vsAttr];
  }
};
/**
 * 아이템의 innerHTML 요소에 이벤트 핸들러를 추가합니다.
 * @param {String} psFuncName 실질적으로 이벤트를 처리할 클래스 내부 메소드명
 * @private
 */
eXria.controls.xhtml.Item.prototype.getEHandler = function(psFuncName) {
  var voParent = this.parent;
  var vsParentId = voParent.id
  var vaStrBuf = [];
  vaStrBuf.push("var e=null;")
  vaStrBuf.push("if(arguments[0]) e=arguments[0];");
  vaStrBuf.push("page.getControl('");
  vaStrBuf.push(vsParentId);
  vaStrBuf.push("').getItemByVal(&quot;");
  vaStrBuf.push(this.value.replace(/"/g, "\\&quot;"));
  vaStrBuf.push("&quot;).");
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(e);");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * 라벨 클릭시에 이벤트를 처리합니다.
 * @param {WindowEvent} e 윈도우 이벤트
 * @private
 */
eXria.controls.xhtml.Item.prototype.clickLabel = function(e) {
  var voParent = this.parent;
  if(this.disabled) {
    voParent.eventObjectType = null;
    voParent.eventObject = null;
    return;
  }
  voParent.eventObjectType = "item";
  voParent.eventObject = this;

  voSelectorCtrl = this.getItemCtrl();
  //voSelectorCtrl.click();
  if(voParent == "RadioButton") {
    voSelectorCtrl.checked = true;
    if(this.selected != true) voParent.changed = true;
  } else {
    if(voSelectorCtrl.checked) voSelectorCtrl.checked = false;
    else voSelectorCtrl.checked = true;
    voParent.changed = true;
  }
};
/**
 * selector onchange시에 이벤트를 처리합니다.
 * @param {WindowEvent} e 윈도우 이벤트
 * @private
 */
eXria.controls.xhtml.Item.prototype.checkSelector = function(e) {
  var voParent = this.parent;
  voParent.eventObjectType = "item";
  voParent.eventObject = this;
  if(voParent == "RadioButton") {
    if(this.selected != true) voParent.changed = true;
  } else {
    voParent.changed = true;
  }
};
/**
 * selector의 onmouseover시에 이벤트를 처리합니다.
 * @param {WindowEvent} e 윈도우 이벤트
 * @private
 */
eXria.controls.xhtml.Item.prototype.changeCursor = function(e) {
  var voParent = this.parent;
  var voEvent = new eXria.event.Event(e, voParent.window);
  var voTarget = voEvent.target;
  if(voTarget) {
    if(voParent.itemgroup.cursor)
      voTarget.style.cursor = voParent.itemgroup.cursor;
  }
};
/**
 * selector의 onmouseout시에 이벤트를 처리합니다.
 * @param {WindowEvent} e 윈도우 이벤트
 * @private
 */
eXria.controls.xhtml.Item.prototype.restoreCursor = function(e) {
  var voParent = this.parent;
  var voEvent = new eXria.event.Event(e, voParent.window);
  var voTarget = voEvent.target;
  if(voTarget) {
    if(voParent.cursor)
      voTarget.style.cursor = voParent.cursor;
  }
};
/**
 * Radio, Checkbox Button 클래스의 라벨 속성 저장 오브젝트입니다.
 * @type Object
 * @constructor
 * @private
 */
eXria.controls.xhtml.Select_label = function(){
  /**
   * 아이템 라벨의 넓이
   * @type number
   */
  this.width = null;

  /**
   * 아이템 라벨의 높이
   * @type number
   */
  this.height = null;

  /**
   * 아이템 라벨의 배경색
   * @type String
   */
  this.backgroundColor = null;

  /**
   * 아이템 라벨의 폰트 크기
   * @type number
   */
  this.fontSize = null;

  /**
   * 아이템 라벨에 설정 값
   * @type String
   */
  this.value = null;
};
/**
 * ignore
 */
eXria.controls.xhtml.Select_label.prototype.create = function(poParent, poCtrl, pnLeft, pnTop, poDocument) {
  var voDocument = this.document;
  var voSubCtrl = voDocument.createElement("span");
  var voSubTextCtrl = poDocument.createTextNode(eXria.controls.xhtml.Util.parseLang(poParent.text));
  voSubCtrl.appendChild(voSubTextCtrl);
  return voSubCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select_label.prototype.getInnerHTML = function(poParent) {
  var vsClass = "";
  if(poParent.parent) {
    vsClass = poParent.parent.getCSSClass(poParent.parent, 1, "itemgroup");
  var vsUserClass = poParent.parent.getCSSClass(poParent.parent, 1);
  if(vsUserClass) vsClass = vsClass + " " + vsUserClass;
  }

  var vsStyle = "";
  if(poParent.color) vsStyle = vsStyle + "color:" + poParent.color + ";";
  if(poParent.fontStyle) vsStyle = vsStyle + "font-style:" + poParent.fontStyle + ";";
  if(poParent.fontSize) vsStyle = vsStyle + "font-size:" + poParent.fontSize + "pt;";
  if(poParent.fontFamily) vsStyle = vsStyle + "font-family:" + poParent.fontFamily + ";";
  if(poParent.fontWeight) vsStyle = vsStyle + "font-weight:" + poParent.fontWeight + ";";

  var vaLabelStrBuf = [];
  vaLabelStrBuf.push("<span class='" + vsClass + "' style= \"" + vsStyle + "padding-left:3px;padding-right:3px;\" onclick=\"");
  vaLabelStrBuf.push(poParent.getEHandler("clickLabel"));
  vaLabelStrBuf.push("\"");
  vaLabelStrBuf.push(" onmouseover=\"")
  vaLabelStrBuf.push(poParent.getEHandler("changeCursor"));
  vaLabelStrBuf.push("\"");
  vaLabelStrBuf.push(" onmouseout=\"")
  vaLabelStrBuf.push(poParent.getEHandler("restoreCursor"));
  vaLabelStrBuf.push("\"/>");
  vaLabelStrBuf.push(eXria.controls.xhtml.Util.parseLang(poParent.text));
  vaLabelStrBuf.push("</span>");

  var vsRet = vaLabelStrBuf.join("");
  vaLabelStrBuf = null;
  return vsRet;
};
/**
 * Radio, Checkbox Button 클래스의 선택버튼 속성 저장 오브젝트입니다.
 * @type Object
 * @constructor
 * @private
 */
eXria.controls.xhtml.Select_selector = function(){
  /**
   * 아이템 선택버튼의 넓이
   * @type number
   */
  this.width = null;

  /**
   * 아이템 선택버튼의 높이
   * @type number
   */
  this.height = null;

  /**
   * 아이템 선택버튼의 배경색
   * @type String
   */
  this.backgroundColor = null;

  /**
   * 아이템 선택버튼의 폰트색상
   * @type String
   */
  this.color = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select_selector.prototype.create = function(poParent, poCtrl, pnLeft, pnTop, poDocument) {
  var voSubCtrl = null;
  if(poParent.type == "none" || poParent.type == null) {
    return null;
  } else {
    if(poParent.parent) {
      vsClass = poParent.parent.getCSSClass(poParent.parent, 1, "itemgroup");
      var vsUserClass = poParent.parent.getCSSClass(poParent.parent, 1);
      if(vsUserClass) vsClass = vsClass + " " + vsUserClass;
    }

    if(poParent.type == "radio") {
      try {   // TODO : ie 브라우저 여부를 체크하는 구문으로 수정할 것
        voSubCtrl = poDocument.createElement("<input class='" + vsClass + "' type='radio' name='radio_item_" + poParent.parent.id + "'>");
      } catch(e) {
        voSubCtrl = poDocument.createElement("input");
        voSubCtrl.setAttribute("name", "radio_item_" + poParent.parent.id);
        voSubCtrl.setAttribute("type", "radio");
      }
      poParent.parent.setAttrCtrl("disabled", poParent.disabled, voSubCtrl);
    }
    else if(poParent.type == "checkbox") {
      try {   // TODO : ie 브라우저 여부를 체크하는 구문으로 수정할 것
        voSubCtrl = poDocument.createElement("<input class='" + vsClass + "' type='checkbox' name='checkbox_item_" + poParent.parent.id + "'>");
      } catch(e) {
        voSubCtrl = poDocument.createElement("input");
        voSubCtrl.setAttribute("name", "checkbox_item_" + poParent.parent.id);
        voSubCtrl.setAttribute("type", "checkbox");
      }
      poParent.parent.setAttrCtrl("disabled", poParent.disabled, voSubCtrl);
    }
    return voSubCtrl;
  }
};
/**
 * 선택자의 HTML 문자열 반환합니다.
 * @return 선택자의 HTML 문자열
 * @type String
 * @private
 */
eXria.controls.xhtml.Select_selector.prototype.getInnerHTML = function(poParent) {
  var vaSelectorStrBuf = [];

  if(poParent.type == "none" || poParent.type == null) {
    return "";
  } else {
    if(poParent.parent) {
      vsClass = poParent.parent.getCSSClass(poParent.parent, 1, "itemgroup");
      var vsUserClass = poParent.parent.getCSSClass(poParent.parent, 1);
      if(vsUserClass) vsClass = vsClass + " " + vsUserClass;
    }

    vaSelectorStrBuf.push("<input class='" + vsClass + "' type='");
    if(poParent.type == "radio") {
      vaSelectorStrBuf.push("radio");
      vaSelectorStrBuf.push("' name='radio_item_");
    }
    else if(poParent.type == "checkbox") {
      vaSelectorStrBuf.push("checkbox");
      vaSelectorStrBuf.push("' name='checkbox_item_");
    }

    vaSelectorStrBuf.push(poParent.parent.id);
    vaSelectorStrBuf.push("'");
    if(poParent.disabled) {
      vaSelectorStrBuf.push(" disabled=true");
    }
    if(poParent.selected) {
      vaSelectorStrBuf.push(" checked=true");
    }

  vaSelectorStrBuf.push(" hideFocus=true");

    vaSelectorStrBuf.push(" onclick=\"")
    vaSelectorStrBuf.push(poParent.getEHandler("checkSelector"));
    vaSelectorStrBuf.push("\"");
    vaSelectorStrBuf.push(" onmouseover=\"")
    vaSelectorStrBuf.push(poParent.getEHandler("changeCursor"));
    vaSelectorStrBuf.push("\"");
    vaSelectorStrBuf.push(" onmouseout=\"")
    vaSelectorStrBuf.push(poParent.getEHandler("restoreCursor"));
    vaSelectorStrBuf.push("\"/>");

    var vsRet = vaSelectorStrBuf.join("");
    vaSelectorStrBuf = null;
    return vsRet;
  }
};


/**
 * @fileoverview
 * Concreate xhtml MenuItem(XHTML MenuItem 컨트롤)
 * @author 김경태
 */

/**
 * Concreate xhtml MenuItem.<br>
 * XHTML MenuItem 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MenuItem 객체
 * @type eXria.controls.xhtml.MenuItem
 * @constructor
 */
eXria.controls.xhtml.MenuItem = function(psLabel, psValue, psImage, psHotKey, poParentControl, pnLeft, pnTop, pnWidth, pnHeight){

  vnLeft = pnLeft == null ? 0 : pnLeft;
  vnTop = pnTop == null ? 0 : pnTop;
  vnWidth = pnWidth == null ? poParentControl.width : pnWidth;
  vnHeight = pnHeight == null ? poParentControl.height : pnHeight;

  eXria.controls.MenuItem.call(this, poParentControl.id + "_item_" + psValue, poParentControl, psLabel, psValue, psImage, psHotKey, vnLeft, vnTop, vnWidth, vnHeight);

  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 이미지 가로 사이즈.
   * @type Number
   */
  this.iconWidth = null;
  /**
   * 이미지 배경색.
   * @type String
   */
  this.iconBackgroundColor = null;
  /**
   * 텍스트 인덴트.
   * @type Number
   */
  this.textIndent = null;
  /**
   * 포커스된 아이템의 배경색.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * 전체 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.items = new eXria.data.ArrayMap();
  /**
   * 하위 아이템이 없는 단독 메뉴인지 여부.
   * @type Boolean
   */
  this.isLeaf = true;
  /**
   * @ignore
   */
  this.df = {};
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   * @private
   */
  this.data = new eXria.controls.DataRefNode(this.parentControl);
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.MenuItem, eXria.controls.xhtml.MenuItem);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("tr");
  this.createSubCtrl(voCtrl, poDocument);
  //this.setMainCtrlStyles(voCtrl, poDocument);
  this.setSpecificDefaults(voCtrl, poDocument);
  this.setSpecificAttrs(voCtrl, poDocument);
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.createSubCtrl = function(poCtrl, poDocument) {
  if(this.label == "-" && this.value == null) {
    var voSeparator = poDocument.createElement("td");
    voSeparator.colSpan="4";
    voSeparator.style.backgroundColor = "red";
    voSeparator.style.height="3px";
    poCtrl.appendChild(voSeparator);
  } else {
   var voIconArea = poDocument.createElement("td");
   var voImage = poDocument.createElement("img");
   voImage.src = this.parentControl.canvas.page.metadata.resourceBaseUrl + "eXria/controls/xhtml/images/calendar.jpg";
   voIconArea.appendChild(voImage);

   var voLabelArea = poDocument.createElement("td");
   var voText = poDocument.createTextNode(eXria.controls.xhtml.Util.parseLang(this.label));
   voLabelArea.appendChild(voText);

   var voHotKeyArea = poDocument.createElement("td");
   if(this.hotKey) {
    var voText = poDocument.createTextNode(this.hotKey);
    voHotKeyArea.appendChild(voText);
   }
   var voArrowArea = poDocument.createElement("td");
   if(this.items.size() > 0) {
     var voText = poDocument.createTextNode("▶");
     voArrowArea.appendChild(voText);
   }
   poCtrl.appendChild(voIconArea);
   poCtrl.appendChild(voLabelArea);
   poCtrl.appendChild(voHotKeyArea);
   poCtrl.appendChild(voArrowArea);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.getInnerHTML = function(poCtrl) {
  this.setSpecificDefaults();

  this.template = [];
  var vaTemplate = this.template;
  var voParentControl = this.parentControl;

  //var vsItemClass = voParentControl.getCSSClass(this, 1, "itemgroup");
  //var vsIconClass = voParentControl.getCSSClass(this, 1, "Iconarea");
  // yhkim 서버에서 설정되는 설정이 Default_ContextMenu_itemgroup_Class같아서 맞춰줘야 한다.
  //  voParentControl.getCSSClass(this, 1, "itemgroup");와 같은 구조는 Default_MenuItem_itemgroup_Class 형태로 만들어내는 문제가 있다
  var vsItemClass = "Default_ContextMenu_itemgroup_Class"
  if(this.parent.itemgroup && this.parent.itemgroup.className) vsItemClass = vsItemClass + " " + this.parent.itemgroup.className;
  var vsIconClass = "Default_ContextMenu_Iconarea_Class";
  if(this.parent.iconarea && this.parent.iconarea.className)  vsIconClass = vsIconClass + " " + this.parent.iconarea.className;

  vaTemplate.push("<tr class=\"" + vsItemClass + "\" onclick=\"");
  vaTemplate.push(this.getEHandler("atclick"));
  vaTemplate.push("\" onmouseover=\"");
  vaTemplate.push(this.getEHandler("atmouseover"));
  vaTemplate.push("\" onmouseout=\"");
  vaTemplate.push(this.getEHandler("atmouseout"));
  vaTemplate.push("\" ");
  vaTemplate.push("@attStrBuf"); //7
  vaTemplate.push(" style='");
  vaTemplate.push("@cssStrBuf"); //9
  vaTemplate.push("'>");

  if(this.label == "-" && this.value == null) {
    vaTemplate.push("<td colSpan=4");
    vaTemplate.push(" style='");
    vaTemplate.push("@cssStrBuf"); //13
    vaTemplate.push("'>");
  } else {
    vaTemplate.push("<td class='" + vsIconClass + "' style='");
    vaTemplate.push("@cssStrBuf"); //12
    vaTemplate.push("'>");
    if(this.image) {
      vaTemplate.push("<img src='");
      //vaTemplate.push(eXria.controls.xhtml.Util.getImagePath(this.image, this.parentControl.window));
      vaTemplate.push(this.image);
      vaTemplate.push("'/>");
    } else {
      vaTemplate.push("");
      vaTemplate.push("");
      vaTemplate.push("");
    }

    vaTemplate.push("<td nowrap style='");
    vaTemplate.push("@cssStrBuf"); //18
    vaTemplate.push("'>");
    vaTemplate.push(eXria.controls.xhtml.Util.parseLang(this.label));
    vaTemplate.push("</td>");

    vaTemplate.push("<td style='");
    vaTemplate.push("@cssStrBuf"); //23
    vaTemplate.push("'>");
    if(this.hotKey) vaTemplate.push(this.hotKey);
    else vaTemplate.push("");
    vaTemplate.push("</td>");

    vaTemplate.push("<td style='");
    vaTemplate.push("@cssStrBuf"); //28
    vaTemplate.push("'>");
    if(this.items.size() > 0) vaTemplate.push("▶");
    vaTemplate.push("</td>");
  }
  vaTemplate.push("</tr>");

  this.setSpecificAttrs();

  var vsRet = vaTemplate.join("");
  vaTemplate = null;
  this.template = null;
  return vsRet;
};
/**
 * Main Style 적용
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MenuItem.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
  //this.parentControl.setAttrCtrl("className", this.className, poCtrl);
};
/**
 * 개별 초기값 설정
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return poCtrl
 * @type HTMLDiv
 * @private
 */
//eXria.controls.xhtml.MenuItem.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
//  // 구분자에 대한 초기값 설정
//  if(this.value == "-") {
//    var voTdSeparator = poCtrl.childNodes[0];
//    voTdSeparator.colSpan="3";
//    voTdSeparator.style.backgroundColor = this.getItemAttrValue("separatorColor", this.separatorColor);
//    voTdSeparator.style.height="3px";
//    return;
//  }
//
//  var vsTextAlign = null;
//  var vsVerticalAlign = null;
//
//  // CSS가 적용되는 속성에 대한 초기값 설정
//  var voCssStyle = this.parentControl.canvas.getCssStyle(this.parentControl.itemgroup.className, poDocument);
//  if(voCssStyle) {
//    var vsCssColor = voCssStyle["color"];
//    var vsCssBackgroundColor = voCssStyle["backgroundColor"];
//    var vsCssBorderColor = voCssStyle["borderColor"];
//    var vsCssBorderStyle = voCssStyle["borderStyle"];
//    var vsCssBorderWidth = voCssStyle["borderWidth"];
//    var vsCssFontFamily = voCssStyle["fontFamily"];
//    var vsCssFontSize = voCssStyle["fontSize"];
//    var vsCssFontStyle = voCssStyle["fontStyle"];
//    var vsCssFontWeight = voCssStyle["fontWeight"];
//    var vsCssTextAlign = voCssStyle["textAlign"];
//    var vsCssVerticalAlign = voCssStyle["verticalAlign"];
//
//    if(vsCssColor == null || vsCssColor == "") this.parentControl.setAttrCtrl("color", this.getItemAttrValue("color", this.color), poCtrl);
//    if(vsCssBackgroundColor == null || vsCssBackgroundColor == "") this.parentControl.setAttrCtrl("backgroundColor", this.getItemAttrValue("backgroundColor", this.backgroundColor), poCtrl);
//    if(vsCssBorderColor == null || vsCssBorderColor == "") this.parentControl.setAttrCtrl("borderColor", this.getItemAttrValue("borderColor", this.borderColor), poCtrl);
//    if(vsCssBorderStyle == null || vsCssBorderStyle == "") this.parentControl.setAttrCtrl("borderStyle", this.getItemAttrValue("borderStyle", this.borderStyle), poCtrl);
//    if(vsCssBorderWidth == null || vsCssBorderWidth == "") this.parentControl.setAttrCtrl("borderStyle", this.getItemAttrValue("borderWidth", this.borderWidth), poCtrl);
//    if(vsCssFontFamily == null || vsCssFontFamily == "") this.parentControl.setAttrCtrl("fontFamily", this.getItemAttrValue("fontFamily", this.fontFamily), poCtrl);
//    if(vsCssFontSize == null || vsCssFontSize == "") this.parentControl.setAttrCtrl("fontSize", this.getItemAttrValue("fontSize", this.fontSize), poCtrl);
//    if(vsCssFontStyle == null || vsCssFontStyle == "") this.parentControl.setAttrCtrl("fontStyle", this.getItemAttrValue("fontStyle", this.fontStyle), poCtrl);
//    if(vsCssFontWeight == null || vsCssFontWeight == "") this.parentControl.setAttrCtrl("fontWeight", this.getItemAttrValue("fontWeight", this.fontWeight), poCtrl);
//    if(vsCssTextAlign == null || vsCssTextAlign == "") vsTextAlign = this.getItemAttrValue("textAlign", this.textAlign);
//    if(vsCssVerticalAlign == null || vsCssVerticalAlign == "") vsVerticalAlign = this.getItemAttrValue("verticalAlign", this.verticalAlign);
//  } else { // CSS가 지정되어 있지 않은 경우에는 control의  속성 값이 null인 속성에 대해서 Default 값을 구해 직접 xhtml에 반영한다.
//    this.parentControl.setAttrCtrl("color", this.getItemAttrValue("color", this.color), poCtrl);
//    this.parentControl.setAttrCtrl("backgroundColor", this.getItemAttrValue("backgroundColor", this.backgroundColor), poCtrl);
//    this.parentControl.setAttrCtrl("borderColor", this.getItemAttrValue("borderColor", this.borderColor), poCtrl);
//    this.parentControl.setAttrCtrl("borderStyle", this.getItemAttrValue("borderStyle", this.borderStyle), poCtrl);
//    this.parentControl.setAttrCtrl("borderWidth", this.getItemAttrValue("borderWidth", this.borderWidth), poCtrl);
//    vsTextAlign = this.getItemAttrValue("textAlign", this.textAlign);
//    vsVerticalAlign = this.getItemAttrValue("verticalAlign", this.verticalAlign);
//  }
//
//  // CSS가 적용되지 않는 속성에 대한 초기값 설정(main 컨트롤)
//  var vnWidth = this.getItemAttrValue("width", this.width);
//  var vnHeight = this.getItemAttrValue("height", this.height);
//  poCtrl.style.height = vnHeight + "px";
//
//  // 하위 요소에 대한 초기값 설정(icon 영역)
//  var voTdIcon = poCtrl.childNodes[0];
//  var vnIconWidth = this.getItemAttrValue("iconWidth", this.iconWidth);
//  voTdIcon.style.backgroundColor = this.getItemAttrValue("iconBackgroundColor", this.iconBackgroundColor);
//  voTdIcon.align = "center";
//  voTdIcon.vertialAlign = "middle";
//  voTdIcon.focusBackgroundColor = this.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
//
//  // 하위 요소에 대한 초기값 설정(label 영역)
//  var voTdLabel = poCtrl.childNodes[1];
//  voTdLabel.style.textIndent = this.getItemAttrValue("textIndent", this.textIndent) + "px";
//  voTdLabel.align = vsTextAlign;
//  voTdLabel.vertialAlign = vsVerticalAlign;
//  voTdLabel.focusBackgroundColor = this.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
//
//  // 하위 요소에 대한 초기값 설정(hotkey 영역)
//  var voTdHotKey = poCtrl.childNodes[2];
//  voTdHotKey.style.paddingLeft = "10px";
//  voTdHotKey.style.paddingRight = "10px";
//  voTdHotKey.align = "center";
//  voTdHotKey.vertialAlign = "middle";
//  voTdHotKey.style.height = vnHeight + "px";
//
//  poCtrl.control = this;
//  poCtrl.onclick = function(e) {
//    this.control.selected = true;
//    this.control.parentControl.selectedItem = this.control;
//    if(this.control.parent != this.control.parentControl) {
//      this.control.notifyEvent(e, this.control, this.control.parentControl);
//    }
//  };
//
//  poCtrl.onmouseover = function(e) {
//    if(this.control.parent !== undefined) {
//      if(this.control.parent.items.size() > 0) {
//        var vsKey = null;
//        var voItem = null;
//        var voIterator1 = this.control.parent.items.getKeyCollection().iterator();
//        while (voIterator1.hasNext()) {
//          vsKey = voIterator1.next();
//          voItem = this.control.parent.items.get(vsKey);
//          if(!voItem) break;
//          if(voItem.toString() == "MenuItem") {
//              this.control.parentControl.hideSubMenu(poDocument, voItem);
//            } else if(voItem.toString() == "MenuItemSet") {
//              voIterator2 = voItem.items.getKeyCollection().iterator();
//              var voChildItem = null;
//            while (voIterator2.hasNext()) {
//              vsKey = voIterator2.next();
//              voChildItem = voItem.items.get(vsKey);
//              if(voChildItem) this.control.parentControl.hideSubMenu(poDocument, voChildItem);
//            }
//          }
//        }
//      }
//    }
//    poCtrl.style.backgroundColor = this.control.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
//    voTdIcon.style.backgroundColor = this.control.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
//    voTdLabel.style.backgroundColor = this.control.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
//    if(this.control.items.size() > 0) {
//      this.control.parentControl.showSubMenu(poDocument, this.control);
//    }
//  };
//
//  poCtrl.onmouseout = function(e) {
//    poCtrl.style.backgroundColor = this.control.getItemAttrValue("backgroundColor", this.backgroundColor);
//    voTdIcon.style.backgroundColor = this.control.getItemAttrValue("iconBackgroundColor", this.iconBackgroundColor);
//    voTdLabel.style.backgroundColor = this.control.getItemAttrValue("backgroundColor", this.backgroundColor);
//  };
//
//  return poCtrl;
//};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;
  this.separatorColor = this.getItemAttrValue("separatorColor", this.parentControl.itemgroup.separatorColor);
  this.separatorHeight = this.getItemAttrValue("separatorHeight", this.parentControl.itemgroup.separatorHeight);
  // CSS가 적용되는 속성에 대한 초기값 설정
  var voParentItemGroup = this.parentControl.itemgroup;
  var voParentIconArea = this.parentControl.iconarea;
  var voCssStyle = this.parentControl.canvas.getCssStyle(this.parentControl.itemgroup.className, poDocument);
  if(voCssStyle) {
    this.color = voCssStyle["color"];
    this.backgroundColor = voCssStyle["backgroundColor"];
    this.borderColor = voCssStyle["borderColor"];
    this.borderStyle = voCssStyle["borderStyle"];
    this.borderWidth = voCssStyle["borderWidth"];
    this.fontFamily = voCssStyle["fontFamily"];
    this.fontSize = voCssStyle["fontSize"];
    this.fontStyle = voCssStyle["fontStyle"];
    this.fontWeight = voCssStyle["fontWeight"];
    this.textAlign = voCssStyle["textAlign"];
    this.verticalAlign = voCssStyle["verticalAlign"];
    if(this.fontSize != null && this.fontSize != "") this.fontSize = parseInt(this.fontSize);

    if(this.color == null || this.color == "") voDf.color = this.getItemAttrValue("color", voParentItemGroup.color);
    if(this.backgroundColor == null || this.backgroundColor == "") this.backgroundColor = this.getItemAttrValue("backgroundColor", voParentItemGroup.backgroundColor);
    if(this.borderColor == null || this.borderColor == "") this.borderColor = this.getItemAttrValue("borderColor", voParentItemGroup.borderColor);
    if(this.borderStyle == null || this.borderStyle == "") this.borderStyle = this.getItemAttrValue("borderStyle", voParentItemGroup.borderStyle);
    if(this.borderWidth == null || this.borderWidth == "") this.borderWidth = this.getItemAttrValue("borderWidth", voParentItemGroup.borderWidth);
    if(this.fontFamily == null || this.fontFamily == "") this.fontFamily = this.getItemAttrValue("fontFamily", voParentItemGroup.fontFamily);
    if(this.fontSize == null || this.fontSize == "") this.fontSize = this.getItemAttrValue("fontSize", voParentItemGroup.fontSize);
    if(this.fontStyle == null || this.fontStyle == "") this.fontStyle = this.getItemAttrValue("fontStyle", voParentItemGroup.fontStyle);
    if(this.fontWeight == null || this.fontWeight == "") this.fontWeight = this.getItemAttrValue("fontWeight", voParentItemGroup.fontWeight);
    if(this.textAlign == null || this.textAlign == "") this.textAlign = this.getItemAttrValue("textAlign", voParentItemGroup.textAlign);
    if(this.verticalAlign == null || this.verticalAlign == "") this.verticalAlign = this.getItemAttrValue("verticalAlign", voParentItemGroup.verticalAlign);
  } else { // CSS가 지정되어 있지 않은 경우에는 control의  속성 값이 null인 속성에 대해서 Default 값을 구해 직접 xhtml에 반영한다.
    /*
    this.color = this.getItemAttrValue("color", voParentItemGroup.color);
    this.backgroundColor = this.getItemAttrValue("backgroundColor", voParentItemGroup.backgroundColor);
    this.borderColor = this.getItemAttrValue("borderColor", voParentItemGroup.borderColor);
    this.borderStyle = this.getItemAttrValue("borderStyle", voParentItemGroup.borderStyle);
    this.borderWidth = this.getItemAttrValue("borderWidth", voParentItemGroup.borderWidth);
    this.fontFamily = this.getItemAttrValue("fontFamily", voParentItemGroup.fontFamily);
    this.fontSize = this.getItemAttrValue("fontSize", voParentItemGroup.fontSize);
    this.fontStyle = this.getItemAttrValue("fontStyle", voParentItemGroup.fontStyle);
    this.fontWeight = this.getItemAttrValue("fontWeight", voParentItemGroup.fontWeight);
    this.textAlign = this.getItemAttrValue("textAlign", voParentItemGroup.textAlign);
    this.verticalAlign = this.getItemAttrValue("verticalAlign", voParentItemGroup.verticalAlign);
    */
  }

  // CSS가 적용되지 않는 속성에 대한 초기값 설정(main 컨트롤)
  this.width = this.getItemAttrValue("width", voParentItemGroup.width);
  this.height = this.getItemAttrValue("height", voParentItemGroup.height);
  this.focusBackgroundColor = this.getItemAttrValue("focusBackgroundColor", voParentItemGroup.focusBackgroundColor);
  this.focusColor = this.getItemAttrValue("focusColor", voParentItemGroup.focusColor);
  this.disabled = this.getItemAttrValue("disabled", this.disabled);
  // 하위 요소에 대한 초기값 설정(icon 영역)
  //this.iconWidth = this.getItemAttrValue("iconWidth", voParentIconArea.width);
  //this.iconBackgroundColor = this.getItemAttrValue("iconBackgroundColor", voParentIconArea.backgroundColor);
  this.iconAlign = this.getItemAttrValue("textAlign", voParentItemGroup.textAlign);
  this.iconVertialAlign = this.getItemAttrValue("verticalAlign", voParentItemGroup.verticalAlign);

  // 하위 요소에 대한 초기값 설정(label 영역)
  this.textIndent = this.getItemAttrValue("textIndent", this.textIndent);
  this.labelAlign = this.textAlign;
  this.labelVertialAlign = this.verticalAlign;

  // 하위 요소에 대한 초기값 설정(hotkey 영역)
  this.hotkeyPaddingLeft = 10;
  this.hotkeyPaddingRight = 10;
  this.hotkeyAlign = "center";
  this.hotkeyVertialAlign = "middle";

  var voData = this.data;
  if(voData.instanceId && voData.instancePath) {
    this.label = voData.getData();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.atclick = function(e) {
  if(this.parentControl.disabled || this.disabled) {
    var voEvent = new eXria.event.Event(e, this.parentControl.window);
    voEvent.stopEvent();
    return;
  }
  this.selected = true;
  this.parentControl.selectedItem = this;
  if(this.parent != this.parentControl) {
    this.notifyEvent(e, this, this.parentControl);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.atmouseover = function(e) {
  if(this.parentControl.disabled || this.disabled) {
    var voEvent = new eXria.event.Event(e, this.parentControl.window);
    voEvent.stopEvent();
    return;
  }
  var voDf = this.df;
  var voParentControl = this.parentControl;
  var voDocument = voParentControl.document;
  if(this.parent !== undefined) {
    var voParent = this.parent;
    if(voParent.items.size() > 0) {
      var vsKey = null;
      var voItem = null;
      var voIterator1 = voParent.items.getKeyCollection().iterator();
      while (voIterator1.hasNext()) {
        vsKey = voIterator1.next();
        voItem = voParent.items.get(vsKey);
        if(!voItem) break;
        if(voItem.toString() == "MenuItem") {
            voParentControl.hideSubMenu(voDocument, voItem);
          } else if(voItem.toString() == "MenuItemSet") {
            voIterator2 = voItem.items.getKeyCollection().iterator();
            var voChildItem = null;
            while (voIterator2.hasNext()) {
            vsKey = voIterator2.next();
            voChildItem = voItem.items.get(vsKey);
            if(voChildItem) voParentControl.hideSubMenu(voDocument, voChildItem);
          }
        }
      }
    }
  }
  voParentControl.showedItem = this;

  var voCtrl = voParentControl.lookup(this.id);
  voCtrl.style.backgroundColor = this.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
  if(voCtrl.childNodes.length > 1) {
    var voTdIcon = voCtrl.childNodes.item(0);
    var voTdLabel = voCtrl.childNodes.item(1);
    voTdIcon.style.backgroundColor = this.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
    voTdLabel.style.backgroundColor = this.getItemAttrValue("focusBackgroundColor", this.focusBackgroundColor);
    voTdLabel.style.color = this.getItemAttrValue("focusColor", this.focusColor);
  }
  if(this.items.size() > 0) {
    voParentControl.showSubMenu(voDocument, this);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItem.prototype.atmouseout = function(e) {
  if(this.parentControl.disabled || this.disabled) {
    var voEvent = new eXria.event.Event(e, this.parentControl.window);
    voEvent.stopEvent();
    return;
  }
  var voParentControl = this.parentControl;
  var voDocument = voParentControl.document;
  var voDf = this.df;
  var voCtrl = voParentControl.lookup(this.id);
//  voCtrl.style.backgroundColor = this.getItemAttrValue("backgroundColor", this.backgroundColor);
  if(this.backgroundColor) voCtrl.style.backgroundColor = this.backgroundColor;
  else voCtrl.style.backgroundColor = "";
  if(voCtrl.childNodes.length > 1) {
    var voTdIcon = voCtrl.childNodes.item(0);
    var voTdLabel = voCtrl.childNodes.item(1);
//    voTdIcon.style.backgroundColor = this.getItemAttrValue("iconBackgroundColor", this.iconBackgroundColor);
//    voTdLabel.style.backgroundColor = this.getItemAttrValue("backgroundColor", this.backgroundColor);
//    voTdLabel.style.color = this.getItemAttrValue("color", this.color);
    if(this.iconBackgroundColor) voTdIcon.style.backgroundColor = this.iconBackgroundColor;
    else voTdIcon.style.backgroundColor = "";
    if(this.backgroundColor) voTdLabel.style.backgroundColor = this.backgroundColor;
    else voTdLabel.style.backgroundColor = "";
    if(this.color) voTdLabel.style.color = this.color;
    else voTdLabel.style.color = "";
  }
};
/**
 * 개별 Attrs 적용
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
//eXria.controls.xhtml.MenuItem.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
//  poCtrl.setAttribute("id", this.id);
//  poCtrl.disabled = this.disabled;
//};
eXria.controls.xhtml.MenuItem.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voParentControl = this.parentControl;
  var voDf = this.df;
  var vaTemplate = null;
  vaTemplate = this.template;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vfcSetAttStrBuf = voParentControl.setAttStrBuf;
  var vfcSetCssStrBuf = voParentControl.setCssStrBuf;

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "id", this.id);
  //if(voDf.disabled) vaAttStrBuf.push("disabled");
  vaTemplate[7] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  if(this.label == "-" && this.value == null) {
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.separatorHeight, "px");
  } else {
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.height, "px");
  }
  if(this.disabled) vfcSetCssStrBuf(vaCssStrBuf, "color", voParentControl.disabledColor);
  else vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", this.borderWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.verticalAlign);
  vaTemplate[9] = vaCssStrBuf.join("");

  if(this.label == "-" && this.value == null) {
    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.separatorColor);
    vaTemplate[13] = vaCssStrBuf.join("");

    vaAttStrBuf = null;
    vaCssStrBuf = null;
    vaTemplate = null;
    return;
  }

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.iconBackgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.iconAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.iconVertialAlign);
  vaTemplate[12] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "text-indent", this.textIndent, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.labelAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.labelVertialAlign);
  vaTemplate[18] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.hotkeyPaddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.hotkeyPaddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.hotkeyAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.hotkeyVertialAlign);
  vaTemplate[23] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", "center");
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.labelVertialAlign);
  //vfcSetCssStrBuf(vaCssStrBuf, "font-size", Math.round(voDf.fontSize * 1.5), "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vaTemplate[28] = vaCssStrBuf.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
};
/**
 * 아이템 새로고침
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MenuItem.prototype.refresh = function(poDocument) {
  //this.createCtrl();
};
/**
 * 자식 아이템 추가.
 * @param poItem 추가할 아이템
 * @return void
 * @private
 */
eXria.controls.xhtml.MenuItem.prototype.addChild = function(poItem) {
  this.items.put(this.items.size(), poItem);
  poItem.parent = this;
  this.isLeaf = false;
};
/**
 * 지정된 인덱스에 자식 아이템 추가.
 * @param poItem 추가할 아이템
 * @param pnIndex 지정할 인덱스
 * @return void
 * @private
 */
eXria.controls.xhtml.MenuItem.prototype.addChildToIndex = function(poItem, pnIndex) {
 var voNewItems = new eXria.data.ArrayMap();
 var vnIndex = 0;
 var voValue = null;
 var voIterator = this.items.getValueCollection().iterator();
 while(voIterator.hasNext()) {
   if(vnIndex == pnIndex) voNewItems.put(vnIndex++, poItem);
   voValue = voIterator.next();
   voNewItems.put(vnIndex, voValue);
   vnIndex++;
 }
 this.items.clear();
 this.items = voNewItems;
};
/**
 * 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 디폴트 속성값
 * @type String
 */
eXria.controls.xhtml.MenuItem.prototype.getItemAttrValue = function(psAttrName, psAttrValue) {
  if (psAttrValue != null) return psAttrValue;
  else return this.getItemDefaultValue(psAttrName);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 */
eXria.controls.xhtml.MenuItem.prototype.getItemDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.ContextMenu.itemgroup[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 아이템의 innerHTML요소에 이벤트 핸들러를 추가하기 위한 메소드
 * @param {String} psFuncName 실질적으로 이벤트를 처리할 클래스 내부 메소드명
 * @private
 */
eXria.controls.xhtml.MenuItem.prototype.getEHandler = function(psFuncName) {
  var voParentControl = this.parentControl;
  var vaStrBuf = [];
  vaStrBuf.push("var e=null;")
  vaStrBuf.push("if(arguments[0]) e=arguments[0];");
  vaStrBuf.push("page.getControl('");
  vaStrBuf.push(voParentControl.id);
  vaStrBuf.push("').getItemById('");
  vaStrBuf.push(this.id);
  vaStrBuf.push("').")
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(e);");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * 클래스 명을 반환.
 * @return "MenuItem"
 * @type String
 */
eXria.controls.xhtml.MenuItem.prototype.toString = function() {
  return "MenuItem";
};

/**
 * @fileoverview
 * Concreate xhtml MenuItemSet(XHTML MenuItemSet 컨트롤)
 * @author 김경태
 */

/**
 * @class Concreate xhtml MenuItemSet.<br>
 * ContextMenu 컨트롤을 구성하는 아이템의 속성정보를 담당하는 클래스.
 * 아이템의 실체화는 ContextMenu에서 담당.
 * @version 2.0
 * @return 새로운 eXria.controls.xhtml.MenuItemSet 객체
 * @type eXria.controls.xhtml.MenuItemSet
 * @constructor
 */
//eXria.controls.xhtml.MenuItemSet = function(psLabelPath, psValuePath, psImagePath, psHotKeyPath, psParentPath, poParentControl) {
eXria.controls.xhtml.MenuItemSet = function(psLabelPath, psValuePath, psImagePath, psHotKeyPath, psParentPath, psInstanceId, psNodeSet, poParentControl) {
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * @ignore
   */
  this.parentControl = poParentControl;
  /**
   * 메뉴 아이템 이름 인스턴스 패스.
   * @type String
   */
  this.labelPath = psLabelPath;
  /**
   * 메뉴 아이템 값 인스턴스 패스.
   * @type String
   */
  this.valuePath = psValuePath;
  /**
   * 메뉴 아이템 이미지 인스턴스 패스.
   * @type String
   */

  this.imagePath = psImagePath;
  /**
   * 메뉴 아이템 단축키 인스턴스 패스.
   * @type String
   */
  this.hotKeyPath = psHotKeyPath;
  /**
   * 부모 메뉴 아이템 인스턴스 패스.
   * @type String
   */
  this.parentPath = psParentPath;
  /**
   * 부모 메뉴 아이템.
   * @type eXria.controls.xhtml.MenuItem
   */
  this.parent = null;
  /**
   * 전체 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.items = new eXria.data.ArrayMap();
  /**
   * 데이타 연동 객체
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset();
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItemSet.prototype.loadData = function(poDocument) {
  if(this.parentControl == null || (this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null)) return;
  this.data.control = this.parentControl;

  var vsRefValue = null;
  if(this.data.instanceId != null) vsRefValue = this.data.getData();
  var voCollectionNode = this.data.getNodesetData2();
  if(voCollectionNode == null) return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsLabel = null;
  var vsValue = null;
  var vsImage = null;
  var vsHotKey = null;
  var vsParent = null;
  for(var i = 0; i < vnLoop; i++) {
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    vsLabel = voMapNode.get(this.labelPath);
    vsValue = voMapNode.get(this.valuePath);
    vsImage = voMapNode.get(this.imagePath);
    vsHotKey = voMapNode.get(this.hotKeyPath);
    vsParent = voMapNode.get(this.parentPath);

    var voItem = this.parentControl.createMenuItem(vsLabel, vsValue, vsImage, vsHotKey);
    this.checkParent(voItem, vsParent);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItemSet.prototype.checkParent = function(poItem, psParent, poItems) {
  //if(psParent == null) psParent = "";
  if(psParent == null || psParent == "") {
    poItem.parent = this.parent;
    this.items.put(this.items.size(), poItem);
  } else {
    if(poItems == null) poItems = this.items;
    var voIterator = poItems.getValueCollection().iterator();
    var voParent = null;
    while(voIterator.hasNext()) {
      voParent = voIterator.next();
      if(voParent.value == psParent) {
        voParent.addChild(poItem);
        break;
      } else if(voParent.items.size() > 0) {
        this.checkParent(poItem, psParent, voParent.items);
      }
    }
  }

};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItemSet.prototype.display = function(poDocument, poCtrl) {
  var vsKey = null;
  var voValue = null;
  var vsType = 0;
  var voIterator = this.items.getKeyCollection().iterator();

  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voValue = this.items.get(vsKey);
    vsType = voValue.toString();
    if(vsType== "MenuItem") {
      var voItemCtrl = voValue.createCtrl(poDocument);
      poCtrl.appendChild(voItemCtrl);
    } else if(vsType == "MenuItemSet") {
      voValue.loadData(poDocument);
      voValue.display(poDocument, poCtrl);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItemSet.prototype.getInnerHTML = function() {
  var vsKey = null;
  var voItem = null;
  var vsType = 0;
  var voIterator = this.items.getKeyCollection().iterator();
  var vaStrBuf = [];
  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voItem = this.items.get(vsKey);
    vsType = voItem.toString();
    if(vsType == "MenuItem") {
      vaStrBuf.push(voItem.getInnerHTML());
    } else if(vsType == "MenuItemSet") {
      voItem.items.clear();
      voItem.loadData(poDocument);
      vaStrBuf.push(voItem.getInnerHTML());
    }
  }
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MenuItemSet.prototype.addChild = function(poItem) {
  this.items.put(this.items.size(), poItem);
  poItem.parent = this;
};
/**
 * data 속성으로 부터 DOM 데이타를 얻어옴.
 * @return data 속성으로 부터 얻어온 DOM 데이타
 * @type XMLElement
 * @private
 */
eXria.controls.xhtml.MenuItemSet.prototype.getInstanceData =function() {
  var viInstance = this.data.getNodesetInstance();
  var voDataNode = null;
  if(viInstance) voDataNode = viInstance.selectSingleNode(this.data.nodesetInstancePath);
  return voDataNode;
};
/**
 * 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 디폴트 속성값
 * @type String
 */
eXria.controls.xhtml.MenuItemSet.prototype.getItemAttrValue = function(psAttrName, psAttrValue) {
  if (psAttrValue != null) return psAttrValue;
  else return this.getItemDefaultValue(psAttrName);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 */
eXria.controls.xhtml.MenuItemSet.prototype.getItemDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.ContextMenu.itemgroup[psAttrName];
  if(vsDefaultValue === undefined) return null;
  else return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "TreeNodes"
 * @type String
 */
eXria.controls.xhtml.MenuItemSet.prototype.toString = function() {
  return "MenuItemSet";
};


/**
 * @fileoverview
 * Concreate xhtml Button(XHTML 버튼 컨트롤)
 * @author 조영진, 박찬수
 */

/**
 * @class 내부에 text나 img를 넣을 수 있는 버튼 컨트롤을 생성하는 class입니다.<br>
 * XHTML Button control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Button 객체
 * @type eXria.controls.xhtml.Button
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Button = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).
   * @type String
   */
  this.position = "absolute";
  /**
   * 버튼에 라벨값(아이콘 url정보 포함) 저장.
   * @type String
   */
  this.value = null;
  /**
   * 컨트롤 외곽 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 컨트롤 외곽 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 컨트롤 외곽 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 컨트롤 외곽 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 표시될 텍스트 가로정렬.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트에 밑줄을 넣을때.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 버튼이 눌려을 때 표시될 이미지.
   * @type String
   */
  this.imagePushed = null;
  /**
   * 버튼에 포커스가 위치했을 때 표시될 이미지.
   * @type String
   */
  this.imageFocused = null;
  /**
   * 버튼에 마우스가 위치했을 때 표시될 이미지.
   * @type String
   */
  this.imageMouseover = null;
  /**
   * 버튼의 이미지가 바뀌기전의 이미지.
   * @type String
   * @type private
   */
  this.oldImage = null;
  /**
   * 버튼에 포커스가 위치했는지 여부.
   * @type boolean
   * @private
   */
  this.focused = false;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * default로 eXria_CSS_Configure.xml에 정의된 값으로 설정(최소 default 설정 필요함)
   * @type Object
   * @private
   */
  this.cursor = null;
  /**
   * 자동줄바꿈 여부.
   * @type Boolean
   */
  this.wordWrap = null;

  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Button);

eXria.controls.xhtml.Button.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

eXria.controls.xhtml.Button.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<button hidefocus='true' type='button' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' style=\"");
  vaTemplate.push("@cssStrbuf"); //setSpecificAttrs메소드에서  스타일 속성이 대체될  부분은 @cssStrBuf로 마크(Element 속성의 경우엔 @attStrBuf로 마크)
  vaTemplate.push("\" class='" + vsClass + "'>");
  vaTemplate.push("@innStrBuf"); //setSpecificAttrs메소드에서 innerHTML이 대체될 부분은 @innStrBuf로 마크
  vaTemplate.push("</button>");
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\"/>");
};

eXria.controls.xhtml.Button.prototype.refreshTemplate = null;

eXria.controls.xhtml.Button.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.showContextByClick = voUserAttr.showContextByClick;
    this.labelName = voUserAttr.labelName;
  }
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.width = this.getAttrValue("width", this.width);
  this.value = this.getAttrValue("value", this.value);
  this.backgroundImage = this.getAttrValue("backgroundImage", this.backgroundImage);
  this.imagePushed = this.getAttrValue("imagePushed", this.imagePushed);
  //if(this.imagePushed) this.imagePushed = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imagePushed, this.window);
  this.imageFocused = this.getAttrValue("imageFocused", this.imageFocused);
  //if(this.imageFocused) this.imageFocused = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imageFocused, this.window);
  this.imageMouseover = this.getAttrValue("imageMouseover", this.imageMouseover);
  //if(this.imageMouseover) this.imageMouseover = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imageMouseover, this.window);
  this.wordWrap = this.getAttrValue("wordWrap", this.wordWrap);
};

eXria.controls.xhtml.Button.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  ///////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  ///////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존에 이와같은 코드가 있었는데 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  //////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  //////////////////////////////////////////////////////////////////////////////////////////

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[2] + "')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[1] + "')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(poCtrl.style["filter"]) poCtrl.style["filter"] = "";
    }
  }

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  vaTemplate[3] = vaCssStrBuf.join("");
  vaTemplate[5] = this.getLabelText(this.value);
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[8] = vaCssStrBuf.join("");
  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Button.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.button = this.getSubCtrl("button", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Button.prototype.setSpecificEvents = function(poCtrl) {
  var voBtn = this.subElement.button;
  this.eventManager.addListener(voBtn, "onblur", this.mediateEvent);
  this.eventManager.addListener(voBtn, "onfocus", this.mediateEvent);
  voBtn.control = this;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Button.prototype.dofocus = function() {
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(this.visible != false)
    voBtn.focus();
};
/**
 * @ignore
 */
eXria.controls.xhtml.Button.prototype.atfocus = function(poEvent) {
  var voDf = this.df;
  this.focused = true;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var vsImage = voBtn.style.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imageFocused) {
    vsImage = this.imageFocused;
  }
  this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atblur = function(poEvent) {
  var voDf = this.df;
  this.focused = false;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atmousedown = function(poEvent) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(poEvent.target == voBtn) this.focused = true;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imagePushed) vsImage = this.imagePushed;
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atmouseup = function(poEvent) {
  var voDf = this.df;
  if(!this.imagePushed) return;
  var voBtn = this.subElement.button;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atmouseover = function(poEvent) {
  if(this.focused == null) return;  //조건절이 true가 될 수 없는 코드

  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imageFocused && this.imageFocused == vsImage) return;
  if(this.imageMouseover) vsImage = this.imageMouseover;
//  if(poEvent.target.id == this.id) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atmouseout = function(poEvent) {
  if(this.focused == null) return;  //조건절이 true가 될 수 없는 코드

  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
//if(poEvent.target.id == this.id) this.setAttrCtrl("backgroundImage", this.oldImage, voBtn);
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.atclick = function(poEvent) {
  if(this.showContextByClick == null) return;
  var vcCtl = this.canvas.page.getControl(this.showContextByClick);
  vcCtl.left = this.left;
  vcCtl.top = this.top + this.height;
  if(this.showContext) {
    vcCtl.isShowing = false;
    this.showContext = null;
  } else {
    vcCtl.isShowing = true;
    this.showContext = true;
  }
  vcCtl.refresh();
};
/**
 * 텍스트 박스의 텍스트 세로정렬을 새로고침 합니다.
 * @param {HTMLDiv} poCtrl
 * @private
 */
eXria.controls.xhtml.Button.prototype.setInputHeight = function(poCtrl){
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  var vsText = voBtn.value;
  if(vsText == "") voSpan.innerHTML = "&nbsp;";
  else voSpan.innerHTML = vsText;
  //var vnHeight = voSpan.offsetHeight;
  //this.setAttrCtrl("height", vnHeight, voBtn);
}
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.loadComplete = function(poDocument) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(this.canvas.page.metadata.browser.opera){
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voBtn, voCtrl);
  }
};
/**
 * 수직정렬 처리.
 * @param {HTMLElement} poCtrl 수직정렬 대상 Element
 * @param {HTMLElement} poParent 수직정렬 대상 Element 의 상위 Element
 * @private
 */
eXria.controls.xhtml.Button.prototype.setVerticalAlign = function(poCtrl, poParent) {
  var vnHeight = this.subElement.span.offsetHeight;
  var vnParentHeight = parseInt(poParent.style.height);
  var vnPadding = vnParentHeight - vnHeight;
  if(vnPadding < 0) vnPadding = 0;
  vnPadding = vnPadding / 2;
  if(vnParentHeight < vnHeight) vnPadding = 0;
  poCtrl.style.paddingTop = vnPadding + "px";
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Button.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voBtn, psAttrValue);
    break;
  case "width" :
    this.setAttrCtrl("width", this.innerWidth, voBtn);
    break;
  case "height" :
    if(this.canvas.page.metadata.browser.opera){
      this.setVerticalAlign(voBtn, poCtrl);
    }
    this.setAttrCtrl("height", this.innerHeight, voBtn);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Button.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voBtn = this.subElement.button;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  voBtn.className = this.getCSSClass(this, 1);
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존 voDF.disabed는 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" + vsSplit[2] + "\')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" + vsSplit[1] + "\')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(voBtn.style["filter"]) voBtn.style["filter"] = "";
    }
  }

  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");

  voBtn.style.cssText = vaCssStrBuf.join("");
  if(this.canvas.page.metadata.browser.opera){
  //20091125 최현종 수정 voCtrl -> poCtrl (opera bug)
    this.setVerticalAlign(voBtn, poCtrl, "middle");
  }
  voBtn.innerHTML = this.getLabelText(this.value)
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Button.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    if(this.canvas.page.metadata.browser.opera){
      this.setInputHeight(voCtrl);
      this.setVerticalAlign(voBtn, voCtrl, "middle");
    }
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    voCtrl.style[psAttrName] = psAttrValue + "px";
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.setAttrCtrl(psAttrName, this.df[psAttrName] + "px", voCtrl);
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "padding" :
    if(this.paddingLeft == null) this.paddingLeft = this.padding;
    if(this.paddingRight == null) this.paddingRight = this.padding;
    if(this.paddingTop == null) this.paddingTop = this.padding;
    if(this.paddingBottom == null) this.paddingBottom = this.padding;
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voBtn);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voBtn);
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voBtn);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voBtn);
    break;
  case "paddingLeft" :
  case "paddingRight" :
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voBtn);
    break;
  case "backgroundImage" :
    psAttrValue = eXria.controls.xhtml.Util.getBackgroundImagePath(psAttrValue, this.window);
    if(voObj) voObj[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "value" :
    this.setValue(psAttrValue);
    break;
  case "backgroundColor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
  case "fontFamily" :
  case "fontSize" :
  case "fontStyle" :
  case "fontWeight" :
  case "textAlign" :
  case "textDecoration" :
  case "backgroundPosition":
  case "backgroundRepeat":
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "outerClassName" :
  case "className" :
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * loadData
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Button.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null || this.data.isRelativeRef()) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var vsRefValue = this.data.getData();
  this.setValue(vsRefValue);
};
/**
 * @private
 */
eXria.controls.xhtml.Button.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
};
/**
 * 버튼에 라벨(아이콘 이미지 포함)을 표시합니다.
 * @param {String} psLabel 라벨명
 */
eXria.controls.xhtml.Button.prototype.setValue = function(psLabel) {
  var voBtnCtrl = this.subElement.button;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psLabel) {
    vbChanged = true;
  }
  this.value = psLabel;
  if(vbChanged) {
    this.data.setData(this.value);
  }

  voBtnCtrl.innerHTML = this.getLabelText(psLabel);
};
/**
 * 지정된 값을 버튼에 표시할 라벨 텍스트로 변경시켜 주는 메소드입니다.
 * @param {String} psValue 입력 텍스트
 * @private
 */
eXria.controls.xhtml.Button.prototype.getLabelText = function(psValue) {
  if(psValue == null) return "";
  this.value = psValue;
//  this.df.value = psValue;

  var vaLabel = psValue.split(";");
  var vaStrBuf = [];
  var vsStr = null;
  vsStr = vaLabel[0];
  if(vsStr) {
    vsStr = vsStr.replace(/</g, "&lt;");
    vsStr = vsStr.replace(/>/g, "&gt;");
    vsStr = vsStr.replace(/\n/g, "<br/>");
    vsStr = eXria.controls.xhtml.Util.parseLang(vsStr);
    vaStrBuf.push(vsStr);
  }
  vsStr = vaLabel[1];
  if(vsStr) {
    vaStrBuf.push("<img src='");
    vaStrBuf.push(vsStr);
    vaStrBuf.push("'>");
  }

  return vaStrBuf.join("");
};
/**
 * 버튼에 표시된 라벨값을 반환합니다.
 * @return 컨트롤 value속성 값
 * @type String
 */
eXria.controls.xhtml.Button.prototype.getValue = function() {
  return this.value;
};
/**
 * 버튼의 포커스를 해제합니다.
 */
eXria.controls.xhtml.Button.prototype.blur = function() {
  this.ctrl.blur();
};
/**
 * 버튼에 클릭 이벤트를 발생시킵니다.
 */
eXria.controls.xhtml.Button.prototype.click  = function() {
  this.ctrl.click();
};
/**
 * 버튼에 포커스를 발생시켜 줍니다.
 */
eXria.controls.xhtml.Button.prototype.focus  = function() {
  this.ctrl.focus();
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @private
 */
eXria.controls.xhtml.Button.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Button[psAttrName];
  if(vsDefaultValue === undefined) {
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "Button"
 * @type String
 */
eXria.controls.xhtml.Button.prototype.toString = function() {
  return "Button";
};

/**
 * @fileoverview
 * Concreate xhtml Calendar(XHTML 카렌더 컨트롤)
 * @author
 */
/**
 * @class 달력을 생성하는 class입니다. DateInput이나 EditMask에서 날자를 입력할때 주로 쓰입니다.<br/>
 * XHTML Calendar Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @param {Boolean} pbFlag DateInput, EditMask 에서 호출되었는지 여부
 * @return 새로운 eXria.controls.xhtml.Calendar 객체
 * @type eXria.controls.xhtml.Calendar
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Calendar = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pbFlag){

    pnLeft = pnLeft == null ? 20 : pnLeft;
    pnTop = pnTop == null ? 20 : pnTop;
    pnWidth = pnWidth == null ? 250 : pnWidth;
    pnHeight = pnHeight == null ? 250 : pnHeight;

  /**
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  /**
   * Calendar에 의해 선택된 날짜를 셋팅할 컨트롤
   * @type eXria.controls.xhtml.UIControl
   * @private
   */
  this.target;

  this.width = pnWidth;

  this.height = pnHeight;
  /**
   * 외부 컨트롤에 의해 호출되었는지 여부를 저장하는 속성
   * @type Boolean
   * @private
   */
  this.isCalledBy = pbFlag;
  /**
   * 컨트롤에 지정된 값을 Date형태로 접근하기 위한 속성.
   * @type Date
   */
  this.date;
  /**
   * 기본형 달력VIEW와 년도와 월을 동시에 변경(getMultiSelectHTML)하는 VIEW를 구분하기 위한 속성.
   * @private
   */
  this.calType = 'default';

  /**
   * 년도와 월을 동시에 변경(getMultiSelectHTML)하는 VIEW를 유지 하기 위한 속성
   * @type Boolean
   * @private
   */
  this.keepMultiSelector = null;

  /**
   * Defaults.xml의 경로 설정
   * @type String
   */
  this.defaultFileName = null;
  /**
   * Text.xml의 경로 설정
   * @type String
   */
  this.textFileName = null;
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).
   * @type String
   */
  this.position = "absolute";

  var date = (!this.date) ? new Date() : this.date;
  var now = new Date();
  /**
   * 년
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.year = date.getUTCFullYear();
  /**
   * 월
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.month = date.getUTCMonth() + 1;
  /**
   * 일
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.dayNum = date.getUTCDate();
  /**
   * 다국어 처리를 언어 locale
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.locale = null;
  /**
   * TreeGrid 관련 CSS
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.CSS = null;
  /**
   * 올해 년
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.NOWYEAR = now.getUTCFullYear();
  /**
   * 올해 월
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.NOWMONTH = now.getUTCMonth() + 1;
  /**
   * 올해 일
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.NOWDAYNUM = now.getUTCDate();
  /**
   * 일자 선택 관련 속성
   * 달력 연산을 처리 하기 위한 내부 속성으로 사용됨
   * @private
   */
  this.FY;
  /**
   * 달과 년이 선택되었는지 여부(0|1)
   * @type Number
   * @private
   */
  this.record;
  /**
   * @private
   */
  this.loadedStyles = [];
  //this.loadDefaultSpce();
};

/////////////////////////////////////////
// 상속 Start
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Calendar);
// 상속 End
/////////////////////////////////////////


/////////////////////////////////////////
// Setter Method
/**
 * Calendar에 의해 선택된 날짜를 셋팅할 컨트롤을 설정합니다.
 * @param {eXria.controls.xhtml.UIControl} poCtrl 타겟 컨트롤
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.setTarget = function(poCtrl){
    this.target = poCtrl;
};
/**
 * Calendar에 의해 선택된 날짜를 셋팅합니다.
 * @param {Date} poDate 달력에 선택될 날짜 개체
 */
eXria.controls.xhtml.Calendar.prototype.setDate = function(poDate){
    this.date = poDate;
};
// Setter Method
/////////////////////////////////////////


/////////////////////////////////////////
// Lifecycle Method START
eXria.controls.xhtml.Calendar.prototype.createCtrl = function(poDocument){
    ///// DIV Control Create Start /////
    var voCtrl = poDocument.createElement("div");
    voCtrl["id"] = this.id;
    voCtrl["tabIndex"] = -1;
    if (this.canvas.page.metadata.browser.ie > 0)
        voCtrl["hideFocus"] = true;
    this.template = [];
    this.document = poDocument;
    this.ctrl = voCtrl;
    return voCtrl;
};

eXria.controls.xhtml.Calendar.prototype.setTemplate = function(poCtrl){
  this.loadDefaultSpce();
  var voCaltyp = this.calType;

  //2010.04.20
  //Ref 처리를 위해 추가
  if(this.data.instanceId == null || this.data.isRelativeRef()){
  }else{
    if(!this.loadNodeRefFlag) this.loadNodeRef();
  }

  if(true === this.keepMultiSelector) {
      this.getMultiSelectHTML(this.keepMultiSelector);
  }else{
    //일반적인 경우
    if (!!voCaltyp && voCaltyp === 'default') {
      this.getHTML();
    } else {
      if (!!voCaltyp && voCaltyp === 'multi') this.getMultiSelectHTML();
    }
  }
};
/**
 * 인스턴스에 매핑된 data를 얻어오기 위한 메소드.
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.loadNodeRef = function(){
  var vsNodeRef = this.data.getData();

  if(!!vsNodeRef && vsNodeRef.length >= 8) {

    this.loadNodeRefFlag = true; //@ignore

    vsNodeRef = vsNodeRef + '';
    vsNodeRef = vsNodeRef.replace(/[^0-9]/gi,'');
    var vsDate = new Date(Date.UTC(Number(vsNodeRef.substring(0, 4)), Number(vsNodeRef.substring(4, 6)) - 1, Number(vsNodeRef.substring(6, 8)), 0, 0, 0));

    this.date = vsDate;
    this.year = vsDate.getUTCFullYear();
    this.month = vsDate.getUTCMonth() + 1;
    this.dayNum = vsDate.getUTCDate();

    this.NOWYEAR = vsDate.getUTCFullYear();
    this.NOWMONTH = vsDate.getUTCMonth() + 1;
    this.NOWDAYNUM = vsDate.getUTCDate();
  }
};
/**
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.loadComplete = function(){
    this.loadCSS(this.CSS, "complete");
    if (this.isCalledBy == true)
        this.focusDate();
};
/**
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.focusDate = function(){
    var voDocument = this.getCalenderCtrl("document");
    var voCal = voDocument.getElementById(this.id);
    voCal.focus();
};
/**
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl){
    if (poCtrl.id != this.id) return;

    var voTable = poCtrl.childNodes.item(0);

    //width, height 180px 미만이면 메세지 출력(발생될 경우가 절대 없음)
    if (psAttrName == "width" && this.width < 180) {
      alert(" width 최소값: 180px \n 180px 이상으로 입력하십시오.");
    } else {
      if (psAttrName == "height" && this.height < 180) {
        alert(" height 최소값: 180px \n 180px 이상으로 입력하십시오.");
      }
    }
    switch (psAttrName) {
      case "width":
        this.setAttrCtrl("width", this.innerWidth, voTable);
        break;
      case "height":
        this.setAttrCtrl("height", this.innerHeight, voTable);
        break;
    }
};

/**
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument){

    var voCtrl = this.getCtrl(poDocument);
    this.setAttr(psAttrName, psAttrValue);
    switch (psAttrName) {
      case "visible":
        this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
        break;
      case "disabled":
        this.setDisable(voCtrl, psAttrValue);
        break;
      default:
        this.refresh(poDocument);
        break;
    }
};

eXria.controls.xhtml.Calendar.prototype.removeSpecificDefaults = function(poCtrl, poDocument){
    this.df = {};
};

eXria.controls.xhtml.Calendar.prototype.setSpecificDefaults = function(poCtrl, poDocument){
    var voDf = this.df;
    var vaCssStrBuf = null;
    var vaAttStrBuf = null;
    var vaInnStrBuf = null;
    var vaTemplate = this.template;
    var vfcSetCssStrBuf = this.setCssStrBuf;

    poCtrl["tabIndex"] = this.tabIndex;
    poCtrl["tooltip"] = this.tooltip;
    if (this.disabled) poCtrl["disabled"] = true;

    vaCssStrBuf = [];
    vaCssStrBuf.push("margin:0px;padding:0px;");
    if (this.visible == false) vaCssStrBuf.push("display:none;");
    else vaCssStrBuf.push("display:block;");
    vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
    vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
    vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
    vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
    vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");

    vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
    vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
    vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
    vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
    vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
    poCtrl.style.cssText = vaCssStrBuf.join("");

    poCtrl.innerHTML = vaTemplate.join("");
    this.template = null;
    this.templateIndexMap = null;

    this.defaultFileName = this.getAttrValue("defaultFileName", this.defaultFileName);
    this.textFileName = this.getAttrValue("textFileName", this.textFileName);
};

eXria.controls.xhtml.Calendar.prototype.setSpecificAttrs = function(poCtrl, poDocument){
    var voDf = this.df;
    var vaCssStrBuf = null;
    var vaAttStrBuf = null;
    var vaInnStrBuf = null;
    var vaTemplate = this.template;
    var vfcSetCssStrBuf = this.setCssStrBuf;
    var vfcSetAttStrBuf = this.setAttStrBuf;
    var voIndexMap = this.templateIndexMap;
    
    var voPage = this.getCalenderCtrl();
    var voTarget = this.target;
    var voFrameElement = (voTarget ) ? voTarget.window.frameElement : window.frameElement;
    var vnLeft = null;
    var vnTop = null;
    
    if(!!voFrameElement && voFrameElement.id.indexOf("sbp") > -1){
      vsMainPage = voFrameElement.src;
      vsSrc = vsMainPage.substring(vsMainPage.lastIndexOf("/")+1, (vsMainPage.length-4));
      if(vsSrc.indexOf(".xrf") > -1){
        vsSrc = vsSrc.substr(0, vsSrc.indexOf(".xrf"));
      }   
      vsSrc = vsSrc+"_canvas";
  
      if(vsSrc != voPage.id){
        while(voFrameElement.id){
          if(!isNaN(voFrameElement.offsetTop)) vnTop = vnTop + voFrameElement.offsetTop;
          if(!isNaN(voFrameElement.offsetLeft)) vnLeft = vnLeft + voFrameElement.offsetLeft;
          voFrameElement = voFrameElement.parentNode;
        }
      }
    }
    var vnParentHeight = window.document.documentElement.clientHeight;
    if(!!voTarget && !!voTarget.ctrl.parentNode) {
      var voParentCtl = voTarget.ctrl.parentNode;
      vnTop = vnTop + voTarget.height + voTarget.top + voTarget.borderTopWidth;
      vnLeft = vnLeft + voTarget.left + voTarget.borderLeftWidth;
      
      if(!!voFrameElement && voFrameElement.id.indexOf("sbp") > -1){
        vnTop = vnTop + voFrameElement.offsetTop;
        vnLeft = vnLeft + voFrameElement.offsetLeft;
      }
      while(voParentCtl.parentNode.id){
        if(!isNaN(voParentCtl.offsetTop)) vnTop = vnTop + voParentCtl.offsetTop;
        if(!isNaN(voParentCtl.offsetLeft)) vnLeft = vnLeft + voParentCtl.offsetLeft;
        voParentCtl = voParentCtl.parentNode;
      }
    }else{
      vnLeft = this.left;
      vnTop = this.top;
    }
    
    if(!!voTarget && (vnTop + this.height + voTarget.height) > vnParentHeight){
      vnTop = ((parseInt(vnTop) - voTarget.borderTopWidth) - (voTarget.borderTopWidth + this.borderBottomWidth + (parseInt(this.height) - voTarget.height))) - 3;
      if (!(this.canvas.page.metadata.browser.ie > 0))  vnTop = vnTop - 15;
    }
    
    poCtrl["tabIndex"] = this.tabIndex;
    poCtrl["tooltip"] = this.tooltip;
    if (this.disabled) poCtrl["disabled"] = true;

    vaCssStrBuf = [];
    vaCssStrBuf.push("margin:0px;padding:0px;");
    if (this.visible == false) vaCssStrBuf.push("display:none;");
    else vaCssStrBuf.push("display:block;");
    vfcSetCssStrBuf(vaCssStrBuf, "z-index", 500000);
    vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
    vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
    vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
    vfcSetCssStrBuf(vaCssStrBuf, "left", vnLeft, "px");

    vfcSetCssStrBuf(vaCssStrBuf, "top", vnTop, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
    vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
    vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
    vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
    vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
    poCtrl.style.cssText = vaCssStrBuf.join("");
    
    this.setAttrCtrl("zIndex", 50000, poCtrl);
};

/**
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.atkeydown = function(e){
  if(!!this.target && !!this.target.ctrl.firstChild.value) {
     if(e.keyCode == 27)
      this.close();
  }
};

// Lifecycle Method END
/////////////////////////////////////////

/////////////////////////////////////////
//달력상수
/**
 * @ignore
 */
eXria.controls.xhtml.Calendar.CGLang = {
    "kor": {
        "month": "",
        "day": ""
    },
    "eng": {
        "month": "",
        "day": ""
    },
    "chn": {
        "month": "",
        "day": ""
    },
    "jpn": {
        "month": "",
        "day": ""
    }
};
//달력상수
/////////////////////////////////////////

/////////////////////////////////////////////
// 사용자 메소드 리스트 START
/**
 * Calendar의 visible속성을 설정합니다.
 * @param {boolean} pbVisible 화면 보여짐 여부
 */
eXria.controls.xhtml.Calendar.prototype.setVisible = function(pbVisible){
    this.visible = pbVisible;
};

/**
 * 달력을 화면에 표시해주는 메소드.
 * @param {HTMLElement} poCtrl 컨트롤이 위치한 상위 Dom Element. 생략가능.
 * @param {HTMLElement} poDocument 컨트롤이 생성될 document 객체. 생략가능.
 */
eXria.controls.xhtml.Calendar.prototype.show = function(poCtrl, poDocument){
  this.close();
  this.visible = true;
  var voTarget = this.target;
  var voCanvas = null;
  if(voTarget) voCanvas = voTarget.canvas;
  if(voCanvas == null) voCanvas = this.canvas;
  if(voCanvas) {
    if(!!this.target && !!this.target.ctrl.firstChild.value) {
      var voDateStr = this.target.getValue();
      var vsRegType = /[^0-9]/gi;
      voDateStr = voDateStr.replace(vsRegType, '');

      this.date = new Date(Date.UTC(Number(voDateStr.substring(0, 4)), Number(voDateStr.substring(4, 6)) - 1, Number(voDateStr.substring(6, 8)), 0, 0, 0));

      this.year = this.date.getUTCFullYear();
      this.month = this.date.getUTCMonth() + 1;
      this.dayNum = this.date.getUTCDate();
    }

    // 부모 컨트롤 밑에 appendChild 되게 수정 (poCtrl이 없는 경우에는 parent 컨트롤이 없는 경우)
    if(!poCtrl) poCtrl = this.canvas;
    var voCanvasCtrl = this.getCalenderCtrl();
    voCalendarCtrl = this.create();
    voCanvasCtrl.appendChild(voCalendarCtrl);
    this.load();
  }
};
/**
 * Calender 컨트롤이 속한 page 객체, dom 객체 가져오는 메서드.
 */
eXria.controls.xhtml.Calendar.prototype.getCalenderCtrl = function(poDiv) {
  var vbSpbFlag = false;
  var voCanvasCtrl = null;
  var vsReferrer = null;
  var vsFrameId = null;
  var voTarget = this;
  var voPage = voTarget.canvas.page;
  
  if(voTarget.window.frameElement) vsFrameId = voTarget.window.frameElement.id;
  while(voPage){
    if(voPage.getPage)  if(!!voPage.getPage(vsFrameId)) vbSpbFlag = true;
    if(vbSpbFlag) {
      vsReferrer = this.document.referrer;
      break;
    }else {
      vsReferrer = this.document.location.pathname;
      if(!voPage.parent? false : voPage.id == voPage.parent.id) break;
      else voPage = voPage.parent;
    }
  }
  if(!vsReferrer) vsReferrer = this.document.location.pathname;
   
  var vsMainPage = vsReferrer.substring(vsReferrer.lastIndexOf("/")+1, (vsReferrer.length-4));
  voPage = voTarget.canvas.page;
  
  while(voPage.parent) {
    if(voPage.id.indexOf(vsMainPage) > -1)  break;
    voPage = voPage.parent;
  }
//  if(poDiv == "document") voCanvasCtrl = voPage.window.document;  
//  else voCanvasCtrl = voPage.canvas.getCtrl();
  if(poDiv == "document") voCanvasCtrl = voPage.canvas.ctrl.parentNode.ownerDocument;
  else voCanvasCtrl = voPage.canvas.ctrl.parentNode;
  return voCanvasCtrl;
};

/**
 * css를 동적으로 로드한다.
 * @param {String} psCSSFilePath 경로가 포함된 로딩될 CSS
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치할 Doucment.
 * @return {boolean}
 * @type boolean
 */
eXria.controls.xhtml.Calendar.prototype.loadCSSFile2 = function(psCSSFilePath, poDocument){
  var voRtnVal = false;
  var vbCssFlag = true;
  var voDocument = poDocument;
  var voDocumentElement = voDocument.documentElement;
  var voLink = voDocument.documentElement.getElementsByTagName("link");

  if (!!psCSSFilePath) {
    for (var i = 0; i < voLink.length; i++) {
      if (voLink[i].rel.toLowerCase() == "stylesheet" && voLink[i].href && voLink[i].href.indexOf(psCSSFilePath) >= 0){
        vbCssFlag = false;
        break;
      }
    }
    //TODO : CSS 파일 존재 여부 확인 로직추가
    
    if (vbCssFlag) {
      var voCreateElement = voDocument.createElement("link");
      voCreateElement.href = psCSSFilePath;
      voCreateElement.rel = "Stylesheet";
      voCreateElement.type = "text/css";
  
      var voHead = voDocumentElement.getElementsByTagName("head")[0];
      if (!voHead) {
          voHead = voDocument.createElement("head");
          voDocumentElement.insertBefore(voHead, voDocument.body);
      }
      voHead.insertBefore(voCreateElement, voHead.firstChild);
      voRtnVal = true;
    }
  }
  return voRtnVal;
}

/**
 * Calendar가 화면에서 보이지 않게 만들어줍니다.
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치할 Doucment. 생략가능
 */
eXria.controls.xhtml.Calendar.prototype.hide = function(poDocument){
  this.visible = false;

  if(!!this.ctrl && !!this.ctrl.parentNode && null != this.ctrl.parentNode.oriZindex) {
    this.ctrl.parentNode.style.zIndex = this.ctrl.parentNode.oriZindex;
  }

  this.clearCtrl();
  if(this.lifted) {
//    this.setAttrCtrl("zIndex", this.zIndex, this.ctrl);
    voParent = this.parent;
    while(voParent) {
      if(voParent.ctrl) {
        vnZIndex = voParent.zIndex == null ? 0 : voParent.zIndex;
        this.setAttrCtrl("zIndex", vnZIndex, voParent.ctrl);
      }
      voParent = voParent.parent;
    }
    this.lifted = false;
  }
  this.ctrl = null;
};

/**
 * 기준 날짜의 년도를 구하는 메소드입니다.
 * @return 년도
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getYear = function(){

  var vnYear = this.date.getUTCFullYear();
  if (vnYear > 1900) {
    return vnYear;
  }
  return 1900 + vnYear;
};

/**
 * 기준 날짜의 월을 반환합니다.
 * @return 월(1 ~ 12)
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getMonth = function(){
  var vnMonth = this.date.getUTCMonth() + 1;
  return vnMonth;
};

/**
 * 기준 날짜의 일을 반환합니다.
 * @return 일
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getDate = function(){
  var vnDate = this.date.getUTCDate();
  return vnDate;
};

/**
 * 선택된 날짜의 년도를 반환 합니다.
 * @return 년도
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getSelectYear = function(){
  var vnYear;
  vnYear = this.date;

  if(!!this.date) vnYear = Number(this.date.substring(0, 4));
  else vnYear = this.getYear();

  return vnYear;
};

/**
 * 선택된 날짜의 월을 반환 합니다.
 * @return 월(1 ~ 12)
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getSelectMonth = function(){
  var vnMonth;
  vnMonth = this.date;

  if(!!this.date) vnMonth = Number(this.date.substring(4, 6));
  else vnMonth = this.getMonth();

  return vnMonth;
};

/**
 * 선택된 날짜의 일을 반환 합니다.
 * @return 일
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getSelectDate = function(){
  var vnDate;
  vnDate = this.date;

  if(!!this.date) vnDate = Number(this.date.substring(6, 8));
  else vnDate = this.getDate();

  return vnDate;
};

/**
 * 기준 날짜의 최대 일자를 반환합니다(파라미터값 미입력시 현재날짜를 기준).
 * @param pnYear 기준년도(생략가능)
 * @param pnMonth 기준달(생략가능)
 * @return 기준 달의 최대 일자
 * @type Number
 */
eXria.controls.xhtml.Calendar.prototype.getMaxDay = function(pnYear, pnMonth){
  var vnMonth = pnMonth;
  var vnYear = pnYear;
  if (pnYear == null) vnYear = this.date.getUTCFullYear();
  if (pnMonth == null) vnMonth = this.date.getUTCMonth();
  else vnMonth -= 1;
  var vnMaxDay = 30;
  if (vnMonth == 0 || vnMonth == 2 || vnMonth == 4 || vnMonth == 6 || vnMonth == 7 || vnMonth == 9 || vnMonth == 11) {
    vnMaxDay = 31;
  }
  if (vnMonth == 1) {
    if (vnYear % 4 == 0 && (vnYear % 400 == 0 || vnYear % 100 != 0)) {
      vnMaxDay = 29;
    } else {
      vnMaxDay = 28;
    }
  }
  return vnMaxDay;
};

/**
 * 기준날짜를 지난 달로 이동합니다.
 */
eXria.controls.xhtml.Calendar.prototype.toLastMonth = function(){
  this.monthChange(-1);
};

/**
 * 기준날짜를 다음 달로 이동합니다.
 */
eXria.controls.xhtml.Calendar.prototype.toNextMonth = function(){
  this.monthChange(1);
};

/**
 * 기준날짜를 지난 해로 이동합니다.
 */
eXria.controls.xhtml.Calendar.prototype.toLastYear = function(){
  this.yearSelect(this.year - 1);
};

/**
 * 기준날짜를 다음 해로 이동합니다.
 */
eXria.controls.xhtml.Calendar.prototype.toNextYear = function(){
  this.yearSelect(this.year + 1);
};

/**
 * 원하는 일자로 달력을 이동시킵니다.
 * @param {Number} pnYear 기준년도
 * @param {Number} pnMonth 기준월
 * @param {Number} pnMonth 기준일
 */
eXria.controls.xhtml.Calendar.prototype.move = function(pnYear, pnMonth, pnDay){
  this.year = pnYear;
  this.month = pnMonth;
  this.dayNum = pnDay;
  this.update();
};

/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @private
 */
eXria.controls.xhtml.Calendar.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Calendar[psAttrName];
  if (vsDefaultValue === undefined) {
    return null;
  }
  return vsDefaultValue;
};

/**
 * 클래스 명을 반환합니다.
 * @return "Calendar"
 * @type String
 */
eXria.controls.xhtml.Calendar.prototype.toString = function(){
  return "Calendar";
};
// 사용자 메소드 리스트 END
/////////////////////////////////////////////


/////////////////////////////////////////////
// 달력처리 내부 메소드 리스트 START
/**
 * SPEC 정보를 로딩
 * @return undefined
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.loadDefaultSpce = function(){
  this.loadLocale();
  this.calendarLocale();
  this.calendarDefaultCSS();
  if(!this.loadedStyles) this.loadCSS(this.CSS);
};

/**
 * Default.xml 로드
 * @return undefined
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.calendarDefaultCSS = function(){
  //Defaults.XML을 읽어 온다.
  if (!this.defaultFileName) this.defaultFileName = page.metadata.resourceBaseUrl + 'eXria/lib/gridex/Defaults.xml';

  var vaFilePath = this.defaultFileName;

  if (this.defaultFileName !== 'eXria/lib/gridex/Defaults.xml') {
    var vaXMLObj = eXria.controls.xhtml.Util.loadXML(vaFilePath);
    if (vaXMLObj.success) {
      try{
        var vsStyle = vaXMLObj.xmlDox.getElementsByTagName("Cfg")[0].getAttribute("Style");
        vsStyle = {
            "Borders": "GB",
            "Light": "GL",
            "Modern": "GM",
            "Office": "GO",
            "Plain": "GP",
            "Robust": "GR",
            "Standard": "GS"
        }[vsStyle];
        this.CSS = vsStyle;
        eXria.controls.xhtml.Calendar.CSSStyle = this.CSS;
      }catch(e){
        //load 실패시 default 파일 로드
        var vaXMLObj = eXria.controls.xhtml.Util.loadXML(page.metadata.resourceBaseUrl + 'eXria/lib/gridex/Defaults.xml');
        var vsStyle = vaXMLObj.xmlDox.getElementsByTagName("Cfg")[0].getAttribute("Style");
        vsStyle = {
            "Borders": "GB",
            "Light": "GL",
            "Modern": "GM",
            "Office": "GO",
            "Plain": "GP",
            "Robust": "GR",
            "Standard": "GS"
        }[vsStyle];
        this.CSS = vsStyle;
        eXria.controls.xhtml.Calendar.CSSStyle = this.CSS;

      }
    }
  } else {
    this.CSS = eXria.controls.xhtml.Calendar.CSSStyle;
  }

};

/**
 * Text.xml 로드
 * @return undefined
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.calendarLocale = function(){
  if (!this.textFileName) this.textFileName = page.metadata.resourceBaseUrl +'eXria/lib/gridex/Text.xml';

  //Text.XML을 읽어 온다.
  var vaFilePath = this.textFileName;

  if (!eXria.controls.xhtml.Calendar.CGLang["kor"]['month']) {
    var vaXMLObj = eXria.controls.xhtml.Util.loadXML(vaFilePath);
    if (vaXMLObj.success) {
      try {
        //vaXMLObj.xmlDox.document.getElementsByTagName("Format")[0].getAttribute("LongMonthNames_"+this.locale); //"January,February,March
        var vaLangArr = ["kor", "eng", "jpn", "chn"];

        for (var i = 0; i < vaLangArr.length; i++) {
          var vsDayCharNames = vaXMLObj.xmlDox.getElementsByTagName("Format")[0].getAttribute("Day2CharNames_" + vaLangArr[i]);
          var vsMonthNames = vaXMLObj.xmlDox.getElementsByTagName("Format")[0].getAttribute("ShortMonthNames_" + vaLangArr[i]);
          vsDayCharNames = vsDayCharNames.split(',');
          vsMonthNames = vsMonthNames.split(',');
          eXria.controls.xhtml.Calendar.CGLang[vaLangArr[i]]['month'] = vsMonthNames;
          eXria.controls.xhtml.Calendar.CGLang[vaLangArr[i]]['day'] = vsDayCharNames;
        }

      } catch(e) {
        //load 실패시 default 파일 로드
        var vaLangArr = ["kor", "eng", "jpn", "chn"];
        var vaXMLObj = eXria.controls.xhtml.Util.loadXML(page.metadata.resourceBaseUrl + 'eXria/lib/gridex/Text.xml');

        for (var i = 0; i < vaLangArr.length; i++) {
          var vsDayCharNames = vaXMLObj.xmlDox.getElementsByTagName("Format")[0].getAttribute("Day2CharNames");
          var vsMonthNames = vaXMLObj.xmlDox.getElementsByTagName("Format")[0].getAttribute("ShortMonthNames");
          vsDayCharNames = vsDayCharNames.split(',');
          vsMonthNames = vsMonthNames.split(',');
          eXria.controls.xhtml.Calendar.CGLang[vaLangArr[i]]['month'] = vsMonthNames;
          eXria.controls.xhtml.Calendar.CGLang[vaLangArr[i]]['day'] = vsDayCharNames;
        }
      }

    }
  }
};

/**
 * locale 정보를 동적으로 로드한다.
 * @return undefined
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.loadLocale = function(){
//  var vsLocale = "kor";
//  if (this.locale == null) {
    var vsLocale = eXria.controls.xhtml.Util.getDefaultLocale();
//  }

  this.locale = vsLocale;
};

/**
 * css를 동적으로 로드한다.
 * @param (String) css명
 * @return undefined
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.loadCSS = function(psCss, psDiv){
  if (!psCss) psCss = 'GL';

  this.CSS = psCss;

  var vaFilePath = page.metadata.resourceBaseUrl + 'eXria/lib/gridex/';
  vaFilePath = vaFilePath +
  {
      "GS": "Standard/Grid.css",
      "GM": "Modern/Grid.css",
      "GO": "Office/Grid.css",
      "GL": "Light/Grid.css",
      "GB": "Borders/Grid.css",
      "GR": "Robust/Grid.css",
      "GP": "Plain/Grid.css"
  }[psCss];
  if(psDiv == "complete"){
    var voRtnVal = this.loadCSSFile2(vaFilePath, this.getCalenderCtrl("document"));
    if (voRtnVal) this.loadedStyles[psCss] = vaFilePath;
  }else{
    var vbFlag = this.getGridExYn();
    //여러번 Calendal가 여러개 있을경우 CSS의 반복호출을 막기 위해 사용
    if (vaFilePath && !vbFlag) {
      var voRtnVal = eXria.controls.xhtml.Util.loadCSSFile(vaFilePath);
      if (voRtnVal) this.loadedStyles[psCss] = vaFilePath;
    }   
  }
};

/**
 * Calendar 컨트롤이 있는 페이지에 그리드 컨트롤 존재 여부
 * @return boolean
 * @type boolean
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.getGridExYn = function(){
  var vbResult = false;
  var voPage = page;
  var vnCnt = voPage.canvas.controls.seq;
  var vaKeyEntries = new Array();
  var voCtrl = null;
  
  for(var i = 0; i < vnCnt; i++){
    vaKeyEntries[i] = page.canvas.controls.keyEntries[i];
    voCtrl = eval(vaKeyEntries[i]).control;
    if(!!voCtrl){
      if(voCtrl.toString() == "GridEx"){
       vbResult = true;
        break;
      }
    }
  }
  return vbResult;
};

/**
 * 넘어온 인자의 양끝에 ' 문자를 찍어서 반환하는 메소드
 * @param {String} 양끝에 ' 찍혀서 반환될 문자열
 * @return 양끝에 ' 찍혀서 반환된 문자열
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.getPreString = function(psName){
  return "'" + psName + "'";
};

/**
 * 이벤트 핸들러를 정의하는 문자열을 반환하는 메소드
 * @param {String} psFuncName 이벤트 핸들러 내부에서 호출되는 working 메소드 명
 * @return 이벤트 핸들러를 정의하는 문자열
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.getEHandler = function(psFuncName){
  var vaStrBuf = [];
  var voPage = null;
  
  if(this.target) {
    var vsTargetId = this.target.id;
    var vaStrBuffer = function(){
      vaStrBuf.push("page.getControl('");
      vaStrBuf.push(vsTargetId);
      vaStrBuf.push("').calendar.");
    };
    if(!!page.parent){
      voPage = page.parent;
    }else{
      voPage = page;
    }
    if(!this.window.frameElement){
      vaStrBuffer();
    }else{
      if(!voPage.getPage(this.window.frameElement.id)){
        vaStrBuffer();
      }else if(!!voPage.getPage(this.window.frameElement.id).getControl(this.target.id)){
        vaStrBuf.push("page.getPage('");
        vaStrBuf.push(this.window.frameElement.id);
        vaStrBuf.push("').getControl('"); 
        vaStrBuf.push(vsTargetId);
        vaStrBuf.push("').calendar.");  
      }else{
        vaStrBuffer();
      }
    }
  } else {
    vaStrBuf.push("page.getControl('");
    vaStrBuf.push(this.id);
    vaStrBuf.push("').");
  }
  
  var vsStrCommon = vaStrBuf.join("");
  vaStrBuf.push("eventStopPropagation(event); ");
  vaStrBuf.push(vsStrCommon);
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(");

  for (var i = 1; i < arguments.length; i++) {
      if (i == 1) vaStrBuf.push(arguments[i]);
      else vaStrBuf.push("," + arguments[i]);
  }
  vaStrBuf.push(");");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};

eXria.controls.xhtml.Calendar.prototype._showTimesInfo = function(psTime){
  var voDocument = this.document;
  var voDomFoot = voDocument.getElementById(this.id + '_tfoot'),voINPUT,voTR,voTD;
  var that = this;

  voINPUT = document.createElement('input');
  voINPUT.id = this.id + '_tfoot_ipb'
  voINPUT.type = 'text';
  voINPUT.setAttribute('style','border: 0px;padding:0px; font:12px Verdana,Arial;text-align:right;');
  voINPUT.value = psTime;
  voINPUT.onkeydown = function(e){
    that._hhmmss = voINPUT;
    var voEvent = e || window.event;
    if(voEvent.keyCode === 13) {
      var dayNum = (10 > that.dayNum) ? '0' + that.dayNum : that.dayNum;
      var month =  (10 > that.month) ? '0' + that.month : that.month;
      var selectDate = that.year + "" + month + "" + dayNum;

      that.daySelect(that.dayNum, that.dayNum, selectDate);
    }
  }

  voTR = document.createElement('tr');
  voTR.className = this.CSS + 'PickTimeCell';
  voTR.setAttribute('style', 'height: 20px; padding: 5px;');

  voTD = document.createElement('td');
  voTR.appendChild(voTD);

  voTD = document.createElement('td');
  voTD.colSpan = '7'
  voTD.appendChild(voINPUT);
  voTR.appendChild(voTD);

  voTD = document.createElement('td');
  voTR.appendChild(voTD);

  voDomFoot.appendChild(voTR);
}

/**
 * 달력그리기
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.getHTML = function(){
  this.template = [];
  var vaTemplate = this.template;
  var p = 0, CNBSP = "&#160;", vsLocale = this.locale;
  var monthYear = eXria.controls.xhtml.Calendar.CGLang[vsLocale]["month"][this.month - 1] + CNBSP + this.year + CNBSP;
  var re = /[^0-9]/gi;

  vaTemplate[p++] = "<table cellspacing='0' cellpadding='0' class='" + this.CSS + "PickBorder'><tfoot id='"+this.id+'_tfoot'+"'>";
  // --- month and year ---
  vaTemplate[p++] = "<tr><td></td><td colspan='7'></td><td></td></tr>";
  vaTemplate[p++] = "<tr class='" + this.CSS + "PickDate'><td></td>";
  vaTemplate[p++] = "<td colspan='7' class='" + this.CSS + "PickMY'>";

  vaTemplate[p++] = "<div class='" + this.CSS + "PickBL " + this.CSS + "PickBLIE7' onclick=\"" + this.getEHandler('monthChange', -1) +
    "\"><center>" +
    "</center></div>";

  vaTemplate[p++] = "<div class='" + this.CSS + "PickBR " + this.CSS + "PickBRIE7' onclick=\"" + this.getEHandler('monthChange', 1) + "\"><center>" +
    "</center></div>";

  vaTemplate[p++] = "<center><table cellspacing='0' cellpadding='0'><tfoot><tr style='cursor:pointer;' onclick=\"" + this.getEHandler('downSel') + "\">" +
    "<td class='" +
    this.CSS +
    "PickMY " +
    this.CSS +
    "PickMYDown' dir='ltr'>" +
    monthYear +
    "</td>" +
    "<td><center>" +
    "</center></td></tr></tfoot></table></center></td>";
  vaTemplate[p++] = "<td></td></tr>";

  // --- day names ---
  vaTemplate[p++] = "<tr class='" + this.CSS + "PickRowW'><td></td>";
  for (var i = 0; i < 7; i++) {
    vaTemplate[p++] = "<td class='" + this.CSS + "PickCell'><div class='" + this.CSS + "PickWDN'>" +
    eXria.controls.xhtml.Calendar.CGLang[vsLocale]["day"][i] +
    "</div></td>";
  }
  vaTemplate[p++] = "<td></td></tr>";

  // --- days Num---
  //GLPickOM - 공백날자
  //GLPickWD - 일반
  //GLPickSa - 토요일
  //GLPickSu - 일요일
  //GLPickSel- 선택된 날자
  //GLPickNow- 지금날자

  var m1 = new Date(this.year, this.month - 1, 0);

  m1 = m1.getDate(); //m1 저번달 마지막일
  var m2 = new Date(this.year, this.month, 0);
  m2 = m2.getDate(); //m2 이번달 마지막일
  var d1 = new Date(this.year, this.month - 1, 1);
  d1 = d1.getDay(); //이번달 시작요일(월화수 등)
  if (d1 < 0) d1 += 7;
  var d = 1 - d1; // 이번달 시작요일의 전일(월화수등)
  var sun = 0;
  var sat = 6;

  for (var r = 0; r < 6; r++) {
    vaTemplate[p++] = "<tr class='" + this.CSS + "PickRow'><td></td>";
    for (var c = 0; c < 7; c++) {
      var cls = "" + this.CSS + "PickWD";
      if (c == sun) cls = "" + this.CSS + "PickSu";
      else if (c == sat) cls = "" + this.CSS + "PickSa";
      var ds = d;

      if (d <= 0) {   // 저번달일 경우
        ds = d + m1;
        cls = "" + this.CSS + "PickOM";
      } else if (d > m2) {  // 다음달일 경우
        ds = d - m2;
        cls = "" + this.CSS + "PickOM";
      }

      // 저번달 또는 다음달 영역에 있는 날짜를 선택했을 경우의 처리 추가
      var selectMonth = this.month;
      var selectYear = this.year;
      if(d<=0) {
        selectMonth = selectMonth - 1;
        if(selectMonth < 1) {
          selectYear--;
          selectMonth = 12;
        }
      }
      if(d>m2) {
        selectMonth = selectMonth + 1;
        if(selectMonth > 12) {
          selectYear++;
          selectMonth = 1;
        }
      }

      var selectDate = selectYear + "" +
        ((selectMonth < 10) ? "0" + selectMonth : selectMonth) +
        "" +
        ((ds < 10) ? "0" + ds : ds);

      //오늘 날자
      var nowDate = this.NOWYEAR + "" +
        ((this.NOWMONTH < 10) ? "0" + this.NOWMONTH : this.NOWMONTH) +
        "" +
        ((this.NOWDAYNUM < 10) ? "0" + this.NOWDAYNUM : this.NOWDAYNUM);

      cls = ((selectDate.replace(re, "") == nowDate) &&
        !(d <= 0) &&
        !(d > m2)) ? "" + this.CSS + "PickNow" : cls;

      //선택된 날자
      if (!!this.target && !!this.target.ctrl.firstChild.value) {
        cls = ((this.target.ctrl.firstChild.value.replace(re, "").substring(0,8) == selectDate.replace(re, "")) &&
            !(d <= 0) &&
            !(d > m2)) ? "" + this.CSS + "PickSel" : cls;
      } else {
        //target 없이 Calendar 가 단독으로 사용되는 경우
        //2010.05.14
        //Calendar가 단독으로 작동하는경우 선택날짜가 있으면
        //this.date가 8자리(yyyymmdd)형태로 넘어옴
        cls = ((this.date == selectDate.replace(re, "")) &&
            !(d <= 0) &&
            !(d > m2)) ? "" + this.CSS + "PickSel" : cls;
      }

      vaTemplate[p++] = "<td class='" + this.CSS + "PickCell'><div class='" +
        cls +
        "'" +
        "onmouseover='this.className=\"" +
        this.CSS +
        "PickHover\";'" +
        "onmouseout='this.className=\"" +
        cls +
        "\";'" +
        "onclick=\"" +
        this.getEHandler('daySelect', d, ds, this.getPreString(selectDate)) +
        "\">" +
        ds +
        "</div></td>";

      d++;
    }
    vaTemplate[p++] = "<td></td></tr>";
  }

  vaTemplate[p++] = "</tfoot></table>";
};

/**
 * 달력닫기
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.close = function(){
  this.hide();
};

/**
 * 일자선택
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.daySelect = function(postionNum, selectDay, selectDate){
  if (selectDay) {
    if (!!this.target) {  //Calnedar가 다른 컨트롤에서 사용되는 경우
      var voMaxDate = this.target.max;
      var voMinDate = this.target.min;
      var re = /[^0-9]/gi;

      if(!!voMaxDate){
        voMaxDate = voMaxDate.replace(re, "");
        voMinDate = voMinDate.replace(re, "");
      }

      if(!!voMaxDate && voMaxDate.length >= 8){
        voMaxdate = (voMaxDate).substring(0,8);
        selectDate = (selectDate >= voMaxdate) ?
            voMaxdate : selectDate;
      }

      if(!!voMinDate && voMinDate.length >= 8){
        voMindate = (voMinDate).substring(0,8);
        selectDate = (selectDate >= voMindate) ?
            selectDate : voMindate;
      }

      if(this.target.mask.length > 14){
        if(!this._hhmmss){
          var temp = this.target.value;
          var vnHours = temp.substring(8, 10);
          if(vnHours == "") vnHours = "0";
          vnHours = parseInt(vnHours);
          var vnMinutes = temp.substring(10, 12);
          if(vnMinutes == "") vnMinutes = "0";
          vnMinutes = parseInt(vnMinutes);
          var vnSeconds = temp.substring(12, 14);
          if(vnSeconds == "") vnSeconds = "0";
          vnSeconds = parseInt(vnSeconds);

          selectDate = (10 > vnHours) ? selectDate + '0' + vnHours : selectDate + vnHours;
          selectDate = (10 > vnMinutes) ? selectDate + '0' + vnMinutes : selectDate + vnMinutes;
          selectDate = (10 > vnSeconds) ? selectDate + '0' + vnSeconds : selectDate + vnSeconds;
        }else{
          this._hhmmss = this._hhmmss.value.replace(/[^0-9]/gi, "");
          selectDate = selectDate + this._hhmmss;
        }
      }
      this.target.setValueWithNotify(selectDate);
      delete this['_hhmmss'];

      this.close();

    } else {  //Calnedar 가 단독으로 사용되는 경우
      this.setDate(selectDate);
      this.show(this.parent);
    }
    
    if(this.ondateclick) this.ondateclick();
  }
};

/**
 * 월(month 네비게이션) 변경
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.monthChange = function(monthNum){
  this.calType = 'default';
  this.month += monthNum
  if (this.month < 1) {
    this.year--;
    this.month = 12;
  }
  if (this.month > 12) {
    this.year++;
    this.month = 1;
  }
  this.update();

};

/**
 * 변경된 달력 그리기
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.update = function(pbYear){
  this.close();
  this.visible = true;

  //target 과 parent를 구분
  //Calendar 는 target 의 parent에 appendChild 되야 한다.
  var voTarget = this.target; //(!!this.parent)? this.parent : (!!this.target) ?this.target.parent : null;
  var voCanvas = null;
  if (voTarget) voCanvas = voTarget.parent; //(!!voTarget.parent)?voTarget.parent : voTarget;
  if (voCanvas == null) {

    //Tab 컨트롤에 Calendar 가 추가될 경우 parent는 존재하는데 target이 없어서
    //로직상 문제가 있어서 아래 코드를 추가
    if(!!this.parent)
      voCanvas = this.parent;
    else
      voCanvas = this.canvas;

  }
  if (voCanvas) {
    if(!!voTarget && 'EditMask' === voTarget.toString()) voCanvas = this.canvas;
    var voCanvasCtrl = this.getCalenderCtrl();
    voCalendarCtrl = this.create();

    if(!!voTarget && -1 !== 'EditMaskDateInput'.indexOf(voTarget.toString())){

      if(voTarget.parent && voTarget.parent.ctrl){
       voTarget.parent.ctrl.oriZindex = voTarget.parent.ctrl.style.zIndex;
       voTarget.parent.ctrl.style.zIndex = 50000;
      }
    }

    if(this.parent) {
      var vnLeft = voCalendarCtrl.offsetLeft + this.parent.left;
      var vnTop = voCalendarCtrl.offsetTop + this.parent.top;
      this.setAttrCtrl("left", vnLeft);
      this.setAttrCtrl("top", vnTop);
    }
    
    voCanvasCtrl.appendChild(voCalendarCtrl);
    this.load();

    if(!!voTarget && -1 !== 'EditMaskDateInput'.indexOf(voTarget.toString())){
       voTarget.calendarShowed = true;
       voCanvas.collapseControl = voTarget;
       var voCtrl = this.ctrl;
       voTarget.setAttrCtrl("zIndex", 50000, voCtrl);
       voTarget.setAttrCtrl("backgroundColor", "#FFFFFF", voCtrl);
       var voParent = this.parent;
       while(voParent) {
         if(voParent.ctrl) voTarget.setAttrCtrl("zIndex", 50000, voParent.ctrl);
         voParent = voParent.parent;
       }
       voTarget.lifted = true;
     }

  }
};



/**
 * 다중(년도 월 동시)변경 달력 그리기
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.getMultiSelectHTML = function(pbKeepMultiSelect){
  this.template = [];
  var vaTemplate = this.template;
  var p = 0, CNBSP = "&#160;", vsLocale = this.locale;
  var monthYear = eXria.controls.xhtml.Calendar.CGLang[vsLocale]["month"][this.month - 1] + CNBSP + this.year + CNBSP;
  var re = /[^0-9]/gi;

  vaTemplate[p++] = "<table cellspacing='0' cellpadding='0' class='" + this.CSS + "PickBorder'><tfoot>";

  // --- month and year ---
  vaTemplate[p++] = "<tr><td></td><td colspan='7'></td><td></td></tr>";
  vaTemplate[p++] = "<tr class='" + this.CSS + "PickDate'><td></td>";
  //vaTemplate[p++] = "<td colspan='7' >";
  vaTemplate[p++] = "<td colspan='7' class='" + this.CSS + "PickMY'>";

  vaTemplate[p++] = "<div class='" + this.CSS + "PickBL " + this.CSS + "PickBLIE7' onclick=\"" + this.getEHandler('monthChange', -1) + "\"></div>";

  vaTemplate[p++] = "<div class='" + this.CSS + "PickBR " + this.CSS + "PickBRIE7' onclick=\"" + this.getEHandler('monthChange', 1) + "\"></div>";

  if(true === pbKeepMultiSelect){
    vaTemplate[p++] = "<center><table cellspacing='0' cellpadding='0'><tfoot><tr style='cursor:pointer;' onclick=\"" + this.getEHandler('upSel') + "\">" +
      "<td dir='ltr'>" +
      monthYear +
      "</td>" +
      "<td><center>" +
      "</center></td></tr></tfoot></table></center></td>";
  }else{
    vaTemplate[p++] = "<center><table cellspacing='0' cellpadding='0'><tfoot><tr style='cursor:pointer;' onclick=\"" + this.getEHandler('upSel') + "\">" +
      "<td class='" +
      this.CSS +
      "PickMY " +
      this.CSS +
      "PickMYUp' dir='ltr'>" +
      monthYear +
      "</td>" +
      "<td><center>" +
      "</center></td></tr></tfoot></table></center></td>";
  }


  vaTemplate[p++] = "<td></td></tr>";

  // --- month and year select ---
  if (!this.record) this["FY"] = Math.floor(this.year / 5) * 5;
  var fy = this["FY"];

  for (var i = 0; i < 6; i++) {
    vaTemplate[p++] = "<tr class='" + this.CSS + "Pick2Row'><td></td>";
    for (var j = 0; j <= 6; j += 6) {
        vaTemplate[p++] = "<td class='" + this.CSS + "Pick2Cell'>" +
          "<div class='" +
          this.CSS +
          "Pick2M" +
          ((i + j + 1) == this.month ? "Sel" : "") +
          "'" +
          "onmouseover='this.className=\"" +
          this.CSS +
          "Pick2M" +
          ((i + j + 1) == this.month ? "Sel" : "") +
          "Hover\";'" +
          "onmouseout='this.className=\"" +
          this.CSS +
          "Pick2M" +
          ((i + j + 1) == this.month ? "Sel" : "") +
          "\";'" +
          "onclick=\"" +
          this.getEHandler('monthSelect', (i + j + 1)) +
          "\">" +
          eXria.controls.xhtml.Calendar.CGLang[vsLocale]["month"][i + j] +
          "</div></td>";
    }

    vaTemplate[p++] = "<td><div class='" + this.CSS + "Pick2Sep'>" + CNBSP + "</div></td>";

    if (!i) {
      vaTemplate[p++] = "<td class='" + this.CSS + "Pick2BL' onclick=\"" + this.getEHandler('yearChange', -5) + "\">" +
        "</td>" +
        "<td class='" +
        this.CSS +
        "Pick2BR' onclick=\"" +
        this.getEHandler('yearChange', 5) +
        "\">" +
        "</td>";
    } else {
        for (var j = -1; j <= 4; j += 5) {
          vaTemplate[p++] = "<td class='" + this.CSS + "Pick2Cell'>" +
            "<div class='" +
            this.CSS +
            "Pick2Y" +
            ((fy + i + j) == this.year ? "Sel" : "") +
            "'" +
            "onmouseover='this.className=\"" +
            this.CSS +
            "Pick2Y" +
            ((fy + i + j) == this.year ? "Sel" : "") +
            "Hover\";'" +
            "onmouseout='this.className=\"" +
            this.CSS +
            "Pick2Y" +
            ((fy + i + j) == this.year ? "Sel" : "") +
            "\";'" +
            "onclick=\"" +
            this.getEHandler('yearSelect', (fy + i + j)) +
            "\">" +
            (fy + i + j) +
            "</div></td>";
        }
    }

    vaTemplate[p++] = "<td></td></tr>";
  };

  vaTemplate[p++] = "<tr class='" + this.CSS + "PickFooter'><td></td>";
  vaTemplate[p++] = "<td class='" + this.CSS + "PickFootText' colspan='5' align='right'>";
  vaTemplate[p++] = "<button class='" + this.CSS + "PickButton' ";


  if(true === pbKeepMultiSelect){
    var vsTempDate = this.year + '' + ((this.month <10)? '0'+this.month : this.month) + '01'
    vaTemplate[p++] = "onclick=\"" + this.getEHandler('daySelect', true, true, this.getPreString(vsTempDate))  + "\">";
  }else{
    vaTemplate[p++] = "onclick=\"" + this.getEHandler('calSelect') + "\">";
  }

  vaTemplate[p++] = "OK</button>"
  vaTemplate[p++] = "</td><td></td></tr>"
  vaTemplate[p++] = "</tfoot></table>";
};

/**
 * 년도(년도네비게이션) 변경
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.yearChange = function(yer){
  if (!!yer) {
    this.calType = 'multi';
    this.record = 1;
    this.FY = this.FY + yer;
    this.update(true);
  }

}

/**
 * 년도(Year) 선택
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.yearSelect = function(yer){
  if (!!yer) {
    this.record = 1;
    this.year = yer;
    this.update(true);
  }
};

/**
 * 월(Month) 선택
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.monthSelect = function(mon){
  if (!!mon) {
    this.record = 1;
    this.month = mon;
    this.update();
  }
};

/**
 * ok 버튼 클릭
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.calSelect = function(){
  this.calType = 'default';
  this.update();
  var voTarget = this.target;
  if(voTarget == null) return;
  if(voTarget.mask.length > 14 && !voTarget.noUseHMS) {
    var vnTmp = voTarget.getDate(voTarget.value).getTime();
    eXria.controls.xhtml.Calendar.prototype._showTimesInfo.call(this, TGP.GetString(vnTmp, voTarget.formatType, 'HH:mm:ss'));
  }
};

/**
 * ▼ 버튼 클릭
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.downSel = function(){
  this.calType = 'multi';
  this.record = 0;
  this.update(true);
};

/**
 * ▲ 버튼 클릭
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.upSel = function(){
  this.calType = 'default';
  this.update(true);
};

/**
 * 이벤트 전파 방지
 * @ignore
 */
eXria.controls.xhtml.Calendar.prototype.eventStopPropagation = function(e){
  if (!!this.target) {
    var voEvent = new eXria.event.Event(e, this.window);
    voEvent.stopPropagation();
  }
}

// 달력처리 내부 메소드 리스트 END
////////////////////////////////////////////

/**
 * @fileoverview
 * Concreate xhtml ComboBox(XHTML 콤보박스 컨트롤)
 * @author 조영진
 */

/**
 * 콤보 컨트롤 드롭다운 리스트의 아이템 요소를 구성하는 클래스.
 * @version 2.0
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {eXria.controls.xhtml.ComboBox} poControl
 * @constructor
 */
eXria.controls.xhtml.ComboItem = function(psName, poValue, poControl) {
  /**
   * 아이템 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 아이템 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = "3px";
  /**
   * 아이템 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 아이템 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 아이템 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 아이템 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * * 아이템 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * @type Number
   * @private
   */
  this.cellSpacing = 0;
  /**
   * @type Number
   * @private
   */
  this.cellPadding = 0;
  /**
   * 아이템 배경 색상.
   * @type String
   */
  this.backgroundColor = poControl.listarea.backgroundColor;
  /**
   * 아이템 텍스트 색상.
   * @type String
   */
  this.color = poControl.listarea.color;
  /**
   * 아이템 폰트 패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 아이템 폰트 사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 아이템 폰트 스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 아이템 폰트 두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 아이템 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 아이템 라벨 명.
   * @type String
   */
  this.name = psName;
  /**
   * 아이템 설정 값.
   * @type String
   */
  this.value = poValue;
  /**
   * ComboBox Control 참조 변수.
   * @type eXria.controls.xhtml.ComboBox
   */
  this.parent = poControl;
  /**
   * 아이템 선택 여부.
   * @type Boolean
   */
  this.selected = false;
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   * @private
   */
  this.data = new eXria.controls.DataRefNode(this.parent);
};
/**
 * 실체화 컨트롤 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.ComboItem.prototype.create = function(poDocument) {
  if (poDocument == null) poDocument = this.document;
  var voCtrl = this.parent.getCtrl(poDocument);
  var voList = this.parent.subElement.list;
  var voTable = this.parent.subElement.table;
  var voTbody = voTable.childNodes[0];
  var voTr = null;
  var voTd = null;
  var voDiv = null;
  var voInput = null;
  var vsType = null;
  var vsInputId = null;
  var voText = null;
  var vsKey = null;
  var voParent = this.parent;
  var voParentItemgroupDf = voParent.itemgroup;
  var voParentListareaDf = voParent.listarea;

  if (voParentListareaDf.appearance == "radio") {
    vsType = "radio";
    vsInputId = voParent.id + "_radio_";

  } else if (voParentListareaDf.appearance == "checkbox") {
    vsType = "checkbox";
    vsInputId = voParent.id + "_checkbox_";
  }

  voTr = poDocument.createElement("tr");
  var voStyle = voTr.style;
  voStyle.backgroundColor = this.backgroundColor;
  voStyle.color = this.color;

  voTd = poDocument.createElement("td");
  voDiv = poDocument.createElement("div");
  voDiv.name = voParent.id + "_option";
  this.id = voParent.id + "_option_" + voParent.seqNum++;
  voDiv.setAttribute("id", this.id);
  this.ctrl = voDiv;

  this.setDefault(voDiv, poDocument);

  var voInnerTable = poDocument.createElement("table");
  voParent.setAttrCtrl("cellSpacing", "0", voInnerTable);
  voParent.setAttrCtrl("cellPadding", "0", voInnerTable);
  voParent.setAttrCtrl("backgroundColor", this.backgroundColor, voDiv);
  voParent.setAttrCtrl("color", this.color, voInnerTable);
  var voInnerTbody = poDocument.createElement("tbody");
  var voInnerTr = poDocument.createElement("tr");
  var voInnerTd = poDocument.createElement("td");
  var vnWidth = voParent.innerWidth - parseInt(this.borderLeftWidth)
      - parseInt(this.borderRightWidth) - 2 * voParentListareaDf.cellSpacing;
  var vnHeight = voParentItemgroupDf.height - parseInt(this.borderTopWidth)
      - parseInt(this.borderBottomWidth);
  var voOption = null;
  if (voParent.isScrolled()) {
    vnWidth -= voParent.listarea.scrollbarWidth;
    if (voParent.listarea.bScrolled == false) {
      for ( var i = 0; i < voTable.rows.length; i++) {
        voOption = voTable.rows[i].cells[0].childNodes[0];
        voParent.setAttrCtrl("width", vnWidth, voOption);
      }
      voParent.setAttrCtrl("width", voParent.innerWidth, voTable);
      voParent.listarea.bScrolled = true;
    }
  }
  
  voParent.setAttrCtrl("width", vnWidth, voDiv);
  voParent.setAttrCtrl("height", vnHeight, voInnerTd);
  voParent.setAttrCtrl("height", vnHeight, voDiv);
  voParent.setAttrCtrl("width", voParent.innerWidth, voTd);
  voParent.setAttrCtrl("height", voParentItemgroupDf.height, voTd);
  if (voParentListareaDf.appearance != "normal") {
    voInput = poDocument.createElement("input");
    voInput.setAttribute("type", vsType);
    if (voParentListareaDf.appearance == "radio")
      voInput.setAttribute("name", vsInputId);
    var vnIndex = voTable.rows.length;
    voInput.setAttribute("id", vsInputId + vnIndex);
    voParent.setAttrCtrl("width", voParentItemgroupDf.selectorWidth + "px", voInput);
    voInnerTd.appendChild(voInput);
  }
  voText = poDocument.createTextNode(this.name);
  voInnerTd.appendChild(voText);
  voInnerTr.appendChild(voInnerTd);
  voInnerTbody.appendChild(voInnerTr);
  voInnerTable.appendChild(voInnerTbody);
  voDiv.appendChild(voInnerTable);
  if (this.disabled) voDiv.disabled = true;
  voTd.appendChild(voDiv);

  // [Set page context unselective]
  if (typeof voTd.onselectstart != "undefined") {
    voTr.onselectstart = function(e) {
      return false;
    };
  } else {
    voTr.onmousedown = function(e) {
      return false;
    };
  }
  // end of [Set page context unselectable]
  if (this.disabled != true) {
    voTr.onclick = function(e) {
      this.control.listarea.selectList(e);
    };
    voTr.control = voParent;
  }
  voTr.appendChild(voTd);
  voTbody.appendChild(voTr);

  // if(voParent.listarea.heightBySize) {
  vnHeight = parseInt(voParentItemgroupDf.height);
  var vnSize = voParent.getVisibleItemCount();
  if (voParentListareaDf.size != null && voParentListareaDf.size < vnSize) {
    vnHeight = voParentListareaDf.size
        * (vnHeight + voParentListareaDf.cellSpacing)
        + voParentListareaDf.cellSpacing;
    voParent.setAttrCtrl("height", vnHeight, voList);
  } else {
    vnHeight = vnSize * (vnHeight + voParentListareaDf.cellSpacing)
        + voParentListareaDf.cellSpacing;
    voParent.setAttrCtrl("height", vnHeight, voList);
  }
  // }

  if (voParent.isScrolled())
    voParent.setAttrCtrl("overflowY", "scroll", voList);
  else
    voParent.setAttrCtrl("overflowY", "hidden", voList);

  this.setAttrs(voDiv, poDocument);
};

/**
 * 실체화 컨트롤 생성 innerHTML 반환.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 실체화 컨트롤 생성 innerHTML
 * @type String
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.getInnerHTML = function(poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var voParent = this.parent;
  var voParentDf = voParent;
  var voParentListareaDf = voParent.listarea;
  var vaStrBuf = null;
  var vsType = null;
  var vsInputId = null;
  var voPage = null;

  if (voParentListareaDf.appearance == "radio") {
    vsType = "radio";
    vsInputId = voParent.id + "_radio_";

  } else if (voParentListareaDf.appearance == "checkbox") {
    vsType = "checkbox";
    vsInputId = voParent.id + "_checkbox_";
  }
  if(this["id"] == null) {
    var vsName = voParent.id + "_option";
    this["id"] = vsName + "_" + voParent.seqNum++;
  }

  var vsItemGroupClass = "";
  if (voParent.itemgroup.className) {
    vsItemGroupClass = " class='" + voParent.itemgroup.className + "'";
  }

  vaTemplate.push("<tr onselectstart=\"return false;\"><td><div id=");
  vaTemplate.push(this["id"]);
  vaTemplate.push(" name=");
  vaTemplate.push(vsName);
  vaTemplate.push(" style='");
  vaTemplate.push("@cssStrBuf"); // 5
  vaTemplate.push("'");

  vaStrBuf = [];
  
  var vaStrBuffer = function(){
    vaStrBuf.push(" onmousedown=\"");
    vaStrBuf.push(voParent.getEHandler(voParent.id, "atmousedown"));
    vaStrBuf.push("\"");
    vaStrBuf.push(" onclick=\"");
    vaStrBuf.push(voParent.getEHandler(voParent.id, "listarea.selectEventList"));
    vaStrBuf.push("\"");
    vaStrBuf.push(" onmouseover=\"");
    vaStrBuf.push(voParent.getEItemHandler(voParent.id, this.id, "listarea.atmouseover"));
    vaStrBuf.push("\"");
  }
  var vaGetEHandler = function(psId, psFuncName){
    var vaStrBuff = [];
    vaStrBuff.push("getControl('");
    vaStrBuff.push(psId);
    vaStrBuff.push("').");
    vaStrBuff.push(psFuncName);
    vaStrBuff.push("(event);");
  
    var vsRet = vaStrBuff.join("");
    vaStrBuff = null;
    return vsRet;
  };
  var vaGetEventHandler = function(psId, psItemId, psFuncName) {
    var vaStrBuff = [];
    vaStrBuff.push("getControl('");
    vaStrBuff.push(psId);
    vaStrBuff.push("').");
    vaStrBuff.push(psFuncName);
    vaStrBuff.push("(event,'");
    vaStrBuff.push(psItemId);
    vaStrBuff.push("');");
  
    var vsRet = vaStrBuff.join("");
    vaStrBuff = null;
    return vsRet;
  };
  
  if(this.disabled != true) {
    if(!!page.parent){
      voPage = page.parent;
    }else{
      voPage = page;
    }
    if(!voParent.window.frameElement){
      vaStrBuffer.apply(this);  
    }else{
      if(!voPage.getPage(voParent.window.frameElement.id)){
        vaStrBuffer.apply(this);
      }else if(!!voPage.getPage(voParent.window.frameElement.id).getControl(this.parent.id)){
        vaStrBuf.push(" onmousedown=\"");     
        vaStrBuf.push("page.getPage('");
        vaStrBuf.push(voParent.window.frameElement.id);
        vaStrBuf.push("')."); 
        vaStrBuf.push(vaGetEHandler(voParent.id, "atmousedown"));
        vaStrBuf.push("\"");
        vaStrBuf.push(" onclick=\"");
        vaStrBuf.push("page.getPage('");
        vaStrBuf.push(voParent.window.frameElement.id);
        vaStrBuf.push("').");
        vaStrBuf.push(vaGetEHandler(voParent.id, "listarea.selectEventList"));
        vaStrBuf.push("\"");
        vaStrBuf.push(" onmouseover=\"");
        vaStrBuf.push("page.getPage('");
        vaStrBuf.push(voParent.window.frameElement.id);
        vaStrBuf.push("').");
        vaStrBuf.push(vaGetEventHandler(voParent.id, this.id, "listarea.atmouseover"));
        vaStrBuf.push("\"");
      }else{
        vaStrBuffer.apply(this);
      }       
    }
  }
  
  vaTemplate.push(vaStrBuf.join(""));
  vaTemplate.push("/><table " + vsItemGroupClass + "cellSpacing=0 width=100% cellPadding=0 style='");
  vaTemplate.push("@cssStrBuf"); // 9
  vaTemplate.push("'><tbody><tr><td style='");
  vaTemplate.push("@cssStrBuf"); // 11
  vaTemplate.push("'>");

  vaStrBuf = [];
  if(voParentListareaDf.appearance != "normal") {
    vaStrBuf.push("<input ");
    vaStrBuf.push("type=");
    vaStrBuf.push(vsType);

    if(voParentListareaDf.appearance == "radio") {  //2009-03-23 ehj
      vaStrBuf.push(" name=");
      vaStrBuf.push(vsInputId);
    }
    vaStrBuf.push(" style='");
    voParent.setCssStrBuf(vaStrBuf, "width", voParent.itemgroup.selectorWidth, "px");
    vaStrBuf.push("'>");  //2009-03-23 ehj
  }

  vaTemplate.push(vaStrBuf.join(""));
  vaTemplate.push("@innStrBuf"); // 14
  vaTemplate.push("</td></tr></tbody></table></div></td></tr>");

  this.setDefault(null, voParent.document);
  this.setAttrsInn(null, null);

  var vsRet = vaTemplate.join("");
  vaStrBuf = null;
  vaTemplate = null;
  this.template = null;
  return vsRet;
};
/**
 * setDefault
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.setDefault = function(poCtrl, poDocument) {
  this.verticalAlign = this.parent.getAttrValue("verticalAlign", this.verticalAlign);
  var voData = this.data;
  if(voData.instanceId && voData.instancePath) {
    this.name = voData.getData();
  }
};
/**
 * setAttrs
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.setAttrs = function(poCtrl, poDocument) {
  var voDiv = poCtrl;
  var voParent = this.parent;
  if (voDiv == null)
    voDiv = this.getCtrl(poDocument);
  voParent.setAttrCtrl("color", this.color, voDiv);
  voParent.setAttrCtrl("borderStyle", this.borderStyle, voDiv);
  voParent.setAttrCtrl("borderColor", this.borderColor, voDiv);
  voParent.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voDiv);
  voParent.setAttrCtrl("borderRightWidth", this.borderRightWidth, voDiv);
  voParent.setAttrCtrl("borderTopWidth", this.borderTopWidth, voDiv);
  voParent.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voDiv);
  var voInnerTable = voDiv.childNodes[0];
  voParent.setAttrCtrl("fontFamily", this.fontFamily, voInnerTable);
  voParent.setAttrCtrl("fontSize", this.fontSize, voInnerTable);
  voParent.setAttrCtrl("fontStyle", this.fontStyle, voInnerTable);
  voParent.setAttrCtrl("fontWeight", this.fontWeight, voInnerTable);
  var voInnerTd = voInnerTable.rows[0].cells[0];
  //voParent.setAttrCtrl("textAlign", this.textAlign, voInnerTd);
  voParent.setAttrCtrl("verticalAlign", this.verticalAlign, voInnerTd);
  voParent.setAttrCtrl("paddingLeft", this.paddingLeft, voInnerTd);
  voParent.setAttrCtrl("paddingRight", this.paddingRight, voInnerTd);
  voParent.setAttrCtrl("paddingTop", this.paddingTop, voInnerTd);
  voParent.setAttrCtrl("paddingBottom", this.paddingBottom, voInnerTd);
};
/**
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.setAttrsInn = function(poCtrl, poDocument) {
  var voParent = this.parent;
  var vaTemplate = this.template;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vaInnStrBuf = null;
  var vfcSetAttStrBuf = voParent.setAttStrBuf;
  var vfcSetCssStrBuf = voParent.setCssStrBuf;
  var vnWidth = voParent.innerWidth - this.borderLeftWidth - this.borderRightWidth - 2 * voParent.listarea.cellSpacing;
  if (vnWidth < 0) vnWidth = 0;
  var vnHeight = voParent.itemgroup.height - this.borderTopWidth - this.borderBottomWidth;
  var vnHeight = voParent.itemgroup.height;
  if(vnHeight !== null){
    if(this.borderTopWidth !== null) vnHeight = vnHeight - this.borderTopWidth;
    if(this.borderBottomWidth !== null) vnHeight = vnHeight - this.borderBottomWidth;
    if (vnHeight < 0)  vnHeight = 0;
  }
  if (voParent.scrolled) {
    vnWidth -= voParent.listarea.scrollbarWidth;
  }
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", "100%");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth,  "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth,  "px");
  vaTemplate[5] = vaCssStrBuf.join("");

  // table 영역
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  if(this.disabled) vfcSetCssStrBuf(vaCssStrBuf, "color", this.disabledColor);
  // 2009.10.30 yhkim itemgroup설정을 개개별 아이템에 설정
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", voParent.itemgroup.cursor);
  //var vsClass = this.parent.getCSSClass(this.parent, 1, "itemgroup" );
  //alert(vsClass);

  vaTemplate[9] = vaCssStrBuf.join("");

  // td 영역
  vaCssStrBuf = [];
  // vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", this.verticalAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  //yhkim test (for wordwrap)
  vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  vaTemplate[11] = vaCssStrBuf.join("");

  vaInnStrBuf = [];
  vaInnStrBuf.push(this.name);

  vaTemplate[14] = vaInnStrBuf.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaInnStrBuf = null;
  vaTemplate = null;
};
/**
 * 아이템 새로고침 수행.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboItem.prototype.refresh = function(poDocument) {
  var voCtrl = this.parent.getCtrl(poDocument);
  if (voCtrl == null)
    return;
  this.removeAttrDefault(voCtrl, poDocument);
  this.setAttrs(voCtrl, poDocument);
};
/**
 * removeAttrDefault
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.removeAttrDefault = function(poCtrl,
    poDocument) {
  var voDiv = this.getCtrl(poDocument);
  var voParent = this.parent;
  voParent.setAttrCtrl("borderWidth", "", voDiv);
  voParent.setAttrCtrl("borderStyle", "", voDiv);
  voParent.setAttrCtrl("borderColor", "", voDiv);
  var voInnerTable = voDiv.childNodes[0];
  voParent.setAttrCtrl("fontFamily", "", voInnerTable);
  voParent.setAttrCtrl("fontSize", "", voInnerTable);
  voParent.setAttrCtrl("fontStyle", "", voInnerTable);
  voParent.setAttrCtrl("fontWeight", "", voInnerTable);
  var voInnerTd = voInnerTable.rows[0].cells[0];
  this.setAttrCtrl("verticalAlign", this.verticalAlign, voInnerTd);
};
/**
 * 아이템의 실체화 객체 반환.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 실체화 객체
 * @type HTMLDiv
 */
eXria.controls.xhtml.ComboItem.prototype.getCtrl = function(poDocument) {
  // if(poDocument == null) poDocument = document;
  // var voCtrl = poDocument.getElementById(this.id);
//  var voParent = this.parant;
  var voParent = this.parent;
  var voCtrl = voParent.lookup(this.id);
  return voCtrl;
};
/**
 * 아이템 실체화 컨트롤에 적용될 세부 속성 값을 반환하는 메소드.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboItem.prototype.makeSpecificAttrValue = function(poCtrl, poCssStyle, psAttrName, psCtrlAttrName) {
  var vaAttrName = psAttrName.split(".");
  var voAttr = null;

  if (voAttr != null) { // 사용자 지정 속성값이 있을 경우
    return voAttr;
  } else { // 사용자 지정 속성값이 없을 경우
    if (poCssStyle != null) { // 지정된 CSS가 있을 경우
      if (psCtrlAttrName == null)
        psCtrlAttrName = vaAttrName[vaAttrName.length - 1];
      if (poCssStyle[psCtrlAttrName] != null
          && poCssStyle[psCtrlAttrName] != "") {
        return poCssStyle[psCtrlAttrName];
      } else { // CSS에 해당 속성 값이 없을 경우
        return this.getSpecificDefaultValue(psAttrName);
      }
    } else { // 지정된 CSS가 없을 경우
      return this.getSpecificDefaultValue(psAttrName);
    }
  }
};
/**
 * 상위 컨트롤의 itemgroup에 할당된 속성 값을 얻어오기 위한 메소드.
 * @param {String} psAttrName 상위 컨트롤의 itemgroup에서 값을 가져올 속성명
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ComboItem.prototype.getSpecificDefaultValue = function(
    psAttrName) {
  var voRet = null;
  var voParent = this.parent;
  if (voParent.itemgroup[psAttrName] != null) {
    voRet = voParent.itemgroup[psAttrName];
  }
  return voRet;
};
/**
 * 아이템의 스타일 속성값을 일괄적으로 변경하기 위한 메소드.
 * @param {Object} poStyleObject 변경될 속성값을 담은 오브젝트
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboItem.prototype.setItemStyle = function(poStyleObject) {
  var vsAttr = null;
  for (vsAttr in poStyleObject) {
    this[vsAttr] = poStyleObject[vsAttr];
  }
};

/**
 * ComboBox 컨트롤 드롭다운 리스트 박스의 속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.ComboBox_listarea = function(poParent) {
  /**
   * ComboBox 인스턴스.
   * @type eXria.controls.xhtml.ComboBox
   */
  this.parent = poParent;
  /**
   * 다중선택 여부.
   * @type Boolean
   */
  this.multiSelect = null;
  /**
   * normal, radio, checkbox (보여지는 option의 형태 : 라디오, 리스트, 콤보).
   * @type String
   */
  this.appearance = null;
  /**
   * 이전까지 컨트롤의 다중선택 여부.
   * @private
   * @type Boolean
   */
  this.oldMultiSelect = null;
  /**
   * 이전까지 컨트롤의 선택 버튼 형태.
   * @private
   * @type String
   */
  this.oldAppearance = null;
  /**
   * 아이템 리스트에 보여지는 아이템 개수.
   * @type Number
   */
  this.size = null;
  /**
   * 리스트 영역의 세로길이.
   * @type Number
   */
  this.height = null;
  /**
   * 리스트 영역의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 리스트 영역의 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * 아이템에 포커스 위치시에 아이템 배경 색상.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * 아이템에 마우스오버 위치시에 아이템 배경색상.
   * @type String
   */
  this.hoverBackgroundColor = null;
  /**
   * 아이템에 포커스 위치시에 아이템 텍스트 색상.
   * @type String
   */
  this.focusColor = null;
  /**
   * 아이템 사이의 간격.
   * @type Number
   */
  this.cellSpacing = null;
  /**
   * 리스트 영역의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 리스트 영역의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 현재 리스트의 스크롤바가 표시되어 있는지 여부 체크.
   * @private
   * @type Boolean
   */
  this.bScrolled = false;
  /**
   * 리스트 영역의 오버플로우 타입.<br>
   * 'scroll' | 'hidden' | 'auto'
   * @type String
   */
  this.overflow = null;
  /**
   * 리스트 영역의 세로 오버플로우 타입.
   * @type String
   */
  this.overflowY = null;
  /**
   * 리스트 영역의 가로 오버플로우 타입.
   * @type String
   */
  this.overflowX = "hidden";//null
  /**
   * 리스트 영역 계산 시 사용될 스크롤 버튼의 가로 길이.
   * @type Number
   * @private
   */
  this.scrollbarWidth = 19;
  /**
   * 리스트 영역에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 리스트 영역의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 리스트 영역의 크기를 아이템 개수를 기준으로 할지 여부.
   * @type Boolean
   */
  this.heightBySize = true;
  /**
   * 리스트 영역의 크기를 아이템 최대 길이를 기준으로 할지 여부.
   * @type Boolean
   */
  this.widthByMaxLength = true;
  /**
   * listarea의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};

/**
 * @private
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.selectEventList = function(event) {
  var voEvent = null;
  if (event.type == "click") {
    voEvent = new eXria.event.Event(event, this.parent.window);
    this.selectList(voEvent);
  } else {
    voEvent = event;
    this.selectListKeyDown(voEvent);
  }
};

/**
 * 리스트 아이템 선택 시 호출된는 메소드
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.selectList = function(poEvent) {
  var voParent = this.parent;
  //var voEvent = new eXria.event.Event(e, voParent.window);
  voParent.isCallByKeyIn = false;
  voParent.isComboMousedown = false;
  poEvent.object = voParent;
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  voParent.unselectListItem(poEvent, poEvent.ctrlKey || poEvent.shiftKey);

  voDiv = poEvent.target;
  while (voDiv.nodeName.toLowerCase() != "div") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null || voDiv.id.indexOf(voParent.id + "_option") == -1)
    return;
  voTr = voDiv.parentNode.parentNode;

  var vnCurrentIdx = voTr.rowIndex;
  var vnLastIdx = voParent.selectedIndex;
  var vnFirstIdx = voParent.getFirstItemIndex();

  if (voParent.selectedIndex != vnCurrentIdx
      || voParent.listarea.appearance == "checkbox"){
      voParent.bRowChanged = true;
//      voParent.doitemchange(poEvent, voParent);
  }
  else
    voParent.bRowChanged = false;

  var voItem = voParent.getItem(vnCurrentIdx);
  voParent.itemChanged = voItem;
  if (voParent.listarea.appearance != "normal")
    voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;

  if(poEvent.shiftKey && voParent.selectedItems.size() != 0){
    if(!voParent.bRowChanged)return;  //마지막에 선택한 아이템과 동일한 아이템을 선택했을 때 리턴

      voParent.clearSelected();
      var vnTemp = vnFirstIdx;
      var vbChk = false;

      while(vnCurrentIdx != vnTemp){
        if(vbChk){
          if(vnCurrentIdx > vnTemp)++vnTemp;
          else --vnTemp;
        }

        if (voInput != null)
          voInput.checked = true;
        if(voParent.selectedItems.get(vnTemp) == undefined){
          voParent.selectedItems.put(vnTemp, "");
        }

        voParent.getItem(vnTemp).selected = true;

        voParent.selectedIndex = vnTemp;

        voParent.changeRowColorByIndex(vnTemp);
        vbChk = true;
      }

      if(vnFirstIdx == vnCurrentIdx){
        if (voInput != null)
          voInput.checked = true;

        voParent.getItem(vnFirstIdx).selected = true;

        voParent.selectedIndex = vnFirstIdx;
      }
  }else{
    if (voParent.selectedItems.get(vnCurrentIdx) == undefined) {//이전에 선택이 안되어 있는 아이템일 경우
      if (voInput != null)
        voInput.checked = true;
      voParent.selectedItems.put(voTr.rowIndex, "");
      voItem.selected = true;
      voParent.selectedIndex = vnCurrentIdx;
      voParent.changeRowColor(voDiv);

    } else {//이전에 선택이 되어 있는 아이템 선택 해제
      if (voInput != null)
        voInput.checked = false;
      voParent.selectedItems.remove(vnCurrentIdx);
      voItem.selected = false;
      voParent.restoreRowColor(voDiv);
    }
  }

  voParent.checkSelected();
  if (voParent.listarea.multiSelect == false
      || ((voParent.listarea.appearance == "normal" && poEvent.ctrlKey == false)
      && (voParent.listarea.appearance == "normal" && poEvent.shiftKey == false)))
    voParent.showList(false);

  if (voParent.bRowChanged)
  {
    voParent.focusedItemCtrl = voDiv;
    voParent.doitemchange(poEvent, voParent);
    voParent.dochange(poEvent, voParent);
  }
};

/**
 * 리스트 아이템 선택 시 호출된는 메소드(키보드로 선택)
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.selectListKeyDown = function(poEvent) {
  var voParent = this.parent;
  //var voEvent = new eXria.event.Event(e, voParent.window);
  poEvent.object = voParent;
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  voParent.unselectListItem(poEvent, poEvent.shiftKey);

  voDiv = poEvent.target;
  while (voDiv.nodeName.toLowerCase() != "div") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null || voDiv.id.indexOf(voParent.id + "_option") == -1)
    return;
  voTr = voDiv.parentNode.parentNode;
  if (voParent.selectedIndex != voTr.rowIndex
      || voParent.listarea.appearance == "checkbox"){
      voParent.bRowChanged = true;
      voParent.doitemchange(poEvent, voParent);
  }
  else
    voParent.bRowChanged = false;

  var voItem = voParent.getItem(voTr.rowIndex);

  if (voParent.listarea.appearance != "normal")
    voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;

  if (voParent.selectedItems.get(voTr.rowIndex) == undefined ) {
    if (voInput != null)
      voInput.checked = true;
    voParent.selectedItems.put(voTr.rowIndex, "");
    voParent.changeRowColor(voDiv);
    voItem.selected = true;
    voParent.selectedIndex = voTr.rowIndex;
  } else {
    if (voInput != null)
      voInput.checked = false;

    if(poEvent.shiftKey == true ){
      voParent.getItem(voParent.selectedIndex).selected = false;
      voParent.selectedItems.remove(voParent.selectedIndex);
      voParent.restoreRowColorByIndex(voParent.selectedIndex);
    }else{
      voParent.selectedItems.remove(voTr.rowIndex);
      //this.restoreRowColor(voDiv);
      voItem.selected = false;
    }

    if(poEvent.shiftKey == true){
      voParent.selectedIndex = voTr.rowIndex;//2009-03-30 hajubal ctrl 오류때문에 수정
    }
  }



  voParent.checkSelected();
  if (voParent.listarea.multiSelect == false
      || (voParent.listarea.appearance == "normal" && poEvent.shiftKey == false))
    voParent.showList(false);

  if (voParent.bRowChanged)
    voParent.dochange(poEvent, voParent);
};

/**
 * 리스트 아이템 마우스 오버시 호출된는 메소드
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.atmouseover = function(e, psItemId) {
  var voParent = this.parent;
  
  voParent.eventType = "item";
  voParent.eventObject = voParent.getItemById(psItemId);
  if (voParent.eventType == "item" && voParent.eventObject != null) {
    var voDocument = voParent.getComboboxCtrl("document");
    var voItem = voParent.eventObject;
    var voItemCtrl = voDocument.getElementById(voItem.id);
    var voStyle = voItemCtrl.style;
    var vbSelected = false;
    var voTable = voParent.subElement.table

    var vnIdx = voItem.id;
    vnIdx = vnIdx.substring((voParent.id + "_option_").length);
    vnIdx = parseInt(vnIdx);
    if(voParent.selectedItems.get(vnIdx) != null) {
      vbSelected = true;
    }
    if (!vbSelected) {
      this.mouseOver(e, psItemId);
      voStyle.backgroundColor = voParent.listarea.hoverBackgroundColor;// eXria.controls.xhtml.Default.ListBox.focusBackgroundColor;//"#F1F1EB";//voParent.focusBackgroundColor;
      voStyle.color = voParent.listarea.focusColor;
    }
    voParent.focusedItemCtrl = voItemCtrl;
  }
};

/**
 * 리스트 아이템 마우스 오버시 호출된는 메소드
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.mouseOver = function(e, psItemId) {
  var voParent = this.parent;

  voParent.eventType = "item";
  voParent.eventObject = voParent.getItemById(psItemId);

  if(voParent.arrowKeyMode == "select") {
    var voDiv = null;
    var voData = null;
    var voTable = voParent.subElement.table;

    voParent.nonSelectedRestoreColor(voTable);
  } else if(voParent.arrowKeyMode == "focus") {
    if(voParent.focusedItemCtrl) {
      var vnIdx = voParent.focusedItemCtrl.id;
      vnIdx = vnIdx.substring((voParent.id + "_option_").length);
      vnIdx = parseInt(vnIdx);
      if(voParent.selectedItems.get(vnIdx) == null) voParent.restoreRowColor(voParent.focusedItemCtrl);
      voParent.focusedItemCtrl = null;
    }
  }
};

/**
 * 지정된 라벨과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스 반환.
 * @param {String} psName 아이템 라벨 명
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.getIndex = function(psName) {
  var voControl = this.parent;
  var voIterator = voControl.frontItems.getKeyCollection().iterator();
  var vsKey = null;
  var i = -1;
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  voIterator = voControl.itemset.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  voIterator = voControl.backItems.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  return -1;
};
/**
 * 지정된 라벨과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스 반환.
 * @param {String} psValue 아이템 value
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.getIndexByVal = function(psValue) {
  var voParent = this.parent;
  var voIterator = voParent.frontItems.getValueCollection().iterator();
  var voItem = null;
  var i = 0;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  voIterator = voParent.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  voIterator = voParent.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  return -1;
};
/**
 * 지정된 index를 통해 리스트 아이템을 선택하기 위한 메소드.
 * @param {Array(Number)} paIndex 선택될 아이템들의 인덱스를 저장하는 배열
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox_listarea.prototype.select = function(paIndex,
    poCtrl, poDocument) {
  var voParent = this.parent;
  voParent.isChanged = false;
  if (poCtrl == null)
    poCtrl = voParent.getCtrl(poDocument);
  var voList = voParent.subElement.list;
  var voTable = voParent.subElement.table;
  var voDiv = null;
  var voInput = null;

  if(voTable.rows.length == 0) return;

  // TODO : voParent.showList(true);
//  for ( var i = 0; i < voTable.rows.length; i++) {
//    voDiv = voTable.rows[i].cells[0].childNodes[0];
//    if (voParent.listarea.appearance != "normal") {
//      voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
//      voInput.checked = false;
//    } else {
//      voParent.restoreRowColor(voDiv);
//    }
//  }
  var voCollection = voParent.selectedItems.getKeyCollection();
  var vnLoop = voCollection.size();
  var vnRowIdx = null;
  for(var i = 0; i < vnLoop; i++) {
    vnRowIdx = voCollection.get(i);
    vnRowIdx = parseInt(vnRowIdx);
    voDiv = voTable.rows[vnRowIdx].cells[0].childNodes[0];
    if (voParent.listarea.appearance != "normal") {
      voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
      voInput.checked = false;
    } else {
      voParent.restoreRowColor(voDiv);
    }
  }
  voParent.selectedItems.clear();
  if (paIndex == null || paIndex.length == 0) {

    voParent.selectedIndex = -1;
    if(voParent.value == null) voParent.value = [];
    voParent.subElement.input.value = (voParent.value[0] == null ? "" : voParent.value[0]);
    return;
  }


  var voItem = null;
  // 마우스 이벤트에 의해 voParent.selectedIndex가 지정되었는지 여부를 체크
  // multiSelect에 경우 마지막으로 선택된 아이템을 selectedIndex로 지정하나
  // 메소드 콜에 의해 아이템 선택시 이 순서를 자체적으로 체크할 수 없기 때문에 사용됨
  var vbSelected = false;
  for ( var i = 0; i < paIndex.length; i++) {
    if (paIndex[i] == voParent.selectedIndex)
      vbSelected = true;
    voDiv = voTable.rows[paIndex[i]].cells[0].childNodes[0];
    voItem = voParent.getItem(paIndex[i]);
    if (voItem)
      voItem.selected = true;
    voParent.selectedItems.put(paIndex[i], "");
    if (voParent.listarea.appearance == "normal") {
      voParent.changeRowColor(voDiv);
    } else {
      voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
      voInput.checked = true;
    }
    if (voParent.listarea.multiSelect == false)
      break;
  }

  if (vbSelected == false && voParent.bMultiSelectKeyDown == false) {
    voParent.selectedIndex = paIndex[paIndex.length - 1];
  }

  var vsOldVal = voParent.value;
  if(vsOldVal instanceof Array) vsOldVal = vsOldVal.join();
  var vsNewVal = voParent.getSelectedValue(true, poCtrl);
  if(vsNewVal instanceof Array) vsNewVal = vsNewVal.join();
  voParent.value = voParent.getSelectedValue(true, poCtrl);
  var voText = voParent.subElement.input;
  voParent.oldText = voText.value;
  if (voParent.value == null) voParent.value = "";
  if(vsOldVal != vsNewVal) {
    voParent.data.setData(voParent.value);
  }
};

/**
 * ComboBox 컨트롤 아이템의 공통 속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.ComboBox_itemgroup = function() {
  /**
   * 아이템의 세로 길이.
   * @type Number
   */
  this.height = null;
  /**
   * 선택 버튼의 가로 길이.
   * @type Number
   */
  this.selectorWidth = null;
  /**
   * 아이템의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 아이템의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 아이템의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 아이템에 표시될 텍스트의 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * itemgroup의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */

  this.cursor = "null";

  this.df = {};
  this.textAlign = null;
};

/**
 * @class Concreate xhtml ComboBox.<br>
 *        XHTML 콤보박스 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.ComboBox 객체
 * @type eXria.controls.xhtml.ComboBox
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.ComboBox = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 200 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth,
      pnHeight);

  // 데이타 연동 관련
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 인스턴스로 부터 라벨 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.labelTagName = "label";
  /**
   * 인스턴스로 부터 value 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.valueTagName = "value";
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  // 데이타 연동 관련 End
  /**
   * 텍스트 영역의 읽기전용 여부.
   * @type Boolean
   */
  this.readOnly = null;
  /**
   * 선택된 아이템의 인덱스 번호.
   * @type Number
   */
  this.selectedIndex = null;
  /**
   * 인스턴스로 부터 가져올 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.itemset = new eXria.data.ArrayMap();
  /**
   * 앞쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.frontItems = new eXria.data.ArrayMap();
  /**
   * 뒤쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.backItems = new eXria.data.ArrayMap();
  /**
   * 선택된 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.selectedItems = new eXria.data.ArrayMap();
  /**
   * 마우스 오버된 아이템 리스트
   * @type eXria.data.ArrayMap
   */
  this.mouseOverItems = new eXria.data.ArrayMap();
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트의 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 텍스트 박스를 둘러싼 보더의 두께.
   * @private
   * @type Number
   */
  this.subBorderWidth = 0;
  /**
   * 리스트 아이템 아이디에 사용될 번호.
   * @private
   * @type Number
   */
  this.seqNum = 0;
  /**
   * 컨트롤에 설정된 값.
   * @type String
   */
  this.value = null;
  /**
   * 리스트 박스에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.ComboBox_listarea
   */
  this.listarea = new eXria.controls.xhtml.ComboBox_listarea(this);
  this.listarea.bScrolled = false;
  /**
   * 아이템의 공통 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.ComboBox_itemgroup
   */
  this.itemgroup = new eXria.controls.xhtml.ComboBox_itemgroup();
  /**
   * 드롭다운 버튼의 가로 길이.
   * @type Number
   */
  this.btnWidth = null;
  /**
   * 드롭다운 버튼의 배경 색상.
   * @type String
   */
  this.btnBackgroundColor = null;
  /**
   * 드롭다운 버튼의 텍스트 색상.
   * @type String
   */
  this.btnColor = null;
  /**
   * 드롭다운 버튼의 cursor 타입.
   * @type String
   * @private
   */
  this.btnCursor = null;
  /**
   * 드롭다운 버튼에 표시될 배경 이미지.
   * @type String
   */
  this.expandImage = null;
  /**
   * 드롭다운 되었을 때 버튼에 표시될 배경 이미지.
   * @type String
   */
  this.collapseImage = null;
  /**
   * 위 아래 화살표 키 동작 모드(select|focus).
   * select - listarea의 아이템을 선택
   * focus - listarea의 아이템을 포커싱하면서 탐색
   * @type String
   */
  this.arrowKeyMode = "select";
  /**
   * 리스트 목록을 새로 고침할지 여부(리스트 항목 추가/삭제 등으로 인해).
   * @private
   * @type Boolean
   */
  this.bReloadList = false;
  /**
   * css를 통해 지정된 폰트 사이즈.
   * @private
   * @type Number
   */
  this.cssFontSize = null;
  /**
   * 텍스트 박스의 좌우 여백(단위 px).
   * @private
   * @type Number
   */
  this.hPadding = 2;
  /**
   * 선택된 아이템이 변경 되었는지 여부(change이벤트 발생에 이용).
   * @private
   * @type Boolean
   */
  this.bRowChanged = false;
  /**
   * 이전까지 텍스트 박스에 입력된 문자열 값.
   * @type String
   * @private
   */
  this.oldText = null;
  /**
   * 컨트롤이 포커싱 되었는지 여부.
   * @type Boolean
   * @private
   */
  this.focused = false;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트.
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들.
   * @private
   */
  this.subElement = {};

  /**
   * multiselect key down 여부.
   * @type Boolean
   * @private
   */
  this.bMultiSelectKeyDown = false;

  /*
   *  사용자 정의
   */
  this.maxLength = null;
  /*
   *  사용자 정의
   */
  this.minLength = null;
  /*
   *  사용자 정의
   */
  this.nullable = true;
  /*
   *  사용자 정의
   */
  this.maxByteLength = null;
  /*
   *  사용자 정의
   */
  this.minByteLength = null;
  /**
   * 드럽다운 버튼 커서
   * @type String
   */
  this.btnCursor = null;
  /**
   * 드럽다운 방향설정
   * @type String
   */
  this.listDirection = null;
  /*
   * @ignore
   */
  this.scrolled = false;
  /**
   * input element ime-mode 설정 속성
   * @type String
   */
  this.imeMode = null;

  this.itemIdxMap = null;

  this.itemNmMap = null;

  this.itemValMap = null;

  this.itemIdMap = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl,
    eXria.controls.xhtml.ComboBox);
/**
 * 이벤트 키값.
 * @type Object
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.constKey = {
  LEFT :37,
  UP :38,
  RIGHT :39,
  DOWN :40,
  ENTER :13,
  TAB :9,
  BACKSPACE :8,
  DEL :46,
  HAN_ENG :21,
  CTRL :17
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["tabIndex"] = 0;

  this.ctrl = voCtrl;
  this.document = poDocument;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setTemplate = function(poCtrl, poDocument) {
  if (this.listarea.appearance == null)
    this.listarea.appearance = "normal";

  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<input type='text' class='" + vsClass + "' id='");
  vaTemplate.push(this.id);
  // 사용자  css에서 class 형태로 높이를 잡아준다 하지만 input은 동적으로 폰트에 따라 맞춰줘야
  vaTemplate.push("_text' style='position:absolute;margin:0px;");
  vaTemplate.push("@cssStrBuf"); // 0 번째 input 스타일
  vaTemplate.push("' ");
  vaTemplate.push("@attStrBuf"); // 1번째 input Attribute
  vaTemplate.push(">");

  var vsBtnClass = this.getCSSClass(this, 1, "Button");
  vaTemplate.push("<input class='" + vsBtnClass + "' type='button' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' ");
  vaTemplate.push("@attStrBuf"); // 2
  var vsButtonCursor = "";
  // yhkim 2009. 11 버튼의 커서설정이 필요
  if(this.btnCursor)
    vsButtonCursor = "cursor:" + this.btnCursor + ";";
  vaTemplate.push("style=\"position:absolute;margin:0px;padding:0px;top:0px;right:0px;background-repeat:no-repeat;background-position:center center;" + vsButtonCursor);
  vaTemplate.push("@cssStrBuf"); // 3번째 voBtn 스타일
  vaTemplate.push("\" onclick=\"");
  vaTemplate.push(this.getEHandler(this.id, "showList"));
  vaTemplate.push("\">");

  vaTemplate.push("<div id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_listarea' ");
  vaTemplate.push("@attStrBuf"); // 4 voList 클래스 지정
  vaTemplate.push(" style='position:absolute;display:none;");
  vaTemplate.push("@cssStrBuf"); // 5 voList 스타일값 추가
  vaTemplate.push("@cssStrBuf"); // 6 loadData 이후의 높이 값을 설정하기 위한 용도
  vaTemplate.push("'>");
  vaTemplate.push("<table id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_listarea_table' width='100%' cellPadding=0 style='");
  vaTemplate.push("@cssStrBuf"); // 7 voList 스타일값 추가
  vaTemplate.push(" '");
  vaTemplate.push("@attStrBuf"); // 8 voListTable attribute 값 추가
  vaTemplate.push(">");
  vaTemplate.push("<tbody>");
  vaTemplate.push("@innStrBuf"); // 9
  vaTemplate.push("</tbody></table></div>");
  // 사용자  css에서 class 형태로 높이를 잡아준다 하지만 input은 동적으로 폰트에 따라 맞춰줘야
  vaTemplate.push("<span class='" + vsClass + "' style=\"position:absolute;visibility:hidden;");
  vaTemplate.push("@cssStrBuf"); // 10
  vaTemplate.push("\"/>")

  this.templateIndexMap = eXria.controls.xhtml.Util
      .getTemplateIndexMap(vaTemplate);

  this.bReloadList = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.refreshSubStyle = function(poCtrl,
    poDocument) {
  this.setSubCtrlStyles(poCtrl);
};

eXria.controls.xhtml.ComboBox.prototype.clearListArea = function() {
  var voDocument = this.getComboboxCtrl("document");
  var voList = voDocument.getElementById(this.id + "_listarea");
  var voCanvasCtrl = this.getComboboxCtrl();
  var voParentElement = null;
  
  if(voList){
    voParentElement = voList.parentElement;
    if(voParentElement.id != this.id){
      voCanvasCtrl.removeChild(voList);
    }
  }else return;
};

/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setSpecificDefaults = function(poCtrl,
    poDocument) {
  var voDf = this.df;
  var voListareaDf = this.listarea;
  var voItemgroupDf = this.itemgroup;
  var voUserAttr = null;
  if(this.userAttr == "") this.userAttr = null;
  this.userAttr = this.getAttrValue("userAttr", this.userAttr);
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if (this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if (this.innerHeight < 0)  this.innerHeight = 0;

  this.selectedIndex = this.getAttrValue("selectedIndex", this.selectedIndex);
  this.btnWidth = this.getAttrValue("Button.btnWidth", this.btnWidth);
  this.value = this.getAttrValue("value", this.value);
  if (this.value == null)  this.value = [];
  this.expandImage = this.getAttrValue("Button.expandImage", this.expandImage);
  this.collapseImage = this.getAttrValue("Button.collapseImage", this.collapseImage);
  this.btnBackgroundColor = this.getAttrValue("btnBackgroundColor",  this.btnBackgroundColor);
  this.btnColor = this.getAttrValue("btnColor", this.btnColor);
  this.btnCursor = this.getAttrValue("btnCursor", this.btnCursor);
  this.readOnly = this.getAttrValue("readonly", this.readOnly);
  this.arrowKeyMode = this.getAttrValue("arrowKeyMode", this.arrowKeyMode);
  this.maxCanvasWidth = this.getAttrValue("maxCanvasWidth", this.maxCanvasWidth);
  this.maxCanvasHeight = this.getAttrValue("maxCanvasHeight", this.maxCanvasHeight);
  this.listDirection = this.getAttrValue("listDirection", this.listDirection);
  this.type = this.getAttrValue("type", this.type);
  if(voUserAttr) {
    if(voUserAttr.btn) {
      this.btnFontSize = voUserAttr.btn.fontSize;
      this.btnBorderStyle = voUserAttr.btn.borderStyle;
    }
    this.labelName = voUserAttr.labelName;
    if(voUserAttr.arrowKeyMode) this.arrowKeyMode = voUserAttr.arrowKeyMode;
    if(voUserAttr.defaultIndex) this.defaultIndex = voUserAttr.defaultIndex;
    if(voUserAttr.type) this.type = voUserAttr.type;
  }
  if(this.type == "searchable_list") this.arrowKeyMode = "focus";

  voListareaDf.className = this.getAttrValue("listarea.className", this.listarea.className);
  voListareaDf.appearance = this.getAttrValue("listarea.appearance",this.listarea.appearance);
  voListareaDf.multiSelect = this.getAttrValue("listarea.multiSelect",this.listarea.multiSelect);
  voListareaDf.cellSpacing = this.getAttrValue("listarea.cellSpacing",this.listarea.cellSpacing);
  voListareaDf.size = this.getAttrValue("listarea.size", this.listarea.size);
  voListareaDf.heightBySize = this.getAttrValue("listarea.heightBySize",this.listarea.heightBySize);
  var voWidthByMaxLength = this.getAttrValue("listarea.widthByMaxLength",this.listarea.widthByMaxLength);
  voListareaDf.widthByMaxLength = (voWidthByMaxLength == null || voWidthByMaxLength == "undefine")?true:voWidthByMaxLength;

  voListareaDf.focusColor = this.getAttrValue("listarea.focusColor",this.listarea.focusColor);
  voListareaDf.focusBackgroundColor = this.getAttrValue("listarea.focusBackgroundColor", this.listarea.focusBackgroundColor);
  var voHoverColor = this.getAttrValue("listarea.hoverBackgroundColor", this.listarea.hoverBackgroundColor);
  voListareaDf.hoverBackgroundColor = ( voHoverColor == null || voHoverColor == "undefine")?"#F0F0F0":voHoverColor
  this.listarea.oldMultiSelect = voListareaDf.multiSelect;
  this.listarea.oldAppearance = voListareaDf.appearance;

  // voItemgroupDf.className이 계속적으로 중첩되서 늘어나서 메모리 릭 문제로 Default_ComboBox_itemgroup_Class와 같이
  // 조합이 이미 이루어진 경우와  this.itemgroup.className이름이 동적(refresh도 이 함수를 탐) 으로 순수하게 바뀐경우를 대비해서 search문을 추가함
  var vbComposited = false;
  if(voItemgroupDf.className) {
    if(voItemgroupDf.className.search(/Default_ComboBox_itemgroup_Class/) != -1)
      vbComposited = true;
  }

  if(vbComposited == false) {
    //voItemgroupDf.className = this.getAttrValue("itemgroup.className",this.itemgroup.className);
    var vsClass = this.getCSSClass(this, 1, "itemgroup");
    //if(voItemgroupDf.className) vsClass = vsClass + " " + voItemgroupDf.className;
    voItemgroupDf.className = vsClass;
  }

  voItemgroupDf.selectorWidth = this.getAttrValue("itemgroup.selectorWidth",this.itemgroup.selectorWidth);
  voItemgroupDf.verticalAlign = this.getAttrValue("itemgroup.verticalAlign",this.itemgroup.verticalAlign);
  voItemgroupDf.textAlign = this.getAttrValue("itemgroup.textAlign",this.itemgroup.textAlign);
  // list Item Extended 속성추가
  voItemgroupDf.height = this.getAttrValue("itemgroup.height",this.itemgroup.textHeight);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voListareaDf = this.listarea;
  var voItemgroupDf = this.itemgroup;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;
  var vnWidth = 0;
  var vnHeight = 0;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if (this.visible == false)  vaCssStrBuf.push("display:none;");
  else  vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth,  "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth,  "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  // voText
  vaCssStrBuf = [];
  var vnWidth = this.innerWidth;
  if(this.btnWidth !== null) vnWidth = vnWidth - this.btnWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  if (vnWidth < 0) vnWidth = 0;
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", this.subBorderWidth);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  if (this.readOnly)
    vaAttStrBuf.push("readOnly ");
  vaTemplate[voIndexMap.get(1)] = vaAttStrBuf.join("");
  // voBtn
  vaAttStrBuf = [];
  if (this.expandImage) {
    vfcSetAttStrBuf(vaAttStrBuf, "value", "");
  } else {
    vfcSetAttStrBuf(vaAttStrBuf, "value", "▼");
  }
  vaTemplate[voIndexMap.get(2)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.btnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.btnBackgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.btnColor);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.btnCursor);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.btnFontSize);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.btnBorderStyle);
  if (this.expandImage) {
    vfcSetCssStrBuf(vaCssStrBuf, "border-style", "none");
    vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.expandImage);
  }
  vaTemplate[voIndexMap.get(3)] = vaCssStrBuf.join("");
  // voList
  //TODO
  vnHeight = voListareaDf.height;
  if (vnHeight) {
    vnHeight = vnHeight - voListareaDf.borderTopWidth  - voListareaDf.borderBottomWidth;
    if (vnHeight < 0)
      vnHeight = 0;
  }
  if (voListareaDf.appearance == "radio") {
    this.listarea.multiSelect = false;
    voListareaDf.multiSelect = false;
  }

  vaAttStrBuf = [];
  var vsClass = this.getCSSClass(this, 1, "listarea");
  if(voListareaDf.className) vsClass = vsClass + " " + voListareaDf.className;
  vfcSetAttStrBuf(vaAttStrBuf, "class", vsClass); // TODO
  vaTemplate[voIndexMap.get(4)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voListareaDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "color", voListareaDf.color);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", voListareaDf.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", voListareaDf.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width",  voListareaDf.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", voListareaDf.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", voListareaDf.borderTopWidth,
      "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width",  voListareaDf.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "left", -voListareaDf.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top",  (parseInt(this.innerHeight, 10) + parseInt(this.borderBottomWidth, 10)), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voListareaDf.overflowX);
  // vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voListareaDf.overflowY);
  vaTemplate[voIndexMap.get(5)] = vaCssStrBuf.join("");
  // voListTable
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", voItemgroupDf.textAlign);
  vaTemplate[voIndexMap.get(7)] = vaCssStrBuf.join("");
  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "cellSpacing", voListareaDf.cellSpacing);
  vaTemplate[voIndexMap.get(8)] = vaAttStrBuf.join("");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(10)] = vaCssStrBuf.join("");
  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.input = this.getSubCtrl("input", voCtrl, poDocument);
  voSubElement.btn = voCtrl.childNodes[1];
  voSubElement.list = voCtrl.childNodes[2];
  voSubElement.table = this.getSubCtrl("table", voCtrl);
  voSubElement.span = this.getSubCtrl("span", voCtrl);

};

/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.dochange = function(poEvent, poControl) {
  if (poControl.atchange) {
    poControl.atchange(poEvent);
  }
  if (poControl.cochange) {
    poControl.cochange(poEvent);
  }
  if (poControl.onchange) {
    poControl.onchange(poEvent);
  }
  if (poControl.changeEventCallback) {
    poControl.changeEventCallback(poEvent);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.doitemchange = function(poEvent, poControl) {
  if (poControl.atitemchange) {
    poControl.atitemchange(poEvent);
  }
  if (poControl.coitemchange) {
    poControl.coitemchange(poEvent);
  }
  if (poControl.onitemchange) {
    poControl.onitemchange(poEvent);
  }
  if (poControl.itemchangeEventCallback) {
    poControl.itemchangeEventCallback(poEvent);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.dofocus = function() {
  if (this.listShowed)
    return;
  var voCtrl = this.ctrl;
  var voInput = this.getSubCtrl("input", voCtrl);
  try { voInput.focus(); }catch(err) {}
};
/**
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.atkeydown = function(e) {
  this.keyDownEvent(e);
};
/**
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.atclick = function(poEvent) {
  if(this.itemChanged) {
    poEvent.objectType = "item";
    poEvent.object = this.itemChanged;
  }
};
/**
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.finalclick = function(poEvent) {
  this.itemChanged = null;
};
/**
 * 키다운 이벤트 처리 메소드.
 * @param {eXria.event.Event} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.keyDownEvent = function(e){
  var vnKeyCode = e.keyCode;

  var voEvent = new eXria.event.Event(e, this.window);
  var vnItemSize = this.selectedItems.size();

  if(voEvent.target.id === (this.id+'_text'))
   this.isComboMousedown = false;


  if(vnKeyCode == '16' || vnKeyCode == '17')
    this.bMultiSelectKeyDown = true;

  if(vnKeyCode == '38' || vnKeyCode == '40'){//↑↓
    if(!this.listShowed) return;
    if(this.arrowKeyMode == "select") {
      if(vnItemSize > 0){ //선택된 아이템이 있는 경우

        //현재 선택되어 있는 아이템 얻기
        var voNextTarget = this.getLastSelectTr(voEvent);

        if(vnKeyCode == '38'){// ↑
          voNextTarget = voNextTarget.previousSibling;
        }else{  //↓
          voNextTarget = voNextTarget.nextSibling;
        }
        if (voNextTarget != null) {
          var vbChek = true;
          var vnCnt = 0;
          while (vbChek) {
            if (vnCnt > 0 && voNextTarget.nodeName.toUpperCase() == "TD") {
              vbChek = false;
              continue;
            }else if(voNextTarget.nodeName.toUpperCase() == "TD"){
              ++vnCnt;
            }

            voNextTarget = voNextTarget.firstChild;
          }

          voEvent.target = voNextTarget;
          this.isCallByArrowKeySelect = true;
          this.listarea.selectEventList(voEvent);
        }
      }
    } else if(this.arrowKeyMode == "focus") {
      var voListCtrl = this.subElement.list;
      var voItemHeight = this.itemgroup.height
      var vnScrollTop = voListCtrl.scrollTop;
      var vnIdx = this.selectedIndex;
      if(vnIdx == null) vnIdx = -1;
      if(this.focusedItemCtrl) {
        vnIdx = this.focusedItemCtrl.id;
        vnIdx = vnIdx.substring((this.id + "_option_").length);
        vnIdx = parseInt(vnIdx);
      }
      if(vnKeyCode == '38') {// ↑
        vnIdx--;
        if(vnIdx * voItemHeight - voListCtrl.scrollTop < 0) vnScrollTop = vnIdx * voItemHeight;
      } else {  //↓
        vnIdx++;
        if((vnIdx + 1) * voItemHeight - voListCtrl.scrollTop > voListCtrl.clientHeight) vnScrollTop += voItemHeight;
      }
      var voTable = this.subElement.table;
      var vnListCnt = voTable.rows.length;
      if(vnIdx < 0) {
        vnIdx = vnListCnt - 1;
        vnScrollTop = vnIdx * voItemHeight;
      } else if(vnIdx >= vnListCnt) {
        vnIdx = 0;
        vnScrollTop = 0;
      }
      var vsId = this.id + "_option_" + vnIdx;
      this.listarea.mouseOver(null, vsId);
      this.atmouseover(null);
      voListCtrl.scrollTop = vnScrollTop;
    }
  }else if(vnKeyCode == '13'){  //enter
    if(this.listShowed) {
      if(this.arrowKeyMode == "focus" && this.focusedItemCtrl) {
        vnIdx = this.focusedItemCtrl.id;
        vnIdx = vnIdx.substring((this.id + "_option_").length);
        vnIdx = parseInt(vnIdx);
        var vbChanged = false;
        if(this.selectedIndex != vnIdx) vbChanged = true;
        this.selectedIndex = vnIdx;
        this.listarea.select([vnIdx]);
        this.isCallByItemEnter = true;
        if(vbChanged) {
          var voEvent = new eXria.event.Event(null, this.window);
          voEvent.object = this.getItem(vnIdx);
          voEvent.objectType = "item";
          this.doitemchange(voEvent, this);
          this.dochange(voEvent, this);
        }
      }
      if(this.type == "searchable_list") {
        if(!this.focusedItemCtrl) {
          var vbChanged = this.isChanged;
          e.target.value = "";
          this.clearSelected();
          this.setValue(null);
          if(vbChanged) {
            voEvent.object = this;
            if(this.onchange) {
              this.onchange(voEvent);
            }
            if(this.changeEventCallback) this.changeEventCallback(voEvent);
          }
        }
      }
      this.showList(false);
    } else {
      this.showList(true);
    }
    voEvent.stopEvent();
  }
};
/**
 * 이전에 선택된 Tr 정보 얻기
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getLastSelectTr = function(poEvent) {
  // 이전에 선택된 아이템 정보 얻기

  var voSelectItem = null;

  voSelectItem = this.getItem(this.selectedIndex);

  var voDiv = null;

  //voDiv = voDiv.firstChild.nextSibling.nextSibling.firstChild;
  voDiv = this.subElement.table;

  while (voDiv.nodeName.toUpperCase() != "DIV") {
    voDiv = voDiv.firstChild;
  }

  if (voDiv == null || voDiv["id"].indexOf(this.id + "_option") == -1)
    return;

  var voTr = this.subElement.table.firstChild.firstChild;
  //voDiv = voTr.firstChild.firstChild;

  var vbCheck = true;
  while (vbCheck) {
    if (voSelectItem.id == voDiv.id) {
      vbCheck = false;
      continue;
    } else {
      voTr = voTr.nextSibling;
      voDiv = voTr.firstChild.firstChild;
    }
  }

  return voTr;

};

/**
 * 컨트롤 내부적이 mouseover 이벤트 처리 메소드.
 * @param {eXria.event.Event} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.atmouseover = function(e) {

  if(this.eventType == "item" && this.eventObject != null) {
    var voDocument = this.getComboboxCtrl("document");
    var voItem = this.eventObject;
    var voItemCtrl = voDocument.getElementById(voItem.id);
    var voStyle = voItemCtrl.style;
    var vbSelected = false;

    var vnIdx = voItem.id;
    vnIdx = vnIdx.substring((this.id + "_option_").length);
    vnIdx = parseInt(vnIdx);
    if(this.selectedItems.get(vnIdx) != null) {
      vbSelected = true;
    }
    if (!vbSelected) {
      voStyle.backgroundColor = this.listarea.hoverBackgroundColor;// eXria.controls.xhtml.Default.ListBox.focusBackgroundColor;//"#F1F1EB";//this.focusBackgroundColor;
    }
    this.focusedItemCtrl = voItemCtrl;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atmouseout = function(e) {
  var voCanvas = this.canvas;
  var voTarget = e.target;
  var voBtnCtrl = this.subElement.btn;
  var voInputCtrl = this.subElement.input;
  var vnLeft = 0;
  if(voTarget == voBtnCtrl) {
    if(voCanvas.page.metadata.browser.ie) {
      vnLeft = e.e.offsetX;
    } else {
      var voElement = e.target;
      while(voElement.offsetParent) {
        vnLeft += voElement.offsetLeft;
        voElement = voElement.offsetParent ;
      };
      vnLeft = e.e.pageX - vnLeft ;
    }
    if(vnLeft <= 0) this.skipCustomEvent = true;
  }
  if(voTarget == voInputCtrl) {
    if(voCanvas.page.metadata.browser.ie) {
      vnLeft = e.e.offsetX;
    } else {
      var voElement = e.target;
      while(voElement.offsetParent) {
        vnLeft += voElement.offsetLeft;
        voElement = voElement.offsetParent ;
      };
      vnLeft = e.e.pageX - vnLeft ;
    }
    var vnLen = parseInt(voInputCtrl.style.width);
    if(vnLeft >= vnLen) this.skipCustomEvent = true;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atmousedown = function() {
  this.isComboMousedown = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atchange = function(poEvent) {
  if(this.type == "searchable_list") {
    if(this.focusedItemCtrl) {
      var voDiv = this.focusedItemCtrl;
      vnIdx = voDiv.id;
      vnIdx = vnIdx.substring((this.id + "_option_").length);
      vnIdx = parseInt(vnIdx);
      this.selectedIndex = vnIdx;
      this.listarea.select([vnIdx]);
      this.showList(false);
      this.focusedItemCtrl = voDiv;
    } else {
      this.subElement.input.value = "";
      this.clearSelected();
      this.setValue(null);
    }
    return;
  }

  if(this.isCallByKeyIn) return;
//  var voText = this.subElement.input;
//  if (this.selectedIndex == -1) this.setValue(voText.value);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atfocus = function(poEvent) {
  // this.selectText();
  if (this.focused == false) {
    this.selectText();
    this.focused = true;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atblur = function(e) {
  if(!!this.isComboMousedown) {
    this.isComboMousedown = false;
    return;
  }
  if(!!this.isCallByArrowKeySelect) {
    this.isCallByArrowKeySelect = false;
    return;
  }

  var vaSelectItem = this.getSelectedItems();
  var voText = this.subElement.input;

  if(this.value !== voText.value && this.isChanged){
    this.unselectListItem(null, this.bMultiSelectKeyDown);
    this.setValue(voText.value);
  }else{
    return;
  }

  this.setInputHeight();
  this.focused = false;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.doblur = function() {
  var voInput = this.subElement.input;
  voInput.blur();
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.refreshSpecificAttrs = function(poCtrl,
    poDocument) {
  this.bReloadList = true;
  this.setSpecificAttrs(poCtrl, poDocument);
  this.clearListArea();
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.removeSpecificDefaults = function(
    poCtrl, poDocument) {
  this.df = {};
//  this.itemgroup.df = {};
  this.template = null;
  this.templateIndexMap = null
  // var voTable = this.subElement.table;
  // if(voTable) {
  // var voDiv = null;
  // for(var i=0; i < voTable.rows.length; i++) {
  // voDiv = voTable.rows[i].cells[0].firstChild;
  // voDiv.onclick = null;
  // }
  // }
  // var voText = this.subElement.input;
  // var voEventManager = this.eventManager;
  // voEventManager.removeListener(voText, "onblur", this.mediateEvent);
  // voEventManager.removeListener(voText, "onchange", this.mediateEvent);
  // voEventManager.removeListener(voText, "onfocus", this.mediateEvent);
  // voEventManager.removeListener(voText, "onselect", this.mediateEvent);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setAttrSubCtrl = function(psAttrName,
    psAttrValue, poCtrl) {
  if (poCtrl.id != this.id)
    return;
  var voDf = this.df;
  var voText = this.subElement.input;
  var voBtn = this.subElement.btn;
  var voList = this.subElement.list;
  var voListTable = this.subElement.table;
  var voSpan = this.subElement.span;
  var voInput = this.subElement.input;

  switch (psAttrName) {
  case "width":
    var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    if (vnWidth < 0)
      vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voInput);
    this.setAttrCtrl("width", this.innerWidth, voList);
    break;
  case "height":
    this.setAttrCtrl("height", this.innerHeight, voBtn);
    this.setVerticalAlign(voText, poCtrl, this.verticalAlign);
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.applyAttrRebuild = function(psAttrName,
    psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voText = this.subElement.input;
  var voBtn = this.subElement.btn;
  var voList = this.subElement.list;
  var voTable = this.subElement.table;
  var voSpan = this.subElement.span;
  var voStyle = null;
  var vsSubAttrName = null;
  var voDf = this.df;
  var voListAreaDf = this.listarea;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for ( var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if (voObj.df)  voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch (psAttrName) {
  case "visible":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    break;
  case "disabled":
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "backgroundColor":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setAttrCtrl(psAttrName, psAttrValue, voText);
    break;
  case "color":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setAttrCtrl(psAttrName, psAttrValue, voText);
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "textDecoration":
  case "textTransform":
    this.setAttrCtrl(psAttrName, psAttrValue, voText);
    this.setAttrCtrl(psAttrName, psAttrValue, voSpan);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    break;
  case "fontFamily":
  case "fontSize":
  case "fontStyle":
  case "fontWeight":
    this.setAttrCtrl(psAttrName, psAttrValue, voText);
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    this.setAttrCtrl(psAttrName, psAttrValue, voSpan);
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    var voDiv = null;
    var voInnerTable = null;
    for ( var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      voInnerTable = voDiv.childNodes[0];
      this.setAttrCtrl(psAttrName, psAttrValue, voInnerTable);
    }
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    break;
  case "verticalAlign":
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    break;
  case "left":
  case "top":
    this.setAttrCtrl(psAttrName, psAttrValue);
    break;
  case "width":
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if (this.innerWidth < 0)
      this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    var vnWidth = this.innerWidth;
    if(this.btnWidth !== null) vnWidth = vnWidth - this.btnWidth
    if (vnWidth < 0)
      vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voTable);
    this.setInputWidth();
    break;
  case "height":
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if (this.innerHeight < 0)
      this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl("top", (parseInt(this.innerHeight, 10) + parseInt(this.borderBottomWidth, 10)), voList);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
    break;
  case "borderWidth":
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if (this.innerWidth < 0)
      this.innerWidth = 0;
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if (this.innerHeight < 0)
      this.innerHeight = 0;
    // border
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    // width
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    var vnWidth = this.innerWidth;
    if(this.bntWidth !== null) vnWidth = vnWidth - this.btnWidth;
    if (vnWidth < 0)
      vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voTable);
    this.setInputWidth();
    // height
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl("top", (parseInt(this.innerHeight, 10) + parseInt(this.borderBottomWidth, 10)), voList);
    break;
  case "borderLeftWidth":
  case "borderRightWidth":
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if (this.innerWidth < 0)
      this.innerWidth = 0;
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    var vnWidth = this.innerWidth;
    if(this.btnWidth !== null) vnWidth = vnWidth - this.btnWidth;
    if (vnWidth < 0)
      vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voTable);
    this.setInputWidth();
    break;
  case "borderTopWidth":
  case "borderBottomWidth":
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if (this.innerHeight < 0)
      this.innerHeight = 0;
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl("top", (parseInt(this.innerHeight, 10) + parseInt(this.borderBottomWidth, 10)), voList);
    break;
  case "btnWidth":
    var vnWidth = this.innerWidth;
    if(this.btnWidth !== null) vnWidth = vnWidth - this.btnWidth;
    if(this.subBorderWidth !== null) vnWidth = vnWidth - 2 * this.subBorderWidth;
    if (vnWidth < 0) vnWidth = 0;
    vnWidth = this.innerWidth;
    if(this.btnWidth !== null) vnWidth = vnWidth - this.bntWidth;
    this.setAttrCtrl("left", vnWidth, voBtn);
    this.setAttrCtrl("width", this.btnWidth, voBtn);
    this.setInputWidth();
    break;
  case "listarea.size":
  case "listarea.cellSpacing":
    if (voListAreaDf.heightBySize) {
      var vnSize = this.getVisibleItemCount();
      if (voListAreaDf.size < vnSize)
        vnSize = voListAreaDf.size;
      var vnHeight = vnSize
          * (this.itemgroup.height + voListAreaDf.cellSpacing)
          + voListAreaDf.cellSpacing;
      this.setAttrCtrl("height", vnHeight, voList);
    }
    if (psAttrName == "listarea.cellSpacing") {
      voTable.setAttribute("cellSpacing", voListAreaDf.cellSpacing);
    }
    break;
  case "listarea.backgroundColor":
  case "listarea.color":
    this.setAttrCtrl(psAttrName, psAttrValue, voList);
    var voDiv = null;
    for ( var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      if (this.selectedItems.get(i) == null) {
        this.restoreRowColor(voDiv);
      }
    }
    break;
  case "listarea.borderWidth":
    voListAreaDf.borderLeftWidth = voListAreaDf.borderWidth;
    voListAreaDf.borderRightWidth = voListAreaDf.borderWidth;
    voListAreaDf.borderTopWidth = voListAreaDf.borderWidth;
    voListAreaDf.borderBottomWidth = voListAreaDf.borderWidth;
    this.setAttrCtrl("left", (-voListAreaDf.borderLeftWidth), voList);
    this.setAttrCtrl("borderLeftWidth", voListAreaDf.borderLeftWidth, voList);
    this.setAttrCtrl("borderRightWidth", voListAreaDf.borderRightWidth, voList);
    this.setAttrCtrl("borderTopWidth", voListAreaDf.borderTopWidth, voList);
    this.setAttrCtrl("borderBottomWidth", voListAreaDf.borderBottomWidth,
        voList);
    break;
  case "listarea.borderLeftWidth":
    this.setAttrCtrl("left", (-voListAreaDf.borderLeftWidth), voList);
  case "listarea.borderRightWidth":
  case "listarea.borderTopWidth":
  case "listarea.borderBottomWidth":
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voList);
    break;
  case "listarea.focusBackgroundColor":
  case "listarea.focusColor":
    var voDiv = null;
    for ( var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      if (this.selectedItems.get(i) != null) {
        this.changeRowColor(voDiv);
      }
    }
    break;
  case "itemgroup.borderWidth":
  case "itemgroup.borderLeftWidth":
  case "itemgroup.borderRightWidth":
  case "itemgroup.borderTopWidth":
  case "itemgroup.borderBottomWidth":
  case "itemgroup.height":
  case "itemgroup.padding":
  case "itemgroup.paddingLeft":
  case "itemgroup.paddingRight":
  case "itemgroup.paddingTop":
  case "itemgroup.paddingBottom":
  case "itemgroup.selectorWidth":
  case "itemgroup.verticalAlign":
    this.refreshList(voCtrl, poDocument);
    break;
  case "multiSelect":
    voListAreaDf.multiSelect = psAttrValue;
    if (voListAreaDf.appearance == "radio")
      voListAreaDf.multiSelect = false;
    if (voListAreaDf.multiSelect != this.listarea.oldMultiSelect) {
      this.refreshList(voCtrl, poDocument);
    }
    break;
  case "appearance":
    if (voListAreaDf.appearance == "radio")
      voListAreaDf.multiSelect = false;
    if (voListAreaDf.appearance != this.listarea.oldAppearance) {
      this.refreshList(voCtrl, poDocument);
    }
    break;
  case "readOnly" :
    this.setAttrCtrl("readOnly", psAttrValue, voText);
    break;
  default:
    this.refresh(poDocument);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.loadData = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  this.itemset.clear();
  this.selectedItems.clear();

  if (this.datasetId == null) {
    this.loadDataFromInstance(voCtrl, poDocument);
  } else {
    this.loadDataFromDataSet(voCtrl, poDocument);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.loadDataFromInstance = function(poCtrl,  poDocument) {
  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    this.loadDataFromPluginInstance(poCtrl, poDocument);
    return;
  }
  var vaValue = [];
  var vsRefValue = this.value;
  if (this.data.instanceId && this.data.instancePath)
    vsRefValue = this.data.getData();
  if (vsRefValue != null) {
    this.selectedIndex = -1;
    if (vsRefValue instanceof Array)
      vaValue = vsRefValue;
    else
      vaValue.push(vsRefValue);
  }
  this.value = vaValue;
  if (this.data.nodesetInstanceId == null
      || this.data.nodesetInstancePath == null)
    return;
  var voCollectionNode = this.data.getNodesetData2();
  if (voCollectionNode) {
    var vnLoop = voCollectionNode.getLength();
    var voMapNode = null;
    var vsLabelNode = null;
    var vsValueNode = null;
    var voItem = null;
    for ( var i = 0; i < vnLoop; i++) {
      voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
      vsLabelNode = voMapNode.get(this.labelTagName);
      vsValueNode = voMapNode.get(this.valueTagName);
      voItem = this.addToItemset(vsLabelNode, vsValueNode, poDocument);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.loadDataFromPluginInstance = function(poCtrl, poDocument) {
  var vaValue = [];
  var vsRefValue = this.value;
  if (this.data.instanceId && this.data.instancePath)
    vsRefValue = this.data.getData();
  if (vsRefValue != null) {
    this.selectedIndex = -1;
    if (vsRefValue instanceof Array)
      vaValue = vsRefValue;
    else
      vaValue.push(vsRefValue);
  }
  this.value = vaValue;
  if (this.data.nodesetInstanceId == null
      || this.data.nodesetInstancePath == null)
    return;
  var voCollectionNode = this.data.getNodesetStr();
  if(voCollectionNode) voCollectionNode = eval(voCollectionNode);
  if (voCollectionNode) {
    var vnLoop = voCollectionNode.length;
    var voMapNode = null;
    var vsLabelNode = null;
    var vsValueNode = null;
    var voItem = null;
    for ( var i = 0; i < vnLoop; i++) {
      voMapNode = voCollectionNode[i];
      vsLabelNode = voMapNode[this.labelTagName];
      vsValueNode = voMapNode[this.valueTagName];
      voItem = this.addToItemset(vsLabelNode, vsValueNode, poDocument);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.loadDataFromDataSet = function(poCtrl, poDocument) {
  var voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
  if (voDataSet == null)
    return;
  // voDataSet.setDataSync(true);
  voDataSet.rebuild(false);

  var vsLabelNode = null;
  var vsValueNode = null;
  var voItem = null;
  var vnLoop = voDataSet.getRowCnt();
  for ( var i = 1; i <= vnLoop; i++) {
    vsLabelNode = voDataSet.get(i, this.labelTagName);
    vsValueNode = voDataSet.get(i, this.valueTagName);
    voItem = this.addToItemset(vsLabelNode, vsValueNode, poDocument);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;
  var vaTemplate = this.template;
  var voListareaDf = this.listarea;
  var voItemgroupDf = this.itemgroup;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var voIndexMap = this.templateIndexMap;

  //this.scrolled = this.isScrolled();
  this.seqNum = 0;
  if (this.value.length > 0) {
    this.clearSelected();
  }
  var vnHeight = voListareaDf.height;
  if (vnHeight) {
    vnHeight = vnHeight - voListareaDf.borderTopWidth - voListareaDf.borderBottomWidth;
    if (vnHeight < 0)
      vnHeight = 0;
  }
  if (voListareaDf.heightBySize) {
    vnHeight = parseInt(voItemgroupDf.height);
    var vnSize = this.getVisibleItemCount();
    if (voListareaDf.size != null && voListareaDf.size < vnSize) {
      vnHeight = voListareaDf.size * (vnHeight + voListareaDf.cellSpacing) + voListareaDf.cellSpacing;
    } else {
      vnHeight = vnSize * (vnHeight + voListareaDf.cellSpacing)  + voListareaDf.cellSpacing;
    }
  }
  vaCssStrBuf = [];
  if (this.scrolled)
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", "scroll");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voListareaDf.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px"); // 스크롤 높이 잡아준다
  if(this.listDirection == "top") { // 원래 위치에 맞게 조정
    var vnTop = parseInt(this.getStyleCurrentValue(voCtrl, "top", "top"), 10);
    vnTop = vnTop - vnHeight;
    vfcSetCssStrBuf(vaCssStrBuf, "top", vnTop, "px"); // 스크롤 높이 잡아준다
  }

  vaTemplate[voIndexMap.get(6)] = vaCssStrBuf.join("");
  vaTemplate[voIndexMap.get(9)] = this.getListInnerHTML();

  if((this.value.length == 0 || (this.value.length == 1 && this.value[0] == "")) && this.defaultIndex != null) {
    var voItem = this.getItem(this.defaultIndex);
    if(voItem) voItem.selected = true;
  }
  this.skipEvent = true;
  voCtrl.innerHTML = vaTemplate.join("");
  this.skipEvent = false;
  voIndexMap.clear();
  vaCssStrBuf = null;
  // vaTemplate = null;
  // this.template = null;
  // this.templateIndexMap = null;

  this.setSubElement(poDocument);
//  this.setEvnets(voCtrl);
  // var voSpan = poDocument.createElement("span");
  // voSpan.style.visibility = "hidden";
  // voCtrl.appendChild(voSpan);
  //
  // // voSpan
  // this.setAttrCtrl("fontFamily", this.fontFamily, voSpan);
  // this.setAttrCtrl("fontStyle", this.fontStyle, voSpan);
  // this.setAttrCtrl("fontSize", this.fontSize, voSpan);
  // this.setAttrCtrl("fontWeight",this.fontWeight, voSpan);

  var voText = this.subElement.input;
  this.eventManager.addListener(voText, "onblur", this.mediateEvent);
  this.eventManager.addListener(voText, "onchange", this.mediateEvent);
  this.eventManager.addListener(voText, "onfocus", this.mediateEvent);
  this.eventManager.addListener(voText, "onselect", this.mediateEvent);
  this.eventManager.addListener(voText, "onitemchange", this.mediateEvent);

  voText.control = this;

  this.bReloadList = false;
  this.checkSelected(voCtrl, poDocument);
  if (this.selectedIndex == -1) {
    if (this.value instanceof Array) {
      var vsStr = "";
      for ( var i = 0; i < this.value.length; i++) {
        //vsStr += eXria.controls.xhtml.Util.parseLang(this.value[i]);
        vsStr += this.value[i];
        if (i != this.value.length - 1)
          vsStr += ";";
      }
      voText.value = vsStr;
    } else if (this.value) {
//      voText.value = eXria.controls.xhtml.Util.parseLang(this.df.value);
      voText.value = this.getItemByVal(this.value) ? this.getItemByVal(this.value).name : this.value;
    }
  }
  this.oldText = voText.value;

  // yhkim 2009.10.09  선택된 아이템은 있는데 selectedIndex가 null인경우
  if(this.selectedIndex == null && this.getSelectedIndexes().length > 0) {
    var vnIndexes = this.getSelectedIndexes();
    this.selectedIndex = vnIndexes[0];
  }

  this.setInputHeight(voCtrl);
  this.setInputWidth();
  this.setVerticalAlign(voText, voCtrl, this.verticalAlign);  // UIControl 호출
  if(this.readOnly) {
    var voBase = this;
    voText.onclick = function(e) {
      var voEvent = new eXria.event.Event(e, voBase.window);
      voBase.showList();
      voEvent.stopPropagation();
    }
  } else {
    voText.onclick = null;
  }
};
/**
 * 로딩된 아이템을 새로고침하기 위한 메소드.(아이템들을 리로딩 하지 않는다는 점에서 refresh메소드와 구별됨)
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.repaint = function(poDocument) {
  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);

  this.removeUIGeneralDefaults(voCtrl, poDocument);
  this.removeSpecificDefaults(voCtrl, poDocument);
  this.refreshTemplate(voCtrl, poDocument);
  this.refreshUIGeneralDefaults(voCtrl, poDocument);
  this.refreshSpecificDefaults(voCtrl, poDocument);
  this.refreshSpecificAttrs(voCtrl, poDocument);
  this.loadComplete(poDocument);
};

/**
 * @ignore
 * shift로 다중선택된 아이탬중 기준이 되는 처음 선택된 아이템 index
 */
eXria.controls.xhtml.ComboBox.prototype.getFirstItemIndex = function(){
  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var vnIdx = null;

  if(voIterator.hasNext()){
    vnIdx = voIterator.next();

    if(vnIdx == this.selectedIndex)
      vnIdx = voIterator.collection[voIterator.collection.length-1];
  }

  return vnIdx;
};


/**
 * @ignore
 * 기존선택 되어있던 아이템 선택 해제
 */
eXria.controls.xhtml.ComboBox.prototype.unselectListItem = function(poEvent, pbMultiSelectKey){
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  if (this.listarea.multiSelect == false
      || this.listarea.appearance != "normal"
      || (this.listarea.appearance == "normal" && pbMultiSelectKey == false)
      || this.selectedItems.size() == 0) {
    var voTable = this.lookup(this.id + "_listarea_table", this.getComboboxCtrl("document"));
    if (this.listarea.multiSelect == false
        || (this.listarea.appearance == "normal" && pbMultiSelectKey == false)
        || this.selectedItems.size() == 0) {
      this.clearSelected();
//      this.selectedItems.clear();
      if (this.listarea.appearance != "normal") {
        for ( var i = 0; i < voTable.rows.length; i++) {
          voDiv = voTable.rows[i].cells[0].childNodes[0];
          voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
          voInput.checked = false;
        }
      }
    }
    this.nonSelectedRestoreColor(voTable);
  }

};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.reloadData = function(poCtrl,
    poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.refreshData = function(poCtrl, poDocument) {
  if(poDocument == null) poDocument = this.document;
  if(poCtrl == null) poCtrl = this.ctrl;
  this.refreshTemplate(poCtrl, poDocument);
  this.refreshSpecificAttrs(poCtrl, poDocument);
  this.reloadData(poCtrl, poDocument);
};

/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setInputHeight = function(poCtrl) {
  var voInput = this.subElement.input;
  var vsText = voInput.value;
  var voSpan = this.subElement.span;
  voSpan.innerHTML = "&nbsp;";
//  if (vsText == "") voSpan.innerHTML = "&nbsp;";
//  else voSpan.innerHTML = vsText;


  var vnHeight = voSpan.offsetHeight;
  this.setAttrCtrl("height", vnHeight, voInput);

};

/**
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.setInputWidth = function() {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement.input;
  var vnPaddingLeft = parseInt(this.getStyleCurrentValue(voSubElement, "padding-left", "paddingLeft"), 10);
  var vnPaddingRight = parseInt(this.getStyleCurrentValue(voSubElement, "padding-right", "paddingRight"), 10);
  var vnBorderLeft = parseInt(this.getStyleCurrentValue(voCtrl, "border-left-width", "borderLeftWidth"), 10);
  var vnBorderRight = parseInt(this.getStyleCurrentValue(voCtrl, "border-right-width", "borderRightWidth"), 10);
  vnPaddingLeft = vnPaddingLeft == null ? 0 : vnPaddingLeft;
  vnPaddingRight = vnPaddingRight == null ? 0 : vnPaddingRight;
  vnBorderLeft = vnBorderLeft == null ? 0 : vnBorderLeft;
  vnBorderRight = vnBorderRight == null ? 0 : vnBorderRight;
  var vnWidth = voCtrl.offsetWidth - vnBorderLeft - vnBorderRight - 1;
  vnWidth = vnWidth - (vnPaddingLeft + vnPaddingRight);
  if(vnWidth < 0) vnWidth = 0;
  if(this.btnWidth) vnWidth = vnWidth - this.btnWidth;
  this.setAttrCtrl("left", vnPaddingLeft, voSubElement);
  this.setAttrCtrl("width", vnWidth, voSubElement);
  this.setAttrCtrl("paddingLeft", "0px", voSubElement);
  this.setAttrCtrl("paddingRight", "1px", voSubElement);
};

/**
 * 컨트롤 텍스트 수직정렬 재설정.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.refreshVerticalAlign = function() {
  var voCtrl = this.ctrl;
  if (voCtrl == null)
    return;
  var voDf = this.df;
  var voInput = this.getSubCtrl("input", voCtrl);
  this.setInputHeight();
  this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
};

/**
 * combobox가 속한 page 객체, dom 객체 가져오는 메서드.
 */
eXria.controls.xhtml.ComboBox.prototype.getComboboxCtrl = function(poDiv) {
  var vbSpbFlag = false;
  var voCanvasCtrl = null;
  var vsReferrer = null;
  var vsFrameId = null;
  var voTarget = this;
  var voPage = voTarget.canvas.page;
  
  if(voTarget.window.frameElement) vsFrameId = voTarget.window.frameElement.id;
  while(voPage){
    if(voPage.getPage)  if(!!voPage.getPage(vsFrameId)) vbSpbFlag = true;
    if(vbSpbFlag) {
      vsReferrer = this.document.referrer;
      break;
    }else {
      vsReferrer = this.document.location.pathname;
      if(!voPage.parent? false : voPage.id == voPage.parent.id) break;
      else voPage = voPage.parent;
    }
  }
  if(!vsReferrer) vsReferrer = this.document.location.pathname;
  var vsMainPage = vsReferrer.substring(vsReferrer.lastIndexOf("/")+1, (vsReferrer.length-4));
  voPage = voTarget.canvas.page;
  
  while(voPage.parent) {
    if(voPage.id.indexOf(vsMainPage) > -1)  break;
    voPage = voPage.parent;
  }
  if(poDiv == "document") voCanvasCtrl = voPage.canvas.ctrl.parentNode.ownerDocument;
  else voCanvasCtrl = voPage.canvas.ctrl.parentNode;
  return voCanvasCtrl;
};

/**
 * 드롭다운 리스트 표시 여부 설정 메소드.
 * @param {Boolean} pbShow 리스트 표시 여부 설정
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.showList = function(pbShow, poDocument) {
  var voDf = this.df;
  var voCanvas = this.canvas;
  var voCtrl = this.getCtrl(poDocument);
  var voList = this.subElement.list;
  var voBtn = this.subElement.btn;
  var voStyle = null;
  var voCanvasCtrl = this.getComboboxCtrl();
  var voPage = this.getComboboxCtrl();
  this.eventType = null;
  this.eventObject = null;
//  if(pbShow == false) {
  this.focusedItemCtrl = null;
//  }

  if(voCanvas.collapseControl && voCanvas.collapseControl.id != this.id) {
    voCanvas.doCollapseControl(voCanvas);
  }
  if(voList != null) {
    voStyle = voList.style;
    var voParent = null;
    var vnZIndex = null;
    if(pbShow == true) {
      voStyle.display = "block";
      this.setAttrCtrl("zIndex", 50000, voCtrl);
      voParent = this.parent;
      while(voParent) {
        if(voParent.ctrl) this.setAttrCtrl("zIndex", 50000, voParent.ctrl);
        voParent = voParent.parent;
      }
      this.listShowed = true;
      voCanvas.collapseControl = this;
    } else if(pbShow == false) {
      voStyle.display = "none";
      //this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
      //2010.05.07
      //this.zIndex가 doCollapseControl 을 타고 올경우
      //null이 되므로 null 처리 추가
      this.setAttrCtrl("zIndex", this.zIndex === null ? 0: this.zIndex, voCtrl);

      voParent = this.parent;
      while(voParent) {
        if(voParent.ctrl) {
          vnZIndex = voParent.zIndex == null ? 0 : voParent.zIndex;
          this.setAttrCtrl("zIndex", vnZIndex, voParent.ctrl);
        }
        voParent = voParent.parent;
      }
      this.listShowed = false;
      voCanvas.collapseControl = null;
      this.clearListArea();
    } else {
      if(voStyle.display == "none") {
        voStyle.display = "block";
        this.setAttrCtrl("zIndex", 50000, voCtrl);
        //listarea zindex 부여
        voStyle.zIndex = 50000;
        voParent = this.parent;
        while(voParent) {
          if(voParent.ctrl) this.setAttrCtrl("zIndex", 50000, voParent.ctrl);
          voParent = voParent.parent;
        }
        this.listShowed = true;
        voCanvas.collapseControl = this;
      } else {
        voStyle.display = "none";
        this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
        var voParent = this.parent;
        while(voParent) {
          if(voParent.ctrl) {
            vnZIndex = voParent.zIndex == null ? 0 : voParent.zIndex;
            this.setAttrCtrl("zIndex", vnZIndex, voParent.ctrl);
          }
          voParent = voParent.parent;
        }
        this.listShowed = false;
        voCanvas.collapseControl = this;
      }
    }
    if(pbShow == true || voStyle.display == "block"){
      var voTarget = this;
      var voFrameElement = voTarget.window.frameElement;
      var vnLeft = null;
      var vnTop = null;
      var vsMainPage = "";
      var vsSrc = "";
      if(!!voFrameElement && voFrameElement.id.indexOf("sbp") > -1){
        vsMainPage = voFrameElement.src;
        vsSrc = vsMainPage.substring(vsMainPage.lastIndexOf("/")+1, (vsMainPage.length-4));
        if(vsSrc.indexOf(".xrf") > -1){
          vsSrc = vsSrc.substr(0, vsSrc.indexOf(".xrf"));
        }
        vsSrc = vsSrc+"_canvas";
        
        if(vsSrc != voPage.id){
          while(voFrameElement.id){
            if(!isNaN(voFrameElement.offsetTop)) vnTop = vnTop + voFrameElement.offsetTop;
            if(!isNaN(voFrameElement.offsetLeft)) vnLeft = vnLeft + voFrameElement.offsetLeft;
            voFrameElement = voFrameElement.parentNode;
          }
        }
      }
      
      if(!!voTarget.ctrl.parentNode) {
        var voParentCtl = voTarget.ctrl.parentNode;
        vnTop = vnTop + voTarget.height + voTarget.top + voTarget.borderTopWidth;
        vnLeft = vnLeft + voTarget.left + voTarget.borderLeftWidth;
        
        if(!!voFrameElement && voFrameElement.id.indexOf("sbp") > -1){
          vnTop = vnTop + voFrameElement.offsetTop;
          vnLeft = vnLeft + voFrameElement.offsetLeft;
        }
        
        while(voParentCtl.parentNode.id){
          if(!isNaN(voParentCtl.offsetTop)) vnTop = vnTop + voParentCtl.offsetTop;
          if(!isNaN(voParentCtl.offsetLeft)) vnLeft = vnLeft + voParentCtl.offsetLeft;
          voParentCtl = voParentCtl.parentNode;
        }
      }else{
        vnLeft = this.left;
        vnTop = this.top;
      }
      
      voList.style.top = vnTop + "px";
      voList.style.left = vnLeft + "px";
      
      var voParent = this.canvas;
      var vnParentTop = voPage.offsetHeight;
    
    //  if(this.parent && this.parent.overflow != "visible") { voParent = this.parent; }
    //  if(this.parent) {
    //    var vbVisible = this.getStyleCurrentValue(this.parent.ctrl, "overflow", "overflow");
    //    if(this.parent.overflow != null)
    //    vbVisible = this.parent.overflow;
    //    if(vbVisible != "visible") {
    //      voParent = this.parent;
    //      vnParentTop = voParent.top + voParent.height;
    //    }
    //  }
      //listdirection 값 top,bottom,auto 일때 위치값 수정
      if(this.listDirection == "top"){
        voList.style.top = (parseInt(voList.style.top) - (this.borderTopWidth + this.height + parseInt(voList.style.height))) + "px";
      }
      else if(this.listDirection == "bottom"){
        voList.style.top = vnTop;
      }
//      else {
//        if((vnTop + this.height + voList.offsetHeight) > vnParentTop){
//          voList.style.top = (parseInt(voList.style.top) - (this.borderTopWidth + this.height + parseInt(voList.style.height))) + "px";
//        }
//        if((this.left + voList.offsetWidth) > voParent.width) {
//          voList.style.top = vnTop;
//        }
//        if(!!this.maxCanvasWidth) {
//          if((this.left + voList.offsetWidth) > this.maxCanvasWidth) {
//            voList.style.top = (parseInt(voList.style.top) - (this.borderTopWidth + this.height + parseInt(voList.style.height))) + "px";
//          }
//        }
//      }  
      voCanvasCtrl.appendChild(voList);
    }
  }
//to-do  
  if(voStyle.display == "block") {
//    if(this.bReloadList) {
//      this.refreshList(poDocument);
//    }
    var voTable = this.subElement.table;
    var voDiv = null;
    for(var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      this.restoreRowColor(voDiv);
    }

    var voIterator = this.selectedItems.getKeyCollection().iterator();
    var vnIndex = -1;
    while(voIterator.hasNext()) {
      vnIndex = voIterator.next();
      voDiv = voTable.rows[vnIndex].cells[0].childNodes[0];
      this.changeRowColor(voDiv);
    }
    if(vnIndex != null) {
      var voItemGroupDf = this.itemgroup;
      var vnScrollTop = vnIndex * voItemGroupDf.height;
      voList.scrollTop = vnScrollTop;
    }
    if(this.collapseImage) {
      this.setAttrCtrl("backgroundImage", this.collapseImage, voBtn);
      voBtn["value"] = "";
    } else {
      this.setAttrCtrl("backgroundImage", "", voBtn);
      voBtn["value"] = "▲";
    }
  } else {
    if(this.expandImage) {
      this.setAttrCtrl("backgroundImage", this.expandImage, voBtn);
      voBtn["value"] = "";
    } else {
      this.setAttrCtrl("backgroundImage", "", voBtn);
      voBtn["value"] = "▼";
    }
  }
//  var vnListWidth = this.innerWidth - parseInt(this.listarea.df.borderLeftWidth) - parseInt(this.listarea.df.borderRightWidth) - 2 * this.listarea.df.cellSpacing;
  var vnListWidth = this.innerWidth - 2 * this.listarea.cellSpacing;

  if(vnListWidth < this.innerWidth) vnListWidth = this.innerWidth;  //2009-03-10 ehj
  var vnOffsetWidth = 0;

  // 2009.08.24 yhkim
  if(this.isScrolled())
    this.scrolled = true;
  else
    this.scrolled = false;

  if(this.scrolled) {
    vnListWidth = vnListWidth - this.listarea.scrollbarWidth;
  }

  voTable = this.subElement.table;

  if(this.listarea.widthByMaxLength){//아이템 길이에 따라 listarea가 변하는 경우
    for(var j = 0; j < voTable.rows.length; j++) {
      voDiv = voTable.rows[j].cells[0].childNodes[0];
      voOption = voDiv.childNodes[0];
  //    if(voOption.offsetWidth > vnListWidth) vnListWidth = voOption.offsetWidth;
  //  }

    //2009-03-10 ehj
      vnOffsetWidth = voOption.offsetWidth + 2 * this.listarea.cellSpacing;
       // 2009.08.24 yhkim
      if(this.scrolled)
        vnOffsetWidth = vnOffsetWidth - this.listarea.scrollbarWidth;
      if(vnOffsetWidth > vnListWidth) vnListWidth = vnOffsetWidth;
    }
  }else{//아이템 길이에 따라 listarea가 변하지 않는 경우
    //TODO
  }

   // 2009.08.24 yhkim
   if(this.scrolled == true) {
    this.subElement.list.style.overflowY = "auto";
    voTable.style.width = vnListWidth + "px";
    voList.style.width = (vnListWidth + this.listarea.scrollbarWidth) + "px";
  } else {
    this.subElement.list.style.overflowY = "hidden";
    voTable.style.width = vnListWidth + "px";
    voList.style.width = vnListWidth + "px";
  }
  
};
/**
 * listarea의 가로길이 설정
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.setListWidth = function() {
  var voTable = this.subElement.table;
  if (this.isScrolled()) {
    voTable.style.width = (this.innerWidth - this.listarea.scrollbarWidth)
        + "px";
  } else {
    voTable.style.width = this.innerWidth + "px";
  }
};
/**
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getOffsetWidth = function() {
  var vnListWidth = this.subElement.list.style.width;
  voTable = this.subElement.table;

  for ( var j = 0; j < voTable.rows.length; j++) {
    voDiv = voTable.rows[j].cells[0].childNodes[0];
    vsOption = voDiv.childNodes[0];
    if (vsOption.offsetWidth > vnListWidth)
      vnListWidth = vsOption.offsetWidth;
  }

  return parseInt(vnListWidth);
};
/**
 * 드롭다운 버튼에 click 이벤트 발생 메소드.
 * @param {HTMLInput(button)} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.click = function(poDocument) {
  this.lookup(this.id + "_btn", poDocument).click();
};
/**
 * itemset에 아이템 추가 메소드.
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.addToItemset = function(psName,
    poValue, poDocument) {
  var voComboItem = new eXria.controls.xhtml.ComboItem(psName, poValue, this);
  this.itemset.put(poValue, voComboItem);
  return voComboItem;
};
/**
 * frontItems혹은 backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psType 아이템 타입
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @example addItem("front", "라벨명", "value", 3);
 */
eXria.controls.xhtml.ComboBox.prototype.addItem = function(psType, psName,
    poValue, pnIndex, poDocument) {
  var voComboItem = new eXria.controls.xhtml.ComboItem(psName, poValue, this);
  var voItems = null;
  if (psType == "front")
    voItems = this.frontItems;
  else
    voItems = this.backItems;

  if (pnIndex == null) {
    voItems.put(poValue, voComboItem);
  } else {
    var voNewItems = new eXria.data.ArrayMap();
    var vnIndex = 0;
    var voIterator = voItems.getKeyCollection().iterator();
    var vsKey = null;
    while (voIterator.hasNext()) {
      if (vnIndex == pnIndex)
        voNewItems.put(poValue, voComboItem);
      vsKey = voIterator.next();
      voNewItems.put(vsKey, voItems.get(vsKey));
      vnIndex++;
    }
    if (psType == "front")
      this.frontItems = voNewItems;
    else
      this.backItems = voNewItems;
  }

  // var voCtrl = this.getCtrl(poDocument);
  // if(voCtrl != null) {
  // voComboItem.create(poDocument);
  // }

  return voComboItem;
};
/**
 * frontItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @example addItemFront("라벨명", "value", 3);
 */
eXria.controls.xhtml.ComboBox.prototype.addItemFront = function(psName,
    poValue, pnIndex, poDocument) {
  var voItem = this.addItem("front", psName, poValue, pnIndex, poDocument);
  return voItem;
};
/**
 * backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @example addItemBack("라벨명", "value", 3);
 */
eXria.controls.xhtml.ComboBox.prototype.addItemBack = function(psName, poValue,
    pnIndex, poDocument) {
  var voItem = this.addItem("back", psName, poValue, pnIndex, poDocument);
  return voItem;
};
/**
 * 지정된 인덱스에 해당하는 아이템 반환.
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @return 인덱스에 해당하는 아이템
 * @type eXria.controls.xhtml.ComboItem
 */
eXria.controls.xhtml.ComboBox.prototype.getItem = function(pnIndex) {
//  var voIterator = null;
//  var vnIndex = 0;
//  var voItem = null;
//
//  voIterator = this.frontItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (pnIndex == vnIndex)
//      return voItem;
//    vnIndex++;
//  }
//  voIterator = this.itemset.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (pnIndex == vnIndex)
//      return voItem;
//    vnIndex++;
//  }
//  voIterator = this.backItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (pnIndex == vnIndex)
//      return voItem;
//    vnIndex++;
//  }
//
//  return null;
    return this.itemIdxMap[pnIndex];
};
/**
 * @param {String} psName 아이템 라벨 문자.
 * @return 지정된 라벨에 해당하는 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getItemByName = function(psName) {
//  var voItems = null;
//  var voItem = null;
//  var voRet = null;
//  var vbBreak = false;
//  var vaItems = [ this.frontItems, this.itemset, this.backItems ];
//  for ( var i = 0; i < vaItems.length; i++) {
//    voItems = vaItems[i];
//    for ( var j = 0; j < voItems.size(); j++) {
//      voItem = voItems.get(j);
//      if (voItem.name == psName) {
//        voRet = voItem;
//        vbBreak = true;
//        break;
//      }
//    }
//    if (vbBreak)
//      break;
//  }
//
//  return voRet;
    return this.itemNmMap[psName];
};
/**
 * @param {String} psId 아이템 라벨 문자.
 * @return 지정된 라벨에 해당하는 아이템
 * @type eXria.controls.xhtml.ComboItem
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getItemById = function(psId) {
//  var voIterator = null;
//  var voItem = null;
//
//  voIterator = this.frontItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (voItem.id == psId)
//      return voItem;
//
//  }
//  voIterator = this.itemset.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (voItem.id == psId)
//      return voItem;
//  }
//  voIterator = this.backItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.visible == false)
//      continue;
//    if (voItem.id == psId)
//      return voItem;
//  }
//
//  return null;
    return this.itemIdMap[psId];
};
/**
 * 지정된 값을 포함한 아이템 얻어오기 위한 메소드
 * @param {String} psValue 검색할 값
 * @return 지정된 값을 포함한 아이템
 * @type eXria.controls.xhtml.ComboItem
 */
eXria.controls.xhtml.ComboBox.prototype.getItemByVal = function(psValue) {
//  var voItem = null;
//  var voIterator = this.frontItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.value == psValue)
//      return voItem;
//  }
//  voIterator = this.itemset.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.value == psValue)
//      return voItem;
//  }
//  voIterator = this.backItems.getValueCollection().iterator();
//  while (voIterator.hasNext()) {
//    voItem = voIterator.next();
//    if (voItem.value == psValue)
//      return voItem;
//  }
//  return null;
    return this.itemValMap[psValue];
};
/**
 * checkSelected
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 성공여부
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.checkSelected = function(poCtrl,
    poDocument) {
  var voCtrl = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var vaIndex = [];
  var i = -1;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    i++;
    if (voItem.selected == true)
      vaIndex.push(i);
    else
      this.restoreRowColorByIndex(i);
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    i++;
    if (voItem.selected == true)
      vaIndex.push(i);
    else
      this.restoreRowColorByIndex(i);
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    i++;
    if (voItem.selected == true)
      vaIndex.push(i);
    else
      this.restoreRowColorByIndex(i);
  }

//2009-04-03 hajubal 한개남은 체크박스 해제시 해제 안되는 문제 때문에 주석처리
//  if (vaIndex.length == 0 && this.df.selectedIndex != -1) {
//    if (this.getVisibleItemCount() > this.df.selectedIndex)
//      vaIndex.push(this.df.selectedIndex);
//  }
  this.listarea.select(vaIndex, poCtrl, poDocument);

  if (vaIndex.length > 0)
    return true;
  return false;
};
/**
 * 리스트 영역의 스크롤 버튼이 표시되었는지 여부 반환.
 * @return 리스트 영역의 스크롤 버튼이 표시되었는지 여부
 * @type Boolean
 */
eXria.controls.xhtml.ComboBox.prototype.isScrolled = function() {
  var vbScrolled = false;
  var voListAreaDf = this.listarea;
  if (voListAreaDf.overflow == "scroll")
    return true;
  if (voListAreaDf.overflow == "hidden")
    return false;
  var vnSize = this.getVisibleItemCount();
  if (voListAreaDf.heightBySize) {
    if (voListAreaDf.size != null && voListAreaDf.size < vnSize)
      vbScrolled = true;
  } else {
    var vnListHeight = (this.itemgroup.height + voListAreaDf.cellSpacing)
        * vnSize;
    if (vnListHeight)
      vnListHeight += voListAreaDf.cellSpacing;
    var vnHeight = voListAreaDf.height - voListAreaDf.borderTopWidth
        - voListAreaDf.borderBottomWidth;
    if (vnHeight < 0)
      vnHeight = 0;
    if (vnHeight < vnListHeight)
      vbScrolled = true;
  }

  return vbScrolled;
};
/**
 * 리스트 아이템 제거.
 * @param {String} psVal 아이템 값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.removeItem = function(psVal,
    poDocument) {
  var vnIdx = this.listarea.getIndexByVal(psVal);
  this.bReloadList = true;
  this.frontItems.remove(psVal);
  this.itemset.remove(psVal);
  this.backItems.remove(psVal);
  this.selectedItems.remove(vnIdx);
//  var voList = this.subElement.list;
//  var voStyle = voList.style;
//  if (voStyle.display != "none") {
    this.refreshList(poDocument);
//  }
};
/**
 * 모든 리스트 아이템 제거.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.removeAll = function(poDocument) {
  this.bReloadList = true;
  this.frontItems.clear();
  this.itemset.clear();
  this.backItems.clear();
  // var voList = this.subElement.list;
  // var voStyle = voList.style;
  // if(voStyle.display != "none") {
  this.refreshList(poDocument);
  // }
};
/**
 * clearSelected
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.clearSelected = function() {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voComboItem = null;
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  this.selectedItems.clear();
};
/**
 * 리스트 영역 새로 고침.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.refreshList = function(poCtrl,
    poDocument) {
  this.repaint(poDocument);
};
/**
 * 리스트 영역 innerHTML 반환.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 영역 innerHTML
 * @type String
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getListInnerHTML = function(poCtrl, poDocument) {
  var voDf = this.df;
  this.bScrolled = false;
  this.oldMultiselect = this.multiSelect;
  this.oldAppearance = this.apprearance;

  if (this.apprearance == "radio") {
    this.multiSelect = false;
  }

  var vaStrBuf = [];
  var vsKey = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voListItem = null;
  this.itemIdxMap = {};
  this.itemNmMap = {};
  this.itemValMap = {};
  this.itemIdMap = {};
  var vnIdx = 0;
  var vaValue = [];
  if(this.value instanceof Array) vaValue = this.value;
  else vaValue.push(this.value);
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    this.itemIdxMap[vnIdx++] = voListItem;
    this.itemNmMap[voListItem.name] = voListItem;
    this.itemValMap[voListItem.value] = voListItem;
    vaStrBuf.push(voListItem.getInnerHTML());
    this.itemIdMap[voListItem.id] = voListItem;
    for ( var j = 0; j < vaValue.length; j++) {
      if (vaValue[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }

  if(this.seqNum !== vnIdx) this.seqNum = vnIdx;

  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    this.itemIdxMap[vnIdx++] = voListItem;
    this.itemNmMap[voListItem.name] = voListItem;
    this.itemValMap[voListItem.value] = voListItem;
    vaStrBuf.push(voListItem.getInnerHTML());
    this.itemIdMap[voListItem.id] = voListItem;
    for ( var j = 0; j < vaValue.length; j++) {
      if (vaValue[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }

  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    this.itemIdxMap[vnIdx++] = voListItem;
    this.itemNmMap[voListItem.name] = voListItem;
    this.itemValMap[voListItem.value] = voListItem;
    vaStrBuf.push(voListItem.getInnerHTML());
    this.itemIdMap[voListItem.id] = voListItem;
    for ( var j = 0; j < vaValue.length; j++) {
      if (vaValue[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;

  return vsRet;

};
/**
 * 아이템의 배경 색상 변경.
 * @param {HTMLDiv} poDiv 아이템의 실체화 객체
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.changeRowColor = function(poDiv) {
  var voTable = this.subElement.table;
//  alert(this.listarea.focusBackgroundColor + "\n" + this.listarea.focusColor, voTable);
  this.setAttrCtrl("backgroundColor", this.listarea.focusBackgroundColor,  poDiv);
  // yhkim 2009.09.04
  //this.setAttrCtrl("color", this.listarea.focusColor, voTable);
  this.setAttrCtrl("color", this.listarea.focusColor, poDiv);
};

/**
 * 아이템의 배경 색상 변경.
 * @param {HTMLDiv} pnIndex 아이템의 인덱스
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.changeRowColorByIndex = function(pnIndex) {
  var voDiv = null;
  var voTable = this.lookup(this.id + "_listarea_table", this.getComboboxCtrl("document"));

  voDiv = voTable.rows[pnIndex].cells[0].childNodes[0];

  this.changeRowColor(voDiv);
};

/**
 * 변경된 아이템의 색상을 원래대로 되돌림.
 * @param {HTMLDiv} pnIndex 아이템의 인덱스
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.restoreRowColorByIndex = function(pnIndex) {
  var voDiv = null;
//  var voTable = this.lookup(this.id + "_listarea_table");
  var voTable = this.subElement.table;
  if(voTable.rows.length == 0) return;
  var voRowCtrl = voTable.rows[pnIndex];
  if(voRowCtrl) {
    voDiv = voRowCtrl.cells[0].childNodes[0];
    this.restoreRowColor(voDiv);
  }
};
/**
 * 변경된 아이템의 색상을 원래대로 되돌림.
 * @param {HTMLDiv} poDiv 아이템의 실체화 객체
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.restoreRowColor = function(poDiv) {
  var voTable = this.subElement.table;
  if(this.listarea.backgroundColor) this.setAttrCtrl("backgroundColor", this.listarea.backgroundColor, poDiv);
  else this.setAttrCtrl("backgroundColor", "", poDiv);
  // yhkim 2009.09.04
  //if(this.listarea.color) this.setAttrCtrl("color", this.listarea.color, voTable);
  //else this.setAttrCtrl("color", "", voTable);
  if(this.listarea.color) this.setAttrCtrl("color", this.listarea.color, poDiv);
  else this.setAttrCtrl("color", "", poDiv);
};

/**
 * 선택된 아이템을 제외한 변경된 아이템의 색상을 원래대로 되돌림.
 * @param {HTMLTable} poTable
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.nonSelectedRestoreColor = function(poTable){
  var voData = null;
  var voDiv = null;
  var voCollection = this.selectedItems.getKeyCollection()
  var vnLoop01 = poTable.rows.length;
  var vnLoop02 = voCollection.size();
  var vnIndex = null;
  var voItem = null;
  for ( var i = 0; i < vnLoop01; i++) {
    voDiv = poTable.rows[i].cells[0].childNodes[0];

    var vbSelected = false;

    for( var j = 0; j < vnLoop02; j++) {
      vnIndex = voCollection.get(j)
      voItem = this.getItem(vnIndex);

      if (voItem.id == voDiv.id) {
        vbSelected = true;
        break;
      }
    }

    if (!vbSelected) this.restoreRowColor(voDiv);
  }

};
/**
 * 선택된 리스트 아이템 값 반환.
 * @param {Boolean} pbUpdateText 텍스트 박스 갱신여부
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 선택된 리스트 아이템 값
 * @type String|Array(String)
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.getSelectedValue = function(
    pbUpdateText, poCtrl, poDocument) {
  if (poCtrl == null)
    poCtrl = this.getCtrl(poDocument);
  var voSbLabel = new eXria.lang.StringBuilder();
  var vnIndex = null;
  var vsLabel = null;
  var vaValue = [];

  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var voComboItem = null;
  while (voIterator.hasNext()) {
    vnIndex = voIterator.next();
    voComboItem = this.getItem(vnIndex);
    //voSbLabel.append(eXria.controls.xhtml.Util.parseLang(voComboItem.name));
    voSbLabel.append(voComboItem.name);
    voSbLabel.append(";");
    vaValue.push(voComboItem.value);
  }

  vsLabel = voSbLabel.toString();
  if (vsLabel.lastIndexOf(";") == vsLabel.length - 1) {
    vsLabel = vsLabel.substring(0, vsLabel.length - 1);
  }
  if (pbUpdateText) {
    var voText = this.subElement.input;
    voText.value = vsLabel;
  }

  if (vaValue.length > 1)
    return vaValue;
  else
    return vaValue[0];
};
/**
 * 선택된 리스트 아이템들을 반환.
 * @return 선택된 리스트 아이템 배열
 * @type Array(eXria.controls.xhtml.ComboItem)
 */
eXria.controls.xhtml.ComboBox.prototype.getSelectedItems = function() {
  var vnIndex = null;
  var vaItem = [];

  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var voListItem = null;
  while (voIterator.hasNext()) {
    vnIndex = voIterator.next();
    voListItem = this.getItem(vnIndex);
    vaItem.push(voListItem);
  }

  return vaItem;
};

/**
 * 선택된 리스트 아이템들을 반환.
 * @return 선택된 리스트 아이템 index
 * @type Array(eXria.controls.xhtml.ComboItem)
 */
eXria.controls.xhtml.ComboBox.prototype.getSelectedIndexes = function() {
  var vnIndex = null;
  var vaItem = [];

  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var voListItem = null;
  while (voIterator.hasNext()) {
    vnIndex = voIterator.next();
    vaItem.push(vnIndex);
  }
  return vaItem;
};


/**
 *
 * @param e
 * @return
 * @private
 */
eXria.controls.xhtml.ComboBox.prototype.finalkeydown = function(e){

  var voEvent = new eXria.event.Event(e, this.window);
  var vnKeyCode = e.keyCode;

  if(vnKeyCode == '38' || vnKeyCode == '40' ||vnKeyCode == '16' || vnKeyCode == '17')//화살표 위, 아래, shift, ctrl
    voEvent.stopEvent();
};

/**
 * 텍스트 박스에 텍스트 입력 시 아이템 리스트에 입력된 값과 일치하는 아이템이 있는지를 체크. Firefox에서는 텍스트 박스에서 포커스
 * out시에도 이벤트가 발생함.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.atkeyup = function(e) {
  if(e.target != this.subElement.input) return;
  var vnKeyCode = e.keyCode;

  if(vnKeyCode == '16' || vnKeyCode == '17'){
    this.bMultiSelectKeyDown = false;
    return;
  }
  if(vnKeyCode == '38' || vnKeyCode == '40')//화살표 위, 아래
    return;
  if(vnKeyCode == '13' && this.isCallByItemEnter) {
    this.isCallByItemEnter = false;
    return;
  }

  // vnKeyCode == 229 조건에 Firefox에서는 텍스트 박스에서 포커스 out에 대한 체크
  if (vnKeyCode == 229 || vnKeyCode == this.constKey["CTRL"]
      || vnKeyCode == this.constKey["TAB"]) {
    return;
  }
  var voText = this.subElement.input;

  if (voText.value == this.oldText || this.readOnly == true)
    return;

  this.oldText = voText.value;
  this.isChanged = true;
//  this.selectedItems.clear();
//  this.selectedIndex = -1;

  var vsOption = null;
  var voTable = null;
  var voDiv = null;
  var vsText = null;
  var voTable = this.subElement.table;
  var voList = this.subElement.list;
  var vnItemHeight = this.itemgroup.height;
  // 옵션리스트의 diaplay가 none이 아니여야지만 옵션리스트의 하위 옵션리스트테이블이 lookup가능
  this.focusedItemCtrl = null;
  for ( var j = 0; j < voTable.rows.length; j++) {
    voDiv = voTable.rows[j].cells[0].childNodes[0];
    if(!voDiv.childNodes[0].rows[0].cells[0].lastChild) continue;

    vsOption = voDiv.childNodes[0].rows[0].cells[0].lastChild.data;
    if (voText.value.length > 0 && vsOption.indexOf(voText.value) != -1) {
//      if(this.selectedIndex == -1) {
//        this.selectedIndex = vsOption.indexOf(voText.value);
//      }
      this.isCallByKeyIn = true;
      this.showList(true);

      var vbDeselected = true; // 한 번의 loop문 사용으로 row 색상의 변경과 복원을 수행하기 위한 플래그 값
      voTable = this.lookup(this.id + "_listarea_table", this.getComboboxCtrl("document"));
      for ( var i = 0; i < voTable.rows.length; i++) {
        voDiv = voTable.rows[i].cells[0].childNodes[0];
        if(!voDiv.childNodes[0].rows[0].cells[0].lastChild) continue;
        vsText = voDiv.childNodes[0].rows[0].cells[0].lastChild.data;
        this.restoreRowColor(voDiv);
        if (vbDeselected && vsText == vsOption) {
          this.changeRowColor(voDiv);
          this.focusedItemCtrl = voDiv;
          vbDeselected = false;
          voList.scrollTop = i * vnItemHeight;
        }
      }
      return;
    }
  }
  var voTd = null;
  for ( var i = 0; i < voTable.rows.length; i++) {
    voTd = voTable.rows[i].cells[0];
    this.restoreRowColor(voTd);
  }
  this.focused = false;
  this.showList(false);
};
/**
 * 텍스트를 선택상태로 만들어주는 메소드
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.selectText = function() {
  var voCtrl = this.getCtrl();
  var voInput = this.getSubCtrl("input", voCtrl);
  var vnPos = voInput.value.length;
  if (vnPos == 0) {
    // voInput.focus();
  } else {
    if (voInput.createTextRange) {
      var range = voInput.createTextRange();
      range.collapse(true);
      range.moveEnd('character', vnPos);
      range.moveStart('character', 0);
      range.select();
    } else if (voInput.selectionEnd) {
      voInput.selectionStart = 0;
      voInput.selectionEnd = vnPos;
    }
  }
};
/**
 * 컨트롤에 값을 설정.
 * @param {String} psValue 설정될 값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.setValue = function(psValue, poDocument) {
  this.isChanged = false;
  var voDf = this.df;
  var vaValue = [];
  var vaItemVal = this.getItemByVal(psValue);
  if(vaItemVal){
    var voEvent = new eXria.event.Event(null, this.window);
    voEvent.object = vaItemVal;
    voEvent.objectType = "item";
    if(this.getItemByVal(this.value) != this.getItemByVal(psValue)) this.doitemchange(voEvent, this);
  }
  this.selectedIndex = -1;
  if (psValue instanceof Array) {
    vaValue = psValue
  } else {
    if (psValue != null) vaValue.push(psValue);
  }
  var vsOldVal = this.value;
  if(vsOldVal instanceof Array) vsOldVal = vsOldVal.join();
  var vsNewVal = vaValue.join();
  if(vsOldVal != vsNewVal) {
    this.value = vaValue;
    this.data.setData(psValue);
    this.reloadData(null, poDocument);
  }
};

/**
 * 텍스트 영역을 빈 문자열로 초기화.
 * @param {HTMLDocument} poDocument 윈도우 document 객체
 * @return void
 * @type void
 */
eXria.controls.xhtml.ComboBox.prototype.clearText = function(poDocument) {
  var voText = this.subElement.input;
  voText.value = "";
};
/**
 * 컨트롤에 설정된 값을 반환.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 컨트롤 value 속성 값.
 * @type String
 */
eXria.controls.xhtml.ComboBox.prototype.getValue = function(poDocument) {
  return this.value;
};

/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 해당 속성명의 디폴트 속성 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.ComboBox.prototype.getSpecificDefaultValue = function(
    psAttrName) {
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if (vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.ComboBox[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.ComboBox[vaAttrName[0]][vaAttrName[1]] != null ? eXria.controls.xhtml.Default.ComboBox[vaAttrName[0]][vaAttrName[1]]
        : vsDefaultValue;
  }
  if (vsDefaultValue === undefined) {
    // alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 보여지는 아이템 개수를 반환
 * @return 보여지는 아이템 개수
 * @type Number
 * @public
 */
eXria.controls.xhtml.ComboBox.prototype.getVisibleItemCount = function() {
  var vnCnt = 0;
  var voIterator = null;
  var voItem = null;
  voIterator = this.frontItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }

  return vnCnt;
};

/**
 * 현재 선택된 Label값을 가져옴
 * @return Label 텍스트
 * @type String
 */
eXria.controls.xhtml.ComboBox.prototype.getText = function() {
  var voCtrl = this.getCtrl();
  var voInput = this.getSubCtrl("input", voCtrl);
  return voInput.value;
};
/**
 * 클래스 명을 반환.
 * @return "ComboBox"
 * @type String
 */
eXria.controls.xhtml.ComboBox.prototype.toString = function() {
  return "ComboBox";
};

/*************************************************
 * ComboBox 확장 메소드
 *************************************************/
/**
 * 콤보박스 컨트롤 필터링(확장메소드)
 * @member eXria.controls.xhtml.ComboBox
 * @param {String} psExpression 필터링 조건식 문자열
 * @type void
 * @example cbbUnitSystem.filterExt("system_id='NGEN'");
 * @author SUL at 12. 11. 28 오후 2:34
 */
eXria.controls.xhtml.ComboBox.prototype.filterExt = function(psExpression) {  
  //필터링 해제를 위한 Original-Path
  if(!this.hasOwnProperty("oldNodesetInstancePath")){
    this.oldNodesetInstancePath = this.data.nodesetInstancePath;
  }
  //필터링
  this.data.setNodesetRef(this.data.nodesetInstanceId, this.oldNodesetInstancePath+"["+psExpression+"]");
  this.refresh();
  
  //첫번째 아이템 자동선택
  if(this.getVisibleItemCount() > 0){
    this.listarea.select([0]);
  }
};

/**
 * 콤보박스에 적용된 필터를 취소한다.
 * @member eXria.controls.xhtml.ComboBox
 * @type void
 * @example cbbUnitSystem.cancleFilterExt();
 * @author SUL at 12. 11. 28 오후 2:35
 */
eXria.controls.xhtml.ComboBox.prototype.cancleFilterExt = function() {  
  if(this.hasOwnProperty("oldNodesetInstancePath")){
    this.data.setNodesetRef(this.data.nodesetInstanceId, this.oldNodesetInstancePath);
  }else{
    this.data.setNodesetRef(this.data.nodesetInstanceId, this.data.nodesetInstancePath);
  }
  this.refresh();
  
  //첫번째 아이템 자동선택
  if(this.getVisibleItemCount() > 0){
    this.listarea.select([0]);
  }
};

/**
 * @fileoverview
 * Input 컨트롤에 대한 xhtml 공통 클래스
 * @author kim doohwan
 */

/**
 * @class XHTML EditMask, InputBox, SecretBox의 상위클래스입니다.<br />
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.InputCommon 객체
 * @type eXria.controls.xhtml.InputCommon
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */

eXria.controls.xhtml.InputCommon = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  eXria.controls.xhtml.UIControl.call(this, psId,pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  ////속성
  /**
   * 컨트롤 설정 값.
   * @type String
   */
  this.value = null;
  /**
   * 입력 가능한 문자열의 최대 길이.
   * @type Number
   */
  this.maxLength = null;
  /**
   * 입력 가능한 문자열의 최소 길이.
   * @type Number
   */
  this.minLength = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 텍스트 세로 정렬 방식.<br>
   * "top" | "middle" | "bottom"
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트에 줄을 넣을때.<br>
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 텍스트의 대소문자를 지정할때.<br>
   * "capitalize" | "uppercase" | "lowercase"
   * @type String
   */
  this.textTransform = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 컨트롤의 안쪽 여백(단위 px).
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤의 안쪽 상단여백(단위 px).
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 안쪽 우측여백(단위 px).
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 안쪽 하단여백(단위 px).
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 안쪽 좌측여백(단위 px).
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤이 포커싱 되어 있는지 여부
   * @private
   */
  this.focused = false;
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  /**
   * 사용자 정의 nullable 속성
   * @type Boolean
   */
  this.nullable = true;
  /**
   * input element ime-mode 설정 속성
   * @type String
   */
  this.imeMode = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.InputCommon);

eXria.controls.xhtml.InputCommon.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["accesskey"] = this.accessKey;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

eXria.controls.xhtml.InputCommon.prototype.refreshTemplate = null;

eXria.controls.xhtml.InputCommon.prototype.setSpecificEvents = function(poCtrl){
  var voInput = this.subElement.input;
  //@data  TODO: 테스트 필요...
  voInput.control = this;
//  this.eventManager.removeListener(poCtrl, "onmouseover", this.mediateEvent);
//  this.eventManager.removeListener(poCtrl, "onmouseout", this.mediateEvent);
//  this.eventManager.addListener(voInput, "onmouseover", this.mediateEvent);
//  this.eventManager.addListener(voInput, "onmouseout", this.mediateEvent);
//  this.eventManager.addListener(voInput, "onchange", this.mediateEvent);
  this.eventManager.addListener(voInput, "onfocus", this.mediateEvent);
  this.eventManager.addListener(voInput, "onblur", this.mediateEvent);
  this.eventManager.addListener(voInput, "onselect", this.mediateEvent);
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputCommon.prototype.finalkeydown = function(e) {
  this.isEnter = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputCommon.prototype.atkeyup = function(e){
  var vnMaxByteLength = this.maxByteLength;
  if(!vnMaxByteLength) return;

  vnMaxByteLength = Number(vnMaxByteLength);
  var voInput = this.subElement.input;
  var vsValue = voInput.value;
  if(eXria.util.StringUtil.getByteLength(vsValue) > vnMaxByteLength){
    this.isEditing = true;
    voInput.disabled = true;
    voInput.disabled = false;
    var vnLength = vsValue.length;
    for(var i = 1; i < vnLength; i++) {
      if(eXria.util.StringUtil.getByteLength(vsValue.substring(0,vnLength - i)) <= vnMaxByteLength) {
        voInput.value = vsValue.substring(0,vnLength - i);
        break;
      }
    }

    var vnPos = voInput.value.length;
    if (voInput.createTextRange) {
      var range = voInput.createTextRange();
      range.collapse(true);
      range.moveEnd('character', vnPos);
      range.moveStart('character', vnPos);
      range.select();
    } else if (voInput.selectionEnd) {
      voInput.selectionStart = vnPos;
      voInput.selectionEnd = vnPos;
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputCommon.prototype.doblur = function() {
  var voInput = this.subElement.input;
  var voDocument  = this.document;

  if(this.toString && this.toString() == "DateInput"){
    this.calendarShowed = false;
  };
  try{
    if(voDocument.activeElement == voInput) {
      voInput.blur();
      voInput.disabled = true;
      voInput.disabled = false;
    }
  }catch(err){}
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputCommon.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
};

eXria.controls.xhtml.InputCommon.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  //if(this.data.instanceId == null || this.data.isRelativeRef()) return;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  this.setValue(vsRefData);
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputCommon.prototype.loadComplete = function(poDocument, pbReloadData) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  if(this.onchangeInitValue == null) this.onchangeInitValue = voInput.value;

  // todo : yhkim 2009.09.08 실제 이 코드는 사용자 정의 css때문에 정의 된 것인데 inputbox계열 outer는 back-ground color가 있어야 한다
  //var voSubElement = this.getSubCtrl("input", voCtrl, poDocument);
  if(voInput) {
    var vsColor = this.getStyleCurrentValue(voInput, "background-color", "backgroundColor");
    if(vsColor) this.setAttrCtrl("backgroundColor", vsColor, voCtrl);
  }

  this.setInputHeight(voCtrl);
  this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);

  // refreshspecific과 reloadData에서 중복 호출 됨으로써 padding-left가 초기화되는 현상 방지
  if(!pbReloadData) this.setInputWidth(poDocument);
};
/**
 * input element 의 가로 길이 설정 메소드.
 * @private
 */
eXria.controls.xhtml.InputCommon.prototype.setInputWidth = function() {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement.input;
  var vnPaddingLeft = parseInt(this.getStyleCurrentValue(voSubElement, "padding-left", "paddingLeft"), 10);
  var vnPaddingRight = parseInt(this.getStyleCurrentValue(voSubElement, "padding-right", "paddingRight"), 10);
  var vnBorderLeft = parseInt(this.getStyleCurrentValue(voCtrl, "border-left-width", "borderLeftWidth"), 10);
  var vnBorderRight = parseInt(this.getStyleCurrentValue(voCtrl, "border-right-width", "borderRightWidth"), 10);
  vnPaddingLeft = vnPaddingLeft == null ? 0 : vnPaddingLeft;
  vnPaddingRight = vnPaddingRight == null ? 0 : vnPaddingRight;
  vnBorderLeft = vnBorderLeft == null ? 0 : vnBorderLeft;
  vnBorderRight = vnBorderRight == null ? 0 : vnBorderRight;

  //상위 Dom이 display 가 none 일경우 offsetWidth 를 통해서 제대로된
  //width값이 넘어 오지 안기 때문에
  //voCtrl.offsetWidth 를 this.width 로 변경
  //2011.04.21

  var vnWidth = this.width - vnBorderLeft - vnBorderRight - 1;
  vnWidth = vnWidth - (vnPaddingLeft + vnPaddingRight);
  this.setAttrCtrl("left", vnPaddingLeft, voSubElement);
  this.setAttrCtrl("width", vnWidth, voSubElement);
  this.setAttrCtrl("paddingLeft", "0px", voSubElement);
  this.setAttrCtrl("paddingRight", "1px", voSubElement);
  if(this.subElement.divDate  && this.width > 0 )
    this.setAttrCtrl("left", this.width - vnBorderRight - this.imgAreaWidth - vnPaddingRight, this.subElement.divDate);
  if(this.subElement.divSpin && this.width > 0 )
    this.setAttrCtrl("left", this.width - vnBorderRight - this.spinWidth - vnPaddingRight, this.subElement.divSpin);
};

eXria.controls.xhtml.InputCommon.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument, true);
};

eXria.controls.xhtml.InputCommon.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
  this.maskLen = null;
};
/**
 * 텍스트 박스의 텍스트 세로 길이 설정 메소드.
 * @param {HTMLDiv} poCtrl
 * @private
 */
eXria.controls.xhtml.InputCommon.prototype.setInputHeight = function(poCtrl){
  var voInput = this.subElement.input;
  var vsText = voInput.value;
  var voSpan = this.subElement.span;
  voSpan.innerHTML = "&nbsp;";

//  var vnHeight = voSpan.offsetHeight;
//  this.setAttrCtrl("height", vnHeight, voInput);

  var vnHeight = voSpan.offsetHeight;

  //TODO : 임시처리
  if(!!vnHeight) this.backupHeight = vnHeight;
  if(!!this.backupHeight) vnHeight = this.backupHeight;

  var voCtrl = this.ctrl;
  var vnPaddingTop = parseInt(this.getStyleCurrentValue(voInput, "padding-top", "paddingTop"), 10);
  var vnPaddingBottom = parseInt(this.getStyleCurrentValue(voInput, "padding-bottom", "paddingBottom"), 10);
  var vnBorderTop = parseInt(this.getStyleCurrentValue(voCtrl, "border-top-width", "borderTopWidth"), 10);
  var vnBorderBottom = parseInt(this.getStyleCurrentValue(voCtrl, "border-bottom-width", "borderBottomWidth"), 10);

  //var vnHeight = this.height - (vnPaddingTop+vnPaddingBottom);
  //vnHeight = vnHeight - (vnBorderTop + vnBorderBottom);

  this.setAttrCtrl("paddingTop", vnPaddingTop+"px", voInput);
  this.setAttrCtrl("paddingBottom", vnPaddingBottom+"px", voInput);
  this.setAttrCtrl("borderTopWidth", vnBorderTop +"px", voInput);
  this.setAttrCtrl("borderBottomWidth", vnBorderBottom+"px", voInput);

  //top의 위치 조정은 setVerticalAlign 에서 담당
  //this.setAttrCtrl("top", (vnPaddingTop+vnPaddingBottom)+(vnBorderTop + vnBorderBottom), voInput);

  this.setAttrCtrl("height", vnHeight, voInput);

};
/**
 * 컨트롤 텍스트 수직정렬을 새로고침 합니다.
 */
eXria.controls.xhtml.InputCommon.prototype.refreshVerticalAlign = function() {
  var voCtrl = this.ctrl;
  if(voCtrl == null) return;
  var voDf = this.df;
  var voInput = this.subElement.input;
  this.setInputHeight();
  this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
};
/**
 * 컨트롤의 값을 반환합니다.
 * @return 컨트롤에 할당된 값
 * @type String
 */
eXria.controls.xhtml.InputCommon.prototype.getValue = function(){
  return this.value;
};
/**
 * 입력필드에 보여지는 텍스트값을 반환합니다.
 * @return 입력필드에 보여지는값
 * @type String
 */
eXria.controls.xhtml.InputCommon.prototype.getText = function() {
  var voInput = this.subElement.input;
  var vsText = voInput.value;
  return vsText;
};
/**
 * 텍스트를 선택상태로 만듭니다.
 */
eXria.controls.xhtml.InputCommon.prototype.selectText = function() {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vnPos = voInput.value.length;
  if(vnPos == 0) {
    try { voInput.focus(); }catch(err) {}
  }else {
    var vsText = voInput.value;
    if(this.value != vsText && vsText == "NaN") {
      voInput.value = "";
      vnPos = 0;
    }
    if (voInput.createTextRange) {
      var range = voInput.createTextRange();
      range.collapse(true);
      range.moveEnd('character', vnPos);
      range.moveStart('character', 0);
      range.select();
    } else if (voInput.selectionEnd) {
      voInput.selectionStart = 0;
      voInput.selectionEnd = vnPos;
      if(this.focused == false){
        try { voInput.focus(); }catch(err) {}
        this.focused = true;
      }
    }
  }
};
/**
 * 데이트형 입력 값이 mask에 형태와 다르게 숫자만 입력될 경우
 * mask에 숫자 부분에 해당되는 값만을 가져오기 위한 메소드;
 * @param {String} psInputVal input 영역에 입력된 값
 */
eXria.controls.xhtml.InputCommon.prototype.filterDateInput = function(psInputVal){
  var vsRet = psInputVal;
  if(/^\d*$/.test(vsRet) == false || vsRet == "") return vsRet;
  var vsDigitMask = this.mask;
  if(vsDigitMask == null || vsDigitMask == "") return vsRet;
  vsDigitMask = vsDigitMask.replace(/[^YyMDdhms]/g, "");
  if(vsRet.length > vsDigitMask.length) vsRet = vsRet.substring(0, vsDigitMask.length);
  return vsRet;
};
/**
 * 커서 위치를 설정합니다.
 * @param {Number} pnPos 커서 위치 값
 */
eXria.controls.xhtml.InputCommon.prototype.setCursorPosition = function(pnPos) {
  var voInput = this.subElement.input; 
  
  if(this.focused == false) {
    var voBase = this;
    this.afFocusAct = { func : voBase.setCursorPosition,
                      args : [pnPos]};
  }
  if(voInput.selectionEnd) {
    voInput.selectionStart = pnPos;
    voInput.selectionEnd = pnPos;
  } else if (voInput.createTextRange) {
    var voRange = voInput.createTextRange();
    voRange.collapse(true);
    voRange.moveEnd('character', pnPos);
    voRange.moveStart('character', pnPos);
    voRange.select();
  }
};

/**
 * @fileoverview
 * Concreate xhtml DateInput(XHTML DateInput 컨트롤)
 * @author 이종녕
 */

/**
 * @class 날짜 입력필드이며 입력받은 숫자를 설정한 DateFormat에 유효한값으로 나타내어 줍니다.<br />
 * XHTML DateInput Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.DateInput 객체
 * @type eXria.controls.xhtml.DateInput
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.DateInput = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 200 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.InputCommon.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  //  속성
  /**
   * 컨트롤 설정 값.
   * @type String
   */
  this.value = null;
  /**
   * 읽기 전용 여부.
   * @type String
   */
  this.readOnly = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 텍스트에 밑줄을 넣을때.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 하위 컨트롤인 calendar에 대한 참조.
   * @type eXria.controls.xhtml.Calendar
   */
  this.calendar = null;
  /**
   * DateInput에 속한 calendar 컨트롤의 활성화 여부.<br>
   * @type boolean
   */
  this.calendarEnable = null;
  /**
   * format type
   * @type String
   * @private
   */
  this.formatType = "date";
  /**
   * mask string
   * @type String
   */
  this.mask = null;
  /**
   * Date의 출력 포맷
   * @type String
   */
  this.dateFormat = null;
  /**
   * 날짜 입력란에 표시될 문자를 지정한다.<br>
   * "Underscore" | "WhiteSpace" | "Asterisk" | "Dash"
   * @type String
   */
  this.maskPrompt = null;
  /**
   * 날짜의 최소.
   * @type Date
   */
  this.min = null;
  /**
   * 날짜의 최대.
   * @type Date
   */
  this.max = null;
  /**
   * calendar를 실행시키는 이미지의 url.
   * @type String
   */
  this.calendarImageUrl = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   */
  this.innerHeight = this.height;
  /**
   * 이미지가 위치한 영역의 가로 길이.
   * @type Number
   */
  this.imgAreaWidth = 20;
  /**
   * 컨트롤의 안쪽 여백(단위 px).
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤의 안쪽 상단여백(단위 px).
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 안쪽 우측여백(단위 px).
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 안쪽 하단여백(단위 px).
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 안쪽 좌측여백(단위 px).
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 버튼의 커서모양.
   * @type String
   */
  this.btnCursor = null;
  /**
   * 숫자가 아닌 문자 체크를 위한 정규식 표현(/[^\d]/gi).
   * @type RegExp
   */
  this.noDigits = /[^\d]/gi;
  /**
   * 공백 문자 체크를 위한 정규식 표현(/\s/g).
   * @type RegExp
   */
  this.blank = /\s/g;
  /**
   * date mask 체크를 위한 정규식 표현(/[YMDhms]/gi).
   * @type RegExp
   */
  this.regDateMask = /[YMDhms]/gi;
  /**
   * 한글 필터링 정규식 구문([ㄱ-ㅎ가-힝])
   * @type String
   */
  this.regExpHG = "[ㄱ-ㅎ가-힝]";
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  /**
   * 이벤트 키값 상수 저장 오브젝트<br>
   * SHIFT: 16<br>
   * LEFT: 37<br>
   * UP: 38<br>
   * RIGHT: 39<br>
   * DOWN: 40<br>
   * ENTER: 13<br>
   * TAB: 9<br>
   * BACKSPACE: 8<br>
   * DEL: 46<br>
   * @type Object
   */
  this.constKey = {
    SHIFT: 16,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    TAB: 9,
    BACKSPACE: 8,
    DEL: 46
  };
  /**
   * 그리드 달력 활용을 위한 Defaults.xml의 경로 설정
   * @type String
   */
  this.defaultFileName = null;
  /**
   * 그리드 달력 활용을 위한 Text.xml의 경로 설정
   * @type String
   */
  this.textFileName = null;
  /**
   * readOnly속성과 Calendar동기화
   */
  this.readOnlyWithCalendar = null;

  /**
   * 시분초 입력영역 hide 처리
   * @type Boolean
   * @private
   */
  this.noUseHMS = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.InputCommon, eXria.controls.xhtml.DateInput);

//////////////////////////////////////////////////////////////////
//  메소드

eXria.controls.xhtml.DateInput.prototype.createSubCtrl = function(poCtrl, poDocument) {
  if(this.calendar == null) this.calendar = new eXria.controls.xhtml.Calendar(this.id + "calendar", this.width, this.height, 180, 180, true);
};

eXria.controls.xhtml.DateInput.prototype.setTemplate = function(poCtrl, poDocument) {

  this.calendar.defaultFileName = this.getAttrValue("defaultFileName", this.defaultFileName);
  this.calendar.textFileName = this.getAttrValue("textFileName", this.textFileName);
  this.calendar.loadDefaultSpce();

  this.template = [];
  var vaTemplate = this.template;
  //데이터를 입력받는 입력 태그
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<input id='" + this.id + "_text' type='text' class='" + vsClass + "' onclick = \"");
  vaTemplate.push(this.getEHandler(this.id, "updateCursorPosition"));
  vaTemplate.push("\" ");
  vaTemplate.push("@attStrBuf"); // 0 input attribute
  vaTemplate.push(" style=\"");
  vaTemplate.push("@cssStrBuf"); // 1 input style
  vaTemplate.push("\"/>");
  //미니 달력 아이콘
  vaTemplate.push("<div style=\"");
  vaTemplate.push("@cssStrBuf"); // 2 div style
  vaTemplate.push("\">");
  vaTemplate.push("<table style='width:100%; height:100%' cellspacing='0'><tbody><tr><td style='text-align:center;vertical-align:middle' >");
  vaTemplate.push("<img id='" + this.id + "_icon' style=\"");
  vaTemplate.push("@cssStrBuf"); // 3 img style
  vaTemplate.push("\" ");
  vaTemplate.push("@attStrBuf"); // 4 img attribute
  vaTemplate.push("/>");
  vaTemplate.push("</td></tr></tbody></table></div>");
  vaTemplate.push("<span class='" + vsClass + "' style=\"");
  vaTemplate.push("@cssStrBuf"); // 5 span
  vaTemplate.push("\"/>");
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

eXria.controls.xhtml.DateInput.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.noUseHMS = this.getAttrValue("noUseHMS", this.noUseHMS);
  this.verticalAlign = this.getAttrValue("verticalAlign", this.verticalAlign);
  this.value = this.getAttrValue("value",this.value);
  this.readOnly = this.getAttrValue("readonly",this.readOnly);
  this.calendarEnable = this.getAttrValue("calendarEnable",this.calendarEnable);
  this.readOnlyWithCalendar = this.getAttrValue("readOnlyWithCalendar", this.readOnlyWithCalendar);
  this.formatType = this.getAttrValue("formatType", this.formatType);
  this.format = this.getAttrValue("format", this.format);
  this.mask = this.getAttrValue("mask", this.mask);
  if(this.mask == null || this.mask  == "") this.mask = "yyyyMMdd";
  if(this.mask != null && this.mask != "") this.maskLen = this.mask.length;
  if(this.regFormat == null || this.regFormat == "") this.regFormat = "yyyy-MM-dd";
  if(this.regMask == null || this.regMask == "") this.regMask = "yyyyMMdd";
  if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
  else this.dataLen = 8;
  this.min = this.getAttrValue("min",this.min);
  this.max = this.getAttrValue("max",this.max);
  this.calendarImageUrl = this.getAttrValue("calendarImageUrl", this.calendarImageUrl);
  this.btnCursor = this.getAttrValue("btnCursor", this.btnCursor);
  if(this.value == null) this.value = "";
  this.maxCanvasWidth = this.getAttrValue("maxCanvasWidth", this.maxCanvasWidth);
  this.maxCanvasHeight = this.getAttrValue("maxCanvasHeight", this.maxCanvasHeight);

  //
  //
  if(this.userAttr == "") this.userAttr = null;
  this.userAttr = this.getAttrValue("userAttr", this.userAttr);
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    if(!!voUserAttr.keepMultiSelector)  this.calendar.keepMultiSelector = true;
  }
};

eXria.controls.xhtml.DateInput.prototype.setSpecificAttrs = function(poCtrl, poDocument){
  // /////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  // /////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");
  // ////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  // ////////////////////////////////////////////////////////////////////////////////////////

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "value", this.value);
  if(this.readOnly) vfcSetAttStrBuf(vaAttStrBuf, "readOnly", this.readOnly);
  vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maskLen);
  vfcSetAttStrBuf(vaAttStrBuf, "minLength", this.minLength);
  vaTemplate[voIndexMap.get(0)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transform", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;top:0px;");
  var vnWidth = this.innerWidth;
  if(this.imgAreaWidth !== null) vnWidth = vnWidth - this.imgAreaWidth;
  vfcSetCssStrBuf(vaCssStrBuf, "left", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.imgAreaWidth, "px");

  //2010.07.05
  //DateInput 달력선택 이미지 보여짐 수정
  if (! this.calendarEnable){
    vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  }
  vaTemplate[voIndexMap.get(2)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("border-style:none;");
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "inline");
  }
  else {
    if (! this.calendarEnable){
      vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    }
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "inline");
  }
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.btnCursor);
  vaTemplate[voIndexMap.get(3)] = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "src", this.calendarImageUrl);
  vaTemplate[voIndexMap.get(4)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(5)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  voIndexMap.clear();

  var voCalendar = this.calendar;
  voCalendar.canvas = this.canvas;
  voCalendar.window = this.window;
  voCalendar.document = this.document;

  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;

  this.setSubElement(poDocument);

  var voInputCtrl = this.subElement.input;
  //this.runDateFormat(this.value, voInput);
  var vsValue = this.value;
  if(vsValue != null && vsValue != ""){
   vsValue = this.getDate(vsValue).getTime();
  }
  voInputCtrl.value = TGP.GetString(vsValue, this.formatType, this.regFormat);

  var voDateinput_icon = poCtrl.getElementsByTagName("img")[0]; // 수정필요
  //voCalendar.style.visibility = "hidden";
  voDateinput_icon.control = this;
  voDateinput_icon.onclick = function(e){
   var voControl = this.control;
   var voCanvas = voControl.canvas;

   var getPositionLeft = function(poControl){
     var vnL = poControl.left;
     if(poControl.parent) vnL = vnL + getPositionLeft(poControl.parent);
     return vnL;
   }

   var getPositionTop = function(poControl){
     var vnT = poControl.top;
     if(poControl.parent) vnT = vnT + getPositionTop(poControl.parent);
     return vnT;
   }

   if(voCanvas.collapseControl && voCanvas.collapseControl.id != voControl.id) {
     voCanvas.doCollapseControl(voCanvas);
   }
   var voCalendar = voControl.calendar;
   var voCalendarCtrl = voCalendar.getCtrl(poDocument);
   if(voCalendarCtrl) {
     voCalendar.hide();
     this.calendarShowed = false;
     voCanvas.collapseControl = null;
     return;
   }

   //voCalendar.style.visibility = "visible";
   var e = e || window.event;
   if(voControl.calendarEnable) {
     var voCtrl = voControl.getCtrl();
     voCalendar.setDate(voControl.getDate(voControl.value));
     voCalendar.type = "Dateinput";
     voCalendar.fontSize = 10;
     voCalendar.setTarget(voControl);

     //전체화면의 크기
     var vnCanvasWidth =  voControl.maxCanvasWidth || voControl.canvas.width;
     var vnCanvasHeight=   voControl.maxCanvasHeight || voControl.canvas.height;

     //컨트롤(DateInput)의 포지션
     var vnLeft = getPositionLeft(voControl);
     var vnTop = getPositionTop(voControl);

     //컨트롤(DateInput)의 크기
     var vnWidth = voControl.width;
     var vnHeight = voControl.height;

     var vsCSSStyle = {
          "GB": {
             "W":169,
             "H":161
          },
          "GL": {
             "W":196,
             "H":150
          },
          "GM": {
             "W":169,
             "H":161
          },
          "GO": {
             "W":169,
             "H":161
          },
          "GP": {
             "W":169,
             "H":161
          },
          "GR": {
             "W":169,
             "H":161
          },
          "GS": {
             "W":169,
             "H":161
          }
       }[voCalendar.CSS];

       //컨트롤(Calendar)의 크기
       var vnCalendarWidth  =  vsCSSStyle["W"];//voCalendar.width;
       var vnCalendarHeight =  vsCSSStyle["H"];//voCalendar.height;

       //컨트롤(Calendar)의 포지션
       var vnCalendarLeft;
       var vnCalendarTop;

       if( (vnLeft + vnWidth) >= vnCalendarWidth ) {
         vnCalendarLeft = voControl.left;
         if( (vnLeft + vnCalendarWidth) >= vnCanvasWidth ){
           vnCalendarLeft = (voControl.left + vnWidth) - vnCalendarWidth;
         }
       }else{
         vnCalendarLeft = (voControl.left + vnWidth) - vnCalendarWidth;
         if(vnCalendarLeft < 0){
           vnCalendarLeft = 0;
         }
       }

       if( vnCanvasHeight - (vnTop + vnHeight) >= vnCalendarHeight){
          vnCalendarTop = voControl.top + vnHeight;
       }else{
          vnCalendarTop = (voControl.top + 10) - vnCalendarHeight;
       }

       voCalendar.left = vnCalendarLeft;
       voCalendar.top = vnCalendarTop;
       voCalendar.position = "absolute";
       voCalendar.zIndex = 10000;


       if(voControl.parent && voControl.parent.ctrl){
        voControl.parent.ctrl.oriZindex = voControl.parent.ctrl.style.zIndex;
        voControl.parent.ctrl.style.zIndex = 50000;
       }

       voCalendar.show(voControl.parent);

       if(voControl.mask.length > 14 && !voControl.noUseHMS) {
          var vnTmp = voControl.getDate(voControl.value).getTime();
          voCalendar._showTimesInfo(TGP.GetString(vnTmp, voControl.formatType, 'HH:mm:ss'));
       }

       voControl.calendarShowed = true;
       voCanvas.collapseControl = voControl;
       var voCtrl = voCalendar.ctrl;
       voControl.setAttrCtrl("zIndex", 50000, voCtrl);
       voParent = voCalendar.parent;
       while(voParent) {
         if(voParent.ctrl) voControl.setAttrCtrl("zIndex", 50000, voParent.ctrl);
         voParent = voParent.parent;
       }
       voControl.lifted = true;
     }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.input = this.getSubCtrl("input", voCtrl, poDocument);
  voSubElement.divDate = this.getSubCtrl("div", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
  voSubElement.imgCtrl = this.getSubCtrl("img", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDiv = this.subElement.divDate;
  var voInput = this.subElement.input;
  var voDf  = this.df;
  switch(psAttrName) {
  case "width" :
    this.setInputWidth();
    this.calendar.left = this.width;
    break;
  case "height" :
    this.setAttrCtrl("height", this.innerHeight, voDiv);
    this.calendar.top = this.height;
    this.setVerticalAlign(voInput, poCtrl, this.verticalAlign);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.dofocus = function() {
  if(this.calendarShowed) return;
  var voInput = this.subElement.input;
  try { voInput.focus(); }catch(err) {}
};

eXria.controls.xhtml.DateInput.prototype.setSpecificEvents = function(poCtrl){
  var voInput = this.subElement.input;
  //@data  TODO: 테스트 필요...
  voInput.control = this;
  //this.eventManager.addListener(voInput, "onchange", this.mediateEvent);
  this.eventManager.addListener(voInput, "onfocus", this.mediateEvent);
  this.eventManager.addListener(voInput, "onblur", this.mediateEvent);
  this.eventManager.addListener(voInput, "onselect", this.mediateEvent);

  var add = "";
  var tt = this.regFormat && this.regFormat.indexOf('t')>=0 && this.regFormat.indexOf('h')>=0;
  if(tt) add+=Formats.AMDesignator.toUpperCase()+Formats.PMDesignator.toUpperCase();
  voInput.onkeypress = function(ev){ TestKey(ev?ev:event,this,TestKeyDate,add); }
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.atkeydown = function(e){
  if(e.keyCode == 13) {
    this.isEnter = true;
    if(true === this.calendar.keepMultiSelector){
      var voDf = this.df;
      var voCtrl = this.ctrl;
      var voInput = this.subElement.input;
      this.tempValue = voInput.value;
      var vsValue = voInput.value;
      vsValue = this.filterDateInput(vsValue);
      var vsRegMask = this.regMask;
      if(vsValue.length == 6) {
        vsValue = vsValue + '01';
        this.regMask = 'yyyy/MM/dd';
      }
      if(vsValue != null && vsValue != "") {
        vsValue = TGP.GetValueInput(vsValue, this.formatType, this.regMask);
        var voDate = new Date();
        voDate.setTime(vsValue);
        vsValue = this.getDateString(voDate);
        if(this.min != null && this.min != "") {
          if(this.getDate(vsValue).getTime() < this.getDate(this.min).getTime()) vsValue = this.min;
        }
        if(this.max != null && this.max != "") {
          if(this.getDate(vsValue).getTime() > this.getDate(this.max).getTime()) vsValue = this.max;
        }
      }
      this.regMask = vsRegMask;
      this.setValueWithNotify(vsValue);
    }else{
      var voCtrl = this.ctrl;
      var voInput = this.subElement.input;
      var vsInput = this.filterDateInput(voInput.value);
      vsInput = TGP.GetValueInput(vsInput, this.formatType, this.regMask);
      if(vsInput != null && vsInput != "") {
        var voDate = new Date();
        voDate.setTime(vsInput);
        vsInput = this.getDateString(voDate);
      }
      this.setValueWithNotify(vsInput);
     //voInput.blur();
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.atfocus = function(e) {
  var voInput = this.subElement.input;
  var vsValue = this.value;
  if(vsValue != null && vsValue != "") {
   vsValue = this.getDate(vsValue).getTime();
  }
  voInput.value = TGP.GetString(vsValue, this.formatType, this.regMask);
  if(this.focused != true) {
    var voCalendar = this.calendar;
    var voCalendarCtrl = voCalendar.getCtrl();
    if(voCalendarCtrl) {
      voCalendar.hide();
      this.calendarShowed = false;
      this.canvas.collapseControl = null;
    }
    this.selectText();
  }
  this.focused = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.atkeyup = null;
//eXria.controls.xhtml.DateInput.prototype.atkeyup = function(e) {
//  e = new eXria.event.Event(e, this.window);
//  this.checkKey(e);
//};
//eXria.controls.xhtml.DateInput.prototype.atselect = function(e) {
//  var voInput = this.subElement.input;
//  if (voInput.selectionEnd) {
//    this.selectionSize = voInput.selectionEnd - voInput.selectionStart;
//  } else if(document.selection && document.selection.createRange) {
//    var voRange = document.selection.createRange().duplicate();
//    this.selectionSize = voRange.text.length;
//  }
//};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.atblur = function(e) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  this.setInputHeight(voCtrl);
  this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
  this.focused = false;
  this.tempValue = voInput.value;
  var vsValue = voInput.value;
  vsValue = this.filterDateInput(vsValue);
  var vsRegMask = this.regMask;
  if(vsValue.length == 6) {
    vsValue = vsValue + '01';
    this.regMask = 'yyyy/MM/dd';
  }
  if(vsValue != null && vsValue != "") {
    vsValue = TGP.GetValueInput(vsValue, this.formatType, this.regMask);
  //if(this.formatType == "date") {
    var voDate = new Date();
    voDate.setTime(vsValue);
    vsValue = this.getDateString(voDate);
    if(this.min != null && this.min != "") {
      if(this.getDate(vsValue).getTime() < this.getDate(this.min).getTime()) vsValue = this.min;
    }
    if(this.max != null && this.max != "") {
      if(this.getDate(vsValue).getTime() > this.getDate(this.max).getTime()) vsValue = this.max;
    }
  //}
  }
  this.regMask = vsRegMask;
  this.setValueWithNotify(vsValue);
  this.atkeydown({'keyCode':13});
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
  var voText = this.subElement.input;

  var voEventManager = this.eventManager;
  voEventManager.removeListener(voText, "onblur", this.mediateEvent);
  voEventManager.removeListener(voText, "onchange", this.mediateEvent);
  voEventManager.removeListener(voText, "onfocus", this.mediateEvent);
  voEventManager.removeListener(voText, "onselect", this.mediateEvent);
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.refreshMainStyle = function(poCtrl, poDocument) {
  this.setMainCtrlStyles(poCtrl, poDocument);
};
/**
* @ignore
*/
eXria.controls.xhtml.DateInput.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voInputCtrl = this.subElement.input;
  var voDivCtrl = this.subElement.divDate;
  var voImgCtrl = this.subElement.imgCtrl;
  var voSpanCtrl = this.subElement.span;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  if(this.readOnly != null) voInputCtrl ["readOnly"] = this.readOnly;
  if(this.maskLen != null) voInputCtrl["maxLength"] = this.maskLen;
  if(this.minLength != null) voInputCtrl["minLength"] = this.minLength;

  if(this.className != null) voInputCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transform", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  voInputCtrl.style.cssText = vaCssStrBuf.join("");

  var vsValue = this.value;
  if(vsValue != null && vsValue != ""){
    vsValue = this.getDate(vsValue).getTime();
  }
  voInputCtrl.value = TGP.GetString(vsValue, this.formatType, this.regFormat);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;top:0px;");
  var vnLeft = this.innerWidth;
  if(this.imgAreaWidth !== null) vnLeft = vnLeft - this.imgAreaWidth;
  vfcSetCssStrBuf(vaCssStrBuf, "left", vnLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.imgAreaWidth, "px");

  //2010.07.05
  //DateInput 달력선택 이미지 보여짐 수정
  if (! this.calendarEnable){
    vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  }

  voDivCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("border-style:none;");
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "inline");
  }
  else {
    if (! this.calendarEnable) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "inline");
  }
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.btnCursor);
  voImgCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  voImgCtrl["src"] = this.calendarImageUrl;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");

  this.setInputWidth();
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  if(vsRefData != null && vsRefData != "") {
    this.dataLen = vsRefData.length;
  } else if(this.dataLen == null) {
    if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
    else this.dataLen = 8;
  }
  this.setValue(vsRefData);
};
/**
 * oldclear
 * @private
 */
eXria.controls.xhtml.DateInput.prototype.oldclear = eXria.controls.xhtml.DateInput.prototype.clear;

eXria.controls.xhtml.DateInput.prototype.clear = function() {
  if(this.calendar) this.calendar.clear();
  this.oldclear();
};
/**
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var voDivDate = this.subElement.divDate;
  var voSpan = this.subElement.span;
  var voImgCtrl = this.subElement.imgCtrl;
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName){
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "disabled" :
    if(psAttrValue == true) this.doblur();
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "outerClassName":
  case "className":
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setInputWidth();
    this.calendar.left = this.width;
    //this.calendar.refresh(poDocument);
    this.refresh(poDocument);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.calendar.top = this.height;
    //this.calendar.refresh(poDocument);
    this.refresh(poDocument);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setInputWidth();
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setVerticalAlign(voInput, voCtrl, "middle");
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setInputWidth();
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setVerticalAlign(voInput, voCtrl, "middle");
    break;
  case "padding" :
    this.paddingTop = this.padding;
    this.paddingRight = this.padding;
    this.paddingBottom = this.padding;
    this.paddingLeft = this.padding;
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voInput);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voInput);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voInput);
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voInput);
    this.setInputWidth();
    break;
  case "paddingTop" :
  case "paddingRight" :
  case "paddingBottom" :
  case "paddingLeft" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
    this.setInputWidth();
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "verticalAlign":
//    var voTd = this.getSubCtrl("td", voCtrl, poDocument);
//    this.setAttrCtrl(psAttrName, psAttrValue, voTd);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "fontFamily" :
  case "fontSize" :
  case "fontStyle" :
  case "fontWeight" :
  case "textDecoration":
  case "textTransform":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
//  case "value" :
  case "dateFormat" :
  case "maskPrompt" :
    this.runDateFormat(this.value, voInput);
    break;
  case "readOnly" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
  // this.readOnlyWithCalendar상황에서는 this.calendarEnable는 don't care
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) this.setAttrCtrl("visible", false, voImgCtrl);
    else this.setAttrCtrl("visible", true, voImgCtrl);
  }
  break;
  case "readOnlyWithCalendar" :
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) this.setAttrCtrl("visible", false, voImgCtrl);
    else this.setAttrCtrl("visible", true, voImgCtrl);
  }
  else {
    if (! this.calendarEnable) this.setAttrCtrl("visible", false, voImgCtrl);
  }
  break;
  case "textAlign" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    break;
  case "calendarEnable" :
    if (this.readOnlyWithCalendar !== "auto")
      this.setAttrCtrl("visible", psAttrValue, voImgCtrl);
    break;
  case "value" :
  case "format" :
    if(this.format == null || this.format == "") this.format = "yyyy-MM-dd";
    this.setValue(this.value);
    break;
  case "mask" :
    if(this.mask == null || this.mask == "") this.mask = "yyyyMMdd";
    this.maskLen = this.mask.length;
    if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
    else this.dataLen = 8;
    voInput.maxLength = this.maskLen;
    break;
  default:
    this.refresh(poDocument);
    break;
  }
};
/**
 * 현재에서의 커서 위치를 반환합니다.
 * @return 현재의 커서위치
 * @type Number
 * @private
 */
eXria.controls.xhtml.DateInput.prototype.getCursorPosition = function() {
  var voDocument = this.document;
  var voInput = this.subElement.input;
  var vnCursorPosition = -1;
  if (voInput.selectionEnd) {
    vnCursorPosition = voInput.selectionEnd;
  } else if(voDocument.selection && voDocument.selection.createRange) {
    var voRange = voDocument.selection.createRange().duplicate();
    voRange.moveStart('textedit', -1);
    vnCursorPosition = voRange.text.length;
  }
  return vnCursorPosition;
};
/**
 * 현재 커서의 위치값을 갱신합니다.
 */
eXria.controls.xhtml.DateInput.prototype.updateCursorPosition = function() {
  var vnPos = this.getCursorPosition();
  this.cursorPosition = vnPos;
};
/**
 * 숫자만  입력받아서 format에 맞게 변환합니다.
 * @param {HTMLEvent} e 윈도우이벤트
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.checkKey = function(e){
  var voDf = this.df;
  var vnPos = this.getCursorPosition();
  var voInputCtrl = this.subElement.input;
  var vnKeyCode = e.e.keyCode;
  var vsValue = voInputCtrl.value;

  if(vnKeyCode == 229 && e.type != "keyup")  // 한글 입력 상태에서 마우스 클릭시 keyup 이벤트가 발생하여 이를 제외하여 체크
  {
    alert("숫자 이외의 입력은 허용이 되지 않습니다.");
    vsValue = vsValue.replace(this.noDigits,"");
    e.stopEvent();
  } else if(vnKeyCode == 229 && e.type == "keyup") {
    return;
  }
  vnKeyCode = this.matchNumberPad(vnKeyCode);
  var vsKeyCharacter = String.fromCharCode(vnKeyCode);
  if(/[0-9]/.test(vsKeyCharacter) == false) {
    vnPos--;
    vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
  }


  if(this.checkDate(vsValue) == false) {
    vnPos--;
    vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
  }
  vsValue = vsValue.replace(this.noDigits, "");

  var voConstKey = this.constKey;
  switch(vnKeyCode) {
  case voConstKey["ENTER"] :
  case voConstKey["TAB"] :
  case voConstKey["DEL"] :
  case voConstKey["BACKSPACE"] :
  case voConstKey["SHIFT"] :
  case voConstKey["LEFT"] :
  case voConstKey["RIGHT"] :
    return true;
  }

  vsValue = this.toDateFormatValue(vsValue);
  voInputCtrl.value = vsValue;
  var vsChar = null;
  if(vsValue != null) {
    while(vsValue.charAt(vnPos)) {
      vsChar = vsValue.charAt(vnPos);
      if(/[0-9]/.test(vsChar) == false && this.maskPrompt != vsChar) {
        vnPos++;
      } else {
        break;
      }
    }
  }
  if(vsValue.indexOf(this.maskPrompt) > -1) vnPos = vsValue.indexOf(this.maskPrompt);
  this.setCursorPosition(vnPos);
//  this.skipBlur = true;
  return true;
};
/**
 * 넘버패드의 keycode를 기본 숫자 keycode로 변환합니다.
 * @param {Number} keyCode
 * @return 변환된 keyCOde
 * @type Number
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.matchNumberPad = function(vnKeyCode){
  if(vnKeyCode > 95 && vnKeyCode < 106) return vnKeyCode -= 48;
  else return vnKeyCode;
}
/**
 * 설정된 maskFormat에 유효한 날짜를 검사합니다.
 * @param {String} 검사할 날짜값
 * @return 유효한지의 여부
 * @type Boolean
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.checkDate = function(psValue){
  var voDf = this.df;
  psValue = psValue.replace(this.noDigits, "");
  if(psValue == "") return false;
  var vsFormat = this.dateFormat;
  vsFormat = vsFormat.replace(/[^YyMDdhms]/g, "");

  var vnYearPos = vsFormat.search(/yyyy/i);
  var vnMonthPos = vsFormat.search(/mm/i);
  var vnDatePos = vsFormat.search(/dd/i);
  var vnYear = psValue.substr(vnYearPos, 4);
  if(vnYear != "") vnYear = parseInt(vnYear);
  var vnMonth = psValue.substr(vnMonthPos, 2);
  if(vnMonth.length == 1) vnMonth += "0"; ;
  if(vnMonth != "") vnMonth = parseInt(vnMonth) - 1;
  var vnDate = psValue.substr(vnDatePos, 2);
  if(vnDate.length == 1) vnDate += "0";
  if(vnDate != "") vnDate = parseInt(vnDate);

  var voDate = new Date();
  if(vnYear === "" || vnYear === 0) vnYear = voDate.getFullYear();
  if(vnMonth === "" || vnMonth === -1) { vnMonth = voDate.getMonth() }
  if(vnDate === "" || vnDate === 0) vnDate = voDate.getDate();

  voDate.setFullYear(vnYear);
  voDate.setMonth(vnMonth);
  voDate.setDate(vnDate);

  if( voDate.getFullYear() != vnYear
      || voDate.getMonth() != vnMonth
      || voDate.getDate() != vnDate) {
    return false;
  }
  return true;
};
/**
 * 입력된값을 설정된 날짜포멧으로 변환합니다.
 * @param {String} psValue 입력값
 * @return 날짜 포맷이 적용된 문자열 값
 * @type String
 * @private
 */
eXria.controls.xhtml.DateInput.prototype.toDateFormatValue = function(psValue){
  var vsFormat = this.dateFormat.replace(this.regDateMask,this.maskPrompt);
  // 개체의 값 얻어오기
  var vsReg = new RegExp('['+this.maskPrompt+']','gi');
  //var vsValue = psValue.replace(vsReg,"a");
  var vsRegValue = vsFormat;
  var vsRegFormat = new RegExp('['+this.maskPrompt+']','i');
  for(var i=0;i < psValue.length;i++) {
    vsRegValue = vsRegValue.replace(vsRegFormat, psValue.charAt(i));
  }
  vsRegValue = vsRegValue.replace(/[YMDhms]/g,this.maskPrompt);
  return vsRegValue;
};
/**
 * dateformat 과  maskPrompt 가 적용되는 메소드입니다.
 * @param {String} psValue 적용할 값
 * @param {HTMLInput(text)} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.DateInput.prototype.runDateFormat = function(psValue, poCtrl){
  var vsDateFormat = this.dateFormat;
  if(this.maskPrompt != null) {
    vsDateFormat = vsDateFormat.replace(this.regDateMask,this.maskPrompt);
  }
  psValue = eXria.controls.xhtml.Util.parseLang(psValue);
  if(psValue == null) psValue = "";
  psValue = psValue.replace(this.noDigits,"");

  // yhkim 2009.10.08  firefox date값 길이 맞춰주기
  if(psValue.length > 0) {
    var vnMinLen = this.min.length;
    var vnMaxLen = this.max.length;
    var vnValueLen = psValue.length;
    // 값이길이가 min길이보다 작은 경우
    if(vnValueLen < vnMinLen) {
      for(var i = 0; i < vnMinLen - vnValueLen; i++) psValue += '0';
    }
    // 값의 길이가  max길이보다 작은 경우
    if(vnMaxLen > vnValueLen) {
      for(var i = 0; i < vnMaxLen - vnValueLen; i++) psValue += '0';
    }
  }
  if (psValue !== null && psValue != "") {
    if (this.toDate(psValue).getTime() < this.toDate(this.min).getTime())
      psValue = this.min;
    else
      if (this.toDate(psValue).getTime() > this.toDate(this.max).getTime())
        psValue = this.max;
  }

  var vsValue = this.toDateFormatValue(psValue,vsDateFormat);
  this.setAttrCtrl("value", vsValue, poCtrl);

  if(vsValue == vsDateFormat) {
    this.value = "";
    this.value = "";
  }
};
/**
 * 'YYYYMMDD' 포맷의 날짜값을 Date형태로 변환하여 반환합니다.
 * @param {String} psValue 'YYYYMMDD' 포맷의 날짜 값
 * @return Date객체
 * @type Date
 */
eXria.controls.xhtml.DateInput.prototype.toDate = function(psValue){
  var voDate = new Date();
  var vsValue = psValue.substring(0, 4) + "/";
  vsValue += psValue.substring(4, 6) + "/";
  vsValue += psValue.substring(6);
  voDate.setTime(Date.parse(vsValue));
  return voDate;
};
/**
 * Date객체를 반환합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return Date형으로 변환된 컨트롤 박스의 값
 * @type Date
 */
eXria.controls.xhtml.DateInput.prototype.getDate = function(poDocument) {
  var voCtrl = this.ctrl;
  var voDateinputCtrl = this.subElement.input;
  var voDate = new Date();
  var vsValue = voDateinputCtrl.value;
  var vsFormat = this.dateFormat.replace(/[^YMD]/gi,"");
  vsValue = vsValue.replace(/[^0-9]/gi,"");
  var vnIndex = vsValue.length;
  //year
  var temp = vsFormat.indexOf("YYYY",0);
  var vnYear = vsValue.substring(temp,temp+4);
  if(vnYear.length == 4) voDate.setFullYear(vnYear);
  //month
  var temp = vsFormat.indexOf("MM",0);
  var vnMonth = vsValue.substring(temp,temp+2);
  if(vnMonth.length == 2) voDate.setMonth(vnMonth-1);
  //date
  var temp = vsFormat.indexOf("DD",0);
  var vnDate = vsValue.substring(temp,temp+2);
  if(vnDate.length == 2) voDate.setDate(vnDate);
  //initialize time
  voDate.setHours(0);
  voDate.setMinutes(0);
  voDate.setSeconds(0);
  voDate.setMilliseconds(0);
  //hour
  temp = vsFormat.indexOf("hh",0);
  if(temp != -1) {
    var vnHour = vsValue.substring(temp,temp+2);
    if(vnHour.length == 2) voDate.setHours(vnHour);
  }
  //minute
  temp = vsFormat.indexOf("mm",0);
  if(temp != -1) {
    var vnMinute = vsValue.substring(temp,temp+2);
    if(vnMinute.length == 2) voDate.setMinutes(vnMinute);
  }
  //second
  temp = vsFormat.indexOf("ss",0);
  if(temp != -1) {
    var vnSecond = vsValue.substring(temp,temp+2);
    if(vnSecond.length == 2) voDate.setSeconds(vnSecond);
  }
  return voDate;
};
/**
 * 넘겨받은 Date 객체로 컨트롤의 값을 설정합니다.
 * @param {Date} poDate 컨트롤 값으로 설정될 date형 데이타
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 */
eXria.controls.xhtml.DateInput.prototype.setDate = function(poDate, poDocument){
  var voCtrl = this.ctrl;
  var voDateinputCtrl = this.subElement.input;
  var vnYear = new String(poDate.getFullYear());
  var vnMonth = new String(poDate.getMonth()+1);
  if(vnMonth.length == 1) vnMonth = "0" + vnMonth;
  var vnDate = new String(poDate.getDate(poDocument));
  if(vnDate.length == 1) vnDate = "0" + vnDate;
  var vnHours = new String(poDate.getHours());
  if(vnHours.length == 1) vnHours = "0" + vnHours;
  var vnMinutes = new String(poDate.getMinutes());
  if(vnMinutes.length == 1) vnMinutes = "0" + vnMinutes;
  var vnSeconds = new String(poDate.getSeconds());
  if(vnSeconds.length == 1) vnSeconds = "0" + vnSeconds;
//  var vsValue = this.dateFormat.replace(/[^YMDhms]/g,"");
  var vsValue = "YYYYMMDDhhmmss";
  vsValue = vsValue.replace(/YYYY/g,vnYear);
  vsValue = vsValue.replace(/MM/g,vnMonth);
  vsValue = vsValue.replace(/DD/g,vnDate);
  vsValue = vsValue.replace(/hh/g,vnHours);
  vsValue = vsValue.replace(/mm/g,vnMinutes);
  vsValue = vsValue.replace(/ss/g,vnSeconds);
  if(this.dataLen < 14) vsValue = vsValue.substring(0, 8);
  //this.runDateFormat(vsValue, voDateinputCtrl);

  this.setValue(vsValue)
  //voDateinputCtrl.onblur();
};
/**
 * 입력값을 정해진 날짜 포맷으로 설정합니다.
 * @param {String} psData 설정 값
 */
eXria.controls.xhtml.DateInput.prototype.setValue = function(psData) {
  var voInput = this.subElement.input;
  if(this.mask && /^\d*$/g.test(psData) == false) {
    var vsRegMask = this.mask
    vsRegMask = vsRegMask.replace("yyyy", "\\d{4}");
    vsRegMask = vsRegMask.replace("MM", "\\d{2}");
    vsRegMask = vsRegMask.replace("dd", "\\d{2}");
    if(new RegExp(vsRegMask).test(psData)) {
      psData = TGP.GetValueInput(psData, "date", this.mask);
      var voDate = new Date();
      voDate.setTime(psData);
      psData = this.getDateString(voDate);
    }
  }
  if(psData == null) psData = "";
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;
  this.value = psData;
  if(vbChanged) {
    this.data.setData(this.value);
  }
  if(psData != null && psData != "") {
    psData = this.getDate(psData).getTime();
    voInput.value = TGP.GetString(psData, this.formatType, this.regFormat);
  } else {
    voInput.value = "";
  }
};
/**
 * 컨트롤에 값을 설정하며 값의 변경이 있으면 onchange 이벤트를 발생시킵니다.
 * @param {String} psData 설정 값
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
 */
eXria.controls.xhtml.DateInput.prototype.setValueWithNotify = function(psData, poCtrl) {
  var voInput = this.subElement.input;
  if(this.mask && /^\d*$/g.test(psData) == false) {
    var vsRegMask = this.mask
    vsRegMask = vsRegMask.replace("yyyy", "\\d{4}");
    vsRegMask = vsRegMask.replace("MM", "\\d{2}");
    vsRegMask = vsRegMask.replace("dd", "\\d{2}");
    if(new RegExp(vsRegMask).test(psData)) {
      psData = TGP.GetValueInput(psData, "date", this.mask);
      var voDate = new Date();
      voDate.setTime(psData);
      psData = this.getDateString(voDate);
    }
  }
  if(psData == null) psData = "";
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;
  this.value = psData;
  if(psData != null && psData != "") {
    psData = this.getDate(psData).getTime();
    voInput.value = TGP.GetString(psData, this.formatType, this.regFormat);
  } else {
    voInput.value = "";
  }
  if(vbChanged) {
    this.data.setData(this.value)
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
    if(this.changeEventCallback) this.changeEventCallback(voEvent);
  }
};
/**
 * addClass
 * @param {HTMLElement} poElement
 * @param {String} poClassName
 * @private
 */
eXria.controls.xhtml.DateInput.prototype.addClass = function(poElement,poClassName) {
  if(!poElement.className) {
    poElement.className = poClassName;
  } else {
    var newClassName = poElement.className;
    newClassName += " ";
    newClassName += poClassName;
    poElement.className = newClassName;
  }
};
/*
 * @ignore
 */
eXria.controls.xhtml.DateInput.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.DateInput[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "DateInput"
 * @type String
 */
eXria.controls.xhtml.DateInput.prototype.toString = function() {
  return "DateInput";
};
/**
 * @fileoverview
 * Concreate xhtml EditMask(XHTML EditMask 컨트롤)
 * @author 조영진 , 이종녕
 */

/**
 * @class maskType에 알맞은 입력값을 정의된 maskFormat으로 변경해 주는 입력필드입니다.<br />
 * XHTML EditMask Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.EditMask 객체
 * @type eXria.controls.xhtml.EditMask
 * @constructor
 * @base eXria.controls.xhtml.InputCommon
 */
eXria.controls.xhtml.EditMask = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft =  pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.InputCommon.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 읽기 전용 여부.
   * @type String
   */
  this.readOnly = null;
  /**
   * 컨트롤에 적용될 마스크 종류 구분 문자열("string" | "date" | "number")
   * @type String
   */
  this.maskType = null;
  /**
   * 문자열 표현 마스크.
   * @type String
   */
  this.mask = null;
  /**
   *문자열 표현 마스크를 제외한 값
   *@type Object
   *@private
   */
  this.nonMask = []; //d
  /**
   * 딜리트 상태인지의 여부.
   * @type boolean
   * @ignore
   */
  this.vbCheck = false;
  /**
   * 마스크 프롬프트 문자.
   * @type String
   */
  this.maskPrompt = null;
  /**
   * 스핀 컨트롤 영역의 가로 길이(px).
   * @type Number
   */
  this.spinWidth = 20;
  /**
   * 이미지가 위치한 영역의 가로 길이.
   * @private
   * @type Number
   */
  this.imgAreaWidth = 20;
  /**
   * calendar를 실행시키는 이미지의 url.
   * @type String
   */
  this.calendarImageUrl = null;
  /**
   * 하위 컨트롤인 calendar에 대한 참조.
   * @type eXria.controls.xhtml.Calendar
   */
  //this.calendar = new eXria.controls.xhtml.Calendar(psId+"calendar",pnWidth,pnHeight,200,200);
  this.calendar = null;
  /**
   * calendar 컨트롤의 활성화 여부.
   * @type Boolean
   */
  this.calendarEnable = null;
  /**
   * 스핀 버튼을 클릭시의 증가치.
   * @type Number
   */
  this.spinNum = null;
  /**
   * 스핀 버튼의 사용 여부.
   * @type String
   */
  this.useSpin = null;
  /**
   * @type Number
   * @private
   */
  this.selectionSize = 0;
  /**
   * #,x 가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noMaskVal = /[^\#Xx*Aa!^Ww90]/gi;
  /**
   * 숫자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noDigits = /[^\d]/gi;
  /**
   * 문자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noString = /[^A-Za-z]/gi;
  /**
   * 문자, 숫자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noGeneric = /[^A-Za-z0-9]/gi;
  /**
   * 공백 문자 정규식 표현.
   * @type RegExp
   * @private
   */
  this.blank = /\s/g;
  /**
   * YYMMDD의 정규식 표현.
   * @type RegExp
   * @private
   */
  this.regDateMask = /[YMDhmis]/g;
  /**
   * 버튼의 커서 모양.
   * @type String
   */
  this.btnCursor = null;
  /**
   * 커서 위치 저장 변수
   * @type Number
   * @private
   */
  this.cursorPosition = -1;
  /**
   * 이벤트 키값 상수 정의 오브젝트.
   * @type Object
   * @private
   */
  this.constKey = {
    SHIFT: 16,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    TAB: 9,
    BACKSPACE: 8,
    DEL: 46,
    HAN_ENG: 21,
    UP : 38,
    DOWN : 40
  };
  /**
   * 유효값 체크유무
   * @type string
   * @private
   */
  this.vbValidation = "nonChecked";
  /**
   * 텍스트가 전체 select 되었는지 여부
   * @type Boolean
   * @private
   */
  this.vbSelectAll = false;

  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;

  /**
   *  readOnly와 Calendar의 동기화
   */
  this.readOnlyWithCalendar = null;

  /**
   * 시분초 입력영역 hide 처리
   * @type Boolean
   * @private
   */
  this.noUseHMS = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.InputCommon, eXria.controls.xhtml.EditMask);

//////////////////////////////////////////////////////////////////
//// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.createSubCtrl = function(poCtrl,poDocument) {
  this.spinWidth = this.getAttrValue("spinWidth", this.spinWidth);
  if(this.calendar == null) this.calendar = new eXria.controls.xhtml.Calendar(this.id + "calendar", this.width, this.height, 180, 180, true);
//  this.calendar = new eXria.controls.xhtml.Calendar(this.id + "calendar", this.width, this.height, 200, 200);
  var voCalendar = this.calendar;
  voCalendar.canvas = this.canvas;
  voCalendar.window = this.window;
  voCalendar.document = this.document;
};

eXria.controls.xhtml.EditMask.prototype.setTemplate = function(poCtrl,poDocument) {

  this.calendar.defaultFileName = this.getAttrValue("defaultFileName", this.defaultFileName);
  this.calendar.textFileName = this.getAttrValue("textFileName", this.textFileName);
  this.calendar.loadDefaultSpce();

  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
//  vaTemplate.push("<table cellPadding='0px' cellSpacing='0px' style='position:absolute; overflow:hidden; left:0px; top:0px'><tbody><tr>");
//  vaTemplate.push("<td ");
//  vaTemplate.push("@attStrBuf"); // 2 - td attribute
//  vaTemplate.push(" style='");
//  vaTemplate.push("@cssStrBuf"); // 4 - td style
//  vaTemplate.push("'>");
  vaTemplate.push("<input id='" + this.id + "_text' type='text' class='" + vsClass + "' ");
  vaTemplate.push("@attStrBuf"); // 0 - input attribute
  vaTemplate.push(" style=\"");
  vaTemplate.push("@cssStrBuf"); // 1 - input style
  vaTemplate.push("\"/>");
//  vaTemplate.push("</td></tr></tbody></table>");

  vaTemplate.push("<div style=\"");
  vaTemplate.push("@cssStrBuf"); // 2 - spin div style
  vaTemplate.push("\">");
  vaTemplate.push("<input id='" + this.id + "_btn_up' type='button' value='▲' style=\"");
  vaTemplate.push("@cssStrBuf"); // 3
  vaTemplate.push("\" onclick=\"");
  vaTemplate.push(this.getEHandler(this.id, "increaseNum"));
  vaTemplate.push("\">");
  vaTemplate.push("<input id='" + this.id + "_btn_down' type='button' value='▼' style=\"");
  vaTemplate.push("@cssStrBuf"); // 4
  vaTemplate.push("\" onclick=\"");
  vaTemplate.push(this.getEHandler(this.id, "decreaseNum"));
  vaTemplate.push("\">");
  vaTemplate.push("</div>");

  vaTemplate.push("<div style=\"");
  vaTemplate.push("@cssStrBuf"); // 5 - img div style
  vaTemplate.push("\">");
  vaTemplate.push("<table style='width:100%;height:100%' cellspacing='0'><tbody><tr><td style=\"text-align:center;vertical-align:middle;\">");
  vaTemplate.push("<img id='" + this.id + "_icon' ");
  vaTemplate.push("@attStrBuf"); // 6 - img attribute
  vaTemplate.push("style=\"border-color:red;border-style:none;border-width:1px;width:16px;height:16px;\"/>");
  vaTemplate.push("</td></tr></tbody></table></div>");

  vaTemplate.push("<span class='" + vsClass + "'" + " style=\"");
  vaTemplate.push("@cssStrBuf"); //7
  vaTemplate.push("\"/>");

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

eXria.controls.xhtml.EditMask.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;


  this.noUseHMS = this.getAttrValue("noUseHMS", this.noUseHMS);
  this.verticalAlign = this.getAttrValue("verticalAlign", this.verticalAlign);
  this.value = this.getAttrValue("value", this.value);
  this.readOnly = this.getAttrValue("readonly", this.readOnly);
  this.formatType = this.getAttrValue("formatType", this.formatType);
  this.format = this.getAttrValue("format", this.format);
  this.mask = this.getAttrValue("mask", this.mask);
  if(this.formatType == "date") {
    if(this.mask == null || this.mask  == "") this.mask = "yyyyMMdd";
    if(this.regFormat == null || this.regFormat == "") this.regFormat = "yyyy-MM-dd";
    if(this.regMask == null || this.regMask == "") this.regMask = "yyyyMMdd";
    this.maskLen = this.mask.length;
    if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
    else this.dataLen = 8;
  }

  //this.stringPromptMask = this.mask.replace(/[#Xx*Aa!^Ww90]/g,this.maskPrompt);
  this.spinWidth = this.getAttrValue("spinWidth", this.spinWidth);
  this.spinNum = this.getAttrValue("spinNum", this.spinNum);
  this.useSpin = this.getAttrValue("useSpin", this.useSpin);
  this.maxLength = this.getAttrValue("maxLength", this.maxLength);
  this.minLength = this.getAttrValue("minLength", this.minLength);
  this.calendarImageUrl = this.getAttrValue("calendarImageUrl", this.calendarImageUrl);

  this.btnCursor = this.getAttrValue("btnCursor", this.btnCursor);
  if(this.formatType == "date"){
    this.calendarEnable = this.getAttrValue("calendarEnable", this.calendarEnable);
    this.readOnlyWithCalendar = this.getAttrValue("readOnlyWithCalendar", this.readOnlyWithCalendar);
  }else
    this.calendarEnable = false;
  this.vbSelectAll = this.vbSelectAll;
};

eXria.controls.xhtml.EditMask.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  // /////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  // /////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    if(voUserAttr.regFormat) this.regFormat = voUserAttr.regFormat;
  }

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");
  // ////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  // ////////////////////////////////////////////////////////////////////////////////////////

  vaAttStrBuf = [];
  if(this.readOnly) vfcSetAttStrBuf(vaAttStrBuf, "readOnly", this.readOnly);
  if(this.maskLen) vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maskLen);
  else vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maxLength);
  vfcSetAttStrBuf(vaAttStrBuf, "minLength", this.minLength);
  vaTemplate[voIndexMap.get(0)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;border-style:none;top:0px;width:" + this.spinWidth + "px;height:" + this.height + "px;");
  if(!this.useSpin) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  vfcSetCssStrBuf(vaCssStrBuf, "left", (this.innerWidth - this.spinWidth), "px");
  vaTemplate[voIndexMap.get(2)] = vaCssStrBuf.join("");

  var vnFontSize = Math.round(this.fontSize / 2);
  if(vnFontSize < 2) vnFontSize = 2;
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;left:0px;top:0px;width:" + this.spinWidth + "px;height:" + (this.height / 2) + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vnFontSize, "pt");
  vaTemplate[voIndexMap.get(3)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;left:0px;top:" + ((this.height / 2) - 1) + "px;width:" + this.spinWidth + "px;height:" + ((this.height - (this.height / 2))-1) + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vnFontSize, "pt");
  vaTemplate[voIndexMap.get(4)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute; top:0px; width:" + this.imgAreaWidth + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "left", (this.innerWidth - this.imgAreaWidth), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.btnCursor);
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "block");

    if (! this.calendarEnable) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  }
  else {
    if (! this.calendarEnable) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "block");
  }
  vaTemplate[voIndexMap.get(5)] = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "src", this.calendarImageUrl);
  vaTemplate[voIndexMap.get(6)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(7)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  voIndexMap.clear();

  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;
  this.setSubElement(poDocument);
  var a = this.subElement.divSpin;
  var b = this.subElement.divDate;
  a.style.zindex = -1;
  b.style.zindex = -1;
  this.showSpin(this.useSpin, this.spinNum);
  var voInputCtrl = this.subElement.input;
  var vsValue = this.value;
  if(vsValue != null && vsValue != ""){
    switch(this.formatType) {
    case "number":
      break;
    case "date":
      vsValue = this.getDate(vsValue).getTime();
      break;
    case "string":
      break;
    }
    vsValue = TGP.GetString(vsValue, this.formatType, this.regFormat);
  } else {
    vsValue = "";
  }
  voInputCtrl.value = vsValue;
  var voDateinput_icon = poCtrl.getElementsByTagName("img")[0]; // 수정필요
  this.calendar.canvas = this.canvas;
  //voCalendar.style.visibility = "hidden";
  voDateinput_icon.control = this;
  voDateinput_icon.onclick = function(e) {
   var voControl = this.control;
   var voCanvas = voControl.canvas;

   var getPositionLeft = function(poControl){
     var vnLeft = poControl.left;
     if(poControl.parent) vnLeft = vnLeft + getPositionLeft(poControl.parent);
     return vnLeft;
   }

   var getPositionTop = function(poControl){
     var vnTop = poControl.top;
     if(poControl.parent) vnTop = vnTop + getPositionTop(poControl.parent);
     return vnTop;
   }

   if(voCanvas.collapseControl && voCanvas.collapseControl.id != voControl.id) {
     voCanvas.doCollapseControl(voCanvas);
   }
   var voCalendar = voControl.calendar;
   var voCalendarCtrl = voCalendar.getCtrl(poDocument);
   if(voCalendarCtrl) {
     voCalendar.hide();
     this.calendarShowed = false;
     voCanvas.collapseControl = null;
     return;
   }

   //voCalendar.style.visibility = "visible";
   var e = e || window.event;
   if(voControl.calendarEnable) {
     var voCtrl = voControl.getCtrl();
     voCalendar.setDate(voControl.getDate(voControl.value));
     voCalendar.type = "Dateinput";
     voCalendar.fontSize = 10;
     voCalendar.setTarget(voControl);


     //전체화면의 크기
     var vnCanvasWidth = voControl.canvas.width;
     var vnCanvasHeight= voControl.canvas.height;

     //컨트롤(DateInput)의 포지션
     var vnLeft = getPositionLeft(voControl);
     var vnTop = getPositionTop(voControl);

     //컨트롤(DateInput)의 크기
     var vnWidth = voControl.width;
     var vnHeight = voControl.height;

     var vsCSSStyle = {
          "GB": {
             "W":169,
             "H":161
          },
          "GL": {
             "W":196,
             "H":150
          },
          "GM": {
             "W":169,
             "H":161
          },
          "GO": {
             "W":169,
             "H":161
          },
          "GP": {
             "W":169,
             "H":161
          },
          "GR": {
             "W":169,
             "H":161
          },
          "GS": {
             "W":169,
             "H":161
          }
      }[voCalendar.CSS];


     //컨트롤(Calendar)의 크기
     var vnCalendarWidth  =  vsCSSStyle["W"];//voCalendar.width;
     var vnCalendarHeight =  vsCSSStyle["H"];//voCalendar.height;

     //컨트롤(Calendar)의 포지션
     var vnCalendarLeft;
     var vnCalendarTop;


     if( (vnLeft+vnWidth) >= vnCalendarWidth ){
        vnCalendarLeft = vnLeft;
        if( (vnCalendarLeft+vnCalendarWidth) >= vnCanvasWidth ){
          vnCalendarLeft = (vnLeft+vnWidth) - vnCalendarWidth;
        }
     }else{
        vnCalendarLeft = (vnLeft+vnWidth) - vnCalendarWidth;
        if(vnCalendarLeft < 0)
          vnCalendarLeft = vnLeft;
     }

     if( vnCanvasHeight-(vnTop+vnHeight) >= vnCalendarHeight){
        vnCalendarTop = vnTop+vnHeight;
     }else{
        vnCalendarTop = (vnTop+vnHeight) -  vnCalendarHeight;
     }

     voCalendar.left = vnCalendarLeft;
     voCalendar.top = vnCalendarTop;
     voCalendar.position = "absolute";
     voCalendar.zIndex = 10000;
     voCalendar.show();


     //window.useHMS 속성은 이대프로젝트에 의존된 속성임.
     //template_xhtml.xml에 적용됨
     if(voControl.mask.length > 14 && !voControl.noUseHMS) {
        var vnTmp = voControl.getDate(voControl.value).getTime();
        voCalendar._showTimesInfo(TGP.GetString(vnTmp, voControl.formatType, 'HH:mm:ss'));
     }

     voControl.calendarShowed = true;
     voCanvas.collapseControl = voControl;
   }
  }
};

eXria.controls.xhtml.EditMask.prototype.setSpecificEvents = function(poCtrl){
  var voInput = this.subElement.input;
  //@data  TODO: 테스트 필요...
  voInput.control = this;
  //this.eventManager.addListener(voInput, "onchange", this.mediateEvent);
  this.eventManager.addListener(voInput, "onfocus", this.mediateEvent);
  this.eventManager.addListener(voInput, "onblur", this.mediateEvent);
  this.eventManager.addListener(voInput, "onselect", this.mediateEvent);

  var add = "";
  if(this.formatType == "number") voInput.onkeypress = function(ev){ TestKey(ev?ev:event,this,TestKeyFloat,add); }
  else if(this.formatType == "date") {
    var tt = this.regFormat && this.regFormat.indexOf('t')>=0 && this.regFormat.indexOf('h')>=0;
    if(tt) add+=Formats.AMDesignator.toUpperCase()+Formats.PMDesignator.toUpperCase();
    voInput.onkeypress = function(ev){ TestKey(ev?ev:event,this,TestKeyDate,add); }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.input = this.getSubCtrl("input", voCtrl, poDocument);
  voSubElement.divSpin = voCtrl.childNodes[1];
  voSubElement.btnUp = this.getSubCtrl("input", voCtrl, poDocument, 1);
  voSubElement.btnDown = this.getSubCtrl("input", voCtrl, poDocument, 2);
  voSubElement.img = this.getSubCtrl("img", voCtrl, poDocument);
  voSubElement.divDate = voCtrl.childNodes[2];
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voInput = this.subElement.input;
  var voDivSpin = this.subElement.divSpin;
  var voDivDate = this.subElement.divDate;
  var voSpan = this.subElement.span;
  switch(psAttrName) {
    case "width" :
      this.setInputWidth();
      this.calendar.left = this.width;
//    this.calendar.refresh();
      break;
    case "height" :
      this.setAttrCtrl("height", this.innerHeight, voDivDate);
      this.calendar.top = this.height;
//      this.setVerticalAlign(voInput, poCtrl, voDf.verticalAlign);
//        this.calendar.refresh();
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.dofocus = function() {
  if(this.calendarShowed) return;
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  setTimeout(function(){ try { voInput.focus(); }catch(err) {} },10); //ff에서 제대로 작동하지 않아서 setTimeout 사용
  //voInput.focus();
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atfocus = function(e) {
  var voInput = this.subElement.input;
  var vsValue = this.value;
  if(vsValue != null && vsValue !== "") {
    switch(this.formatType) {
    case "number":
      break;
    case "date":
      vsValue = this.getDate(vsValue).getTime();
      break;
    case "string":
      vsValue = this.getMaskedValue(vsValue, this.mask);
      break;
    }
    vsValue = TGP.GetString(vsValue, this.formatType, this.regMask);
  } else {
    vsValue = "";
  }
  voInput.value = vsValue;
  if(this.focused != true) {
    if(this.calendarEnable) {
      var voCalendar = this.calendar;
      var voCalendarCtrl = voCalendar.getCtrl();
      if(voCalendarCtrl) {
        voCalendar.hide();
        this.calendarShowed = false;
        this.canvas.collapseControl = null;
      }
    }
    this.selectText();
  }
  this.vbValidation = "nonChecked";
  this.focused = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atkeydown = function(e){
//  this.checkSelect();
  if(e.keyCode == 13) {
    this.isEnter = true;
    var voInput = this.subElement.input;
    //atkeydown 다음 메소드 콜스택 때 onchange, onblur가 순차적으로 발생되며 그 뒤에 onkeydown이 호출됨.
    voInput.blur();
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atkeyup = null;
//eXria.controls.xhtml.EditMask.prototype.atkeyup = function(e) {
//  e = new eXria.event.Event(e, this.window);
//  //if(this.df.maskType == "string" && e.keyCode == 8) this.chkBackSpace(e);
//  this.checkKey(e);
//};

/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atblur = function(e) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  this.setInputHeight(voCtrl);
  this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
  this.focused = false;

  if(!this.mask && !!this.inputMode)
    voInput.value = eXria.controls.xhtml.Util.getValueFromInputMode(String(voInput.value), this.inputMode);

  // var vsValue = voInput.value;
  if(this.formatType != "string") this.tempValue = voInput.value;
  var vsValue = voInput.value;
  if(this.formatType == "string") vsValue = this.getMaskedValue(vsValue, this.mask);
  else if(this.formatType == "number") {
    if(vsValue !== "") vsValue = TGP.GetValueInput(vsValue, this.formatType, this.regMask);
  } else if(this.formatType == "date" && vsValue) {
    vsValue = this.filterDateInput(vsValue);
    vsValue = TGP.GetValueInput(vsValue, this.formatType, this.regMask);
    var voDate = new Date();
    voDate.setTime(vsValue);
    vsValue = this.getDateString(voDate);
  } else {
    vsValue = TGP.GetValueInput(vsValue, this.formatType, this.regMask);
  }

  if((this.formatType === "date" || this.formatType == "number" ) && isNaN(vsValue)) vsValue = "";

  this.setValueWithNotify(vsValue);
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var voInputCtrl = this.subElement.input;
  var voDivSpinCtrl = this.subElement.divSpin;
  var voBtnUpCtrl = this.subElement.btnUp;
  var voBtnDownCtrl = this.subElement.btnDown;
  var voDivDateCtrl = this.subElement.divDate;
  var voImgCtrl = this.subElement.img;
  var voSpanCtrl = this.subElement.span
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  //else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  var vsValue = this.value;
  if(vsValue != null && vsValue != "") {
    switch(this.formatType) {
    case "number":
     break;
    case "date":
     vsValue = this.getDate(vsValue).getTime();
     break;
    case "string":
     break;
    }
    vsValue = TGP.GetString(vsValue, this.formatType, this.regFormat);
  } else {
    vsValue = "";
  }
  voInputCtrl.value = vsValue;

  if(this.readOnly != null) voInputCtrl ["readOnly"] = this.readOnly;
  if(this.maskLen != null) voInputCtrl["maxLength"] = this.maskLen;
  else if(this.maxLength != null) voInputCtrl["maxLength"] = this.maxLength;
  if(this.minLength != null) voInputCtrl["minLength"] = this.minLength;

  if(this.className != null) voInputCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - this.imgAreaWidth - voDf.paddingLeft - voDf.paddingRight), "px");
  voInputCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;border-style:none;top:0px;width:" + this.spinWidth + "px;height:" + this.height + "px;");
  if(!this.useSpin) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  vfcSetCssStrBuf(vaCssStrBuf, "left", (this.innerWidth - this.spinWidth), "px");
  voDivSpinCtrl.style.cssText = vaCssStrBuf.join("");

  var vnFontSize = Math.round(this.fontSize / 2);
  if(vnFontSize < 2) vnFontSize = 2;
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;left:0px;top:0px;width:" + this.spinWidth + "px;height:" + (this.height / 2) + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vnFontSize, "pt");
  voBtnUpCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;left:0px;top:" + ((this.height / 2) - 1) + "px;width:" + this.spinWidth + "px;height:" + ((this.height - (this.height / 2))-1) + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vnFontSize, "pt");
  voBtnDownCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute; top:0px; width:" + this.imgAreaWidth + "px;");
  vfcSetCssStrBuf(vaCssStrBuf, "left", (this.innerWidth - this.imgAreaWidth), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.btnCursor);
  //if(voDf.formatType == "date" && voDf.calendarEnable == false) vfcSetCssStrBuf(vaCssStrBuf, "visibility", "hidden");
  if (this.readOnlyWithCalendar === "auto") {
    if (this.readOnly === true) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "block");

    if (! this.calendarEnable) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
  }
  else {
    if (! this.calendarEnable) vfcSetCssStrBuf(vaCssStrBuf, "display", "none");
    else vfcSetCssStrBuf(vaCssStrBuf, "display", "block");
  }
  voDivDateCtrl.style.cssText = vaCssStrBuf.join("");

  voImgCtrl["src"] = this.calendarImageUrl;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");

  this.showSpin(this.useSpin, this.spinNum);
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voDivSpin = this.subElement.divSpin;
  var voDivDate = this.subElement.divDate;
  var voInput = this.subElement.input;
  var voImgCtrl = this.subElement.img;
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName){
    case "visible" :
      this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
      this.setInputHeight(voCtrl);
      this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
      break;
    case "disabled" :
      if(psAttrValue == true) this.doblur();
      this.setDisable(voCtrl, psAttrValue);
      break;
    case "textAlign" :
      this.setAttrCtrl(psAttrName, psAttrValue, voInput);
      this.setInputWidth();
      break;
    case "readOnly":
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    // this.readOnlyWithCalendar상황에서는 this.calendarEnable는 don't care
    if (this.readOnlyWithCalendar === "auto") {
      if (this.readOnly === true) this.setAttrCtrl("visible", false, voImgCtrl);
      else this.setAttrCtrl("visible", true, voImgCtrl);
    }

    break;
  case "readOnlyWithCalendar" :
    if (this.readOnlyWithCalendar === "auto") {
      if (this.readOnly === true) this.setAttrCtrl("visible", false, voImgCtrl);
      else this.setAttrCtrl("visible", true, voImgCtrl);
    }
    else {
      if (! this.calendarEnable) this.setAttrCtrl("visible", false, voImgCtrl);
    }
    break;
    case "maxLength":
    case "minLength":
    case "value":
      this.setAttrCtrl(psAttrName, psAttrValue, voInput);
      break;
    case "verticalAlign":
      this.setInputHeight(voCtrl);
      this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
      break;
    case "color" :
    case "fontFamily" :
    case "fontSize" :
    case "fontStyle" :
    case "fontWeight" :
    case "textDecoration":
    case "textTransform":
      this.setAttrCtrl(psAttrName, psAttrValue, voInput);
      this.setInputHeight(voCtrl);
      this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
      break;
    case "outerClassName":
    case "className":
      this.refresh(poDocument);
      break;
    case "width" :
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setInputWidth();
      this.calendar.left = this.width;
      //this.calendar.refresh(poDocument);
      this.refresh(poDocument);
      break;
    case "height" :
      this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setAttrCtrl("height", this.innerHeight, voDivDate);
      this.calendar.top = this.height;
      //this.calendar.refresh(poDocument);
      this.refresh(poDocument);
      break;
    case "borderWidth" :
      this.borderLeftWidth = this.borderWidth;
      this.borderRightWidth = this.borderWidth;
      this.borderTopWidth = this.borderWidth;
      this.borderBottomWidth = this.borderWidth;
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
      this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
      this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
      this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setInputWidth();
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setVerticalAlign(voInput, voCtrl, "middle");

      break;
    case "borderLeftWidth" :
    case "borderRightWidth" :
      this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setInputWidth();
      break;
    case "borderTopWidth" :
    case "borderBottomWidth" :
      this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
      this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setVerticalAlign(voInput, voCtrl, "middle");
      break;
    case "padding" :
      this.paddingTop = this.padding;
      this.paddingRight = this.padding;
      this.paddingBottom = this.padding;
      this.paddingLeft = this.padding;
      this.setAttrCtrl("paddingTop", this.paddingTop + "px", voInput);
      this.setAttrCtrl("paddingRight", this.paddingRight + "px", voInput);
      this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voInput);
      this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voInput);
      this.setInputWidth();
      this.setVerticalAlign(voInput, voCtrl, "middle");
      break;
    case "paddingTop" :
    case "paddingBottom" :
      this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
      this.setInputWidth();
      this.setVerticalAlign(voInput, voCtrl, "middle");
      break;
    case "paddingLeft" :
    case "paddingRight" :
      this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
      this.setInputWidth();
      break;
    case "formatType" :
      break;
    case "format" :
      if(this.formatType == "date") {
        if(this.format == null || this.format == "") this.format = "yyyy-MM-dd";
      }
      if(this.formatType == "string") this.regFormat = null;
      else this.regFormat = this.format;
      this.setValue(this.value);
      break;
    case "regFormat" :
      if(this.formatType == "date") {
        if(this.regFormat == null || this.regFormat == "") this.regFormat = "yyyy-MM-dd";
      }
      if(this.formatType == "string") this.format = null;
      else this.format = this.regFormat;
      this.setValue(this.value);
      return;
    case "mask" :
      if(this.formatType == "date") {
        if(this.mask == null || this.mask == "") this.mask = "yyyyMMdd";
        this.maskLen = this.mask.length;
        if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
        else this.dataLen = 8;
        voInput.maxLength = this.maskLen;
      }
      if(this.formatType == "string") this.regMask = null;
      else this.regMask = this.mask;
      break;
    case "regMask" :
      if(this.formatType == "date") {
        if(this.regMask == null || this.regMask == "") this.regMask = "yyyyMMdd";
        this.mask = this.regMask;
        this.maskLen = this.mask.length;
        if(this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
        else this.dataLen = 8;
        voInput.maxLength = this.maskLen;
      }
      if(this.formatType == "string") this.mask = null;
      else this.mask = this.regMask;
      break;
    default:
      this.refresh(poDocument);
      break;
  }
};
/**
 * 스핀 버튼의 표시 여부를 설정합니다(maskType이 number이고 readOnly가 true일때만).
 * @param {Boolean} pbShow 스핀 버튼 표시여부
 * @param {Number} pnNum 스핀 버튼에 의한 수치 증가치(생략시 디폴트값)
 */
eXria.controls.xhtml.EditMask.prototype.showSpin = function(pbShow, pnNum) {
  var voDf = this.df;
  if(this.formatType != "number" || !this.readOnly) return;

  if(pnNum != null) {
    this.spinNum = pnNum;
//    voDf.spinNum = pnNum;
  }
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var voDiv = this.subElement.divSpin;
  if(pbShow) {
    var voInput = this.subElement.input;
    var vnWidth = this.innerWidth;
    if(this.imgAreaWidth !== null) vnWidth = vnWidth - this.imgAreaWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    voInput.style.width = vnWidth;
    this.useSpin = true;
//    voDf.useSpin = true;
    this.setAttrCtrl("display", "inline", voDiv);
    //this.setAttrCtrl("width", (this.width - 2 * this.subBorderWidth - this.spinWidth), voInput);
  } else {
    this.useSpin = false;
//    voDf.useSpin = false;
    this.setAttrCtrl("display", "none", voDiv);
   // this.setAttrCtrl("width", (this.width - 2 * this.subBorderWidth), voInput);
  }
};
/**
 * 텍스트 박스에 표시된 수치를 증가시켜 줍니다.
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.increaseNum = function() {
  var voDf = this.df;
  var voInput = this.subElement.input;
  var vsTempValue = voInput.value;
  this.onchangeInitValue = vsTempValue;

  if(vsTempValue == "") vsTempValue = "0";
//  voDf.value = vsTempValue;
  var vsValue = vsTempValue;
  var vaValue = vsTempValue.split(".");
  var vsInteger = vaValue[0];
  var vsDecimal = vaValue[1];
  if(vsDecimal == null) vsDecimal = "";
  var vnInteger = Number(vsInteger);
  vnInteger += this.spinNum;
  if(vsDecimal == "") vsValue = vnInteger;
  else vsValue = vnInteger + "." + vsDecimal;
//  voDf.value = vsValue;
  this.value = vsValue;
  voInput.value = vsValue;

  if(!!this.data.instanceId)this.data.setData(vsValue);
  this.setValueWithNotify(vsValue);
};
/**
 * 텍스트 박스에 표시된 수치를 감소시켜 줍니다.
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.decreaseNum = function() {
  var voDf = this.df;
  var voInput = this.subElement.input;
  var vsTempValue = voInput.value;
  this.onchangeInitValue = vsTempValue;


  if(vsTempValue == "") vsTempValue = "0";
//  voDf.value = vsTempValue;
  var vsValue = vsTempValue;
  var vaValue = vsTempValue.split(".");
  var vsInteger = vaValue[0];
  var vsDecimal = vaValue[1];
  if(vsDecimal == null) vsDecimal = "";
  var vnInteger = Number(vsInteger);
  vnInteger -= this.spinNum;
  if(vsDecimal == "") vsValue = vnInteger;
  else vsValue = vnInteger + "." + vsDecimal;
//  voDf.value = vsValue;
  this.value = vsValue;
  voInput.value = vsValue;

  if(!!this.data.instanceId)this.data.setData(vsValue);
  this.setValueWithNotify(vsValue);
};
/**
 * 현재에서의 커서 위치를 반환합니다.
 * @return 커서의 위치
 * @type Number
 */
eXria.controls.xhtml.EditMask.prototype.getCursorPosition = function() {
  var voDocument = this.document;
  var voInput = this.subElement.input;
  var vnCursorPosition = -1;
  if(voInput == null) return vnCursorPosition;
  if (voInput.selectionEnd) {
    vnCursorPosition = voInput.selectionEnd;
  } else if(voDocument.selection && voDocument.selection.createRange) {
    var voRange = voDocument.selection.createRange().duplicate();
    voRange.moveStart('textedit', -1);
    vnCursorPosition = voRange.text.length;
  }
  return vnCursorPosition;
};
/**
 * 입력키에 유효성을 체크하고 마스크 타입에 맞게 문자열을 변환합니다.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return 작업수행의 성공 여부
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.checkKey = function(e){
  var voDf = this.df;
  var vnKeyCode = e.e.keyCode;
  var voInputCtrl = this.subElement.input;
  var vsValue = voInputCtrl.value;
  this.cursorPosition = this.getCursorPosition();
  var vnPos = this.cursorPosition;
  var tempValue = null;
  var vbBackOrDel = false;
//    var vnKeyCode = e.e.which||e.e.which==0?e.e.which:e.e.keyCode;
//    if(vnKeyCode == 229) e.stopEvent();
  if(vnKeyCode == 229 && e.type != "keyup") { // 한글 입력 상태에서 마우스 클릭시 keyup 이벤트가 발생하여 이를 제외하여 체크
    alert("한글 입력은 허용이 되지 않습니다.");
  } else if(vnKeyCode == 229 && e.type == "keyup") {
    return;
  }
  var voConstKey = this.constKey;
  switch(vnKeyCode) {
  case voConstKey["ENTER"] :
  case voConstKey["TAB"] :
  //case voConstKey["BACKSPACE"] :
  //case voConstKey["DEL"] :
  case voConstKey["SHIFT"] :
  case voConstKey["LEFT"] :
  case voConstKey["RIGHT"] :
  case voConstKey["UP"] :
  case voConstKey["DOWN"] :
    return true;
  }
  if(vnKeyCode == 27) {
    vbValidation = "nonChecked";
    vsValue = this.mask.replace(/[#Xx*Aa!^Ww9]/g, this.maskPrompt);
  }
  if(vnPos == 0 && vsValue.length == this.mask.length && vnConstKey == "BACKSPACE") return true;
  if(this.maskType == "number" && (vnKeyCode == 8 || vnKeyCode == 46)) return true;
  vnKeyCode = this.matchNumberPad(vnKeyCode);
  var vsKeyCharacter = String.fromCharCode(vnKeyCode);

  switch(this.maskType) {
    case "number":
      // vnKeyCode = 190 -> "."
      if((vsKeyCharacter == "-" || vsKeyCharacter == "+") && vsValue == vsKeyCharacter) return;
      if(/[0-9]/.test(vsKeyCharacter) == false && vnKeyCode != 190) {
        vnPos--;
        vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
      } else if(vnKeyCode == 190) {
        var vaMatch = vsValue.match(/\./g);
        if(vaMatch && vaMatch.length > 1) {
          vnPos--;
          vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
        }
      }
      var vsPreValue = vsValue;
      vsValue = this.setNumber(vsValue);
      if(!/[0-9]/.test(vsValue.charAt(vnPos))) vnPos++;
      if(vsPreValue.length < vsValue.length) vnPos = vsValue.length;
      voInputCtrl.value = vsValue;
      break;
    case "date":
      if(vnKeyCode == 8 || vnKeyCode == 46){
        var voValues = this.chkBackSpace(e);
        if(voValues[0] != null){
          vsValue = voValues[0];
          if(voValues[1]) vnPos = voValues[1];
        }
      }else if(/[0-9]/.test(vsValue) == false) {
        vnPos--;
        vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
      }else if(this.checkDate(vsValue) == false) {
        vnPos--;
        vsValue = vsValue.substring(0, vnPos) + vsValue.substring(vnPos + 1);
      }
      vsValue = vsValue.replace(this.noDigits, "");
      this.tempValue = vsValue;
      vsValue = this.toDateFormatValue(vsValue);
      voInputCtrl.value = vsValue;
      var vsChar = null;
      if(vsValue != null) {
        while(vsValue.charAt(vnPos)) {
          vsChar = vsValue.charAt(vnPos);
          if(/[0-9]/.test(vsChar) == false && this.maskPrompt != vsChar) {
            vnPos++;
          } else {
            break;
          }
        }
      }
      break;
    case "string":
      if(vnKeyCode == 8 || vnKeyCode == 46){
        this.vbCheck = true;
        vsValue = this.setGeneric(vsValue);
        voInputCtrl.value = vsValue;
        vbBackOrDel = true;
      }else{
        vsValue = this.setGeneric(vsValue);
        var vcTest = this.mask.charAt(vnPos);
        if(this.noMaskVal.test(this.mask.charAt(vnPos))) vcTest = this.mask.charAt(vnPos + 1);
        if(/[0]/g.test(vcTest)){
          if(!/[#Xx*Aa!^Ww90]/.test(this.mask.charAt(0)) && (vnPos == 1 || vnPos == 0)) vnPos++;
          vnPos = this.stringPromptMask.indexOf(this.maskPrompt, this.vsInput == "fail" ? vnPos - 1 : vnPos);
        }else vnPos = vsValue.indexOf(this.maskPrompt);
        voInputCtrl.value = vsValue;
      }
      break;
  }
  if(vbBackOrDel){
    if(this.stringPromptMask.charAt(vnPos) != this.maskPrompt) vnPos--;
  }
  if(vnPos >= 0) this.setCursorPosition(vnPos);
  this.skipBlur = true;
  return true;
};
/**
 * 넘버패드의 keycode를 기본 숫자 keycode로 변환합니다.
 * @param {Number} 넘버패드의 keycode
 * @return 변환된 keyCOde
 * @type Number
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.matchNumberPad = function(vnKeyCode){
  if(vnKeyCode > 95 && vnKeyCode < 106) return vnKeyCode -= 48;
  else return vnKeyCode;
}
/**
 * 입력된 날짜에 대해서 유효성 체크를 합니다.
 * @param {String} psValue 입력된 날짜
 * @return 성공여부
 * @type Boolean
 */
eXria.controls.xhtml.EditMask.prototype.checkDate = function(psValue){
  var voDf = this.df;
  psValue = psValue.replace(this.noDigits, "");
  var vsFormat = this.vsMask;
  vsFormat = vsFormat.replace(/[^YyMDdhmis]/g, "");
  var voDate = new Date();
  var vnYearPos = vsFormat.search(/yyyy/i);
  var vnMonthPos = vsFormat.search(/mm/i);
  var vnDatePos = vsFormat.search(/dd/i);
  var vnHour = "";
  var vnMinute = "";
  var vnSecond = "";
  var vnYear = psValue.substr(vnYearPos, 4);
  if(vnYearPos < 0) {
    vnYearPos = vsFormat.search(/yy/i);
    vnYear = psValue.substr(vnYearPos, 2);
    vnYear = String(voDate.getFullYear()).substring(0, 2) + vnYear;
  }
  if(vnYear != "") vnYear = parseInt(vnYear);
  var vnMonth = psValue.substr(vnMonthPos, 2);
  if(vnMonth.length == 1) vnMonth += "0";
  if(vnMonth != "") vnMonth = parseInt(vnMonth) - 1;
  var vnDate = psValue.substr(vnDatePos, 2);
  if(vnDate.length == 1) vnDate += "0";
  if(vnDate != "") vnDate = parseInt(vnDate);
  var vnHourPos = vsFormat.search(/hh/i);
  var vnMinutePos = vsFormat.search(/mi/i);
  var vnSecondPos = vsFormat.search(/ss/i);
  if(vnHourPos > -1){
    vnHour = psValue.substr(vnHourPos, 2);
    if(vnHour.length == 1) vnHour += "0";
    if(/hh12/.test(this.mask) && vnHour > 12) {
      return false;
    }
  }
  if(vnHour != "") vnHour = parseInt(vnHour);
  if(vnMinutePos > -1){
    vnMinute = psValue.substr(vnMinutePos, 2);
    if(vnMinute.length == 1) vnMinute += "0";
  }
  if(vnMinute != "") vnMinute = parseInt(vnMinute);
  if(vnSecondPos > -1){
    vnSecond = psValue.substr(vnSecondPos, 2);
    if(vnSecond.length == 1) vnSecond += "0";
  }
  if(vnSecond != "") vnSecond = parseInt(vnSecond);
  if(vnYear == "" || vnYear == 0) vnYear = voDate.getFullYear();
  if(vnMonth == "" || vnMonth == -1) vnMonth = voDate.getMonth();
  if(vnDate == "" || vnDate == 0) vnDate = voDate.getDate();
  if(vnHour == "" || vnHour == 0) vnHour = voDate.getHours();
  if(vnMinute == "" || vnMinute == 0) vnMinute = voDate.getMinutes();
  if(vnSecond == "" || vnSecond == 0) vnSecond = voDate.getSeconds();

  voDate.setFullYear(vnYear);
  voDate.setMonth(vnMonth);
  voDate.setDate(vnDate);
  voDate.setHours(vnHour);
  voDate.setMinutes(vnMinute);
  voDate.setSeconds(vnSecond);

  if( voDate.getFullYear() != vnYear
      || voDate.getMonth() != vnMonth
      || voDate.getDate() != vnDate
      || voDate.getHours() != vnHour
      || voDate.getMinutes() != vnMinute
      || voDate.getSeconds() != vnSecond) {
    return false;
  }
  return true;
};
/**
 * 마스크 프롬프트를 공백문자로 치환합니다.
 * @param {String} 치환할 마스크 프롬프트값
 * @return 마스크프롬프트가 공백으로 치환된 값
 * @type String
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.maskPromptToBlank = function(psValue){
  var vsReg = new RegExp('['+this.maskPrompt+']','gi');
  psValue = psValue.replace(vsReg, " ");
  return psValue;
};
/**
 * 설정된 숫자형 마스크 포맷으로 값을 변환합니다.
 * @param {String} 변환할 값
 * @return 숫자형 마스크 포맷 적용 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.toNumberFormatValue = function(psValue){
  var vsFormat = this.mask.replace(/[#0]/gi,this.maskPrompt);
  // 개체의 값 얻어오기
  var vsReg = new RegExp('['+this.maskPrompt+']','gi');
  var vsValue = psValue.replace(vsReg,"a");
  var vsRegValue = vsFormat;
  var vsRegFormat = new RegExp('['+this.maskPrompt+'0]','i');
  for(var i=0;i < vsValue.length;i++) {
    vsRegValue = vsRegValue.replace(vsRegFormat, vsValue.charAt(i));
  }
  vsRegValue = vsRegValue.replace(/[#]/g,this.maskPrompt);
  return vsRegValue;
};
/**
 * 설정된 날짜형 마스크 포맷으로 값을 변환합니다.
 * @param {String} 변환할 값
 * @param {Boolean} 데이타에서 넘어왔는지의 여부
 * @return 마스크 포멧이 적용된 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.toDateFormatValue = function(psValue, pbData){
  var voDf = this.df;
  var vbData = pbData;
  if(vbData == null) vbData = false;
  psValue = psValue.replace(/[^\d]/g, "");
  var vsMask = this.mask.replace(/[124]/g, "");
  var vsRegValue = "";
  var voDate = new Date();
  if(!vbData){
    var vsFormat = vsMask.replace(this.regDateMask,this.maskPrompt);
    // 개체의 값 얻어오기
    var vsReg = new RegExp('['+this.maskPrompt+']','gi');
    //var vsValue = psValue.replace(vsReg,"a");
    vsRegValue = vsFormat;
    var vsRegFormat = new RegExp('['+this.maskPrompt+']','i');
    for(var i=0;i < psValue.length;i++) {
      vsRegValue = vsRegValue.replace(vsRegFormat, psValue.charAt(i));
    }
    vsRegValue = vsRegValue.replace(/[YMDhms]/g,this.maskPrompt);
  }else{
    var vnLen = psValue.length;
    var voDates = {"year" : "____", "month" : "__", "day" : "__",
        "hour" : "__", "minute" : "__", "second" : "__"};
    vsRegValue = vsMask;
    vsMask = vsMask.replace(/[^YMDhmis]/g, "");
    if(vnLen >= 8){
      voDates.year = psValue.substring(0, 4);
      voDates.month = psValue.substring(4, 6);
      voDates.day = psValue.substring(6, 8);
      if(vnLen == 14){
        voDates.hour = psValue.substring(8, 10);
        voDates.minute = psValue.substring(10, 12);
        voDates.second = psValue.substring(12);
      }
    }else if(vnLen == 6){
      voDates.hour = psValue.substring(0, 2);
      voDates.minute = psValue.substring(2, 4);
      voDates.second = psValue.substring(4);
    }
    vsRegValue = vsRegValue.replace(/yyyy/ig, voDates.year);
    vsRegValue = vsRegValue.replace(/mm/ig, voDates.month);
    vsRegValue = vsRegValue.replace(/dd/ig, voDates.day);
    vsRegValue = vsRegValue.replace(/hh/ig, voDates.hour);
    vsRegValue = vsRegValue.replace(/mi/ig, voDates.minute);
    vsRegValue = vsRegValue.replace(/ss/ig, voDates.second);
    vsRegValue = vsRegValue.replace(/[YMDhmis]/g,this.maskPrompt);
  }
  return vsRegValue;
};

eXria.controls.xhtml.EditMask.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null || this.data.isRelativeRef()) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voDf = this.df;
  if(this.data.instanceId == null) return;
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  if (vsRefData != null && typeof vsRefData != this.formatType) {
    switch (this.formatType) {
      case "number" :
        if(vsRefData != "") vsRefData = Number(vsRefData);
        break;
      case "date" :
        if (vsRefData != null && vsRefData != "") {
          this.dataLen = vsRefData.length;
        } else if (this.dataLen == null) {
          if (this.mask && /(H{1,2}|h{1,2}|m{1,2}|s{1,2})/.test(this.mask)) this.dataLen = 14;
          else this.dataLen = 8;
        }
        break;
      case "string" :
        vsRefData = String(vsRefData);
        break;
    }
  }
  this.setValue(vsRefData);
};
/**
 * 정해진 마스크 타입에 따라 컨트에 값을 설정합니다.
 * @param {String} psData 설정할 값
 */
eXria.controls.xhtml.EditMask.prototype.setValue = function(psData) {
  var voInput = this.subElement.input;
  if(this.formatType == "date") {
    if(this.mask && /^\d*$/g.test(psData) == false) {
      var vsRegMask = this.mask
      vsRegMask = vsRegMask.replace("yyyy", "\\d{4}");
      vsRegMask = vsRegMask.replace("MM", "\\d{2}");
      vsRegMask = vsRegMask.replace("dd", "\\d{2}");
      if(new RegExp(vsRegMask).test(psData)) {
        psData = TGP.GetValueInput(psData, "date", this.mask);
        var voDate = new Date();
        voDate.setTime(psData);
        psData = this.getDateString(voDate);
      }
    }
  }
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue !== psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;
  this.value = psData;
  if(vbChanged) this.data.setData(this.value);
  if(psData != null && psData !== "") {
    switch(this.formatType) {
    case "number":
			psData = TGP.GetString(psData, this.formatType, this.regFormat);
      break;
    case "date":
      psData = this.getDate(psData).getTime();
			psData = TGP.GetString(psData, this.formatType, this.regFormat);
      break;
    case "string":
			psData = this.getFormatedValue(psData, this.format);
      psData = TGP.GetString(psData, this.formatType, this.regFormat);
      break;
    }		
  } else {
    psData = "";
  }
  voInput.value = psData;
};
/**
 * 컨트롤에 값을 설정하며 값의 변경이 있으면 onchange 이벤트를 발생시킵니다.
 * @param {String} psData 설정 값
 */
eXria.controls.xhtml.EditMask.prototype.setValueWithNotify = function(psData) {
  var voInput = this.subElement.input;
  if(this.formatType == "date") {
    if(this.mask && /^\d*$/g.test(psData) == false) {
      var vsRegMask = this.mask
      vsRegMask = vsRegMask.replace("yyyy", "\\d{4}");
      vsRegMask = vsRegMask.replace("MM", "\\d{2}");
      vsRegMask = vsRegMask.replace("dd", "\\d{2}");
      if(new RegExp(vsRegMask).test(psData)) {
        psData = TGP.GetValueInput(psData, "date", this.mask);
        var voDate = new Date();
        voDate.setTime(psData);
        psData = this.getDateString(voDate);
      }
    }
  }
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue !== psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;
  this.value = psData;
  if(psData != null && psData !== "") {
    switch(this.formatType) {
    case "number":
      break;
    case "date":
      psData = this.getDate(psData).getTime();
      break;
    case "string":
      psData = this.getFormatedValue(psData, this.format);
      break;
    }
    psData = TGP.GetString(psData, this.formatType, this.regFormat);
  } else {
    psData = "";
  }
  voInput.value = psData;
  if(vbChanged) {
    this.data.setData(this.value)
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
    if(this.changeEventCallback) this.changeEventCallback(voEvent);
  }
};
/**
 * 주어진 마스크에 의해 데이타를 필터링하는 메소드
 * @param {String} psData 데이타
 * @param {String} psMask 마스크 문자열
 * @return 주어진 마스크에 의해 필터링된 데이타 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.getMaskedValue = function(psData, psMask) {
  if(psData == null || psData == "") return psData;
  if(psMask == null || psMask == "") return psData;
  var voRegMap = {"x": "[A-Za-z0-9]", "X": "[A-Za-z0-9]", "#": "[0-9]", "*": ".", "S" : "[a-zA-Z0-9\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]"};
  psMask = psMask.replace(/[^#Xx\*S]/g, "");
  var vsRegValue = "";
  var vnIndex = 0;
  var vnSize = psMask.length;
  var vsMaskChar = null;
  var vsChar = null;
  var vnValLen = psData.length;
  var vsRegStr = null;
  for(var i=0; i < vnSize; i++) {
    vsMaskChar = psMask.charAt(i);
    vsChar = psData.charAt(vnIndex++);
    vsRegStr = voRegMap[vsMaskChar];
    if(vsRegStr && (new RegExp(vsRegStr)).test(vsChar)) vsRegValue += vsChar;
    else i--;
    if(vnIndex >= vnValLen) break;
  }
  return vsRegValue;
};
/**
 * 컨트롤에 설정된 값을 Date형태로 반환합니다.
 * @return Date형으로 변환된 컨트롤 설정 값
 * @type Date
 */
eXria.controls.xhtml.EditMask.prototype.getDate = function(psDate){
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voDateinputCtrl = this.subElement.input;
  var voDate = new Date();
  if(psDate) {

   //psDate 가 숫자로만 들어온다는 가정하에 구현된 코드 이므로
   //숫자만 남기는 코드 추가
   //2010-03-10
   var vsRegType = /[^0-9]/gi;
   psDate = psDate + "";
   psDate = psDate.replace(vsRegType, '');

   var vsTime = psDate.substring(0, 4) + "/" + psDate.substring(4, 6) + "/" + psDate.substring(6, 8);
   if(psDate.length > 8) {
     var _HH = (psDate.substring(8, 10)*1 >= 24)? 23 :psDate.substring(8, 10);
     var _mm = (psDate.substring(10, 12)*1>= 60)? 59 :psDate.substring(10, 12);
     var _ss = (psDate.substring(12, 14)*1>= 60)? 59 :psDate.substring(12, 14);

     vsTime += " " + _HH + ":" + _mm + ":" + _ss;
   }

   var vnTime = Date.parse(vsTime);
   if(isNaN(vnTime)) vnTime = new Date();

   voDate.setTime(vnTime);
   return voDate;
  }
  var vsValue = voDateinputCtrl.value;
  var vsFormat = this.regFormat;
  if(vsFormat == null) vsFormat = "";
  vsFormat = vsFormat.replace(/[^YMDhmis]/gi,"");
  vsValue = vsValue.replace(/[^0-9]/gi,"");
  var vnIndex = vsValue.length;
  //year
  var temp = vsFormat.indexOf("YYYY",0);
  var vnYear = vsValue.substring(temp,temp+4);
  if(temp < 0){
   temp = vsFormat.search(/yy/i);
   vnYear = vsValue.substring(temp, temp + 2);
   vnYear = String(voDate.getFullYear()).substring(0, 2) + vnYear;
  }
  if(vnYear.length == 4) voDate.setFullYear(vnYear);
  //month
  var temp = vsFormat.indexOf("MM",0);
  var vnMonth = vsValue.substring(temp,temp+2);
  if(vnMonth.length == 2) voDate.setMonth(vnMonth-1);
  //date
  var temp = vsFormat.indexOf("DD",0);
  var vnDate = vsValue.substring(temp,temp+2);
  var vnHour = "00";
  var vnMinute = "00";
  var vnSecond = "00";
  if(vnDate.length == 2) voDate.setDate(vnDate);
  //initialize time
  voDate.setHours(0);
  voDate.setMinutes(0);
  voDate.setSeconds(0);
  voDate.setMilliseconds(0);
  //hour
  temp = vsFormat.indexOf("hh",0);
  if(temp != -1) {
   vnHour = vsValue.substring(temp,temp+2);
   if(vnHour.length == 2) voDate.setHours(vnHour);
  }
  //minute
  temp = vsFormat.indexOf("mi",0);
  if(temp != -1) {
   vnMinute = vsValue.substring(temp,temp+2);
   if(vnMinute.length == 2) voDate.setMinutes(vnMinute);
  }
  //second
  temp = vsFormat.indexOf("ss",0);
  if(temp != -1) {
   vnSecond = vsValue.substring(temp,temp+2);
   if(vnSecond.length == 2) voDate.setSeconds(vnSecond);
  }
  return voDate;
};
/**
 * 컨트롤에 설정된 값을 yyyymmdd형태의 문자열 값으로 반환합니다.
 * @parame {Date} 문자열 형태로 변환될 Date 값
 * @return yyyymmdd형태의 문자열 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.getDateString = function(poDate){
  var voDf = this.df;
  var voDate = poDate;
  if(voDate == null) voDate = this.getDate();
  var vaStrBuf = [];
  vaStrBuf.push(voDate.getFullYear());
  var vnMonth = voDate.getMonth() + 1;
  if(vnMonth < 10) vnMonth = "0" + vnMonth;
  vaStrBuf.push(vnMonth);
  var vnDate = voDate.getDate();
  if(vnDate < 10) vnDate = "0" + vnDate;
  vaStrBuf.push(vnDate);
  if(this.dataLen >= 14) {
    var vnHour = voDate.getHours();
    if(vnHour < 10) vnHour = "0" + vnHour;
    var vnMinute = voDate.getMinutes();
    if(vnMinute < 10) vnMinute = "0" + vnMinute;
    var vnSecond = voDate.getSeconds();
    if(vnSecond < 10) vnSecond = "0" + vnSecond;
    vaStrBuf.push(vnHour + "" + vnMinute + vnSecond);
  }
  return vaStrBuf.join("");
};
/**
 * 입력된 date형 데이타를 컨트롤 값으로 설정해주는 메소드.
 * @param {Date} poDate 컨트롤 값으로 설정할 date형 데이타
 */
eXria.controls.xhtml.EditMask.prototype.setDate = function(poDate){
  var voDateinputCtrl = this.subElement.input;
  var vnYear = new String(poDate.getFullYear());
  var vnMonth = new String(poDate.getMonth()+1);
  if(vnMonth.length == 1) vnMonth = "0" + vnMonth;
  var vnDate = new String(poDate.getDate());
  if(vnDate.length == 1) vnDate = "0" + vnDate;
  var vnHours = new String(poDate.getHours());
  if(vnHours.length == 1) vnHours = "0" + vnHours;
  var vnMinutes = new String(poDate.getMinutes());
  if(vnMinutes.length == 1) vnMinutes = "0" + vnMinutes;
  var vnSeconds = new String(poDate.getSeconds());
  if(vnSeconds.length == 1) vnSeconds = "0" + vnSeconds;
//  var vsValue = this.mask.replace(/[^YMDhmis]/g,"");
  var vsValue = "YYYYMMDDhhmmss";
  vsValue = vsValue.replace(/YYYY/g,vnYear);
  vsValue = vsValue.replace(/MM/g,vnMonth);
  vsValue = vsValue.replace(/DD/g,vnDate);
  vsValue = vsValue.replace(/hh/g,vnHours);
  vsValue = vsValue.replace(/mm/g,vnMinutes);
  vsValue = vsValue.replace(/ss/g,vnSeconds);
  if(this.dataLen < 14) vsValue = vsValue.substring(0, 8);
  this.setValue(vsValue);
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.EditMask[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 마스크포멧이 적용된값에서 사용자가 입력한값만을 추출하는 메소드입니다.
 * @param psValue
 * @return 사용자가 입력한값
 * @type String
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.evalValue = function (psValue){
  var voDf = this.df;
  var vsValue = psValue;
  var vsRegValue = "";
  var vsMask = this.stringPromptMask;
  for(var i = 0; i < vsMask.length; i++ ){
    if(vsMask.charAt(i) == this.maskPrompt) vsRegValue += vsValue.charAt(i)
  }
  return vsRegValue;
}
/**
 * 문자형 마스크 포맷으로 값을 변환합니다.
 * @param {String} psValue 입력값
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.setGeneric = function (psValue){
  var voDf = this.df;
  var vsValue = String(psValue);
  var vsTempValue = vsValue;
  var vsMaskChar = "Xx#A*a!^Ww90";
  var vsMaskChange = this.stringPromptMask;
  var vsMaskChangeZero = this.mask.replace(/[Xx#A*a!^Ww9]/g, this.maskPrompt);
  var vaReg = [];
  var vsRetVal = "";
  var vbMask;
  var vsChar;
  var vbFail = false;
  var vaIsMaskChar = [];
  var vnIndex = -1;
  var vaRegExp = {"x": "A-Za-z0-9", "X": "A-Za-z0-9", "#": "0-9", "*": " A-Za-z0-9", "A" : "A-Z0-9",
      "a" : "0-9a-z", "!" : "A-Z0-9", "^" : "0-9a-z", "W" : "A-Z", "w" : "a-z", "9" : "0-9" , "0" : "0-9"};
  //var vnPos = this.cursorPosition;
  var vnPos = this.getCursorPosition();
  var vsMask = this.mask;
  var vnLen = vsMask.length
  var vaIsMaskForChar = [];
  for(var i = 0; i < vnLen; i++) {
    // grab the current character
    vsChar = vsMask.charAt(i);
    // check to see if current character is a mask, escape commands are not a mask character
    vbMask = (vsMaskChar.indexOf(vsChar) > -1);
    // build a regex to test against
    //if(vbMask && (vaReg.length < vsValue.length)) vaReg[vaReg.length] = "[" + vaRegExp[vsChar] + "]";
    if(vbMask) vaReg[vaReg.length] = "[" + vaRegExp[vsChar] + "]";
    else vaReg[vaReg.length] = vsChar;
    // build mask definition table
    vaIsMaskForChar[vaIsMaskForChar.length] = { "char": vsChar, "mask": vbMask };
  }
  //////////////////
  if(this.vbCheck && this.vbSelectAll) {
    this.tempValue = "";
    return vsMaskChangeZero;
  }
  if(this.vbCheck && vaIsMaskForChar[vnPos]["mask"]){
    if(vnPos == 0 && vsValue.length > this.mask.length) return vsValue;
    var vsDelString = "";
    var vnLastSize = vnPos + this.selectionSize;
    for(var i = vnPos; i < vnLastSize; i++){
      if(vaIsMaskForChar[i]["mask"]) vsDelString += vaIsMaskForChar[i]["char"] == 0 ? 0 : this.maskPrompt;
      else vsDelString += vaIsMaskForChar[i]["char"];
    }
    vsValue = vsValue.substring(0, vnPos) + vsDelString + vsValue.substring(vnPos);
    this.vbCheck = false;
    this.tempValue = this.evalValue(vsValue);
    return vsValue;
  }else if(this.vbCheck && !vaIsMaskForChar[vnPos]["mask"]){
    vnCutPos = this.stringPromptMask.substring(0, vnPos).lastIndexOf(this.maskPrompt);
    if(vnCutPos < 0) {
      vnCutPos = 0;
      vsValue = vsMaskChange.substring(0, this.selectionSize) + vsMaskChange.substring(vnCutPos + 1, vnPos + 1) + vsValue.substring(vnPos);
    }else{
      var vsDelString = "";
      var vnLastSize = vnPos + this.selectionSize;
      for(var i = vnPos; i < vnLastSize; i++){
        if(vaIsMaskForChar[i]["mask"]) vsDelString += vaIsMaskForChar[i]["char"] == 0 ? 0 : this.maskPrompt;
        else vsDelString += vaIsMaskForChar[i]["char"];
      }
      vsValue = vsValue.substring(0, vnCutPos) + (vaIsMaskForChar[vnPos - 1]["char"] == 0 ? "0" : this.maskPrompt) + vsDelString + vsValue.substring(vnCutPos + 1);
    }
    this.cutPos = vnCutPos;
    this.tempValue = this.evalValue(vsValue);
    this.vbCheck = false;
    return vsValue;
  }
  /////////////////
  if(!this.vbSelectAll){
    this.vsInput = "";
    var vsData = "";
    for(var i = 0; i < vnPos; i++) {
      if(vaIsMaskForChar[i]){
        vnIndex++;
        if(vaIsMaskForChar[i]["mask"]) {
          var vcValue = vsTempValue.charAt(vnIndex).split(" ").join("");
          switch(vaIsMaskForChar[i]["char"]){
          case "A" :
          case "W" :
          case "!" : vcValue = vcValue.toUpperCase();
            break;
          case "^" :
          case "w" :
          case "a" : vcValue = vcValue.toLowerCase();
            break;
          }
          if(new RegExp(vaReg[i]).test(vcValue) && vcValue.length != 0) {
            if(vcValue != this.maskPrompt)vsData += vcValue;
          }else if(vcValue != this.maskPrompt){
            this.vsInput = "fail";
            vbFail = true;
            vsTempValue = vsTempValue.substring(0, vnIndex) + vsTempValue.substring(vnIndex + 1);
            vnPos--;
            vnIndex--;
          }else{
            vsData += vcValue;
          }
        }
      }
    }
    var vnLength = vsValue.length;
    vnLength = vnLength < this.mask.length ? this.mask.length : vnLength - (vnPos + 1);
    //var vnStartIndex = vaIsMaskForChar.length - vnLength - 1;
    var vnStartIndex = vbFail == true ? vnPos : vnPos + 1;
    var vnEndIndex = vaIsMaskForChar.length - 1;
    var vaRevertData = [];
    var vsChar = null;
    var vnIndex = 0;
    for(var i = vnEndIndex; i >= vnPos; i--) {
      vnIndex++;
      if(vaIsMaskForChar[i]["mask"]) {
        var vnToIndex = this.mask.length + 1 - vnIndex;
        vsChar = vsValue.substring(vnToIndex, vnToIndex + 1);
        if(vsChar != this.maskPrompt){
          if(new RegExp(vaReg[i]).test(vsChar)) vaRevertData.push(vsChar);
        }else vaRevertData.push(vsChar);
      }
    }
    //if(vbFail) vsData += vsTempValue.substring(vnPos);
    //else vsData += vsTempValue.substring(vnPos + 1);
    vsData = vsData + vaRevertData.reverse().join("");
    var vsPlusData = "";
    //vnPos = this.getCursorPosition();
    if(vnLen < vnPos){
      var vnIndex = 0;
      vsValue = psValue.substring(vnLen);
      for(var i = 0; vsValue.charAt(vnIndex).length != 0; i++){
        var vnPromptIndex = vsTempValue.indexOf(this.maskPrompt);
        if( vnPromptIndex > 0 && vaIsMaskForChar[vnPromptIndex]["mask"]) {
          var vcValue = vsValue.charAt(vnIndex++);
          switch(vaIsMaskForChar[vnPromptIndex]["char"]){
          case "A" :
          case "W" :
          case "!" : vcValue = vcValue.toUpperCase();
            break;
          case "^" :
          case "w" :
          case "a" : vcValue = vcValue.toLowerCase();
            break;
          }
          if(new RegExp(vaReg[vnPromptIndex]).test(vcValue)) {
            if(vcValue != this.maskPrompt)vsPlusData += vcValue;
          }
        }else vnIndex++;
      }
    }
    vsData += vsPlusData;
  }else{
    var vnIndex = 0;
    var vnValueIndex = 0;
    var vsData = "";
    for(var i = 0; i < vaIsMaskForChar.length; i++){
      if(vaIsMaskForChar[i]["mask"]) {
        var vcValue = vsValue.charAt(vnValueIndex++);
        switch(vaIsMaskForChar[i]["char"]){
          case "A" :
          case "W" :
          case "!" : vcValue = vcValue.toUpperCase();
            break;
          case "^" :
          case "w" :
          case "a" : vcValue = vcValue.toLowerCase();
            break;
         }
        if(new RegExp(vaReg[i]).test(vcValue)) {
          if(vcValue != this.maskPrompt)vsData += vcValue;
        }
      }
    }
  }

  this.tempValue = vsData;
  vsRetVal = this.toStringFormatValue(vsData);
  this.tempValue = this.evalValue(vsRetVal);

  var vsChar = null;
  if(vsRetVal != null) {
    var voIsMaskForChar = null;
    if(vaIsMaskForChar[vnPos]) voIsMaskForChar = vaIsMaskForChar[vnPos];
    while(voIsMaskForChar && voIsMaskForChar["mask"] == false) {
      vnPos++;
      if(vaIsMaskForChar[vnPos]) voIsMaskForChar = vaIsMaskForChar[vnPos];
      else voIsMaskForChar = null;
    }
  }
  if(vnPos == vnLen - 1) vnPos++;
  this.cursorPosition = vnPos;
  this.vbSelectAll = false;
  return vsRetVal;
};
/**
 * 설정한 문자형 포맷으로 값을 변환합니다.
 * @param (String) psValue value 값
 * @return 스트링 포맷이 적용된 문자열 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.toStringFormatValue = function(psValue) {
  var voDf = this.df;
  var vrMask = /[#Xx*Aa!^Ww90]/g;
  var vsFormat = this.mask.replace(vrMask, this.maskPrompt);
  var vrMaskPrompt = new RegExp('['+this.maskPrompt+']','i');
  var vsRegValue = "";
  var vnIndex = 0;
  for(var i=0;i < vsFormat.length;i++) {
    var vcFormat = vsFormat.charAt(i);
    if(vcFormat == this.maskPrompt){
      var vcValue = psValue.charAt(vnIndex++);
      if(vcValue.length == 0) vsRegValue += this.mask.charAt(i) == 0 ? 0 : this.maskPrompt;
      else vsRegValue += vcValue;
    }else vsRegValue += vcFormat;
  }
//  for(var i = 0; i < psValue.length; i++){
//    vsRegValue = vsRegValue.replace(vrMaskPrompt, psValue.charAt(i));
//  }
  return vsRegValue;
};
//************************ NUMBERS *********************** //
/**
 * 숫자형 마스크 포맷으로 값을 변환합니다.
 * @param {String} psValue 입력값
 * @param {Boolean} pbData data값인지의 여부
 * @return 숫자형 마스크 포맷 적용 값
 * @type String
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.setNumber = function(psValue, pbData) {
  var voDf = this.df;
  var vnPos =  this.cursorPosition;
  //var vsMask = voDf.mask;
  if(pbData == null) pbData = false;
  var vsMask = this.mask.replace(/[0]/g, "#");
  var vsValue = psValue;
  //if(vsValue.length > vsMask.length){
    //vsValue = psValue.substring(0, vnPos) + (psValue.charAt(vnPos) == "." ? "" : psValue.substring(vnPos + 1));
  //}
  if(psValue.charAt(vnPos) != "." && !pbData) vsValue = psValue.substring(0, vnPos) +
  (psValue.charAt(vnPos) == "." ? "" : psValue.substring(vnPos + 1));
  var vnLen = null;
  var vbMaskHasDecimal = false;
  if(vsMask.indexOf(".") > -1) vbMaskHasDecimal = true;

  vsValue = String(vsValue).replace(/[^\d.-]*/gi, "");
  // make sure there's only one decimal point
  vsValue = vsValue.replace(/\./, "d").replace(/\./g, "").replace(/d/, ".");

  // check to see if an invalid mask operation has been entered
  if(!/^[+-]?((([0#]{1,3},)?([0#]{3},)*([0#]{3}))|([0#]{1,3})+)(\.[0#]*)?$/.test(vsMask.replace(/[^0#.\,\-\+]/gi, ""))) {
    alert("An invalid mask was specified for the \nMask constructor.");
    return psValue;
  }
  if(vsValue.length == 0) vsValue = NaN;
  if(vsValue == "." && vbMaskHasDecimal) vsValue = "0.";
  var vnValue = Number(vsValue);
  if(isNaN(vnValue)) {
    //alert("The value entered was not a number.");
    return "";
  }

  // if no mask, stop processing
  if(vsMask.length == 0) return vsValue;

  // get the value before the decimal point
  var vsInteger = String(Math.abs((vsValue.indexOf(".") > -1) ? vsValue.split(".")[0] : vsValue));
  // get the value after the decimal point
  var vbDecimal = false;
  if(vsValue.indexOf(".") > -1 && vbMaskHasDecimal) vbDecimal = true;
  var vsDecimal = (vbDecimal) ? vsValue.split(".")[1] : "";
  var vbNegative = ((Math.abs(vnValue)*-1 == vnValue) && (Math.abs(vnValue) != 0));

  // check for masking operations
  var vaIsShow = {
    "+" : ((vsMask.indexOf("+") != -1) && !vbNegative),
    "-" : vbNegative,
    "￥" : (vsMask.indexOf("￥") != -1), // Japanese yen
    "￡" : (vsMask.indexOf("￡") != -1), // English Pound
    "€" : (vsMask.indexOf("€") != -1), // /^[€]/.test(m), // Euro
    "$" : (vsMask.indexOf("$") != -1), // /^[\$]/.test(m), // Dollar
    "%" : (vsMask.indexOf("%") != -1), // Percentage
    "(" : (vbNegative && (vsMask.indexOf("(") > -1))
  };

  vaIsShow["-"] = (vbNegative && (!vaIsShow["("] || (vsMask.indexOf("-") != -1)));
  // if mask contain more than one symbol ￥ € $ and %, select just one
  if (vaIsShow["￥"] && ( vaIsShow["￡"] || vaIsShow["€"] || vaIsShow["$"] || vaIsShow["%"] )) vaIsShow["￥"] = false;
  if (vaIsShow["￡"] && ( vaIsShow["€"] || vaIsShow["$"] || vaIsShow["%"] )) vaIsShow["￡"] = false;
  if (vaIsShow["€"] && ( vaIsShow["$"] || show["%"] )) vaIsShow["€"] = false;
  if (vaIsShow["$"] && vaIsShow["%"]) vaIsShow["$"] = false;

  // replace all non-place holders from the mask
  //var vsMask = vsMask.replace(/[^#0._,]*/gi, "");


  var vaMask = vsMask.split(".");

  //pad the int with any necessary zeros

  // get number of digits before decimal point in mask
  var vsIntegerMask = (vaMask[0]) ? vaMask[0] : vsMask;
  vsIntegerMask = vsIntegerMask.replace(/[^0#]+/gi, "");
  // find the first zero, which indicates the minimum length
  // that the value must be padded w/zeros
  vnLen = vsValue.split(".")[0].length;
  if(vnLen > vsIntegerMask.length) {
    vnPos--;
  }
  if(vsInteger.length > vsIntegerMask.length) {
//    vsInteger = vsInteger.substring(0, vsIntegerMask.length);
    vsInteger = vsInteger.substring(vsInteger.length - vsIntegerMask.length);
  }
  var vnFirstZeroMask = vsIntegerMask.indexOf("0") + 1;
  // if there is a zero found, make sure it's padded
  //var vnFillZeroMask = -1;
  if(vnFirstZeroMask > 0) {
    vnFillZeroMask = vsIntegerMask.length - vnFirstZeroMask + 1;

    while(vsInteger.length < vnFillZeroMask) vsInteger = "0" + vsInteger;
  }


  //make sure there are the correct number of decimal places
  // get number of digits after decimal point in mask
  var vsDecimalMask = (vaMask[1]) ? vaMask[1] : "";
  if(vsDecimalMask.length == 0) {
    vsDecimal = "";
  } else {
    // find the last zero, which indicates the minimum number
    // of decimal places to show
    //vsDecimalMask = vsDecimalMask.replace(/[#0]/g, "0");
    //var vsTempDMask = vsDecimalMask.replace(/[#]/g, "%");
    //vsDecimalMask = vsDecimalMask.replace(/[#0]/g, "0");
    var vnLastZeroMask = vsDecimalMask.lastIndexOf("0") + 1;
    while(vsDecimal.length < vnLastZeroMask) vsDecimal += "0";
    //vsDecimalMask = vsTempDMask.replace(/[%]/g, "#");
  }
//  if(vsDecimal.length >= vsDecimalMask.length) {
//    vsDecimal = vsDecimal.substring(0, vsDecimalMask.length);
//  }
  //소수점 마지막위치에서 입력할때의 처리부분
  var vnDeMaskL = vsDecimalMask.length;
  if(vsDecimal.length > vnDeMaskL) {
    var vbZero = false;
    //var vsRealDecimalMask = voDf.mask.split(".")[1];
    var vsDecimalOverVal = vsDecimal.substring(vnDeMaskL);
    vsDecimal = vsDecimal.substring(0, vnDeMaskL);
    var vnNotZero = vsDecimal.indexOf("0");
    if(vsDecimalOverVal.length > vnDeMaskL) {
      vsDecimalOverVal = vsDecimalOverVal.substring(0, vnDeMaskL);
    }
    if(vnNotZero != -1){
      for(var i = vnNotZero; i <= vsDecimal.length; i++){
        if(vsDecimal.charAt(vnNotZero + i) == 0) vbZero = true;
        else {
          vbZero = false;
          i = vsDecimal.length + 1;
        }
      }
    }
    if(vbZero) {
      vsDecimal = vsDecimal.substring(0, vnNotZero) + vsDecimalOverVal +
      vsDecimal.substring(vsDecimalOverVal.length + vnNotZero);
    }
  }
  //check to see if we need commas in the thousands place holder
  //OLD: if( /[#0]+,[#0]{3}/.test(m) ){
  if( /[#0]+,[#0]{3}/.test(vsMask) ){
    // add the commas (or a space) as the place holder
    //added by Sylvain Machefert: we can define _ symbol to replace comma with space (French notation)
    //so mask = #,###.00 => 1,234,567.89
    //   mask = #_###.00 => 1 234 567.89
    var vaIntegerByComma = [];
    var i = 0;
    var vnNum = Number(vsInteger);
    while( vnNum > 999 ){
      vaIntegerByComma[i] = "00" + String(vnNum % 1000);
      vaIntegerByComma[i] = vaIntegerByComma[i].substring(vaIntegerByComma[i].length - 3);
      vnNum = Math.floor(vnNum / 1000);
      i++;
    }
    vaIntegerByComma[i] = String(vnNum % 1000);
    vsInteger = vaIntegerByComma.reverse().join(",");
  }


  //combine the new value together

  //if((vsDecimalMask.length > 0) && this.allowPartial && (vsValue.indexOf(".") > -1)) {
  //if(vsDecimalMask.length > 0 && vsDecimal.length) {
  if(vsDecimalMask.length > 0 && vsDecimal.length) {
    vsValue = vsInteger + "." + vsDecimal;
  } else {
    vsValue = vsInteger;
    if(vbDecimal) vsValue += ".";
  }

  //this.tempValue = vsValue;
  // 포멧이 0인곳에 0을 표시하는부분..
  var vsRegValue = "";
  var vbIsZero = false;
  var vsIntgerValue = vsValue.split(".")[0];
  var vsDecimalValue = vsValue.split(".")[1];
  var vsIntegerMask = this.mask.split(".")[0];
  var vsDecimalMask = this.mask.split(".")[1];
  vsDecimalValue = vsDecimalValue == undefined ? "" : vsDecimalValue;
  for(var i = 0; i < vsIntegerMask.length - vsIntgerValue.length; i++){
    var vcMask = this.mask.charAt(i);
    if(vcMask == 0) vbIsZero = true;
    if(vsRegValue.length != 0 && vcMask == "#") {
      vsRegValue = "";
      vbIsZero = false;
    }else if(vbIsZero) vsRegValue += vcMask;
  }
  vsValue = vsRegValue + vsValue;
  //소수점부분에서 포멧이 0인부분 처리
  if(vsValue.indexOf(".") > -1 && vsDecimalMask.replace(/0/g, "").length == 0
      && vsDecimalValue.length < vsDecimalMask.length && Number(vsDecimalValue) <= 0){
    vsDecimalValue = vsDecimalMask.substring(0, vsDecimalMask.length - vsDecimalValue.length) + vsDecimalValue;
  }else vsDecimalValue = "";
  vsValue += vsDecimalValue;

  vnLen = psValue.split(".")[0].length;
  if(vaIsShow["+"]) vsValue = "+" + vsValue;
  if(vaIsShow["-"]) vsValue = "-" + vsValue;
  if(vaIsShow["￥"]) vsValue = vsValue + "￥";
  if(vaIsShow["￡"]) vsValue = "￡" + vsValue;
  if(vaIsShow["€"]) vsValue = "€ " + vsValue; // this.mask.replace(/(^[€])(.+)/gi, "€ ") + v;
  if(vaIsShow["$"]) vsValue = "$" + vsValue; // this.mask.replace(/(^[\$])(.+)/gi, "$ ") + v;
  if(vaIsShow["%"]) vsValue = vsValue + " %";
  if(vaIsShow["("]) vsValue = "(" + vsValue + ")";
//  var vnLen2 = vsValue.split(".")[0].length;
//  if(vnLen2 - vnLen > 0) {
//    vnPos = vnPos + (vnLen2 - vnLen);
//  }
//  this.cursorPosition = vnPos;
  this.tempValue = vsValue;
  return vsValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "EditMask"
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.toString = function() {
  return "EditMask";
};
/**
 * 현재 텍스트가 전체 select 되어있는지 여부를 확인합니다.
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.checkSelect = function() {
  var voDf = this.df;
  var voDocument = this.document;
  var voCanvas = this.canvas;
  var voInput = this.subElement.input;
  var vnTextLen = this.mask.length;
  this.vbSelectAll = false;
  if(voCanvas.page.metadata.browser.ie){
    var voTextRange = voDocument.selection.createRange();
    var vnLen = voTextRange.text.length;
    this.selectionSize = vnLen == 0 ? 1 : vnLen;
    if(vnLen == vnTextLen) this.vbSelectAll = true;
  }else{
    if(voInput.selectionEnd - voInput.selectionStart == vnTextLen) this.vbSelectAll = true;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atselect = function(poEvent){
//  this.checkSelect();
};
/**
 * @ignore
 */
eXria.controls.xhtml.EditMask.prototype.atclick = function(poEvent){
//  this.checkSelect();
};
/**
 * 텍스트값을 삭제시 사용자가 정의한 마스크를 제외한값을 삭제합니다.
 * @param poEvent
 * @return 삭제하고 난 후의 값
 * @private
 */
eXria.controls.xhtml.EditMask.prototype.chkBackSpace = function(poEvent){
  var voDf = this.df;
  var vnKeyCode = poEvent.keyCode;
  var vnPos = this.getCursorPosition();
  var vsValue = null;
  var vnCutPos = 0;
  //var voStringReg = new RegExp("[^#*XxAa!Ww9^]","g");
  var voDateReg = new RegExp("[^YMDhms]","g");
  var voValues = new Array;
  if(this.vbSelectAll) return "";
  this.vbCheck = true;
  var voReg = voDateReg;
  var voRegI = /[YMDhms]/g;
  if(voReg.test(this.mask.charAt(vnPos))){
      vsValue = this.tempValue;
      if(vsValue == null || vsValue == undefined || vsValue.legnth == 0) vsValue = "";
      else vsValue = this.toDateFormatValue(vsValue);
      if(vnKeyCode == 8){
        vnCutPos = this.mask.replace(voRegI, this.maskPrompt).substring(0, vnPos).lastIndexOf(this.maskPrompt);
        if(vnCutPos < 0) vnCutPos = 0;
        vsValue = vsValue.substring(0, vnCutPos) + this.maskPrompt + vsValue.substring(vnCutPos + 1);
        voValues[1] = vnCutPos;
      }else{
        vnCutPos = this.mask.replace(voRegI, this.maskPrompt).substring(vnPos).indexOf(this.maskPrompt);
        vnCutPos += vnPos;
        vsValue = vsValue.substring(0, vnCutPos) + this.maskPrompt + vsValue.substring(vnCutPos + 1);
      }
      voValues[0] = vsValue;
  }
  return voValues;
};

/**
 * 주어진 포맷에 의해 데이타를 필터링하는 메소드
 * @param {String} psData 데이타
 * @param {String} psFormat 포맷 문자열
 * @return 주어진 포맷에 의해 필터링된 데이타 값
 * @type String
 */
eXria.controls.xhtml.EditMask.prototype.getFormatedValue = function(psData, psFormat) {
  if(psData == null || psData == "") return psData;
  if(psFormat == null || psFormat == "") return psData;
  var voRegMap = {"x": "[A-Za-z0-9]", "X": "[A-Za-z0-9]", "#": "[0-9]", "*": ".", "S" : "[a-zA-Z0-9\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]"};
  var vsRegValue = "";
  var vnIndex = 0;
  var vnSize = psFormat.length;
  var vsFormatChar = null;
  var vsChar = null;
  var vnValLen = psData.length;
  var vsRegStr = null;
  for(var i=0; i <= vnSize; i++) {
    vsFormatChar = psFormat.charAt(i);
    vsChar = psData.charAt(vnIndex);
    vsRegStr = voRegMap[vsFormatChar];
    if(vsRegStr && (new RegExp(vsRegStr)).test(vsChar)) {
			vsRegValue += vsChar;
			vnIndex++;
		} else {
			vsRegValue += vsFormatChar;
		}
    if(vnIndex >= vnValLen) break;
  }
  return vsRegValue;
};
/**
 * @fileoverview
 * Concreate xhtml Ellipse(XHTML Ellipse 컨트롤)
 * @author 이종녕
 */

/**
 * @class xhtml Ellipse Control.<br>
 * 타원 도형을 표현하는 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Ellipse 객체
 * @type eXria.controls.xhtml.Ellipse
 * @constructor
 * @base eXria.controls.xhtml.ShapeControl
 */
eXria.controls.xhtml.Ellipse = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  /**
   * pnLeft 컨트롤 좌상단 점의 x좌표.
   * @type Number
   */
  pnLeft = pnLeft == null ? 20 : pnLeft;
  /**
   * pnTop 컨트롤 좌상단 점의 y좌표.
   * @type Number
   */
  pnTop = pnTop == null ? 20 : pnTop;
  /**
   * pnWidth 컨트롤의 가로 길이.
   * @type Number
   */
  pnWidth = pnWidth == null ? 100 : pnWidth;
  /**
   * pnHeight 컨트롤의 세로 길이.
   * @type Number
   */
  pnHeight =  pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.ShapeControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 도형 채움 색상의 글라데이션 시작 값.
   * @type String
   */
  this.fillStartColor = null;
  /**
   * 도형 채움 색상의 글라데이션 마무리 값.
   * @type String
   */
  this.fillEndColor = null;
  /**
   * 도형 색상 채움 타입.<br>
   * "none" | "solid" | "gradient" | "gradientradial" | "default:solid"
   * @type String
   */
  this.fillType = null;
  /**
   * 글라데이션 진행 각도.
   * @type Number
   */
  this.fillAngle = null;
  /**
   * 색상 채움 불투명도.
   * @type Number
   */
  this.fillOpacity = null;
  /**
   * 컨트롤의 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.ShapeControl, eXria.controls.xhtml.Ellipse);
//////////////////////////////////////////////////////////////////
//// 메소드

eXria.controls.xhtml.Ellipse.prototype.createCtrl = function(poDocument){
  var voDiv = poDocument.createElement("div");
  var voStyle = voDiv.style;
  voDiv.setAttribute("id",this.id);
  voStyle.padding = "0px";
  voStyle.margin = "0px";
  voStyle.borderStyle = "none";
  voStyle.borderWidth = "0px";
  this.ctrl = voDiv;
  return voDiv;
};
/**
 * 지정된 각도를 -90 ~ 90도 사이에 값으로 변환하는 메소드.
 * @param {Number} pnAngle 지정한 각도
 * @return 변환된 각도
 * @type Number
 */
eXria.controls.xhtml.Ellipse.prototype.quartAngle = function(pnAngle) {
  var vnNumber = pnAngle%180;
  if( vnNumber > 90) vnNumber = 180 - vnNumber;
  return vnNumber;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Ellipse.prototype.angleHeight = function(pnWidth,pnHeight) {
  var vnAngle = this.angle % 90;
  var vnR1 = pnWidth * Math.sin(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.cos(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Ellipse.prototype.angleWidth = function(pnWidth,pnHeight) {
  var vnAngle = this.angle % 90;
  var vnR1 = pnWidth * Math.cos(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.sin(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/**
 * 도형 객체 생성.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Ellipse.prototype.createEllipseCtrl = function(poCtrl,poDocument){
  var voDf = this.df;
  var voWindow = this.window;
  poCtrl.style.top = this.top ;
  poCtrl.style.left = this.left;
  var vnDistanceY = this.angleHeight(this.width,this.height);
  var vnDistanceX = this.angleWidth(this.width,this.height);
  var vnHeight = (vnDistanceY - this.height/2);
  var vnWidth = (vnDistanceX - this.width/2);
   gCore.init(voWindow); // 초기화.....
  var pane = new voWindow.Pane(this.id+"_draw",-vnWidth,-vnHeight,vnDistanceX*2,vnDistanceY*2,poDocument);
  var border = this.penWeight/2;
  var vnCtrlHeight = this.height - voDf.penWeight - 1;
  var vnCtrlWidth = this.width - voDf.penWeight - 1;
  if(gCore.browser.msie && gCore.browser.msie < 9 && border%1 == 0){
    vnCtrlHeight -= 1;
    vnCtrlWidth -= 1;
  }
  var voCtrl = new voWindow.Ellipse(this.id+"_ellipse",border+vnWidth, border+vnHeight, vnCtrlWidth, vnCtrlHeight);
  var voCtrlStroke = voCtrl.stroke;
  var voCtrlFill = voCtrl.fill;
  voCtrlStroke.weight = voDf.penWeight + "px";
  voCtrlStroke.color = voDf.penColor;
  voCtrlStroke.type = this.toConstPenstyle(voDf.penStyle);
  voCtrlStroke.opacity = this.toPercent(voDf.penOpacity);
  if(voDf.penColor == "transparent") voCtrlStroke.opacity = 0;
  voCtrlStroke.lineCap = this.toConstPencap(voDf.penCap);
  voCtrlStroke.joinType = this.toConstJointype(voDf.joinType);
  voCtrlFill.color = voDf.fillStartColor;
  voCtrlFill.color2 = voDf.fillEndColor;
  voCtrlFill.type = voDf.fillType;
  voCtrlFill.angle = voDf.fillAngle;
  voCtrlFill.opacity = this.toPercent(voDf.fillOpacity);
  voCtrl.angle = voDf.angle;
  voCtrl.cursor = voDf.cursor;
  pane.addShape(voCtrl);
  pane.draw(poCtrl);
};

eXria.controls.xhtml.Ellipse.prototype.setSpecificDefaults = function(poCtrl,poDocument) {
  var voDf = this.df;
  voDf.fillStartColor = this.getAttrValue("fillStartColor",this.fillStartColor);
  voDf.fillEndColor = this.getAttrValue("fillEndColor", this.fillEndColor);
  voDf.fillType = this.getAttrValue("fillType",this.fillType);
  voDf.fillAngle = this.getAttrValue("fillAngle",this.fillAngle);
  voDf.fillOpacity = this.getAttrValue("fillOpacity",this.fillOpacity);
};

eXria.controls.xhtml.Ellipse.prototype.setSpecificAttrs = function(poCtrl,poDocument) {
  this.createEllipseCtrl(poCtrl,poDocument);

};
/**
 * @ignore
 */
eXria.controls.xhtml.Ellipse.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
};

eXria.controls.xhtml.Ellipse.prototype.setSpecificEvents = function(poCtrl,poDocument) {
};

eXria.controls.xhtml.Ellipse.prototype.removeSpecificDefaults = function(poCtrl,poDocument) {
  this.df = {};
};

eXria.controls.xhtml.Ellipse.prototype.refreshSpecificAttrs = function(poCtrl,poDocument){
  var voDiv = this.getCtrl(poDocument);
  var voPaneCtrl = voDiv.childNodes[0];
  voDiv.removeChild(voPaneCtrl);
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Ellipse.prototype.applyAttrRefresh = function(psAttrName, psAttrValue, poDocument) {
  this.setAttr(psAttrName, psAttrValue);
  this.refresh(poDocument);
};

eXria.controls.xhtml.Ellipse.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Ellipse[psAttrName];
  if(vsDefaultValue == null) vsDefaultValue = this.getShapeDefaultValue(psAttrName);
  if(vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "Ellipse"
 * @type String
 */
//this.toString = function() {
eXria.controls.xhtml.Ellipse.prototype.toString = function() {
  return "Ellipse";
};

/**
 * @fileoverview
 * Concreate xhtml FreeForm(XHTML FreeForm 컨트롤)
 * @author : 조영진
 */

/**
 * @class Concreate xhtml FreeForm.<br>
 * XHTML FreeForm 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.FreeForm 객체
 * @type eXria.controls.xhtml.FreeForm
 * @constructor
 * @base eXria.controls.xhtml.Group
 */
eXria.controls.xhtml.FreeForm = function(psId, pnLeft, pnTop, pnWidth, pnHeight, pbTableLayout) {
  if(pbTableLayout != true && page.tableLayoutMap && page.tableLayoutMap[psId] != null) {
    this.inheritTableLayout(psId, pnLeft, pnTop, pnWidth, pnHeight);
    return;
  }
  
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;

  eXria.controls.xhtml.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight, true);  // UIControl을 상속받는다.
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 프린트 작업 담당 오브젝트.
   * @type eXria.controls.xhtml.Print
   */
  this.printObject = null;
  /**
   * 화면에 표시될 인스턴스 데이타의 row index(base 0)
   * @type Number
   */
  this.rowIndex = 0;
  /**
   * 그리도 연동 데이타 셋 참조 변수
   * @type eXria.data.plugin.DataSetCmd
   */
  this.dataset = null;

  this.cursor = null;
	
	this.recursiveCnt = 0;
	this.recursiveMap = new eXria.data.ArrayMap();
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Group, eXria.controls.xhtml.FreeForm);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.FreeForm.prototype.loadData = function(poDocument, pbKeepStatus) {
  if(this.datasetId == null || this.datasetId == "") {
    this.loadDataFromInstance(poDocument);
  } else {
    this.loadDataFromDataSet(poDocument, pbKeepStatus);
  };
};
/**
 * loadDataFromInstance.
 * 인스턴스 데이타 연동 메소드.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.loadDataFromInstance = function(poDocument) {
  var voData = this.data;
  var vsInstanceId = voData.nodesetInstanceId;
  var vsInstancePath = voData.nodesetInstancePath;
  if(vsInstanceId == null || vsInstancePath == null) return;
  var voCtrl = this.getCtrl(poDocument);
  //this.removeChildren();

  var voCollectionNode = voData.getNodesetData2();
  if(voCollectionNode == null) return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsValue = null;
  var voChildData = null;
  var vnRowIndex = this.rowIndex;
  for(var i = 0; i < vnLoop; i++) {
    if(vnRowIndex != i) continue;
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    var voChild = null;
    var voIterator = this.controls.iterator();
    var vsId = null;
    var vsPath = null;
    var vsType = null;
    var vsValue = null;
    var vbJsonPath = page.metadata.useJsonInstance && (page.metadata.useDomPath != true);
		
		var voMap = null;
		var vnMapLength = null;
		
    while(voIterator.hasNext()) {
      voChild = voIterator.next();

			if(voChild.controls != null) {
				this.recursiveControl(voChild);
				voMap = this.recursiveMap;
			}

			if(voMap == null) vnMapLength = 1;
			else vnMapLength = voMap.size();
			
			for(var i = 0; i < vnMapLength; i++) {
				if(voMap != null) voChild = voMap.get(i);
				voChildData = voChild.data;
				
	      if(voChildData != null) {
	        var vbNotAttached = false;
	        if(voChild.canvas == null) {
	          voChild.canvas = this.canvas;
	          vbNotAttached = true;
	        }
	        vsId = voChildData.instancePath;
	        if(vsId) {
	          vsId = vsId.split("/");
	          vsId = vsId[vsId.length - 1];
	          vsPath = vsInstancePath + "[" + (vbJsonPath ? vnRowIndex : (vnRowIndex + 1)) + "]/" + vsId;
	          voChildData.setRef(vsInstanceId, vsPath);
	          voChildData.markUpdateAbove = true;
	          vsType = voChild.toString();
	          if(vsType == "DateInput" || vsType == "EditMask") {
	            vsValue = voChildData.getData();
	            if(vsValue != null && vsValue != "") {
	              if(voChild.maxLength == null) voChild.maxLength = vsValue.length;
	            }
	          }
	//         vsValue = voMapNode.get(vsId);
	//         if(vsValue == null) vsValue = "";
	//         voChildCtrl = voChild.getCtrl(poDocument);
	//         if(voChildCtrl) {
	//          if(voChild.setValue) voChild.setValue(vsValue, null, poDocument);
	//         } else {
	//          voChild.value = vsValue;
	//         }
	        }
	        if(vbNotAttached) voChild.canvas = null;
	      }
			}
			this.recursiveCnt = 0;
			this.recursiveMap.clear();
			voMap = null;
			vnMapLength = null;
    }
    break;
//    if(this.printMode == false) break;
  }
};
eXria.controls.xhtml.FreeForm.prototype.recursiveControl = function(poSubChild) {
	var voSubChild = null;
	if(poSubChild != null && poSubChild.controls != null) {
		var voSubIterator = poSubChild.controls;
		
		for(var i = 0; i < voSubIterator.size(); i++) {
			voSubChild = voSubIterator.get(i);
			
			if(voSubChild.controls != null) {
				this.recursiveControl(voSubChild);
			} else {
				this.recursiveMap.put(this.recursiveCnt, voSubChild);
				this.recursiveCnt += 1;
			}
		}
	}
};
/**
 * loadDataFromDataset.
 * dataset을 통한 데이타 연동 메소드.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.loadDataFromDataSet = function(poDocument, pbKeepStatus) {
  var vsDataSetId = this.datasetId;
  if(this.dataset == null) this.dataset = this.canvas.page.model.getDataSet(vsDataSetId);
  var voDataSet = this.dataset;
  if(voDataSet == null) return;
//  voDataSet.setDataSync(true);
  if(!pbKeepStatus) voDataSet.rebuild(false);

  var voCtrl = this.ctrl;

  var vnLoop = voDataSet.getRowCnt();
  var voMapNode = null;
  var vsValue = null;
  var voChildData = null;
  for(var i = 0; i < vnLoop; i++) {
    if(this.rowIndex != i) continue;
    var voChild = null;
    var voIterator = this.controls.iterator();
    var vsId = null;
    var vsPath = null;
    var vsType = null;
    var vsValue = null;
    var voMap = null;
    var vnMapLength = null;
    
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      
      if(voChild.controls != null) {
        this.recursiveControl(voChild);
        voMap = this.recursiveMap;
      }

      if(voMap == null) vnMapLength = 1;
      else vnMapLength = voMap.size();
      
      for(var j = 0; j < vnMapLength; j++) {
        
        if(voMap != null) voChild = voMap.get(j);
        voChildData = voChild.data;
        
        if(voChildData != null) {
          vsDatasetCol = null;
          if(voChild.datasetCol) vsDatasetCol = voChild.datasetCol;
          if(vsDatasetCol) {
            var voDataProxy = new eXria.controls.DataProxy(voDataSet, vsDataSetId, vsDatasetCol, i);
            if(voChildData.isProxy) voDataProxy.data = voChildData.data;
            else voDataProxy.data = voChildData;
            if(voChildData.nodesetInstanceId && voChildData.nodesetInstancePath) {
              voDataProxy.nodesetInstanceId = voChildData.nodesetInstanceId;
              voDataProxy.nodesetInstancePath = voChildData.nodesetInstancePath;
            }
            voChild.data = voDataProxy;
            vsType = voChild.toString();
  //          if(vsType == "DateInput" || vsType == "EditMask") {
  //            vsValue = voDataProxy.getData();
  //            if(vsValue != null && vsValue != "") {
  //              voChild.maxLength = vsValue.length;
  //            }
  //          }
          }
        }
      }
      this.recursiveCnt = 0;
      this.recursiveMap.clear();
      voMap = null;
      vnMapLength = null;
    }
  }
};

eXria.controls.xhtml.FreeForm.prototype.reloadData = function(poCtrl, poDocument, pbKeepStatus) {
  this.loadData(poDocument, pbKeepStatus);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.toString() == "ComboBox")  voChild.refresh();
    if(voChild.reloadData) voChild.reloadData();
  }
};

eXria.controls.xhtml.FreeForm.prototype.refreshData = function(poCtrl, poDocument, pbKeepStatus) {
  this.loadData(poDocument, pbKeepStatus);
  var voChild = null;
  var voMap = null;
  var vnMapLength = null;
  var voIterator = this.controls.iterator();
  
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    
    if(voChild.controls != null) {
      this.recursiveControl(voChild);
      voMap = this.recursiveMap;
    }
    
    if(voMap == null) vnMapLength = 1;
    else vnMapLength = voMap.size();
      
    for(var i = 0; i < vnMapLength; i++) {
      if(voMap != null) voChild = voMap.get(i);
      if(voChild.refreshData) voChild.refreshData(poCtrl, poDocument, pbKeepStatus);
    }
    
    this.recursiveCnt = 0;
    this.recursiveMap.clear();
    voMap = null;
    vnMapLength = null;
  }
};

eXria.controls.xhtml.FreeForm.prototype.refresh = function(poDocument, pbKeepStatus) {
  if(poDocument == null) poDocument = this.document;

  if(this.removeUIGeneralDefaults) { this.removeUIGeneralDefaults(this.ctrl, poDocument); };           // 공통 초기값으로 지정된 속성값을 제거
  if(this.removeSpecificDefaults) { this.removeSpecificDefaults(this.ctrl, poDocument); };             // 개별 초기값으로 지정된 속성값을 제거

  if(this.refreshTemplate) { this.refreshTemplate(this.ctrl, poDocument); };
  if(this.refreshMainStyles) { this.refreshMainStyles(this.ctrl, poDocument); };                       // Main Style 새로고침
  if(this.refreshSubStyles) { this.refreshSubStyles(this.ctrl, poDocument); };                         // Composite Child Style 새로고침

  if(this.refreshUIGeneralDefaults) { this.refreshUIGeneralDefaults(this.ctrl, poDocument); };         // 공통 초기값으로 새로고침
  if(this.refreshSpecificDefaults) { this.refreshSpecificDefaults(this.ctrl, poDocument); };           // 개별 초기값으로 새로고침

  if(this.refreshSpecificAttrs) { this.refreshSpecificAttrs(this.ctrl, poDocument); };                 // 개별 속성으로 새로고침

  if(this.refreshSpecificEvents) { this.refreshSpecificEvents(this.ctrl); };                          // 개별 Events로 새로고침

  if(this.reloadData) { this.reloadData(this.ctrl, poDocument, pbKeepStatus); };                                   // Data 새로고침
  if(this.refreshComplete) {this.refreshComplete(this.ctrl, poDocument); };                           // 새로고침 최종 처리
};
/**
 * freeform을 다음 페이지 데이타로 새로고침 합니다.
 */
eXria.controls.xhtml.FreeForm.prototype.moveToNextPage = function() {
  var vnPageCount = this.getPageCount();
  if(this.rowIndex < vnPageCount - 1) {
    this.rowIndex++;
    this.refreshData(null, null, true);
  }
};
/**
 * freeform을 이전 페이지 데이타로 새로고침 합니다.
 */
eXria.controls.xhtml.FreeForm.prototype.moveToPrevPage = function() {
  if(this.rowIndex > 0) {
    this.rowIndex--;
    this.refreshData(null, null, true);
  }
};
/**
 * freeform을 지정된 페이지 데이타로 새로고침 합니다.
 * @param {Number} pnIndex 표시될 page index(0부터 시작)
 */
eXria.controls.xhtml.FreeForm.prototype.moveToPage = function(pnIndex) {
  var vnPageCount = this.getPageCount();
  if(pnIndex >= 0 && pnIndex < vnPageCount) {
//    if(pnIndex == this.rowIndex) return;
    this.rowIndex = pnIndex;
    this.refreshData(null, null, true);
  }
};
/**
 * 데이타 페이지 수를 반환합니다.
 * @return 데이타 페이지 수
 * @type Number
 */
eXria.controls.xhtml.FreeForm.prototype.getPageCount = function() {
  var vnCnt = 0;
  var vsDataSetId = this.datasetId;
  if(vsDataSetId == null) {
    var voData = this.data;
    var vsInstanceId = voData.nodesetInstanceId;
    var vsInstancePath = voData.nodesetInstancePath;
    if(vsInstanceId == null || vsInstancePath == null) return 0;
    var voCollectionNode = voData.getNodesetData2();
    if(voCollectionNode == null) return 0 ;
    vnCnt = voCollectionNode.getLength();

  } else {
    var voDataSet = this.canvas.page.model.getDataSet(vsDataSetId);
    if(voDataSet == null) return 0;
    vnCnt = voDataSet.getRowCnt();
  };
  return vnCnt;
};
/**
 * 프린트 창을 호출합니다.
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.print = function(){
  this.window.PrintForm = this;
  var voWindow = this.window.open(this.canvas.page.metadata.resourceBaseUrl + "eXria/controls/xhtml/eXria.controls.xhtml.FreeFormPrint.html","FreeFormPrint","",false);
};
/**
 * 프린트 창에 출력될 전체 폼을 디스플레이 합니다.
 * @param {HTMLWindow} voWindow
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.printForm = function(voWindow) {
  this.setPrintingState(true);
  var voDocument = voWindow.document;
  var voHead = voDocument.getElementsByTagName("head")[0];
  var voLink = null;
  if(this.printObject.css) {
    voLink = voDocument.createElement("link");
    voLink.setAttribute("href", this.printObject.css);
    voLink.setAttribute("type", "text/css");
    voLink.setAttribute("rel", "stylesheet");
    voHead.appendChild(voLink);
  } else {
    var vaStyleSheet = voDocument.styleSheets;
    if(!vaStyleSheet) vaStyleSheet = voDocument.getElementsByTagName("link");
    if(vaStyleSheet) {
      for (var i = 0; i < vaStyleSheet.length; i++) {
        voLink = voDocument.createElement("link");
        voLink.setAttribute("href", vaStyleSheet[i]);
        voLink.setAttribute("type", "text/css");
        voLink.setAttribute("rel", "stylesheet");
        voHead.appendChild(voLink);
      }
    } //end of if(vaStyleSheet)
  } //end of if(this.printCSS)
  this.printObject.create(voDocument);
  this.printObject.repeatForm();
  this.setPrintingState(false);
};
/**
 * 컨트롤의 프린트 출력 상태를 설정합니다.
 * @param {Boolean} pbPrinting 프린팅 여부
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.setPrintingState = function(pbPrinting) {
  this.printMode = pbPrinting;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    voControl.printMode = pbPrinting;
  }
};

eXria.controls.xhtml.FreeForm.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.FreeForm[psAttrName];
  if(vsDefaultValue == null) vsDefaultValue = eXria.controls.xhtml.Default.Group[psAttrName];
  if(vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "FreeForm"
 * @type String
 */
eXria.controls.xhtml.FreeForm.prototype.toString = function() {
  return "Freeform";
};
/**
 * TableLayout 상속.
 * @private
 */
eXria.controls.xhtml.FreeForm.prototype.inheritTableLayout = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  eXria.controls.xhtml.TableLayout.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  var parentProto = eXria.controls.xhtml.TableLayout.prototype;
  for(psAttr in parentProto) {
    this[psAttr] = parentProto[psAttr];
  }
};

/**
 * @fileoverview
 * Concreate xhtml TableLayout(XHTML TableLayout 컨트롤)
 * @author ???
 */

/**
 * @class Concreate xhtml TableLayout.<br>
 * XHTML TableLayout 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.TableLayout 객체
 * @type eXria.controls.xhtml.TableLayout
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @base eXria.controls.TableLayout
 */
eXria.controls.xhtml.TableLayout = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight =  pnHeight == null ? 300 : pnHeight;

  eXria.controls.TableLayout.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  eXria.controls.xhtml.FreeForm.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight, true); // UIControl을 상속받는다.
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 테이블의 열 갯수
   * @type Number
   * @private
   */
  this.colCnt = null;

  this.rowsInfo = {};

  /**
   * 테이블 선 속성
   * @type String
   * @private
   */
  this.isCellBorder = null;

  this.borderCollapse = null;
  /**
   * 테이블 cellSpacing
   * @type String
   * @private
   */
  this.cellSpacing = null;

  this.cursor = null;
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  
  this.ctrlPositionMap = {};
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.TableLayout, eXria.controls.xhtml.TableLayout);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.FreeForm, eXria.controls.xhtml.TableLayout);
//////////////////////////////////////////////////////////////////
// 메소드

/**
 * @ignore
 */
eXria.controls.xhtml.TableLayout.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;

  vaTemplate.push("<table id='" + this.id + "_tableLayout' cellspacing='");
  vaTemplate.push("@innStrBuf");
  vaTemplate.push("' width='100%' height='100%' style='table-layout:fixed;position:absolute;z-index:-1;'>");
  vaTemplate.push("@innStrBuf");
  vaTemplate.push("</table>");

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

eXria.controls.xhtml.TableLayout.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
//  this.minWidth = this.getAttrValue("minWidth", this.minWidth);
//  this.minHeight = this.getAttrValue("minHeight", this.minHeight);
//  this.maxWidth = this.getAttrValue("maxWidth", this.maxWidth);
//  this.maxHeight = this.getAttrValue("maxHeight", this.maxHeight);
  if(this.minWidth == null) this.minWidth = this.width;
  if(this.minHeight == null) this.minHeight = this.height;
  if(this.maxWidth == null) this.maxWidth = page.canvas.width - this.left;
  if(this.maxHeight == null) this.maxHeight = page.canvas.height - this.top;
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    if(voUserAttr.layoutInfo != null){
      voLayoutInfo = eval(voUserAttr.layoutInfo);
      var voRowInfo = null;
      var voCellInfo = null;
      var voRowObj = null;
      var voCellObj = null;
      for(var vsAttr in voLayoutInfo) {
        if(isNaN(vsAttr)) {
          this[vsAttr] = voLayoutInfo[vsAttr];
        } else {
          voRowInfo = this.getRowInfo(eval(vsAttr));
          voRowObj = voLayoutInfo[vsAttr];
          for(var vsAttrRow in voRowObj) {
            if(isNaN(vsAttrRow)) {
              voRowInfo[vsAttrRow] = voRowObj[vsAttrRow];
            } else {
              voCellInfo = voRowInfo.getCellInfo(eval(vsAttrRow));
              voCellObj = voRowObj[vsAttrRow];
              for(var vsAttrCell in voCellObj) {
                voCellInfo[vsAttrCell] = voCellObj[vsAttrCell];
              }
            }
          }
        }
      }
    }
  }
};

eXria.controls.xhtml.TableLayout.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;

  var vaCssStrBuf = null;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vaTemplate = this.template;
  var voIndexMap = this.templateIndexMap;


  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.10.12 동적인 코드에서는 disabled를 제어하지 않으며 FF에서는 없는 속성이다
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "tooltip", this.tooltip);
  vfcSetCssStrBuf(vaCssStrBuf, "disabled", this.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  if(this.cellSpacing == null) this.cellSpacing = 0;
  vaTemplate[voIndexMap.get(0)] = this.cellSpacing;
  vaCssStrBuf = null;

  if(page.tableLayoutMap && page.tableLayoutMap[this.id] != null) this.setPositions();
  
  var vaInnStrBuf = [];
  var vnCntI = this.rowCnt;
  var vnCntJ = this.colCnt;
  var vnTrRowSpan = null;
  var vnRowSpan = null;
  var vnColSpan = null;
  var vbCellRowSpan = null;
  var voRowInfo = null;
  var voCellInfo = null;
  var vnStep = null;
  var vnTdWidth = null;
  var vnTdHeight = null;
  
  var voBase = this;
  var voFuncSetEmptyRowSpan = function(poRowInfo, pnCol, pnColSpan) {
    var voTCellInfo = null;
    var vnCntIi = pnCol + pnColSpan;
    for(var ii = pnCol; ii < vnCntIi; ii++) {
      voTCellInfo = poRowInfo.getCellInfo(ii);
      voTCellInfo.rowSpan = 0;
    }
  };
  this.maRowHeight = [];
  this.maColWidth = [];
  var vaRowHeight = this.maRowHeight;
  var vaColWidth = this.maColWidth;
  for(var i = 0; i < vnCntI; i++) {
    vaInnStrBuf.push("<tr");
    voRowInfo = this.getRowInfo(i);
    if(voRowInfo.height != null) {
      vaInnStrBuf.push(" style=\"height:" + voRowInfo.height + "px;\"");
      vaRowHeight[i] = voRowInfo.height;
    }
    vnTrRowSpan = voRowInfo.rowSpan;
    if(vnTrRowSpan != null && vnTrRowSpan > 1) {
      vbCellRowSpan = false;
    } else {
      vbCellRowSpan = true;
    }
    vaInnStrBuf.push(">");
    for(var j = 0; j < vnCntJ; j++) {
      voCellInfo = voRowInfo.getCellInfo(j);
      if(voCellInfo.padding == null) voCellInfo.padding = 0;
      if(voCellInfo.paddingLeft == null) voCellInfo.paddingLeft = voCellInfo.padding;
      if(voCellInfo.paddingRight == null) voCellInfo.paddingRight = voCellInfo.padding;
      if(voCellInfo.paddingTop == null) voCellInfo.paddingTop = voCellInfo.padding;
      if(voCellInfo.paddingBottom == null) voCellInfo.paddingBottom = voCellInfo.padding;
      
      if(vbCellRowSpan == false) {
        voCellInfo.rowSpan = vnTrRowSpan;
      }
      vnRowSpan = voCellInfo.rowSpan;
      vnColSpan = voCellInfo.colSpan;
      
      if(vnRowSpan == null) vnRowSpan = 1;
      if(vnColSpan == null) vnColSpan = 1;
      vaInnStrBuf.push("<td");
      var vsStyle = "padding:0px;";
      if(voCellInfo.width != null) {
        vsStyle += "width:" + voCellInfo.width + "px;";
        vaColWidth[i] = voCellInfo.width;
      }
      if(voCellInfo.height != null) {
        vsStyle += "height:" + voCellInfo.height + "px;";
        vaRowHeight[i] = voCellInfo.height;
      }
      if(vsStyle != "") vaInnStrBuf.push(" style=\"" + vsStyle + "\"");
      vnStep = 1;
      if(vnRowSpan > 1) {
        var voNextRowInfo = null;
        while(vnStep < vnRowSpan) {
          voNextRowInfo = this.getRowInfo(i + vnStep);
          voFuncSetEmptyRowSpan(voNextRowInfo, j, vnColSpan);
          vnStep++;
        }
      }
      vnStep = 1;
      if(vnColSpan > 1) {
        while(vnStep < vnColSpan) {
          voCellInfo = voRowInfo.getCellInfo(j + vnStep);
          voCellInfo.colSpan = 0;
          vnStep++;
        }
//        j += vnColSpan - 1;
      }
      vaInnStrBuf.push("></td>");
    }
    vaInnStrBuf.push("</tr>");
  }
  vaTemplate[voIndexMap.get(1)] = vaInnStrBuf.join("");
  this.ctrl.innerHTML = vaTemplate.join("");
  this.setSubElement(this.document);
  vaTemplate = null;
  voIndexMap.clear();
  this.template = null;
  this.templateIndexMap = null;
  
  var vnFixedRowHeight = 0;
  var vnFixedColWidth = 0;
  var vnFixedRowCnt = 0;
  var vnFixedColCnt = 0;
  for(var i = 0; i < vnCntI; i++) {
    if(vaRowHeight[i] != null) {
      vnFixedRowHeight += vaRowHeight[i];
      vnFixedRowCnt++;
    }
  }
  for(var j = 0; j < vnCntJ; j++) {
    if(vaColWidth[j] != null) {
      vnFixedColWidth += vaColWidth[j];
      vnFixedColCnt++;
    }
  }
  var vnRelRowHeight = (this.innerHeight - (vnCntI + 1) * this.cellSpacing - vnFixedRowHeight) / (vnCntI - vnFixedRowCnt);
  var vnRelColWidth = (this.innerWidth - (vnCntJ + 1) * this.cellSpacing - vnFixedColWidth) / (vnCntJ - vnFixedColCnt);
  for(var i = 0; i < vnCntI; i++) {
    if(vaRowHeight[i] == null) vaRowHeight[i] = vnRelRowHeight;
  }
  for(var j = 0; j < vnCntJ; j++) {
    if(vaColWidth[j] == null) vaColWidth[j] = vnRelColWidth;
  }
};

/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.TableLayout.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.table = this.getSubCtrl("table", voCtrl, poDocument);
};

eXria.controls.xhtml.TableLayout.prototype.refreshComplete = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshComplete(voChild.ctrl, voChild.document);
  }
  this.resizeChildren(this.controls, poDocument);
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TableLayout.prototype.resize = function() {
  if(this.isResize === false) {
    this.refreshPos();
    return;
  }
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

	this.ctrl.style["left"] = this.left + "px";
  this.ctrl.style["top"] = this.top + "px";
  this.ctrl.style["width"] = this.innerWidth + "px";
  this.ctrl.style["height"] = this.innerHeight + "px";

  this.resizeChildren(this.controls);
};
/**
 * resizeTable 이벤트 발생시 TableLayout 크기가 변함에 따라 안에 있는 컨트롤 크기를 변화시킨후 refresh해줌.
 * @param {HTMLElement} poCtrls 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.TableLayout.prototype.resizeChildren = function(poCtrls, poDocument) {
  var voChild = null;
  var voIterator = poCtrls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    this.resizeChild(voChild);
    voChild.resize();
  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.TableLayout.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTableLayout = poCtrl.childNodes[0];

  switch(psAttrName) {
    case "disabled" :
      poCtrl.disabled = psAttrValue;
      this.applyAttrToChildren("disabled", psAttrValue);
      break;
    //case "borderWidth" :
    //  this.innerWidth = this.width - 2 * this.borderWidth;
    //  this.innerHeight = this.height - 2 * this.borderWidth;
    //  poCtrl.style.width = this.innerWidth + "px";
    //  poCtrl.style.height = this.innerHeight + "px";
    //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TableLayout.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
  case "overflow" :
    this.refresh(poDocument);
    break;
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue)
    this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
    var voChild = null;
    var voIterator = this.controls.iterator();
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      if(voChild.refreshVerticalAlign) {
        voChild.refreshVerticalAlign();
      }
    }
    break;
  case "readOnly" :
    this.setReadOnly(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};

eXria.controls.xhtml.TableLayout.prototype.clear = function() {
  this.removeChildren();
  this.clearCtrl();
  this.clearControl();
};
/**
 * @ignore
 */
eXria.controls.xhtml.TableLayout.prototype.loadComplete = function() {
  this.resizeTable();
  this.createChildren();
  if(this.readOnly != null) this.setReadOnly(this.readOnly);
};
/**
 * 하위 컨트롤 resize, repositioning
 * @param voControl
 * @private
 */
eXria.controls.xhtml.TableLayout.prototype.resizeChild = function(poControl) {
  var voTable = this.subElement.table;
  var voRowInfo = this.getRowInfo(poControl.rowNum);
  var voCellInfo = voRowInfo.getCellInfo(poControl.colNum);
  var position = voTable.rows[voCellInfo.rowNum].cells[voCellInfo.colNum];
  var vnCellSpacing = this.cellSpacing;
  var vnRowSpan = voCellInfo.rowSpan;
  var vnColSpan = voCellInfo.colSpan;
  if(vnRowSpan == null) vnRowSpan = 1;
  if(vnColSpan == null) vnColSpan = 1;
  var positionEd = voTable.rows[voCellInfo.rowNum + vnRowSpan - 1].cells[voCellInfo.colNum + vnColSpan - 1];;
  var voPositionMap = this.getLeftTop(poControl);
  var vbFill = voCellInfo.fill;
  vbFill == undefined ? vbFill = true : vbFill = false;
  
  if(vbFill){
    poControl.left = position.offsetLeft + voCellInfo.paddingLeft;
    poControl.top = position.offsetTop + voCellInfo.paddingTop;
    poControl.isResize = false;
  }else{
    poControl.left = voPositionMap.left + position.offsetLeft + voCellInfo.paddingLeft;
    poControl.top = voPositionMap.top + position.offsetTop + voCellInfo.paddingTop;
  }
  var vnWidth = (positionEd.offsetLeft - position.offsetLeft) + positionEd.offsetWidth - voCellInfo.paddingLeft - voCellInfo.paddingRight;;
  var vnHeight = (positionEd.offsetTop - position.offsetTop) + positionEd.offsetHeight - voCellInfo.paddingTop - voCellInfo.paddingBottom;;
  if(vbFill) {
    poControl.width = vnWidth;
    poControl.isResize = true;
  }
  if(vbFill) {
    poControl.height = vnHeight;
    poControl.isResize = true;
  }
};

/**
 * 포함된 하위 컨트롤의 실체화 객체를 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {String} psIdSuffix 실체화된 컨트롤 id에 따라붙을 문자열
 * @private
 */
eXria.controls.xhtml.TableLayout.prototype.createChildren = function(poDocument, psIdSuffix) {
  if(poDocument == null) poDocument = this.document;
  if(psIdSuffix == null && this.idSuffix) psIdSuffix = this.idSuffix;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  var voTable = this.subElement.table;
  var voCell = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    this.setLeftTop(voControl);
//    this.setIndex(voControl);
    vsId = voControl.id;
    if(psIdSuffix != null) voControl.id += psIdSuffix;
    if(voControl.canvas == null) {
      voControl.canvas = this.canvas;
      voControl.window = this.window;
      voControl.document = this.document;

      this.resizeChild(voControl);
      this.canvas.registerControl(voControl);
    }
    if(voControl.toString() != "Timer") {
      this.appendChild(voControl.create(poDocument), poDocument);
      voControl.load(this.document);
    }
    voControl.id = vsId;
  }
};
/**
 * 윈도우에 리사이즈 이벤트 발생시 TableLayout 컨트롤의 사이즈를 자동조정
 * @param {HTMLElement} poCtrl 넓이와 높이 사이즈가 변경될 TableLayout 컨트롤의 배열
 */
eXria.controls.xhtml.TableLayout.prototype.resizeTable = function(pnWidth, pnHeight, poCtl) {
  page.mnWidth = page.window.document.documentElement.clientWidth;
  page.mnHeight = page.window.document.documentElement.clientHeight;
  var vsResizeEventCnt = "resizeEventCnt_" + page.id;

  if(poCtl == null) poCtl = this.ctrl.control;

  if(pnWidth != null) poCtl.applyAttr("width", pnWidth);
  if(pnHeight != null) poCtl.applyAttr("height", pnHeight);
  if(pnWidth != null || pnHeight != null) poCtl.resizeChildren(poCtl.controls);

  var voFunc = function() {
    page [vsResizeEventCnt] = 0;
    var vnHGap = page.window.document.documentElement.clientWidth - page.mnWidth;
    var vnVGap = page.window.document.documentElement.clientHeight - page.mnHeight;
    page.mnWidth = page.window.document.documentElement.clientWidth;
    page.mnHeight = page.window.document.documentElement.clientHeight;

    var vbResizeChildren = false;
    if((poCtl.width > poCtl.minWidth || vnHGap > 0) && (poCtl.width < poCtl.maxWidth || vnHGap < 0)) {
      vbResizeChildren = true;
      poCtl.applyAttr("width", poCtl.width + vnHGap);
    }
    if((poCtl.height > poCtl.minHeight || vnVGap > 0) && (poCtl.height < poCtl.maxHeight || vnVGap < 0)) {
      vbResizeChildren = true;
      poCtl.applyAttr("height", poCtl.height + vnVGap);
    }
    if(vbResizeChildren) poCtl.resizeChildren(poCtl.controls);
  };

  if (page [vsResizeEventCnt] == null) page [vsResizeEventCnt] = 0;
  if (page.window.onresize == null) {
    page.window.onresize = function(poEvent) {
      page [vsResizeEventCnt]++;

      var voCaller = arguments.caller;
      if (!!voCaller) return false;

      if (page [vsResizeEventCnt] == 1) {
        setTimeout(voFunc, 100);
      }
    };

  }
};

eXria.controls.xhtml.TableLayout.prototype.setLeftTop = function(poControl) {
  this.ctrlPositionMap[poControl.id + "_left"] = poControl.left;
  this.ctrlPositionMap[poControl.id + "_top"] = poControl.top;
};

eXria.controls.xhtml.TableLayout.prototype.getLeftTop = function(poControl) {
  var voPositionMap = {};
  voPositionMap["left"] = this.ctrlPositionMap[poControl.id + "_left"];
  voPositionMap["top"] = this.ctrlPositionMap[poControl.id + "_top"];
  return voPositionMap;
};

eXria.controls.xhtml.TableLayout.prototype.setIndex = function(poControl) {
  var vnCellSpacing = this.cellSpacing;
  var vnRowCnt = this.rowCnt;
  var vnColCnt = this.colCnt;
  if(this.maIdx == null) this.maIdx = [];
  var vaIdx = this.maIdx;
  var voDistMap = {};
  var vfDist = null;
  var vaColWidth = this.maColWidth;
  var vaRowHeight = this.maRowHeight;
  var voRowInfo = null;
  var voCellInfo = null;
  var vnTop = 0;
  var vnLeft;
  for(var i = 0; i < vnRowCnt; i++) {
    if(vaIdx[i] == null) vaIdx[i] = [];
    vnTop += vnCellSpacing + (i > 0 ? vaRowHeight[i - 1] : 0);
    vnLeft = 0;
    voRowInfo = this.getRowInfo(i);
    for(var j = 0; j < vnColCnt; j++) {
      voCellInfo = voRowInfo.getCellInfo(j);
      if(voCellInfo.rowSpan == 0 || voCellInfo.colSpan == 0) continue;
      vnLeft += vnCellSpacing + ( j > 0 ? vaColWidth[j - 1] : 0);
      if(vaIdx[i][j] != null) continue;
      vfDist = Math.sqrt(Math.pow(poControl.left - vnLeft, 2) + Math.pow(poControl.top - vnTop, 2));
      if(vaIdx[i][j] == null && voDistMap[vfDist + ""] == null) voDistMap[vfDist + ""] = i + "," + j;
    }
  }
  var vaDist = [];
  for(var vsDist in voDistMap) {
    vaDist.push(eval(vsDist));
  }
  vaDist.sort(function(a,b){return a-b});
  var vsIdx = voDistMap[vaDist[0] + ""];
  vsIdx = vsIdx.split(",");
  vnRowNum = eval(vsIdx[0]);
  vnColNum = eval(vsIdx[1]);
  vaIdx[vnRowNum][vnColNum] = poControl;
  poControl.rowNum = eval(vnRowNum);
  poControl.colNum = eval(vnColNum);
};

eXria.controls.xhtml.TableLayout.prototype.setPositions = function() {
  var voColPosMap = {};
  var voRowPosMap = {};
  var voCollection = this.controls;
  var vnCnt = voCollection.size();
  var voCtl = null;  
  for(var i = 0; i < vnCnt; i++) {
    voCtl = voCollection.get(i);
    voColPosMap[voCtl.colNum + ""] = "";
    voRowPosMap[voCtl.rowNum + ""] = "";
  }
  
  var vaRowPos = [];
  var vaColPos = [];
  for(var vsCol in voColPosMap) {
    vaColPos.push(eval(vsCol));
  }
  for(var vsRow in voRowPosMap) {
    vaRowPos.push(eval(vsRow));
  }
  
  var voSortFunc = function(a,b){return a-b};
  vaColPos.sort(voSortFunc);
  vaRowPos.sort(voSortFunc);
  
  vnCnt = voCollection.size();
  var vnCntJ = vaColPos.length;
  var vnCntK = vaRowPos.length;
  this.colCnt = vnCntJ;
  this.rowCnt = vnCntK;
  var vnColSpan, vnRowSpan;
  var voRowInfo = null;
  var voCellInfo = null;

  for(var i = 0; i < vnCnt; i++) {
    voCtl = voCollection.get(i);
    voRowInfo = this.getRowInfo(voCtl.rowNum);
    voCellInfo = voRowInfo.getCellInfo(voCtl.colNum);
    vnColSpan = 1;
    for(var j = voCtl.colNum + 1; j < vnCntJ; j++) {
      if(voCtl.left + voCtl.width > vaColPos[j]) vnColSpan++;
      else break;
    }
    if(vnColSpan > 1) voCellInfo.colSpan = vnColSpan;
    vnRowSpan = 1;
    for(var k = voCtl.rowNum + 1; k < vnCntK; k++) {
      if(voCtl.top + voCtl.height > vaRowPos[k]) vnRowSpan++;
      else break;
    }
    if(vnRowSpan > 1) voCellInfo.rowSpan = vnRowSpan;
  }
  for(var i = vnCnt - 1; i >= 0; i--) {
    voCtl = voCollection.get(i);
    if(voCtl.value == "@") voCollection.remove(i);
  }
};

eXria.controls.xhtml.TableLayout.prototype.getRowInfo = function(pnRow) {
  var vsId = "" + pnRow;
  var voRowInfo = this.rowsInfo[vsId];
  if(voRowInfo == null) {
    voRowInfo = new eXria.controls.xhtml.TableLayout_rowInfo(pnRow);
    this.rowsInfo[vsId] = voRowInfo;
  }
  return voRowInfo;
};
/**
 * 클래스 명을 반환합니다.
 * @return "TableLayout"
 * @type String
 */
eXria.controls.xhtml.TableLayout.prototype.toString = function() {
  return "TableLayout";
};

eXria.controls.xhtml.TableLayout_rowInfo = function(pnRow) {
  this.rowNum = pnRow;
};

eXria.controls.xhtml.TableLayout_rowInfo.prototype.setCellInfo = function(pnCol, poControl) {
  var vsId = "" + pnCol;
  var voCellInfo = this[vsId];
  if(voCellInfo == null) {
    voCellInfo = {};
    voCellInfo.ctrlLeft = poControl.left;
    voCellInfo.ctrlTop = poControl.top;
    voCellInfo.ctrlHeight = poControl.height;
    voCellInfo.ctrlWidth = poControl.width;
    this[vsId] = voCellInfo;
  }
};

eXria.controls.xhtml.TableLayout_rowInfo.prototype.getCellInfo = function(pnCol) {
  var vsId = "" + pnCol;
  var voCellInfo = this[vsId];
  if(voCellInfo == null) {
    voCellInfo = {};
    voCellInfo.rowNum = this.rowNum;
    voCellInfo.colNum = pnCol;
    voCellInfo.rowIdx = this.rowNum;
    voCellInfo.colIdx = pnCol;
//    voCellInfo.ctrlLeft = pnCol;
//    voCellInfo.ctrlTop = pnCol;
//    voCellInfo.ctrlHeight = pnCol;
//    voCellInfo.ctrlWidth = pnCol;
    this[vsId] = voCellInfo;
  }
  return voCellInfo;
};
/**
 * @fileoverview
 * Concreate xhtml Image(XHTML Image 컨트롤)
 * @author 조영진
 */

/**
 * @class 이미지파일을 보다 간편하게 화면에 링크할 수 있는 컨트롤을 생성합니다.<br />
 * XHTML Image Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Image 객체
 * @type eXria.controls.xhtml.Image
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Image = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);

  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 이미지 경로.
   * @type String
   */
  this.src = null;
  /**
   * 로딩 실패 이미지 경로.
   * @type String
   */
  this.altSrc = null;
  /**
   * 이미지 불투명도.
   * @type Number
   */
  this.imageOpacity = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   */
  this.innerHeight = this.height;
  /**
   * (임시) 백그라운드 이미지
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};

  this.cursor = null;

};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Image);
//////////////////////////////////////////////////////////////////
// 메소드

//this.click  = function() {
/**
 * 이미지에 클릭 이벤트 발생 메소드.
 */
eXria.controls.xhtml.Image.prototype.click  = function() {
  this.ctrl.click();
};

eXria.controls.xhtml.Image.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

eXria.controls.xhtml.Image.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<img class='" + vsClass + "' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_img' ");
  vaTemplate.push("@attStrBuf"); //index:3
  vaTemplate.push("style=\"");
  vaTemplate.push("@cssStrBuf"); //index:5
  vaTemplate.push("\"/>");
};

eXria.controls.xhtml.Image.prototype.refreshTemplate = null;

eXria.controls.xhtml.Image.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  //this.src = this.getAttrValue("src",this.src);
  if(this.data.instanceId == null || this.data.isRelativeRef())
  this.src = this.getAttrValue("src",this.src);
  else{
  this.src = this.data.getData();
  }

  this.imageOpacity = this.getAttrValue("imageOpacity", this.imageOpacity);
};

eXria.controls.xhtml.Image.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  //var vsContextPath = eXria.controls.xhtml.Util.getImagePath(this.getAttrValue("src",this.src), this.window);
  var vsContextPath = this.getAttrValue("src",this.src);
  vfcSetAttStrBuf(vaAttStrBuf, "src", vsContextPath);
//  IE 6.0이하 투명 PNG처리 용 (MS AlphaImageLoader로 대체되는 방식이라 Size/opacity 처리 안됨)
//  var vsImageType = this.src.substring(this.src.lastIndexOf(".") + 1, this.src.length);
//  if(vsImageType == "png") vfcSetAttStrBuf(vaAttStrBuf, "class", "png24");
  vaAttStrBuf.push(" onerror=\"");
  vaAttStrBuf.push(this.getEHandler(this.id, "aterror"));
  vaAttStrBuf.push("\"");
  vaTemplate[3] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;border-style:none;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  var pnOpacity = 100;
  if(isFinite(this.imageOpacity)) pnOpacity = this.imageOpacity;
  var vsFilter = "alpha(opacity=" + pnOpacity + ")";
  var vsOpacity = "" + pnOpacity/100;
  this.setOpacityToCssStrBuf(vaCssStrBuf, vsFilter, vsOpacity);

  vaTemplate[5] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Image.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.img = this.getSubCtrl("img", voCtrl, poDocument);
};

eXria.controls.xhtml.Image.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

eXria.controls.xhtml.Image.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voImgCtrl = this.subElement.img;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  //voImgCtrl["src"] = this.src+"?status="+Math.round(Math.random()* (new Date().getTime()));
  voImgCtrl["src"] = this.src;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;border-style:none;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  var pnOpacity = 100;
  if(isFinite(this.imageOpacity)) pnOpacity = this.imageOpacity;
  var vsFilter = "alpha(opacity=" + pnOpacity + ")";
  var vsOpacity = "" + pnOpacity/100;
  this.setOpacityToCssStrBuf(vaCssStrBuf, vsFilter, vsOpacity);

  voImgCtrl.style.cssText = vaCssStrBuf.join("");
};
/**
 * @ignore
 */
eXria.controls.xhtml.Image.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voImg = poCtrl.childNodes[0];
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(psAttrValue);
    break;
  case "width" :
    this.setAttrCtrl("width", this.innerWidth, voImg);
    break;
  case "height" :
    this.setAttrCtrl("height", this.innerHeight, voImg);
    break;
  //case "borderWidth" :
  //  this.setAttrCtrl("width", this.innerWidth, voImg);
  //  this.setAttrCtrl("height", this.innerHeight, voImg);
  //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Image.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voImg = voCtrl.childNodes[0];
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
//    if(this.borderLeftWidth == null) this.borderLeftWidth = this.borderWidth;
//    if(this.borderRightWidth == null) this.borderRightWidth = this.borderWidth;
//    if(this.borderTopWidth == null) this.borderTopWidth = this.borderWidth;
//    if(this.borderBottomWidth == null) this.borderBottomWidth = this.borderWidth;
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;

    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderTopHeight" :
    this.innerHeight = this.width - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "imageOpacity" :
    var vsFilter = "alpha(opacity=" + this.imageOpacity + ")";
    var vsOpacity = "" + this.imageOpacity/100;
  this.setOpacity(voCtrl, vsFilter, vsOpacity);
  break;
  case "src" :
  var vsContextPath = eXria.controls.xhtml.Util.getImagePath(psAttrValue, this.window);
    this.setAttrCtrl(psAttrName, vsContextPath, voImg);
    break;
  case "cursor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setAttrCtrl(psAttrName, psAttrValue, voImg);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Image.prototype.aterror = function(e) {
  var voImgCtrl = this.subElement.img;
  if(this.altSrc != null && this.tempSrc != this.altSrc) {
    this.tempSrc = this.altSrc;
    voImgCtrl.src = this.altSrc;
  }
};
/**
 * 불러오는 이미지에 대한 URL 및 파일 경로 설정합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @param {Boolean} pbChgUrlPattern 브라우저에서의 Image 캐싱 방지를 위해 URL 패턴을 변경할 지 여부
 */
eXria.controls.xhtml.Image.prototype.setSrc = function(psSrc, pbChgUrlPattern) {
  this.src = psSrc;
  if(!!this.data)
  this.data.setData(psSrc);

  this.tempSrc = null;
  var voImgCtrl = this.subElement.img;
  var vsParam = "";
  if(pbChgUrlPattern) {
    if(/\?/.test(psSrc)) vsParam = "&";
    else vsParam = "?"
    vsParam += "ct=" + new Date().toTimeString();
  }
  voImgCtrl.src = psSrc + vsParam;
};

eXria.controls.xhtml.Image.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Image[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * Image의 Div에 포커스를 사용
 * @private
 */
eXria.controls.xhtml.Image.prototype.dofocus = function() {
  this.ctrl.focus();
};
/**
 * 클래스 명을 반환합니다.
 * @return "Image"
 * @type String
 */
eXria.controls.xhtml.Image.prototype.toString = function() {
  return "Image";
};

/**
 * @fileoverview
 * Concreate xhtml Image(XHTML Import 컨트롤)
 * @author 조동일
 */

/**
 * @class page 내부에 외부 page를 포함하는 기능을 수행<br>
 * 서버 측에서 포함 시킬 page의 내용을 상위 page에 하나로 병합하여 보여줌.
 * SubPage와는 다르게 import 페이지는 사용자 화면에서 개별적으로 접근할 수 있는 컨트롤이 아님.<br>
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Import 객체
 * @type eXria.controls.xhtml.Import
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @ignore
 */
eXria.controls.xhtml.Import = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);   // UIControl을 상속받는다.
  /**
   * Import에 속한 컨트롤들의 표시 여부.<br>
   * true | false
   * @type Boolean
   * @ignore
   */
  this.visible = null;
  /**
   * Import에 속한 컨트롤들의 활성화 여부.<br>
   * true | false
   * @type Boolean
   * @ignore
   */
  this.enable = null;
  /**
   * 불러오는 화면에 대한 URL 및 파일 경로.
   * @type String
   */
  this.src = null;

  this.cursor = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Import);
/**
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.createCtrl = function() {
  var voDocument = this.document;
  var voCtrl = voDocument.createElement("iframe");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  voCtrl.frameBorder = "no";
  voCtrl.scrolling = "no";
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.createSubCtrl = function(poCtrl) {
  if(this.src) {
    poCtrl.src = this.src;
  }
  if(this.visible) {
    poCtrl.style.visibility = this.visible;
  }
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  switch(psAttrName) {
    case "disabled" :
      //this.setEnable(!psAttrValue, poCtrl);
      break;
    case "visible" :
      this.setVisible(psAttrValue, poCtrl);
      break;
    default :
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setSpecificAttrs = function(poCtrl) {
  this.setAttrCtrl("src", this.src, poCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setSpecificEvents = null;
/**
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.refreshSpecificAttrs = function(poCtrl) {
  this.setSpecificAttrs(poCtrl);
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로를 설정합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setSrc = function(psSrc, poDocument) {
  this.src = psSrc;
  var voCtrl = this.getCtrl(poDocument);
  if(voCtrl) {
    voCtrl.src = this.src;
  }
};
/**
 * 컨트롤 화면 디스플레이 여부를 설정합니다.
 * @param {String} psVisible 화면 디스플레이 여부
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setVisible = function(psVisible, poCtrl) {
  this.visible = psVisible;
  poCtrl.style.visibility = psVisible;
};
/**
 * 컨트롤의 화면 디스플레이 상태 값 반환합니다.
 * @return 컨트롤의 visible 속성값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.getVisible = function() {
  return this.visible;
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로 반환합니다.
 * @return 컨트롤의 src 속성 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.getSrc = function() {
  return this.src;
};
/**
 * 이벤트를 활성화 시킵니다.
 * @param {Boolean} pbEnable 활성화 설정
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.setEnable = function(pbEnable, poCtrl) {
  if(this.enable != pbEnable) {
    //iframe inner control들을 disable 시킨다.
    this.enable = pbEnable;
    var voImportWindow = poCtrl.contentDocument || poCtrl.contentWindow;

    var voControls = voImportWindow.page.canvas.controls.getValueCollection();
    var voControlIterator = voControls.iterator();
    var voControl;
    while(voControlIterator.hasNext()) {
      voControl = voControlIterator.next();
      voControl.applyAttr("disabled", !this.enable);
    }
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "Import"
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Import.prototype.toString = function() {
  return "Import";
};

/**
 * @fileoverview
 * Concreate xhtml Image(XHTML SubPage 컨트롤)
 * @author 조동일, 김경태
 */

/**
 * @class page 내부에 외부 page를 포함시키는 기능을 수행<br>
 * IFRAME으로 표현
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.SubPage 객체
 * @type eXria.controls.xhtml.SubPage
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
// 요구사항 :<br>
// 1. outter page와 inner page간의 data 연동 기능(function 제공) -> canvas 또는 page를 통해 연동 -> 협의 필요<br>
// 2. inner page에서의 outter page와 독립적인 data 구조 사용(data의 독립성 확보)<br>
// 3. 보여지는 size 및 좌표를 가짐<br>
// 4. import 되는 소스의 수정이 가능<br>
// 5. visible 여부의 관리 가능<br>
// 6. 활성화 여부의 관리 가능<br>
// View : <br>
eXria.controls.xhtml.SubPage = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;
  /**
   * Inheritance Call
   */
  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);   // UIControl을 상속받는다.
  /*
   * Class Field List
   */
  /**
   * Import에 속한 컨트롤들의 표시 여부.<br>
   * true | false
   * @type Boolean
   */
  this.visible = null;
  /**
   * SubPage에 속한 컨트롤들의 활성화 여부.<br>
   * true | false
   * @type Boolean
   */
  this.enable = null;
  /**
   * 불러오는 화면에 대한 URL 및 파일 경로.
   * @type String
   */
  this.src = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * SubPage 영역의 Scrolling 속성
   * @type String
   * @private
   */
  this.scrolling = "auto";
  /**
   * SubPage에 로딩된 xrf의 page 객체
   * @type eXria.form.Page
   * @private
   */
  this.page = null;

  this.df = {};
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.SubPage);

//  Lifecycle Function List
//
//  Canvas에 의해 호출된다.
//  객체가 생성되고, 좌표가 설정된 후에 Canvas에 append 시점에 호출된다.
//  HTML Control 생성후 리턴
//
//  HTML Control 생성

eXria.controls.xhtml.SubPage.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("iframe");
  voCtrl["id"] = this.id;
  voCtrl["frameBorder"] = "no";
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
//  if(this.src) {
//    voCtrl["src"] = this.getAbsolutePath(this.src);
//  }
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.SubPage.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  switch(psAttrName) {
    case "disabled" :
      //this.setEnable(!psAttrValue, poCtrl);
      break;
    case "visible" :
      //this.setVisible(psAttrValue, poCtrl);
      break;
    default :
      break;
  }
};

eXria.controls.xhtml.SubPage.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.scrolling = this.getAttrValue("scrolling", this.scrolling);
};

eXria.controls.xhtml.SubPage.prototype.setSpecificAttrs = function(poCtrl, poDocument, pbChildRefresh) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  if(pbChildRefresh != false && this.src) {
    poCtrl["src"] = this.getAbsolutePath(this.src);
  }

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  poCtrl["scrolling"] = this.scrolling;
  if(this.backgroundColor !== null && this.backgroundColor.toUpperCase() == "TRANSPARENT") poCtrl["allowTransparency"] = true;
  else  poCtrl["allowTransparency"] = false;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow", voDf.overflow);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voDf.overflowX);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voDf.overflowY);
  poCtrl.style.cssText = vaCssStrBuf.join("");
};

eXria.controls.xhtml.SubPage.prototype.setSpecificEvents = null;

eXria.controls.xhtml.SubPage.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

eXria.controls.xhtml.SubPage.prototype.refreshSpecificAttrs = function(poCtrl, poDocument, pbChildRefresh) {
  this.setSpecificAttrs(poCtrl, poDocument, pbChildRefresh);
};
/**
 * @ignore
 */
eXria.controls.xhtml.SubPage.prototype.refreshVerticalAlign = function() {
  var voPage = this.getPage();
  if(voPage == null) return;
  var voControls = voPage.canvas.controls.entries;
  var voControl = null;
  for(var member in voControls) {
    voControl = voControls[member];
    if(voControl.refreshVerticalAlign) {
      voControl.refreshVerticalAlign();
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SubPage.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderTopHeight" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
    this.refresh(poDocument);
    break;
  case "src" :
    this.setSrc(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로 설정합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.SubPage.prototype.setSrc = function(psSrc, poDocument) {
  if(psSrc === 'javascript:false'){
    psSrc = 'about:blank';
  }else{
    psSrc = this.getAbsolutePath(psSrc);
  }
  this.src = psSrc;
  var voCtrl = this.getCtrl(poDocument);
  var vsCssText = voCtrl.style.cssText;
  if(voCtrl) {
    if(this.canvas.page.metadata.browser.ie > 0) {
//      var voParent = voCtrl.parentNode;
//      if(voCtrl.contentWindow.page) {
//        voCtrl.contentWindow.page.isUnload = true;
//      }
//      voParent.removeChild(voCtrl);
//      voCtrl = this.document.createElement("iframe");
//      voCtrl["id"] = this.id;
//      voCtrl["frameBorder"] = "no";
//      voCtrl["hideFocus"] = true;
//      voCtrl.style.cssText = vsCssText;
//      voParent.appendChild(voCtrl);
//      this.ctrl = voCtrl;

      var voWindow = this.window;
      var voEvent = voWindow.event;
      if(voEvent && voEvent.type == "keydown" && voEvent.keyCode == 13) {
        voEvent.cancelBubble = true;
        voEvent.returnValue = false;
      }

    }
    voCtrl.src = this.src;
      //voCtrl.contentWindow.document.location.href = this.src;
//    voCtrl.offsetHeight;
  }
};
/**
 * 받은 경로를 절대경로로 변환하여 반환합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @return 절대경로로 변환된값
 * @type String
 */
eXria.controls.xhtml.SubPage.prototype.getAbsolutePath = function(psSrc){
  var getSubSrc = function(psSrc){
    if(psSrc.indexOf("../") == 0) {
      if(vsBaseUrl != (this.document.location.protocol + "//" + this.document.location.host)) vsBaseUrl = vsBaseUrl.substring(0, vsBaseUrl.lastIndexOf("/"));
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
    } else if(psSrc.indexOf("./") == 0 || psSrc.indexOf("/") == 0){
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
    } else if(psSrc.indexOf("/") != -1){
      var vsTemp = psSrc.substring(0, psSrc.indexOf("/"));
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
      vsBaseUrl = vsBaseUrl + "/" + vsTemp;
    }
    if(psSrc.indexOf("/") != -1) psSrc = getSubSrc(psSrc);
    return psSrc;
  }
  if(psSrc == "#") return psSrc;
  if(psSrc.indexOf("http://") == -1 && psSrc.indexOf("about:") == -1 && psSrc.indexOf("/") != 0){ // 절대경로가 아닐 경우
    var vsBaseUrl = this.document.location.href;
    vsBaseUrl = vsBaseUrl.substring(0, vsBaseUrl.lastIndexOf("/"));

    psSrc = getSubSrc(psSrc);
    psSrc = vsBaseUrl + "/" + psSrc;
  }

  return psSrc;
};
/**
 * SubPage에 로딩된 xrf의 page 객체를 반환하는 메소드
 * @return SubPage에 로딩된 xrf의 page 객체
 * @type eXria.form.Page
 */
eXria.controls.xhtml.SubPage.prototype.getPage = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  if(voCtrl == null) {
    this.page = null;
  }else if(voCtrl.contentWindow && voCtrl.contentWindow.page) {
    this.page = voCtrl.contentWindow.page;
  }
  return this.page;
};
/**
 * 컨트롤 화면 디스플레이 여부를 설정합니다.
 * @param {String} psVisible 화면 디스플레이 여부
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 * @deprecated
 */
eXria.controls.xhtml.SubPage.prototype.setVisible = function(psVisible, poCtrl) {
  var voDf = this.df;
  this.visible = psVisible;
//  voDf.visible = psVisible;
//
//  debugger;
//  this.ctrl;

  if(!poCtrl)
    poCtrl = this.getCtrl(this.document);

  poCtrl.style.display = psVisible;
};
/**
 * 컨트롤의 화면 디스플레이 상태 값을 반환합니다.
 * @return 컨트롤의 visible 속성값
 * @type String
 */
eXria.controls.xhtml.SubPage.prototype.getVisible = function() {
  return this.visible;
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로를 반환합니다.
 * @return 컨트롤의 src 속성 값
 * @type String
 */
eXria.controls.xhtml.SubPage.prototype.getSrc = function() {
  return this.src;
};
/**
 * 내부페이지의 활성화 여부를 설정합니다.
 * @param {Boolean} pbEnable 활성화 설정
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 */
eXria.controls.xhtml.SubPage.prototype.setEnable = function(pbEnable, poCtrl) {
  if(this.enable != pbEnable) {
    //iframe inner control들을 disable 시킨다.
    this.enable = pbEnable;
    var voSubPageWindow = poCtrl.contentWindow;

    var voControls = voSubPageWindow.page.canvas.controls.getValueCollection();
    var voControlIterator = voControls.iterator();
    var voControl;
    while(voControlIterator.hasNext()) {
      voControl = voControlIterator.next();
      voControl.applyAttr("disabled", !this.enable);
    }
  }
};

eXria.controls.xhtml.SubPage.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.SubPage) vsDefaultValue = eXria.controls.xhtml.Default.SubPage[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "SubPage"
 * @type String
 */
eXria.controls.xhtml.SubPage.prototype.toString = function() {
  return "SubPage";
};

/**
 * @fileoverview
 * Concreate xhtml HtmlSnippet(SubPage 컨트롤과 동일하지만 매쉬업 코드를 담는 기능을 수행하는 컨트롤)
 * @author 김경태
 */

/**
 * @class page 내부에 외부 page를 포함시키는 기능을 수행<br>
 * IFRAME으로 표현
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.HtmlSnippet 객체
 * @type eXria.controls.xhtml.HtmlSnippet
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
// 요구사항 :<br>
// 1. outter page와 inner page간의 data 연동 기능(function 제공) -> canvas 또는 page를 통해 연동 -> 협의 필요<br>
// 2. inner page에서의 outter page와 독립적인 data 구조 사용(data의 독립성 확보)<br>
// 3. 보여지는 size 및 좌표를 가짐<br>
// 4. import 되는 소스의 수정이 가능<br>
// 5. visible 여부의 관리 가능<br>
// 6. 활성화 여부의 관리 가능<br>
// View : <br>
eXria.controls.xhtml.HtmlSnippet = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;
  /**
   * Inheritance Call
   */
  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);   // UIControl을 상속받는다.
  /*
   * Class Field List
   */
  /**
   * HtmlSnippet에 속한 컨트롤들의 표시 여부.<br>
   * true | false
   * @type Boolean
   */
  this.visible = null;
  /**
   * HtmlSnippet에 속한 컨트롤들의 활성화 여부.<br>
   * true | false
   * @type Boolean
   */
  this.enable = null;
  /**
   * 불러오는 화면에 대한 URL 및 파일 경로.
   * @type String
   */
  this.src = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   *
   */
  this.scrolling = "auto";
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.HtmlSnippet);

eXria.controls.xhtml.HtmlSnippet.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("iframe");
  voCtrl["id"] = this.id;
  voCtrl["frameBorder"] = "no";
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  if(this.src) {
    voCtrl["src"] = this.getAbsolutePath(this.src);
  }
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlSnippet.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  switch(psAttrName) {
    case "disabled" :
      //this.setEnable(!psAttrValue, poCtrl);
      break;
    case "visible" :
      //this.setVisible(psAttrValue, poCtrl);
      break;
    default :
      break;
  }
};

eXria.controls.xhtml.HtmlSnippet.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.scrolling = this.getAttrValue("scrolling", this.scrolling);
};

eXria.controls.xhtml.HtmlSnippet.prototype.setSpecificAttrs = function(poCtrl) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  poCtrl["scrolling"] = this.scrolling;
  if(this.backgroundColor !== null && this.backgroundColor.toUpperCase() == "TRANSPARENT") poCtrl["allowTransparency"] = true;
  else  poCtrl["allowTransparency"] = false;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(voDf.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow", voDf.overflow);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voDf.overflowX);
//  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voDf.overflowY);
  poCtrl.style.cssText = vaCssStrBuf.join("");
};

eXria.controls.xhtml.HtmlSnippet.prototype.setSpecificEvents = function(poCtrl){
  if(this.canvas.page.metadata.browser.ie > 0) {
    setTimeout("document.getElementById('"+this.id+"').fireEvent('onclick');",4*1000);
  }
};

eXria.controls.xhtml.HtmlSnippet.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

eXria.controls.xhtml.HtmlSnippet.prototype.refreshSpecificAttrs = function(poCtrl) {
  this.setSpecificAttrs(poCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlSnippet.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderTopHeight" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
    this.refresh(poDocument);
    break;
  case "src" :
    this.setSrc(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로 설정합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.HtmlSnippet.prototype.setSrc = function(psSrc, poDocument) {
  psSrc = this.getAbsolutePath(psSrc);
  this.src = psSrc;
  var voCtrl = this.getCtrl(poDocument);
  if(voCtrl) {
    voCtrl.src = this.src;
      //voCtrl.contentWindow.document.location.href = this.src;
//    voCtrl.offsetHeight;
  }
};
/**
 * 받은 경로를 절대경로로 변환하여 반환합니다.
 * @param {String} psSrc URL 및 파일 경로
 * @return 절대경로로 변환된값
 * @type String
 */
eXria.controls.xhtml.HtmlSnippet.prototype.getAbsolutePath = function(psSrc){
  var getSubSrc = function(psSrc){
    if(psSrc.indexOf("../") == 0) {
      if(vsBaseUrl != (this.document.location.protocol + "//" + this.document.location.host)) vsBaseUrl = vsBaseUrl.substring(0, vsBaseUrl.lastIndexOf("/"));
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
    } else if(psSrc.indexOf("./") == 0 || psSrc.indexOf("/") == 0){
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
    } else if(psSrc.indexOf("/") != -1){
      var vsTemp = psSrc.substring(0, psSrc.indexOf("/"));
      psSrc = psSrc.substring((psSrc.indexOf("/") + 1), psSrc.length);
      vsBaseUrl = vsBaseUrl + "/" + vsTemp;
    }
    if(psSrc.indexOf("/") != -1) psSrc = getSubSrc(psSrc);
    return psSrc;
  }

  if(psSrc.indexOf("http://") == -1 && psSrc.indexOf("about:") == -1 && psSrc.indexOf("/") != 0){ // 절대경로가 아닐 경우
    var vsBaseUrl = this.document.location.href;
    vsBaseUrl = vsBaseUrl.substring(0, vsBaseUrl.lastIndexOf("/"));

    psSrc = getSubSrc(psSrc);
    psSrc = vsBaseUrl + "/" + psSrc;
  }

  return psSrc;
};
/**
 * src 로 지정된 화면의 page 객체를 반환하는 메소드.
 * @return src 로 지정된 화면의 page 객체
 * @type eXria.form.Page
 */
eXria.controls.xhtml.HtmlSnippet.prototype.getPage = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  if(voCtrl.contentWindow && voCtrl.contentWindow.page) {
    this.page = voCtrl.contentWindow.page;
  }
  return this.page;
};
/**
 * 컨트롤 화면 디스플레이 여부를 설정합니다.
 * @param {String} psVisible 화면 디스플레이 여부
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 */
eXria.controls.xhtml.HtmlSnippet.prototype.setVisible = function(psVisible, poCtrl) {
  var voDf = this.df;
  this.visible = psVisible;
//  voDf.visible = psVisible;
  poCtrl.style.display = psVisible;
};
/**
 * 컨트롤의 화면 디스플레이 상태 값을 반환합니다.
 * @return 컨트롤의 visible 속성값
 * @type String
 */
eXria.controls.xhtml.HtmlSnippet.prototype.getVisible = function() {
  var voDf = this.df;
  return this.visible;
};
/**
 * 불러오는 화면에 대한 URL 및 파일 경로를 반환합니다.
 * @return 컨트롤의 src 속성 값
 * @type String
 */
eXria.controls.xhtml.HtmlSnippet.prototype.getSrc = function() {
  return this.src;
};
/**
 * 내부페이지의 활성화 여부를 설정합니다.
 * @param {Boolean} pbEnable 활성화 설정
 * @param {HTMLIframe} poCtrl 실체화 컨트롤
 */
eXria.controls.xhtml.HtmlSnippet.prototype.setEnable = function(pbEnable, poCtrl) {
  if(this.enable != pbEnable) {
    //iframe inner control들을 disable 시킨다.
    this.enable = pbEnable;
    var voWindow = poCtrl.contentWindow;

    var voControls = voWindow.page.canvas.controls.getValueCollection();
    var voControlIterator = voControls.iterator();
    var voControl;
    while(voControlIterator.hasNext()) {
      voControl = voControlIterator.next();
      voControl.applyAttr("disabled", !this.enable);
    }
  }
};

eXria.controls.xhtml.HtmlSnippet.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.HtmlSnippet) vsDefaultValue = eXria.controls.xhtml.Default.HtmlSnippet[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "HtmlSnippet"
 * @type String
 */
eXria.controls.xhtml.HtmlSnippet.prototype.toString = function() {
  return "HtmlSnippet";
};

/**
 * @fileoverview
 * Concreate xhtml InputBox(XHTML InputBox 컨트롤)
 * @author 이종녕
 */

/**
 * @class 문자열 모양으로 사용자가 한줄에 데이터를 입력하는 입력필드를 생성합니다.<br />
 * XHTML InputBox Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.InputBox 객체
 * @type eXria.controls.xhtml.InputBox
 * @constructor
 * @base eXria.controls.xhtml.InputCommon
 */
eXria.controls.xhtml.InputBox = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.InputCommon.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 텍스트 입력시의 표시방향.<br>
   * ltr(left to right), rtl(right to left)<br>
   * @type String
   */
  this.dir = null;
  /**
   * 읽기 전용 여부.
   * @type Boolean
   */
  this.readOnly = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.InputCommon, eXria.controls.xhtml.InputBox);
//////////////////////////////////////////////////////////////////
//// 메소드

eXria.controls.xhtml.InputBox.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<input id='" + this.id + "_text' type='text' class='" + vsClass + "'");
  vaTemplate.push("@attStrbuf");  //0
  vaTemplate.push(" style=\"");
  vaTemplate.push("@cssStrBuf");  //1
  vaTemplate.push("\"/>");
  vaTemplate.push("<span class='" + vsClass + "'" + " style=\"");
  vaTemplate.push("@cssStrBuf"); //2
  vaTemplate.push("\"/>");
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

eXria.controls.xhtml.InputBox.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);

  // 내부 폭과 높이를 설정
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.verticalAlign = this.getAttrValue("verticalAlign", this.verticalAlign);
  this.maxLength = this.getAttrValue("maxLength",this.maxLength);
  this.minLength = this.getAttrValue("minLength",this.minLength);
  this.maxByteLength = this.getAttrValue("maxByteLength",this.maxByteLength);
  if(this.maxByteLength != null && this.maxLength == null) {
    this.maxLength = this.maxByteLength;
  }
  this.minByteLength = this.getAttrValue("minByteLength",this.minByteLength);
  this.nullable = this.getAttrValue("nullable",this.nullable);
  this.value = this.getAttrValue("value",this.value);
  this.readOnly = this.getAttrValue("readonly",this.readOnly);
};

eXria.controls.xhtml.InputBox.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  // /////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  // /////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존 voDF.disabed는 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  //vfcSetCssStrBuf(vaCssStrBuf, "tooltip", voDf.tooltip);
  //vfcSetCssStrBuf(vaCssStrBuf, "disabled", voDf.disabled);
  //if(voDf.visible == false) vaCssStrBuf.push("display:none;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");
  // ////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  // ////////////////////////////////////////////////////////////////////////////////////////
  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "value", this.value);
  if(this.readOnly) vfcSetAttStrBuf(vaAttStrBuf, "readOnly", this.readOnly);
  vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maxLength);
  vfcSetAttStrBuf(vaAttStrBuf, "minLength", this.minLength);
  vaTemplate[voIndexMap.get(0)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transForm", this.textTransform);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  var vnWidth = this.innerWidth;

  // loadcomplete에서 처리
  //if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  //if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  /*if(this.borderLeftWidth !== null) vnWidth = vnWidth - this.borderLeftWidth;
  if(this.borderRightWidth !== null) vnWidth = vnWidth - this.borderRightWidth;*/

  // loadcomplete에서 처리
  //vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(2)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  voIndexMap.clear();
  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;
  this.setSubElement(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.input = this.getSubCtrl("input", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDf = this.df;
  var voInput = this.subElement.input;
  var voSpan = this.subElement.span;
  switch(psAttrName) {
  case "width" :
    this.setInputWidth();
    break;
  case "height" :
    this.setVerticalAlign(voInput, poCtrl, voDf.verticalAlign);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.atclick = function(e){
  var voDocument = this.document;
  this.focused = true;
  var voInput = this.subElement.input;
  if(e.target == voInput) {
    if(voDocument.selection && voDocument.selection.createRange) {
      this.textRange = voDocument.selection.createRange();
    }
  } else {
    if(this.textRange) {
      this.textRange.select();
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.dofocus = function() {
  var voInput = this.subElement.input;
  if(this.focused == false) {
    try { voInput.focus(); }catch(err) {}
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.atchange = function(e){
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vsValue = voInput.value;
  //this.setValue(vsValue);
  this.value = vsValue;
//  this.df.value = vsValue;
  try {
    this.data.setData(this.value);
  } catch(err) {
    alert(this.value + "; " + err);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.atkeydown = function(e){
  if(e.keyCode == 13) {
    this.isEnter = true;
    var voCtrl = this.ctrl;
    var voInput = this.subElement.input;
    var vsValue = voInput.value;
    this.setValueWithNotify(vsValue);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.atfocus = function(e) {
  if(this.focused == false) this.selectText();
  this.focused = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.atblur = function(e) {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vsValue = voInput.value;

  if(!!this.inputMode){
  vsValue = eXria.controls.xhtml.Util.getValueFromInputMode(String(vsValue), this.inputMode);
  voInput.value = vsValue;
  }

  this.value = vsValue;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != vsValue) {
    vbChanged = true;
  }
  this.onchangeInitValue = vsValue;
  if(vbChanged) {
    this.data.setData(vsValue);
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
    if(this.changeEventCallback) this.changeEventCallback(voEvent);
  }
  this.focused = false;
};

eXria.controls.xhtml.InputBox.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var voInputCtrl = this.subElement.input;
  var voSpanCtrl = this.subElement.span;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존 voDF.disabed는 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  //vfcSetCssStrBuf(vaCssStrBuf, "tooltip", voDf.tooltip);
  //vfcSetCssStrBuf(vaCssStrBuf, "disabled", voDf.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  var vsInputValue = this.value;
  if(vsInputValue == null) vsInputValue = "";
  voInputCtrl["value"] = vsInputValue;
  if(this.readOnly != null) voInputCtrl ["readOnly"] = this.readOnly;
  if(this.maxLength != null) voInputCtrl["maxLength"] = this.maxLength;
  if(this.minLength != null) voInputCtrl["minLength"] = this.minLength;
  if(this.className != null) voInputCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transForm", this.textTransform);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  voInputCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");

  this.setInputWidth();
};
/**
 * @ignore
 */
eXria.controls.xhtml.InputBox.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vaAttrName = psAttrName.split(".");
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }

  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    this.setInputWidth(voCtrl);
  break;
  case "disabled" :
    if(psAttrValue == true) this.doblur();
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "textAlign" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    this.setInputWidth();
    break;
  case "readOnly" :
  case "maxLength" :
  case "minLength" :
  case "color" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    break;
  case "value" :
    this.setValue(psAttrValue, voCtrl);
    break;
  case "verticalAlign":
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "fontFamily" :
  case "fontSize" :
  case "fontStyle" :
  case "fontWeight" :
  case "textDecoration":
  case "textTransform":
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "outerClassName":
  case "className":
    this.refresh(poDocument);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setInputWidth();
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setInputWidth();
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    this.setInputWidth();
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "padding" :
    this.paddingTop = this.padding;
    this.paddingRight = this.padding;
    this.paddingBottom = this.padding;
    this.paddingLeft = this.padding;
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voInput);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voInput);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voInput);
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voInput);
    this.setInputWidth();
    break;
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "paddingLeft" :
  case "paddingRight" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
    this.setInputWidth();
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 컨트롤에 값을 설정합니다.
 * @param {String} psData 설정 값
 */
eXria.controls.xhtml.InputBox.prototype.setValue = function(psData) {
  this.value = psData;
  var voInput = this.subElement.input;
  if(psData == null) psData = "";
  voInput.value = psData; //eXria.controls.xhtml.Util.parseLang(psData);
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;

  var vsValue = this.value;
  if(vbChanged) this.data.setData(vsValue);
};
/**
 * 컨트롤에 값을 설정하며 값의 변경이 있으면 onchange 이벤트를 발생시킵니다..
 * @param {String} psData 설정 값
 */
eXria.controls.xhtml.InputBox.prototype.setValueWithNotify = function(psData) {
  this.value = psData;
  var voInput = this.subElement.input;
  if(psData == null) psData = "";
  voInput.value = psData; //eXria.controls.xhtml.Util.parseLang(psData);
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;

  var vsValue = this.value;
  if(vbChanged) {
    this.data.setData(vsValue);
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
  }
};

eXria.controls.xhtml.InputBox.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.InputBox[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "InputBox"
 * @type String
 */
eXria.controls.xhtml.InputBox.prototype.toString = function() {
  return "InputBox";
};
/**
 * @fileoverview
 * Concreate xhtml Label(XHTML Label 컨트롤)
 * @author 조영진, 박찬수
 */

/**
 * @class 텍스트필드를 화면상에 보여주는 컨트롤을 생성하는 class입니다. <br />
 * InputBox등과는 다르게 직접적인 데이터의 에디팅이 불가능합니다.<br />
 * XHTML Label Contorl.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Label 객체
 * @type eXria.controls.xhtml.Label
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */

eXria.controls.xhtml.Label = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 텍스트에 줄을 넣을때.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 설정된 값.
   * @type String
   */
  this.value  = null;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflow = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowX = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowY = null;
  /**
   * 자동줄바꿈 여부.
   * @type Boolean
   */
  this.wordWrap = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @ignore
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @ignore
   */
  this.innerHeight = this.height;
  /**
   * 컨트롤의 텍스트 패딩
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤의 상단 패딩
   * @type Number
   * @private
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 우측 패딩
   * @type Number
   * @private
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 하단 패딩
   * @type Number
   * @private
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 좌측 패딩
   * @type Number
   * @private
   */
  this.paddingLeft = null;
  /**
   * 컨트롤이 디스플레이 되는 document객체 지정
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  /**
   * 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;

  /**
  * @private
  */
  this.divOffsetHeight = null;
  /**
  * @private
  */
  this.subElement = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Label);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["accesskey"] = this.accessKey;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;

  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<div class=\"" + vsClass + "\" style=\"");
  vaTemplate.push("@cssStrBuf"); //0
  vaTemplate.push("\">&nbsp;</div>");
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf"); //1
  vaTemplate.push("\"/>")

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.refreshTemplate = null;
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.innerHTML = voUserAttr.innerHTML;
    if(voUserAttr.useHtmlTag != null &&  voUserAttr.useHtmlTag === true){
      this.value = "";
      this.innerHTML = this.data.getData();
    }
    this.funcNec = voUserAttr.funcNec;
    this.labelName = voUserAttr.labelName;
    this.type = voUserAttr.type;
  }
  if(this.type == "SPLITTER") {
    if(this.height > this.width) this.type = "HSPLITTER";
    else this.type = "VSPLITTER";
    this.ltCtls = voUserAttr.ltCtls ? voUserAttr.ltCtls : [];
    this.rbCtls = voUserAttr.rbCtls ? voUserAttr.rbCtls : [];
  }
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.verticalAlign = this.getAttrValue("verticalAlign", this.verticalAlign);
  this.value = this.getAttrValue("value", this.value);
  this.imagePushed = this.getAttrValue("imagePushed", this.imagePushed);
  this.imageFocused = this.getAttrValue("imageFocused", this.imageFocused);
  this.imageMouseover = this.getAttrValue("imageMouseover", this.imageMouseover);
  this.wordWrap = this.getAttrValue("wordWrap", this.wordWrap);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;outline-style:none;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
//  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");

  //외각DIV
  //2010.06.03
  //내부DIV 영역에 스크롤이 생성되는 경우를 막기 위해
  //visible 과 hidden 이 아닌경우에는 auto가 되게 수정
  if(!!this.overflow && !!(this.overflow === "scroll" || this.overflow === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "auto");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);

  if(!!this.overflowX && !!(this.overflowX === "scroll" || this.overflowX === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", auto);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);

  if(!!this.overflowY && !!(this.overflowY === "scroll" || this.overflowY === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);


  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;position:absolute;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else{
    vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
    //2010.06.01
    //영문자 개행 관련 word-wrap 추가
    vfcSetCssStrBuf(vaCssStrBuf, "word-wrap","break-word");
  }

  //2010.06.03
  //내부 div 스크롤 관련 버그 수정
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");

  voIndexMap.clear();
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;

  this.setSubElement(poDocument);
};
/**
 * @ignroe
 */
eXria.controls.xhtml.Label.prototype.setSpecificEvents = function(poCtrl) {
  if(this.type != "HSPLITTER" && this.type != "VSPLITTER") return;
  this.movable = true;
  this.onMove = function(e) {
    var voCtrl = this.getCtrl();
    var voParentNode = voCtrl.parentNode;
    var voPaneCtrl = this.paneHandler.getCtrl();
    if(voCtrl == null || voPaneCtrl == null) {
        return;
    }

    var voStyle = voPaneCtrl.style;

    var voEvent = new eXria.event.Event(e, this.window);
    var voTarget = voEvent.target;
    if(voTarget == voPaneCtrl || voTarget == voPaneCtrl.parentNode) {
    } else {
      return;
    }
    var vnMouseX = voEvent.e.clientX; // - this.clientAbsLeft;
    var vnMouseY = voEvent.e.clientY; // - this.clientAbsTop;

    var vnNewLeft = vnMouseX + this.leftOffset;
    var vnNewTop = vnMouseY + this.topOffset;

    if(voParentNode.style.left == null || voParentNode.style.left == "") voParentNode.style.left = 0;
    if(voParentNode.style.top == null || voParentNode.style.top == "") voParentNode.style.top = 0;
    if(this.type == "HSPLITTER") voStyle.left = vnNewLeft + "px";
    else voStyle.top = vnNewTop + "px";
  };

  this.stopMove = function(e) {
    if (this.disabled == true) { return; }

    var voDocument = this.document;
    var voCtrl = this.getCtrl();
    var voPane = this.paneHandler.getCtrl();
    var voPaneStyle = voPane.style;

    var voParent = this.parent;
    if(voParent == null) voParent = this.canvas;
    var vnOldPos = null;
    if(this.type == "HSPLITTER") {
      vnOldPos = this.left;
      this.left = parseInt(voPaneStyle.left);
      if(this.left < 0) this.left = 0;
      else if(this.left + this.width > voParent.width) this.left = voParent.width - this.width;
      this.resizeHorz(this.left - vnOldPos);
    } else {
      vnOldPos = this.top;
      this.top = parseInt(voPaneStyle.top);
      if(this.top < 0) this.top = 0;
      else if(this.top + this.height > voParent.height) this.top = voParent.height - this.height;
      this.resizeVert(this.top - vnOldPos);
    }
    this.refresh();
    this.paneHandler.removePane();
    this.glassPane.removeCtrl();
    // Check
    voDocument.body.style.cursor = 'auto';
    voCtrl.style.cursor = this.backupCtrlCsr;

    voPane.onmousemove = null;
    voPane.onmouseup = null;
    voDocument.onmousemove = null;
    voDocument.onmouseup = null;
    if (typeof voPane.onselectstart != "undefined") {
      voPane.onselectstart = null;
    } else {
      voPane.onmousedown = null;
    }

    this.mode = null;
    this.leftOffset = -1;
    this.topOffset = -1;
    this.rightOffset = -1;
    this.bottomOffset = -1;
  };
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Label.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.div = this.getSubCtrl("div", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voDivCtrl = this.subElement.div;
  var voSpanCtrl = this.subElement.span;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  if(this.className) voDivCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");

  //외각DIV
  //2010.06.03
  //내부DIV 영역에 스크롤이 생성되는 경우를 막기 위해
  //visible 과 hidden 이 아닌경우에는 auto가 되게 수정
  if(!!this.overflow && !!(this.overflow === "scroll" || this.overflow === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "auto");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);

  if(!!this.overflowX && !!(this.overflowX === "scroll" || this.overflowX === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", auto);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);

  if(!!this.overflowY && !!(this.overflowY === "scroll" || this.overflowY === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;position:absolute;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
//  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else{
    vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
    //2010.06.01
    //영문자 개행 관련 word-wrap 추가
    vfcSetCssStrBuf(vaCssStrBuf, "word-wrap","break-word");
  }

  //2010.06.03
  //내부 div 스크롤 관련 버그 수정
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  voDivCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;

  switch(psAttrName) {
  case "width" :
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    if(vnWidth < 0) vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voDiv);
    //var vsLabel = this.getWordWrapped(this.value, voSpan);
    var vsLabel = this.value;
    this.setText(voDiv, vsLabel);
    this.setVerticalAlign(voDiv, poCtrl, this.verticalAlign);
    break;
  case "height" :
    this.setVerticalAlign(voDiv, poCtrl, this.verticalAlign);
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Label.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;
  var vaAttrName = psAttrName.split(".");
  var voDf = this.df;
  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    voCtrl.style[psAttrName] = psAttrValue + "px";
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "padding" :
    this.paddingTop = this.padding;
    this.paddingRight = this.padding;
    this.paddingBottom = this.padding;
    this.paddingLeft = this.padding;
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voDiv);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voDiv);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voDiv);
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voDiv);
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    this.setAttrCtrl("Width", vnWidth, voDiv);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "paddingLeft" :
  case "paddingRight" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    this.setAttrCtrl("Width", vnWidth, voDiv);
    break;
  break;
  case "value" :
    this.setValue(psAttrValue);
    break;
  case "outerClassName" :
  case "className" :
    this.refresh(poDocument);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 데이타 로딩완료 후에 처리작업을 수행합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Label.prototype.loadComplete = function(poDocument) {
  if(this.value == null) this.value = "";
  if(this.value == "" && this.innerHTML) {
    this.subElement.div.innerHTML = this.innerHTML;
    this.setVerticalAlign(this.subElement.div, this.ctrl, this.verticalAlign);
  } else {
    this.setValue(this.value);
  }
};
/**
 * loadData.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Label.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;

  if(!!this.innerHTML) this.value = "";
  else this.value = this.data.getData();

//  this.value = this.data.getData();
//  this.df.value = this.value;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument);
};
/**
 * 컨트롤에 값을 설정합니다.
 * @param {String} psLabel 컨트롤에 설정할 라벨 값
 */
eXria.controls.xhtml.Label.prototype.setValue = function(psLabel) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;
  var voDf = this.df;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psLabel) {
    vbChanged = true;
  }
  this.onchangeInitValue = psLabel;
  this.value = psLabel;
//  this.df.value = psLabel;
  if(vbChanged) this.data.setData(this.value);

  //var vsLabel = this.getWordWrapped(psLabel, voSpan);
  var vsLabel = "" + psLabel;
  if(this.funcNec) {
    this.funcNec(this, voDiv, vsLabel);
  } else {
    this.setText(voDiv, vsLabel);
  }
  this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
  var vnWidth = voCtrl.offsetWidth - this.borderLeftWidth - this.borderRightWidth;;
  var vnPaddingLeft = parseInt(this.getStyleCurrentValue(voDiv, "padding-left", "paddingLeft"), 10);
  var vnPaddingRight = parseInt(this.getStyleCurrentValue(voDiv, "padding-right", "paddingRight"), 10);
  if(vnPaddingLeft > 0 || vnPaddingRight > 0) {
  if(vnWidth > 0)
      this.setAttrCtrl("width", vnWidth - (vnPaddingRight+vnPaddingLeft), this.subElement.div);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.getWordWrapped = function(psLabel, poSpan) {
  var voDf = this.df;
  psLabel = eXria.controls.xhtml.Util.parseLang(psLabel);
  var vsLabel = "";
  if(psLabel != null) {
    if(this.wordWrap == false) {
      //var vnStrLen = Math.round(vsLabel.length * this.fontSize / 0.75); //pt -> px : pt / 0.75
      //voSpan.innerHTML = psLabel;
      //this.setAttrCtrl("width", voSpan.offsetWidth, voDiv);
      vsLabel = psLabel;
    } else {
      var voIdxCollection = new eXria.data.ArrayCollection();
      var vnSt = 0;
      for(var i = 1; i < psLabel.length; i++) {
        poSpan.innerHTML = psLabel.substring(vnSt, i);
        var vnWidth = this.innerWidth;
        if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
        if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
        if(poSpan.offsetWidth > vnWidth) {
          vnSt = i - 1;
          voIdxCollection.add(vnSt);
        } else if(psLabel.substring(vnSt, i).indexOf("\n") != -1) {
          vnSt = i - 1;
          psLabel = psLabel.substring(0, vnSt) + psLabel.substring(vnSt + 1);
          voIdxCollection.add(vnSt)
          i--;
        }
      }
      var voIterator = voIdxCollection.iterator();
      vnSt = 0;
      var vnIdx = 0;
      while(voIterator.hasNext()) {
        vnIdx = voIterator.next();
        vsLabel += psLabel.substring(vnSt, vnIdx) + "\n";
        vnSt = vnIdx;
      }
      vsLabel += psLabel.substring(vnSt);
    }
  }
  return vsLabel;
};
/**
 * 컨트롤에 할당된 값을 반환합니다.
 * @return 컨트롤에 할당된 값
 * @type String
 */
eXria.controls.xhtml.Label.prototype.getValue = function() {
  return this.value;
};
/**
 * 컨트롤 텍스트 수직정렬을 새로고침 합니다.
 */
eXria.controls.xhtml.Label.prototype.refreshVerticalAlign = function() {
  var voCtrl = this.ctrl;
  if(voCtrl == null) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Label.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Label[psAttrName];
  if(vsDefaultValue === undefined) {
    return null;
  }
  if((psAttrName == "backgroundImage")
  && vsDefaultValue != null) {
    if(vsDefaultValue.indexOf("http://") != -1) {
      vsDefaultValue = "url(" + this.canvas.page.metadata.resourceBaseUrl + vsDefaultValue + ")";
    } else {
      vsDefaultValue = "url(" + vsDefaultValue + ")";
    }
  }
  return vsDefaultValue;
};
/** Label 컨트롤의 Vertical Align을 설정한다
 * @private
 */
// IE6의 예외 처리문제로 추가 되었으며 UIControl에서 if..else문대신 재정의 형태로 함
eXria.controls.xhtml.Label.prototype.setVerticalAlign = function(poCtrl, poParent, psVAlign) {
  if(poCtrl.offsetHeight !== 0)
    this.divOffsetHeight = poCtrl.offsetHeight;

  if(!this.divOffsetHeight)
  this.divOffsetHeight = 0;

  var vnHeight = this.divOffsetHeight;

  if(this.canvas.page.metadata.browser.ie == 6) {
    var voFont = this.getStyleCurrentValue(poCtrl, "font-size", "fontSize");
    vnHeight = parseInt(voFont);
    vnHeight = vnHeight * 1.333;
    // IE6에서  특정 높이보다 작아지면 높이를 제대로 못가져오는 문제로 font-size로 설정하게 했으나
    // 멀티라인처럼 높이가 커진경우에는 원래 경우대로 하게끔 한다.
    if(this.divOffsetHeight > vnHeight) vnHeight = this.divOffsetHeight;
  }
  if(psVAlign == null) psVAlign = "middle";
  var vnParentHeight = poParent.style.height;
  if(vnParentHeight == "") vnParentHeight = "0";
  vnParentHeight = parseInt(vnParentHeight);
  var vnPadding = vnParentHeight - vnHeight;

  //2010.06.01
  //아래 로직이 있으면 스크롤이 중첩되서 생성되고
  //VerticalAlign 이 middle로 강제로 고정되는 경우가발생 그래서 주석 처리
  //if(vnPadding < 0) vnPadding = 0;

  switch(psVAlign) {
  case "top" :
    poCtrl.style.top = "0px";
    poCtrl.style.bottom = "";
    break;
  case "bottom" :
    poCtrl.style.top = ""; //(vnParentHeight - vnPadding)
    poCtrl.style.bottom = "0px";
    break;
  case "middle" :
    var vnPadding = vnPadding / 2;

    //2010.06.01
    //아래 로직이 있으면 스크롤이 중첩되서 생성되고
    //VerticalAlign 이 middle로 강제로 고정되는 경우가발생 그래서 주석 처리
    //if(vnParentHeight < vnHeight) vnPadding = 0;

    poCtrl.style.top = vnPadding + "px";
    poCtrl.style.bottom = "";
    break;
  }
};
/**
 * Label의 div에 포커스를 사용
 * @private
 */
eXria.controls.xhtml.Label.prototype.dofocus = function() {
  this.ctrl.focus();
};
/**
 * 좌우 splitter에 의한 관련 컨트롤들의 위치를 재설정 해주는 메소드
 * @param {Number} pnOffset splitter의 위치 이동 편차
 */
eXria.controls.xhtml.Label.prototype.resizeHorz = function(pnOffset) {
  if(pnOffset == 0) return;
  var voPage = this.canvas.page;
  var vaLeftCtls = this.ltCtls;
  var vaRightCtls = this.rbCtls;
  var vnSize = 0;
  var vcCtl = null;
  var vnWidth = null;
  vnSize = vaLeftCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaLeftCtls[i]);
    if(vcCtl.rWidth === undefined) vcCtl.rWidth = vcCtl.width;
    vnWidth = vcCtl.rWidth + pnOffset;
    vcCtl.rWidth = vnWidth;
    if(vnWidth < 0) vnWidth = 0;
    vcCtl.applyAttr("width", vnWidth);
  }
  vnSize = vaRightCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaRightCtls[i]);
    vcCtl.left = vcCtl.left + pnOffset;
    if(vcCtl.rWidth === undefined) vcCtl.rWidth = vcCtl.width;
    vnWidth = vcCtl.rWidth - pnOffset;
    vcCtl.rWidth = vnWidth;
    if(vnWidth < 0) vnWidth = 0;
    vcCtl.width = vnWidth;
    vcCtl.refresh(null, null, true);
  }
};
/**
 * 상하 splitter에 의한 관련 컨트롤들의 위치를 재설정 해주는 메소드
 * @param {Number} pnOffset splitter의 위치 이동 편차
 */
eXria.controls.xhtml.Label.prototype.resizeVert = function(pnOffset) {
  if(pnOffset == 0) return;
  var voPage = this.canvas.page;
  var vaUpperCtls = this.ltCtls;
  var vaLowerCtls = this.rbCtls;
  var vnSize = 0;
  var vcCtl = null;
  vnSize = vaUpperCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaUpperCtls[i]);
    vcCtl.applyAttr("height", vcCtl.height + pnOffset);
  }
  vnSize = vaLowerCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaLowerCtls[i]);
    vcCtl.top = vcCtl.top + pnOffset;
    vcCtl.height = vcCtl.height - pnOffset;
    vcCtl.refresh(null, null, true);
  }
};
/**
 * @
 */
eXria.controls.xhtml.Label.prototype.atdblclick = function(poEvent) {
  if(this.type != "HSPLITTER" && this.type != "VSPLITTER") return;
  if(this.type == "HSPLITTER") {
    if(this.left != 0) {
      this.orgLeft = this.left;
      this.left = 0;
      this.refresh();
      this.resizeHorz(-this.orgLeft);
    } else {
      this.left = this.orgLeft;
      this.refresh();
      this.resizeHorz(this.left);
    }
  } else {
    if(this.top != 0) {
      this.orgTop = this.top;
      this.top = 0;
      this.refresh();
      this.resizeVert(-this.orgTop);
    } else {
      this.top = this.orgTop;
      this.refresh();
      this.resizeVert(this.top);
    }
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "Label"
 * @type String
 */
eXria.controls.xhtml.Label.prototype.toString = function() {
  return "Label";
};

/**
 * @fileoverview
 * Concreate xhtml Line(XHTML Line 컨트롤)
 * @author 이종녕
 */

/**
 * @class xhtml Line Control.<br>
 * 심플 라인 도형을 표현하는 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Line 객체
 * @type eXria.controls.xhtml.Line
 * @constructor
 * @base eXria.controls.xhtml.ShapeControl
 */
eXria.controls.xhtml.Line = function(psId, pnLeft, pnTop, pnWidth, pnHeight){
//  var base = this;
  /**
   * pnLeft 컨트롤 좌상단 점의 x좌표.
   * @type Number
   */
  pnLeft =  pnLeft == null ? 20 : pnLeft;
  /**
   * pnTop 컨트롤 좌상단 점의 y좌표.
   * @type Number
   */
  pnTop =  pnTop == null ? 20 : pnTop;
  /**
   * pnWidth 컨트롤의 가로 길이.
   * @type Number
   */
  pnWidth =  pnWidth == null ? 100 : pnWidth;
  /**
   * pnHeight 컨트롤의 세로 길이.
   * @type Number
   */
  pnHeight =  pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.ShapeControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  /////////////////////////////////////////////////////////////////////////////
  ////속성

  /**
   * top/bottom
   * @type String
   */
  this.startPosition = null;

  /**
   * 컨트롤의 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.ShapeControl, eXria.controls.xhtml.Line);
//////////////////////////////////////////////////////////////////
//// 메소드

/**
 * 실체화 컨트롤 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 실체화 객체의 최외곽 div
 * @type HTMLDiv
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.createCtrl = function(poDocument){
  var voDiv = poDocument.createElement("div");
  var voStyle = voDiv.style;
  voDiv.setAttribute("id",this.id);
  voStyle.padding = "0px";
  voStyle.margin = "0px";
  voStyle.borderStyle = "none";
  voStyle.borderWidth = "0px";
  voStyle.position = "absolute";

  this.ctrl = voDiv;
  return voDiv;
};
/*
this.angleHeight = function(pnWidth,pnHeight) {
  var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.height/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.angle%91));
  vnR = vnR*vnL;
  return Math.round(vnR);
}

this.angleWidth = function(pnWidth,pnHeight) {
  var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.width/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.angle%91));
  vnR = vnR*vnL;
  return Math.round(vnR);
}
*/

/**
 * createLineCtrl
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.createLineCtrl = function(poCtrl,poDocument){
  var voWindow = this.window;
  poCtrl.style.top = this.top ;
  poCtrl.style.left = this.left;
/*
  var vnDistanceY = this.angleHeight(this.width,this.height);
  var vnDistanceX = this.angleWidth(this.width,this.height);
  var vnHeight = (vnDistanceY - this.height/2);
  var vnWidth = (vnDistanceX - this.width/2);  */
  gCore.init(voWindow); // 초기화.....
  var voDf = this.df;
  var pane = new voWindow.Pane(this.id+"_draw",0,0,this.width,this.height,poDocument);
  var voCtrl = null;
  if(voDf.startPosition == "top") {
    voCtrl = new voWindow.Line(this.id+"_line",0, 0, this.width, this.height);
  }
  else if(voDf.startPosition == "bottom") {
    voCtrl = new voWindow.Line(this.id+"_line",0,this.height,this.width,0);
  }
  var voCtrlStroke = voCtrl.stroke;

  voCtrlStroke.color = voDf.penColor;
  voCtrlStroke.weight = voDf.penWeight + "px";
  voCtrlStroke.type = this.toConstPenstyle(voDf.penStyle);
  voCtrlStroke.opacity = this.toPercent(voDf.penOpacity);
  if(voDf.penColor == "transparent") voCtrlStroke.opacity = 0;
  voCtrlStroke.lineCap = this.toConstPencap(voDf.penCap);
  voCtrlStroke.joinType = this.toConstJointype(voDf.joinType);
  voCtrl.angle = voDf.angle;
  voCtrl.cursor = voDf.cursor;
  //yhkim shapeType 추가
  voCtrl.shapeType = "line";
  pane.addShape(voCtrl);
  pane.draw(poCtrl);
};
/**
 * setMainCtrlStyles
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
//eXria.controls.xhtml.Line.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
//};

/**
 * setSpecificDefaults
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.df.startPosition = this.getAttrValue("startPosition",this.startPosition);
};

/**
 * setSpecificAttrs
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.setSpecificAttrs = function(poCtrl,poDocument) {
  this.createLineCtrl(poCtrl,poDocument);
};

/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
};

/**
 * setSpecificEvents
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.setSpecificEvents = function(poCtrl, poDocument) {
};

/**
 * removeSpecificDefaults
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  //this.setAttrCtrl("borderColor", "", voCtrl);
  //this.setAttrCtrl("borderStyle", "", voCtrl);
  this.df = {};
};

/**
 * refreshSpecificAttrs
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  var voDiv = this.getCtrl(poDocument);
  var voPaneCtrl = voDiv.childNodes[0];
  voDiv.removeChild(voPaneCtrl);
  this.setSpecificAttrs(poCtrl, poDocument);
};

/**
 * applyAttrRefresh
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.applyAttrRefresh = function(psAttrName, psAttrValue, poDocument) {
  this.setAttr(psAttrName, psAttrValue);
//  this.setAttrCtrl(psAttrName, psAttrValue);
//  var voDiv = this.getCtrl(poDocument);
//  var voPaneCtrl = voDiv.childNodes[0];
//  voDiv.removeChild(voPaneCtrl);
//  this.createLineCtrl(voDiv,poDocument);
  this.refresh(poDocument);
};

/**
* 서브 컨트롤 실체화 객체를 얻어온다.
* @param {String} psTagName 컨트롤 태그 이름
* @param {HTMLDiv} poCtrl 실체화 컨트롤, 생략가능
* @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document, 생략가능
* @return 서브 컨트롤 실체화 객체
* @type Object
*/
eXria.controls.xhtml.Line.prototype.getSubCtrl = function(psTagName, poCtrl, poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};

/**
 * 클래스 명을 반환한다.
 * @return "Line"
 * @type String
 */
eXria.controls.xhtml.Line.prototype.toString = function() {
  return "Line";
};

/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 해당 속성명의 디폴트 속성 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Line.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Line[psAttrName];
  if(vsDefaultValue == null) vsDefaultValue = this.getShapeDefaultValue(psAttrName);
  if(vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @fileoverview
 * Concreate xhtml ListBox(XHTML ListBox 컨트롤)
 * @author 조영진
 */

/**
 * Concreate xhtml ListBox
 * @author : 조영진
 * @version 2.0
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {eXria.controls.xhtml.ListBox} poControl
 * @constructor
 */
eXria.controls.xhtml.ListItem = function(psName, poValue, poControl) {
  /**
   * 아이템 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 아이템 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 아이템 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 아이템 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 아이템 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 아이템 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 아이템 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * @type Number
   * @private
   */
  this.cellSpacing = 0;
  /**
   * @type Number
   * @private
   */
  this.cellPadding = 0;
  /**
   * 아이템 배경 색상.
   * @type String
   * @private
   */
  this.backgroundColor = poControl.itemgroup.backgroundColor;
  /**
   * 아이템 텍스트 색상.
   * @type String
   * @private
   */
  this.color = poControl.color;
  /**
   * 아이템 폰트 패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 아이템 폰트 사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 아이템 폰트 스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 아이템 폰트 두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 아이템 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 아이템 라벨 명.
   * @type String
   */
  this.name = psName;
  /**
   * 아이템 설정 값.
   * @type String
   */
  this.value = poValue;
  /**
   * ListBox Control 참조 변수.
   * @type eXria.controls.xhtml.ListBox
   */
  this.parent = poControl;
  /**
   * 아이템 선택 여부.
   * @type Boolean
   */
  this.selected = false;
  /**
   * 아이템 생성 innerHTML 템플릿 저장.
   */
  this.template = null;
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   * @private
   */
  this.data = new eXria.controls.DataRefNode(this.parent);
};
/**
 * 실체화 컨트롤 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListItem.prototype.create = function(poDocument) {
  var voParent = this.parent;

  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = voParent.getCtrl(poDocument);

  var voTable = voCtrl.childNodes[0];
  var voTbody = voTable.childNodes[0];
  var voTr = null;
  var voTd = null;
  var voDiv = null;
  var voInput = null;
  var vsType = null;
  var vsInputId = null;
  var voText = null;
  var vsKey = null;

  if (voParent.appearance == "radio") {
    vsType = "radio";
    vsInputId = voParent.id + "_radio_";

  } else if (voParent.appearance == "checkbox") {
    vsType = "checkbox";
    vsInputId = voParent.id + "_checkbox_";
  }

  voTr = poDocument.createElement("tr");
  voTr.style.backgroundColor = this.backgroundColor;
  voTr.style.color = this.color;
  voTd = poDocument.createElement("td");
  voDiv = poDocument.createElement("div");
  voDiv.name = voParent.id + "_option";
  this.id = voParent.id + "_option_" + voParent.seqNum++;
  voDiv.setAttribute("id", this.id);

  this.setDefault(voDiv, poDocument);

  voParent.setAttrCtrl("overflow", "hidden", voDiv);
  var voInnerTable = poDocument.createElement("table");
  voParent.setAttrCtrl("cellSpacing", 0, voInnerTable);
  voParent.setAttrCtrl("cellPadding", 0, voInnerTable);
  voParent.setAttrCtrl("backgroundColor", this.backgroundColor, voDiv);
  voParent.setAttrCtrl("color", this.color, voInnerTable);
  var voInnerTbody = poDocument.createElement("tbody");
  var voInnerTr = poDocument.createElement("tr");
  var voInnerTd = poDocument.createElement("td");
  var vnWidth = voParent.innerWidth - this.borderLeftWidth - this.borderRightWidth - 2 * voParent.cellSpacing;
  if (vnWidth < 0) vnWidth = 0;
  var vnHeight = voParent.itemgroup.height - this.borderTopWidth - this.borderBottomWidth;
  if (vnHeight < 0) vnHeight = 0;
  var voOption = null;

//   if(voParent.isScrolled()) { vnWidth -= voParent.scrollbarWidth;
//   if(voParent.bScrolled == false) { for(var i = 0; i < voTable.rows.length;
//   i++) { voOption = voTable.rows[i].cells[0].childNodes[0];
//   voParent.setAttrCtrl("width", vnWidth, voOption); }
//   voParent.setAttrCtrl("width", voParent.innerWidth, voTable);
//   voParent.bScrolled = true; } }

  voParent.setAttrCtrl("width", vnWidth, voDiv);
  voParent.setAttrCtrl("height", vnHeight, voInnerTd);
  voParent.setAttrCtrl("height", vnHeight, voDiv);
  voParent.setAttrCtrl("width", voParent.innerWidth, voTd);
  voParent.setAttrCtrl("height", voParent.itemgroup.height, voTd);
  if (voParent.appearance != "normal") {
    voInput = poDocument.createElement("input");
    voInput.setAttribute("type", vsType);
    if (voParent.appearance == "radio")
      voInput.setAttribute("name", vsInputId);
    var vnIndex = voTable.rows.length;
    voInput.setAttribute("id", vsInputId + vnIndex);
    voParent.setAttrCtrl("width", voParent.itemgroup.selectorWidth, voInput);
    voInnerTd.appendChild(voInput);
  }
  voText = poDocument.createTextNode(this.name);
  voInnerTd.appendChild(voText);
  voInnerTr.appendChild(voInnerTd);
  voInnerTbody.appendChild(voInnerTr);
  voInnerTable.appendChild(voInnerTbody);
  voDiv.appendChild(voInnerTable);
//  if (this.disabled) voDiv.disabled = true;
  voTd.appendChild(voDiv);

  // [Set page context unselective]
  if (typeof voTd.onselectstart != "undefined") {
    voTr.onselectstart = function(e) {
      return false;
    };
  } else {
    voTr.onmousedown = function(e) {
      return false;
    };
  }
  // end of [Set page context unselectable]
  voTr.control = voParent;
  if (this.disabled != true)
    voTr.onclick = function(e) {
      this.control.selectList(e);
    }

  voTr.appendChild(voTd);
  voTbody.appendChild(voTr);

  var vnSize = voParent.getVisibleItemCount();
  var vnHeight = parseInt(voParent.itemgroup.height);
  vnHeight = vnSize * (vnHeight + voParent.cellSpacing)
      + voParent.cellSpacing;
  voParent.setAttrCtrl("height", vnHeight, voTable);
  if (voParent.heightBySize && vnSize > 0) {
    voParent.setAttrCtrl("height", vnHeight, voCtrl);
  }

  if (voParent.isScrolled())
    voParent.setAttrCtrl("overflowY", "scroll", voCtrl);
  else
    voParent.setAttrCtrl("overflowY", "hidden", voCtrl);

  this.setAttrs(voDiv, poDocument);

};
/**
 * 실체화 컨트롤 생성 innerHTML
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 실체화 컨트롤 생성 innerHTML
 * @type String
 * @ignore
 */
eXria.controls.xhtml.ListItem.prototype.getInnerHTML = function(poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var voParent = this.parent;
  var vaStrBuf = null;
  var vsType = null;
  var vsInputId = null;

  if (voParent.appearance == "radio") {
    vsType = "radio";
    vsInputId = voParent.id + "_radio_";

  } else if (voParent.appearance == "checkbox") {
    vsType = "checkbox";
    vsInputId = voParent.id + "_checkbox_";
  }


  var vsName = voParent.id + "_option";
  var vnSeqNum = voParent.seqNum++;
  this["id"] = vsName + "_" + vnSeqNum;

  vaTemplate.push("<tr onselectstart=\"return false;\" onmousedown=\"return false;\"><td><div id=");
  vaTemplate.push(this["id"]);
  vaTemplate.push(" name=");
  vaTemplate.push(vsName);
  vaTemplate.push(" style='overflow:hidden;");
  vaTemplate.push("@cssStrBuf"); // 5
  vaTemplate.push("'");

  vaStrBuf = [];
  if (this.disabled != true) {
    vaStrBuf.push(" onclick=\"")
    vaStrBuf.push(voParent.getEHandler(voParent.id, "selectEventList"));
    vaStrBuf.push("\"");

    vaStrBuf.push(" onmouseover=\"");
    vaStrBuf.push(voParent.getEItemHandler(voParent.id, this.id, "mouseOver"));
    vaStrBuf.push("\"");

//    vaStrBuf.push(" onkeydown=\"");
//    vaStrBuf.push(voParent.getEItemHandler(voParent.id, this.id, "keyDown"));
//    vaStrBuf.push("\"");
  }

  vaTemplate.push(vaStrBuf.join(""));
  var vsClass = this.parent.getCSSClass(this.parent, 1, "itemgroup");
  if(voParent.getItemClassName) {
    var vsItemClassName = voParent.getItemClassName(vnSeqNum);
    if(vsItemClassName != null) vsClass = vsClass + " " + vsItemClassName;
  } else if(voParent.itemgroup.className) {
    vsClass = vsClass + " " + voParent.itemgroup.className;
  }
  vaTemplate.push("/><table cellSpacing=0 cellPadding=0 class='" + vsClass + "' style='");
  vaTemplate.push("@cssStrBuf"); // 9
  vaTemplate.push("'><tbody><tr><td style='");
  vaTemplate.push("@cssStrBuf"); // 11
  vaTemplate.push("'>");

  vaStrBuf = [];
  if (voParent.appearance != "normal") {
    vaStrBuf.push("<input ");
    vaStrBuf.push("type=");
    vaStrBuf.push(vsType);
    if (voParent.appearance == "radio") {
      vaStrBuf.push(" name=");
      vaStrBuf.push(vsInputId);
    }
    vaStrBuf.push(" style='width:" + voParent.itemgroup.selectorWidth + "px' />");
//    voParent.setCssStrBuf(vaStrBuf, "width",
//        voParent.itemgroup.selectorWidth, "px");
  }

  vaTemplate.push(vaStrBuf.join(""));
  vaTemplate.push("@innStrBuf"); // 14
  vaTemplate.push("</td></tr></tbody></table></div></td></tr>");

  this.setDefault(null, voParent.document);
  this.setAttrsInn(null, null);

  var vsRet = vaTemplate.join("");
  vaStrBuf = null;
  vaTemplate = null;
  this.template = null;
  return vsRet;
};
/**
 * setDefault
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.setDefault = function(poCtrl, poDocument) {
  this.className = this.makeSpecificAttrValue(poCtrl, null, "className");
  var voData = this.data;
  if(voData.instanceId && voData.instancePath) {
    this.name = voData.getData();
  }
};
/**
 * setAttrs
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.setAttrs = function(poCtrl, poDocument) {
  var voDiv = poCtrl;
  var voParent = this.parent;
  if (voDiv == null)
    voDiv = this.getCtrl(poDocument);
  voParent.setAttrCtrl("color", this.color, voDiv);
  voParent.setAttrCtrl("borderStyle", this.borderStyle, voDiv);
  voParent.setAttrCtrl("borderColor", this.borderColor, voDiv);
  voParent.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voDiv);
  voParent.setAttrCtrl("borderRightWidth", this.borderRightWidth, voDiv);
  voParent.setAttrCtrl("borderTopWidth", this.borderTopWidth, voDiv);
  voParent.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voDiv);
  var voInnerTable = voDiv.childNodes[0];
  voParent.setAttrCtrl("fontFamily", this.fontFamily, voInnerTable);
  voParent.setAttrCtrl("fontSize", this.fontSize, voInnerTable);
  voParent.setAttrCtrl("fontStyle", this.fontStyle, voInnerTable);
  voParent.setAttrCtrl("fontWeight", this.fontWeight, voInnerTable);
  var voInnerTd = voInnerTable.rows[0].cells[0];
  voParent.setAttrCtrl("verticalAlign", this.verticalAlign, voInnerTd);
  voParent.setAttrCtrl("paddingLeft", this.paddingLeft, voInnerTd);
  voParent.setAttrCtrl("paddingRight", this.paddingRight, voInnerTd);
  voParent.setAttrCtrl("paddingTop", this.paddingTop, voInnerTd);
  voParent.setAttrCtrl("paddingBottom", this.paddingBottom, voInnerTd);
};
/**
 * 실체화 부분에 속성 값 설정
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.setAttrsInn = function(poCtrl,
    poDocument) {
  var voParent = this.parent;
  var vaTemplate = this.template;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vaInnStrBuf = null;
  var vfcSetAttStrBuf = voParent.setAttStrBuf;
  var vfcSetCssStrBuf = voParent.setCssStrBuf;

  var vnWidth = voParent.innerWidth - this.borderLeftWidth - this.borderRightWidth - 2 * voParent.cellSpacing;
  if (vnWidth < 0)
    vnWidth = 0;
  var vnHeight = voParent.itemgroup.height - this.borderTopWidth - this.borderBottomWidth;
  if (vnHeight < 0)
    vnHeight = 0;
  if (voParent.isScrolled()) {
    vnWidth -= voParent.scrollbarWidth;
  }
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  // vfcSetCssStrBuf(vaCssStrBuf, "width", "100%");
  // vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", voParent.itemgroup.color);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", voParent.itemgroup.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", voParent.itemgroup.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", voParent.itemgroup.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", voParent.itemgroup.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", voParent.itemgroup.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", voParent.itemgroup.borderBottomWidth, "px");
  vaTemplate[5] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", voParent.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", voParent.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", voParent.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", voParent.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voParent.backgroundColor);
  vaTemplate[9] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  // vfcSetCssStrBuf(vaCssStrBuf, "width", "100%");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "min-height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", voParent.itemgroup.verticalAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", voParent.itemgroup.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", voParent.itemgroup.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", voParent.itemgroup.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", voParent.itemgroup.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
  vfcSetCssStrBuf(vaCssStrBuf, "word-break", "break-all");
  vfcSetCssStrBuf(vaCssStrBuf, "word-wrap", "break-word");

  vaTemplate[11] = vaCssStrBuf.join("");

  vaInnStrBuf = [];
  vaInnStrBuf.push(this.name);

  vaTemplate[14] = vaInnStrBuf.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaInnStrBuf = null;
  vaTemplate = null;
};
/**
 * 아이템 새로고침 수행.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListItem.prototype.refresh = function(poDocument) {
  var voCtrl = this.parent.getCtrl(poDocument);
  if (voCtrl == null)
    return;
  this.removeAttrDefault(voCtrl, poDocument);
  this.setAttrs(voCtrl, poDocument);
};
/**
 * removeAttrDefault
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.removeAttrDefault = function(poCtrl,
    poDocument) {
  this.df = {};
  var voParent = this.parent;

  // var voDiv = this.getCtrl(poDocument);
  // var voInnerTable = voDiv.childNodes[0];
  // var voInnerTd = voInnerTable.rows[0].cells[0];
  //
  // this.setAttrCtrl("verticalAlign", this.verticalAlign, voInnerTd);
};
/**
 * 아이템의 실체화 객체 반환.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return 실체화 객체
 * @type HTMLDiv
 */
eXria.controls.xhtml.ListItem.prototype.getCtrl = function(poDocument) {
  var voParent = this.parent;
  var voCtrl = voParent.lookup(this.id);

  return voCtrl;
};
/**
 * 아이템 실체화 컨트롤에 적용될 세부 속성 값을 반환하는 메소드
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.makeSpecificAttrValue = function(
    poCtrl, poCssStyle, psAttrName, psCtrlAttrName) {
  var vaAttrName = psAttrName.split(".");

   //var voAttr = this; for(var i = 0; i < vaAttrName.length; i++) { voAttr =
   //voAttr[vaAttrName[i]]; if(voAttr == null) { break; } }

  var voAttr = null;
  if (voAttr != null) { // 사용자 지정 속성값이 있을 경우
    return voAttr;
  } else { // 사용자 지정 속성값이 없을 경우
    if (poCssStyle != null) { // 지정된 CSS가 있을 경우
      if (psCtrlAttrName == null)
        psCtrlAttrName = vaAttrName[vaAttrName.length - 1];
      if (poCssStyle[psCtrlAttrName] != null
          && poCssStyle[psCtrlAttrName] != "") {
        return poCssStyle[psCtrlAttrName];
      } else { // CSS에 해당 속성 값이 없을 경우
        return this.getSpecificDefaultValue(psAttrName);
      }
    } else { // 지정된 CSS가 없을 경우
      return this.getSpecificDefaultValue(psAttrName);
    }
  }
};
/**
 * @param {String} psAttrName 속성명
 * @return 지정된 속성에 대한 디폴트 값
 * @type String|Number|Object
 * @private
 */
eXria.controls.xhtml.ListItem.prototype.getSpecificDefaultValue = function(
    psAttrName) {
  var voRet = null;
  if (this.parent.itemgroup[psAttrName] != null) {
    voRet = this.parent.itemgroup[psAttrName];
  }
  return voRet;
};
/**
 * 아이템의 스타일 속성값을 일괄적으로 변경하기 위한 메소드.
 * @param {Object} poStyleObject 변경될 속성값을 담은 오브젝트
 * @return void
 * @type void
 * @example
 * var data = new eXria.data.Map();<br/>
   data.put("name","newName");<br/>
   data.put("fontSize","10");<br/><br/>

   var item = page.getControl("listbox").getItem(0);<br/>
   item.poStyleObject(data.getEntries());<br/>
 */
eXria.controls.xhtml.ListItem.prototype.setItemStyle = function(poStyleObject) {
  var vsAttr = null;
  for (vsAttr in poStyleObject) {
    this[vsAttr] = poStyleObject[vsAttr];
  }
};

/**
 * ListBox 컨트롤 아이템의 공통 속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.ListBox_itemgroup = function() {
  /**
   * 아이템의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 아이템 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 아이템 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 아이템 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 아이템 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 아이템의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 아이템의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 아이템의 세로 길이.
   * @type Number
   */
  this.height = null;
  /**
   * 선택 버튼의 가로 길이.
   * @type Number
   */
  this.selectorWidth = null;
  /**
   * 아이템에 표시될 텍스트의 오버플오루 속성.
   * @type String
   */
  this.overflow = null;
  /**
   * 아이템에 표시될 텍스트의 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * css를 통해 지정된 텍스트 컨텐츠 오버플로우 속성.
   * @private
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 아이템에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;

  this.df = {};
};

/**
 * @class Concreate xhtml ListBox.<br>
 *        XHTML ListBox 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.ListBox 객체
 * @type eXria.controls.xhtml.ListBox
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.ListBox = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 200 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth,
      pnHeight);
  // 데이타 연동 관련
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 인스턴스로 부터 라벨 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.labelTagName = "label";
  /**
   * 인스턴스로 부터 value 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.valueTagName = "value";
  // 데이타 연동 관련 End

  // ////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 컨트롤에 설정된 값.
   * @type String
   */
  this.value = null;
  /**
   * 선택 버튼 형태. normal, radio, checkbox (보여지는 option의 형태 : 라디오, 리스트, 콤보)
   * @type String
   */
  this.appearance = null;
  /**
   * 이전까지의 컨트롤의 선택 버튼 형태.
   * @type Boolean
   * @private
   */
  this.oldAppearance = null;
  /**
   * 아이템 다중선택 여부.
   * @type Boolean
   */
  this.multiSelect = null;
  /**
   * 이전까지 컨트롤의 다중선택 여부.
   * @type Boolean
   * @private
   */
  this.oldMultiselect = false;
  /**
   * 선택된 아이템의 인덱스.
   * @type Number
   */
  this.selectedIndex = null;
  /**
   * 앞쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.frontItems = new eXria.data.ArrayMap();
  /**
   * 인스턴스로 부터 가져올 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.itemset = new eXria.data.ArrayMap();
  /**
   * 뒤쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.backItems = new eXria.data.ArrayMap();
  /**
   * 선택된 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.selectedItems = new eXria.data.ArrayMap();
  /**
   * 리스트에 보여지는 아이템 개수.
   * @type Number
   */
  this.size = null;
  /**
   * 아이템에 포커스 위치시에 아이템 배경색상.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * 아이템에 마우스오버 위치시에 아이템 배경색상.
   * @type String
   */
  this.hoverBackgroundColor = null;
  /**
   * 아이템에 포커스 위치시에 아이템 텍스트색상.
   * @type String
   */
  this.focusColor = null;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트의 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 리스트 아이템 사이의 간격.
   * @type Number
   */
  this.cellSpacing = null;
  /**
   * 컨트롤의 크기를 아이템 개수를 기준으로 할지 여부.
   * @type Boolean
   */
  this.heightBySize = null;
  /**
   * 리스트 영역 계산 시 사용될 스크롤 버튼의 가로 길이.
   * @private
   * @type Number
   */
  this.scrollbarWidth = 19;
  /**
   * 리스트 영역의 오버플로우 타입('scroll' | 'hidden' | 'auto').
   * @type String
   */
  this.overflow = null;
  /**
   * 현재 리스트의 스크롤바가 표시되어 있는지 여부 체크.
   * @type Boolean
   * @private
   */
  this.bScrolled = false;
  /**
   * 아이템의 공통 속성을 저장하기 위한 오브젝트.
   * @type Object
   * @private
   */
  this.itemgroup = new eXria.controls.xhtml.ListBox_itemgroup();
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 선택된 아이템이 변경 되었는지 여부(change이벤트 발생에 이용).
   * @private
   * @type Boolean
   */
  this.bRowChanged = false;
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type Object
   * @private
   */
  this.document = null;
  /**
   * @private
   */
  this.seqNum = 0;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl,
    eXria.controls.xhtml.ListBox);
/**
 * 컨트롤 클릭 이벤트 발생 메소드. click
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.click = function() {
  this.getCtrl().click();
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["tabIndex"] = 0;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.setTemplate = function(poCtrl,
    poDocument) {
  if (this.appearance == null)
    this.appearance = "normal";

  this.template = [];
  var vsClass = this.getCSSClass(this, 1);
  var vaTemplate = this.template;
  vaTemplate.push("<table class='" + vsClass + "' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_list_table' cellpadding=0 ");
  vaTemplate.push("@attStrBuf"); // 3
  vaTemplate.push("style='position:absolute;left:0px;top:0px;background-color:transparent;");
  vaTemplate.push("@cssStrBuf"); // 5
  vaTemplate.push("'>");
  vaTemplate.push("<tbody>");
  vaTemplate.push("@listareaStrBuf"); // 8
  vaTemplate.push("</tbody>");
  vaTemplate.push("</table>");
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.refreshSubStyle = function(poCtrl,
    poDocument) {
  this.setSubCtrlStyles(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.seqNum = 0;
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if (this.innerWidth < 0)
    this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if (this.innerHeight < 0)
    this.innerHeight = 0;
  this.setStyleCurrentBorderValue(this);

  if (this.value == null) this.value = [];

  this.selectedIndex = this.getAttrValue("selectedIndex", this.selectedIndex);
  this.multiSelect = this.getAttrValue("multiSelect", this.multiSelect);
  this.size = this.getAttrValue("size", this.size);
  this.heightBySize = this.getAttrValue("heightBySize", this.heightBySize);
  this.focusColor = this.getAttrValue("focusColor", this.focusColor);
  this.focusBackgroundColor = this.getAttrValue("focusBackgroundColor", this.focusBackgroundColor);
  var voHoverColor = this.getAttrValue("hoverBackgroundColor", this.hoverBackgroundColor);
  this.hoverBackgroundColor = ( voHoverColor == null || voHoverColor == "undefine")?"#F0F0F0":voHoverColor;
  this.cellSpacing = this.getAttrValue("cellSpacing", this.cellSpacing);

  var voItemgroupDf = this.itemgroup;
  voItemgroupDf.verticalAlign = this.getAttrValue("itemgroup.verticalAlign",this.itemgroup.verticalAlign);
  var voUserAttr = null;
  if(this.userAttr == "") this.userAttr = null;
  this.userAttr = this.getAttrValue("userAttr", this.userAttr);
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.labelName = voUserAttr.labelName;
    if(voUserAttr.getItemClassName) this.getItemClassName = voUserAttr.getItemClassName;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.setSpecificAttrs = function(poCtrl,
    poDocument) {
  var voTable = poCtrl.childNodes[0];
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
//  if (this.disabled)
//    poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if (this.visible == false)vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth,"px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth,"px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", "hidden");
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "cellSpacing", this.cellSpacing);
  vaTemplate[3] = vaAttStrBuf.join("");

  vaCssStrBuf = null;
  vaAttSTrBuf = null;
};

/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.atclick = function(e) {
  var voDiv = e.target;
  while (voDiv.nodeName != "DIV") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null) return;
  var vsDivId = voDiv.id;
  var vsId = this.id + "_option";
  if(vsDivId.indexOf(vsId) == -1) return;

  this.document.getElementById(this.id).focus();

  if (this.bRowChanged
      || (this.appearance == "checkbox" && this.multiSelect == true)) {
    this.dochange(e, this);
  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.atkeydown = function(e) {
  this.keyDown(e);

  var voDiv = e.target;
  while (voDiv.nodeName != "DIV") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null || voDiv.name != this.id + "_option")
    return;

  if (this.bRowChanged
      || (this.appearance == "checkbox" && this.multiSelect == true)) {
    this.dochange(e, this);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.finalkeydown = function(e) {
  this.doFinalKey(e);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.finalkeypress = function(e) {
  this.doFinalKey(e);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.doFinalKey = function(e){
  var voEvent = new eXria.event.Event(e, this.window);
  var vnKeyCode = e.keyCode;

  if(vnKeyCode == '38' || vnKeyCode == '40' ||vnKeyCode == '16' || vnKeyCode == '17'){//화살표 위, 아래, shift, ctrl
    voEvent.stopEvent();
  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.atmouseover = function(e) {
  if (this.eventType == "item" && this.eventObject != null) {
    var voDocument = this.document;
    var voItem = this.eventObject;

    voItemCtrl = voDocument.getElementById(voItem.id);

    var voStyle;

    if(!!voItemCtrl)
     voStyle = voItemCtrl.style;

    var voCollection = this.selectedItems.getKeyCollection().iterator();
    var voData = null;
    var vbSelected = false;

    while (voCollection.hasNext()) {
      var vnIndex = voCollection.next();
      var voData = this.getItem(vnIndex);

      if (voData.id == voItem.id)
        vbSelected = true;
    }

    if (!vbSelected)
      voStyle.backgroundColor = this.hoverBackgroundColor;// eXria.controls.xhtml.Default.ListBox.focusBackgroundColor;//"#F1F1EB";//this.df.focusBackgroundColor;
  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.dochange = function(poEvent, poControl) {
  if (poControl.atchange) {
    poControl.atchange(poEvent);
  }
  if (poControl.cochange) {
    poControl.cochange(poEvent);
  }
  if (poControl.onchange) {
    poControl.onchange(poEvent);
  }
  if (poControl.changeEventCallback) {
    poControl.changeEventCallback(poEvent);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.doitemchange = function(poEvent, poControl) {
  if (poControl.atitemchange) {
    poControl.atitemchange(poEvent);
  }
  if (poControl.coitemchange) {
    poControl.coitemchange(poEvent);
  }
  if (poControl.onitemchange) {
    poControl.onitemchange(poEvent);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.atchange = function(poEvent) {
  // if(this.data.instanceId) this.data.setData(this.getSelectedValue());
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.removeSpecificDefaults = function(
    poCtrl, poDocument) {
//  this.df = {};
//  this.itemgroup.df = {};
//  this.template = null;
  // var voTable = this.lookup(this.id + "_list_table");
  // var voDiv = null;
  // for(var i = 0; i < voTable.rows.length; i++) {
  // voDiv = voTable.rows[i].cells[0].firstChild;
  // voDiv.onclick = null;
  // }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.refreshSpecificAttrs = function(poCtrl,
    poDocument) {
  this.setSpecificAttrs(poCtrl, poDocument);
  // this.refreshList(poCtrl, poDocument);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.setAttrSubCtrl = function(psAttrName,
    psAttrValue, poCtrl) {
  if (poCtrl.id != this.id)
    return;

  var voTable = poCtrl.childNodes[0];

  switch (psAttrName) {
  case "disabled":
    this.setDisable(poCtrl, psAttrValue);
    break;
  case "width":
    this.setAttrCtrl("width", psAttrValue, voTable);
    break;
  case "height":
    this.setAttrCtrl("height", psAttrValue, voTable);
    break;
  // case "borderWidth" :
  // this.setAttrCtrl("width", this.innerWidth, voTable);
  // this.setAttrCtrl("height", this.innerHeight, voTable);
  // break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.applyAttrRebuild = function(psAttrName,
    psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voTable = voCtrl.childNodes[0];
  var voStyle = null;
  var vsSubAttrName = null;
  var voDf = this.df;
  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for ( var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }

  switch (psAttrName) {
//  case "disabled":
//    this.setDisable(voCtrl, psAttrValue);
//    break;
  case "backgroundColor":
  case "color":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    var voDiv = null;
    for ( var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      if (this.selectedItems.get(i) == null) {
        this.restoreRowColor(voDiv);
      }
    }
    break;
  case "visible":
  case "borderStyle":
  case "borderColor":
  case "fontFamily":
  case "fontSize":
  case "fontStyle":
  case "fontWeight":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "left":
  case "top":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "borderLeftWidth":
  case "borderRightWidth":
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voCtrl);
    // this.setListWidth();
  case "width":
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if (this.innerWidth < 0)
      this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.refreshList(voCtrl, poDocument);
    break;
  case "borderTopWidth":
  case "borderBottomWidth":
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voCtrl);
  case "height":
    this.innerHeight = this.height - this.borderTopWidth
        - this.borderBottomWidth;
    if (this.innerHeight < 0)
      this.innerHeight = 0;
    if (!this.heightBySize) {
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      // this.refreshList(voCtrl, poDocument);
    }
    this.refreshList(voCtrl, poDocument);
    break;
  case "borderWidth":
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if (this.innerWidth < 0)
      this.innerWidth = 0;
    this.innerHeight = this.height - this.borderTopWidth
        - this.borderBottomWidth;
    if (this.innerHeight < 0)
      this.innerHeight = 0;
    // border
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this
        .setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    // width
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    // height
    if (!this.heightBySize) {
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      // this.refreshList(voCtrl, poDocument);
    }
    this.setListWidth();
    break;
  case "size":
    if (this.heightBySize && this.size > 0) {
      var vnHeight = this.itemgroup.height;
      vnHeight = this.size * (vnHeight + this.cellSpacing) + this.cellSpacing;
      this.setAttrCtrl("height", vnHeight, voCtrl);
    }
    break;
  case "cellSpacing" :
    if (psAttrName == "cellSpacing") {
      voTable.setAttribute("cellSpacing", this.cellSpacing);
    }
    break;
  case "focusBackgroundColor":
  case "focusColor":
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    var voDiv = null;
    for ( var i = 0; i < voTable.rows.length; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes;
      if (this.selectedItems.get(i) == null) {
        this.restoreRowColor(voDiv);
      }
    }
    break;
  case "multiSelect":
    if (this.appearance == "radio") {
      this.multiSelect = false;
      this.multiSelect = false;
    }
    if (this.multiSelect != this.oldMultiselect) {
      this.refreshList(voCtrl, poDocument);
    }
    break;
  case "appearance":
    if (this.appearance == "radio") {
      this.multiSelect = false;
      this.multiSelect = false;
    }
    if (this.appearance != this.oldAppearance) {
      this.refreshList(voCtrl, poDocument);
    }
    break;
  case "itemgroup.borderWidth":
  case "itemgroup.borderLeftWidth":
  case "itemgroup.borderRightWidth":
  case "itemgroup.borderTopWidth":
  case "itemgroup.borderBottomWidth":
  case "itemgroup.height":
  case "itemgroup.padding":
  case "itemgroup.paddingLeft":
  case "itemgroup.paddingRight":
  case "itemgroup.paddingTop":
  case "itemgroup.paddingBottom":
  case "itemgroup.selectorWidth":
  case "itemgroup.verticalAlign":
    this.refreshList(voCtrl, poDocument);
    break;
  default:
    this.refresh(poDocument);
    break;
  }
};
/**
 * loadData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.loadData = function(poDocument) {
  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    this.loadDataFromPluginInstance(poDocument);
    return;
  }

  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);
  this.itemset.clear();

  var vsRefValue = this.value;
  var vaValue = [];
  if (this.data.instanceId != null && this.data.instancePath != null)
    vsRefValue = this.data.getData();
  if (vsRefValue != null) {
    this.selectedIndex = -1;
    this.selectedIndex = -1;
    if (vsRefValue instanceof Array)
      vaValue = vsRefValue;
    else
      vaValue.push(vsRefValue);
  }
  this.value = vaValue;
  this.value = vaValue;
  if (this.data.nodesetInstanceId == null
      || this.data.nodesetInstancePath == null)
    return;
  var voCollectionNode = this.data.getNodesetData2();
  if (voCollectionNode == null)
    return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  for ( var i = 0; i < vnLoop; i++) {
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    vsLabelNode = voMapNode.get(this.labelTagName);
    vsValueNode = voMapNode.get(this.valueTagName);
    voItem = this.addToItemset(vsLabelNode, vsValueNode, poDocument);

    for ( var j = 0; j < vaValue.length; j++) {
      if (vaValue[j] == vsValueNode) {
        voItem.selected = true;
        break;
      }
    }
  }
};
/**
 * loadDataFromPluginInstance
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.loadDataFromPluginInstance = function(poDocument) {
  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);
  this.itemset.clear();

  var vsRefValue = this.value;
  var vaValue = [];
  if (this.data.instanceId != null && this.data.instancePath != null)
    vsRefValue = this.data.getData();
  if (vsRefValue != null) {
    this.selectedIndex = -1;
    this.selectedIndex = -1;
    if (vsRefValue instanceof Array)
      vaValue = vsRefValue;
    else
      vaValue.push(vsRefValue);
  }
  this.value = vaValue;
  this.value = vaValue;
  if (this.data.nodesetInstanceId == null
      || this.data.nodesetInstancePath == null)
    return;
  var voCollectionNode = this.data.getNodesetStr();
  if (voCollectionNode == null)
    return;
  voCollectionNode = eval(voCollectionNode);
  var vnLoop = voCollectionNode.length;
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  for ( var i = 0; i < vnLoop; i++) {
    voMapNode = voCollectionNode[i];
    vsLabelNode = voMapNode[this.labelTagName];
    vsValueNode = voMapNode[this.valueTagName];
    voItem = this.addToItemset(vsLabelNode, vsValueNode, poDocument);

    for ( var j = 0; j < vaValue.length; j++) {
      if (vaValue[j] == vsValueNode) {
        voItem.selected = true;
        break;
      }
    }
  }
};
/**
 * loadComplete
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vaStrbuf = null;

  if (this.value.length > 0)
    this.clearSelected();


//   var vnSize = this.getVisibleItemCount(); var vnHeight =
//   parseInt(this.itemgroup.df.height); vnHeight = vnSize * (vnHeight +
//   this.df.cellSpacing) + this.df.cellSpacing; if(this.df.heightBySize &&
//   vnSize > 0) { this.setAttrCtrl("height", vnHeight, voCtrl); }

  vaStrBuf = [];
  // vfcSetCssStrBuf(vaStrBuf, "height", this.height, "px");
  vfcSetCssStrBuf(vaStrBuf, "width", this.innerWidth, "px");
  vaTemplate[5] = vaStrBuf.join("");

  vaTemplate[8] = this.getListInnerHTML();

  voCtrl.innerHTML = vaTemplate.join("");

  vaStrBuf = null;
  // vaTemplate = null;
  // this.template = null;

  var vnListHeight = this.getListScrollHeight(poDocument);
  if (this.heightBySize && vnListHeight > 0)
    this.setAttrCtrl("height", vnListHeight, voCtrl);
  if (this.isScrolled()) {
    this.setAttrCtrl("overflowY", "scroll", voCtrl);
  } else {
    this.setAttrCtrl("overflowY", "hidden", voCtrl);
  }
  this.setListWidth();

  this.checkSelected(voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.getListScrollHeight = function(
    poDocument) {
  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);
  var voTable = this.lookup(this.id + "_list_table");
  return voTable.scrollHeight;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.setListWidth = function() {
  var voTable = this.lookup(this.id + "_list_table");
  if (this.isScrolled()) {
    voTable.style.width = (this.innerWidth - this.scrollbarWidth) + "px";
  } else {
    voTable.style.width = this.innerWidth + "px";
  }
};
/**
 * 로딩된 아이템을 새로고침하기 위한 메소드(아이템들을 리로딩 하지 않는다는 점에서 refresh메소드와 구별됨).
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 * @ignore
 */
eXria.controls.xhtml.ListBox.prototype.repaint = function(poDocument) {
  if (poDocument == null)
    poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);
  this.removeUIGeneralDefaults(voCtrl, poDocument);
  this.removeSpecificDefaults(voCtrl, poDocument);
  this.refreshTemplate(voCtrl, poDocument);
  this.refreshUIGeneralDefaults(voCtrl, poDocument);
  this.refreshSpecificDefaults(voCtrl, poDocument);

  this.refreshSpecificAttrs(voCtrl, poDocument);

  this.loadComplete(poDocument);
};
/**
 * itemset에 아이템 추가 메소드
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ListItem
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.addToItemset = function(psName, poValue,
    poDocument) {
  var voListItem = new eXria.controls.xhtml.ListItem(psName, poValue, this);
  this.itemset.put(poValue, voListItem);
  return voListItem;
};
/**
 * frontItems혹은 backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psType 아이템 타입("front|back")
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ListItem
 * @example addItem("front", "라벨명", "value", 3);
 */
eXria.controls.xhtml.ListBox.prototype.addItem = function(psType, psName, poValue, pnIndex, poDocument) {
  var voListItem = new eXria.controls.xhtml.ListItem(psName, poValue, this);
  var voItems = null;
  if (psType == "front") voItems = this.frontItems;
  else voItems = this.backItems;

  if (pnIndex == null) {
    voItems.put(poValue, voListItem);
  } else {
    var voNewItems = new eXria.data.ArrayMap();
    var vnIndex = 0;
    var voIterator = voItems.getKeyCollection().iterator();
    var vsKey = null;
    while (voIterator.hasNext()) {
      if (vnIndex == pnIndex)
        voNewItems.put(poValue, voListItem);
      vsKey = voIterator.next();
      voNewItems.put(vsKey, voItems.get(vsKey));
      vnIndex++;
    }
    if (psType == "front")
      this.frontItems = voNewItems;
    else
      this.backItems = voNewItems;
  }

  // var voCtrl = this.getCtrl(poDocument);
  // if(voCtrl != null) {
  // voListItem.create(poDocument);
  // }

  return voListItem;
};
/**
 * frontItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ListItem
 * @example addItemFront("라벨명", "value", 3);
 */
eXria.controls.xhtml.ListBox.prototype.addItemFront = function(psName, poValue,
    pnIndex, poDocument) {
  var voItem = this.addItem("front", psName, poValue, pnIndex, poDocument);
  return voItem;
};
/**
 * backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 리스트 아이템
 * @type eXria.controls.xhtml.ListItem
 * @example addItemBack("라벨명", "value", 3);
 */
eXria.controls.xhtml.ListBox.prototype.addItemBack = function(psName, poValue,
    pnIndex, poDocument) {
  var voItem = this.addItem("back", psName, poValue, pnIndex, poDocument);
  return voItem;
};
/**
 * 지정된 인덱스에 해당하는 아이템 반환.
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @return 인덱스로 지정된 객체
 * @type eXria.controls.xhtml.ListItem
 */
eXria.controls.xhtml.ListBox.prototype.getItem = function(pnIndex) {
  var voIterator = null;
  var vnIndex = 0;
  var voItem = null;

  voIterator = this.frontItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (pnIndex == vnIndex)
      return voItem;
    vnIndex++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (pnIndex == vnIndex)
      return voItem;
    vnIndex++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (pnIndex == vnIndex)
      return voItem;
    vnIndex++;
  }

  return null;
};
/**
 * 지정된 라벨명에 해당하는 아이템을 반환하는 메소드.
 * @param {String} psName 아이템 라벨 값
 * @return 인덱스로 지정된 eXria.controls.xhtml.ListItem 객체
 * @type eXria.controls.xhtml.ListItem
 */
eXria.controls.xhtml.ListBox.prototype.getItemByName = function(psName) {
  var voItems = null;
  var voItem = null;
  var voRet = null;
  var vbBreak = false;
  var vaItems = [ this.frontItems, this.itemset, this.backItems ];
  for ( var i = 0; i < vaItems.length; i++) {
    voItems = vaItems[i].getValueCollection().iterator();
    while(voItems.hasNext()){
      voItem = voItems.next();
      if (voItem.name == psName) {
        voRet = voItem;
        vbBreak = true;
        break;
      }
    }
    if (vbBreak)
      break;
  }

  return voRet;
};

/**
 * 지정된 값을 포함한 아이템 얻어오기 위한 메소드.
 * @param {String} psId 검색할 아이디
 * @return 지정된 값을 포함한 아이템
 * @type eXria.controls.xhtml.ListItem
 */
eXria.controls.xhtml.ListBox.prototype.getItemById = function(psId) {
  var voItem = null;
  var voIterator = this.frontItems.getValueCollection().iterator();

  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return voItem;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return voItem;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return voItem;
  }
  return null;
};

/**
 * 지정된 값을 포함한 아이템 얻어오기 위한 메소드.
 * @param {String} psValue 검색할 값
 * @return 지정된 값을 포함한 아이템
 * @type eXria.controls.xhtml.ListItem
 */
eXria.controls.xhtml.ListBox.prototype.getItemByVal = function(psValue) {
  var voItem = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.value == psValue)
      return voItem;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.value == psValue)
      return voItem;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.value == psValue)
      return voItem;
  }
  return null;
};
/**
 * 아이템의 selected속성을 체크하여 컨트롤의 아이템 선택 작업 수행.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 선택된 값이 있는지 여부
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.checkSelected = function(poCtrl,
    poDocument) {
  var voCtrl = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var vaIndex = [];
  var i = -1;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    i++;
    if (voItem.visible == false)
      continue;
    if (voItem.selected == true)
      vaIndex.push(i);
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    i++;
    if (voItem.visible == false)
      continue;
    if (voItem.selected == true)
      vaIndex.push(i);
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    i++;
    if (voItem.visible == false)
      continue;
    if (voItem.selected == true)
      vaIndex.push(i);
  }
  if (vaIndex.length == 0 && this.selectedIndex != -1)
    vaIndex.push(this.selectedIndex);
  this.select(vaIndex, poCtrl, poDocument, true);

  if (vaIndex.length > 0)
    return true;
  return false;
};
/**
 * 리스트 영역의 스크롤 버튼이 표시되었는지 여부 반환.
 * @return 스크롤 버튼의 유무
 * @type Boolean
 */
eXria.controls.xhtml.ListBox.prototype.isScrolled = function() {
  var vbScrolled = false;
  var voDf = this.df;
  if (this.overflow == "scroll")
    return true;
  if (this.overflow == "hidden")
    return false;
  /*
   * var vnSize = this.getVisibleItemCount(); if(this.heightBySize) {
   * if(this.size < vnSize) vbScrolled = true; } else { var vnHeight =
   * this.itemgroup.df.height; vnHeight = vnSize * (vnHeight + this.cellSpacing) +
   * this.cellSpacing; if(this.innerHeight < vnHeight) vbScrolled = true; }
   */
  if (this.ctrl.clientHeight < this.ctrl.scrollHeight)
    vbScrolled = true;

  return vbScrolled;
};
/**
 * 리스트 아이템 제거.
 * @param {String} psName 아이템 라벨명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListBox.prototype.removeItem = function(psName, poDocument) {
  this.frontItems.remove(psName);
  this.itemset.remove(psName);
  this.backItems.remove(psName);
  var vnIndex = this.getIndex(psName);
  this.selectedItems.remove(vnIndex);
  // var voCtrl = this.getCtrl(poDocument);
  // this.refreshList(voCtrl, poDocument);
};
/**
 * 모든 리스트 아이템 제거.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListBox.prototype.removeAll = function(poDocument) {
  this.frontItems.clear();
  this.itemset.clear();
  this.backItems.clear();
  this.selectedItems.clear();
  var voCtrl = this.getCtrl(poDocument);
  this.refreshList(voCtrl, poDocument);
};
/**
 * 모든 컨트롤의 selected속성을 초기화(false값 설정).
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListBox.prototype.clearSelected = function() {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voComboItem = null;
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voComboItem = voIterator.next();
    voComboItem.selected = false;
  }
  this.selectedIndex = -1;
};

// eXria.controls.xhtml.ListBox.prototype.refreshList = function(poCtrl,
// poDocument) {
// var voDf = this.df;
// this.bScrolled = false;
// //this.selectedItems.clear();
// //this.selectedIndex = -1;
// this.oldMultiselect = this.multiSelect;
// this.oldAppearance = this.appearance;
//
// if(this.appearance == "radio") {
// this.multiSelect = false;
// this.multiSelect = false;
// }
//
// if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
// var voTable = poCtrl.childNodes[0];
// var voTbody = voTable.childNodes[0];
// this.clearCtrlNode(voTbody);
// for(var i = 0; i < voTbody.childNodes.length;) {
// voTbody.removeChild(voTbody.childNodes[i]);
// }
//
// voTable.setAttribute("cellSpacing", this.cellSpacing + "px");
//
// var vsKey = null;
// var voIterator = this.frontItems.getValueCollection().iterator();
// var voListItem = null;
// var vaIndex = new Array();
// while(voIterator.hasNext()) {
// voListItem = voIterator.next();
// if(voListItem.visible == false) continue;
// voListItem.create(poDocument);
// for(var j = 0; j < this.value.length; j++) {
// if(this.value[j] == voListItem.value) {
// voListItem.selected = true;
// break;
// }
// }
// }
// voIterator = this.itemset.getValueCollection().iterator();
// while(voIterator.hasNext()) {
// voListItem = voIterator.next();
// if(voListItem.visible == false) continue;
// voListItem.create(poDocument);
// for(var j = 0; j < this.value.length; j++) {
// if(this.value[j] == voListItem.value) {
// voListItem.selected = true;
// break;
// }
// }
// }
// voIterator = this.backItems.getValueCollection().iterator();
// while(voIterator.hasNext()) {
// voListItem = voIterator.next();
// if(voListItem.visible == false) continue;
// voListItem.create(poDocument);
// for(var j = 0; j < this.value.length; j++) {
// if(this.value[j] == voListItem.value) {
// voListItem.selected = true;
// break;
// }
// }
// }
//
// if(this.isScrolled()) this.setAttrCtrl("overflowY", "scroll", poCtrl);
// else this.setAttrCtrl("overflowY", "hidden", poCtrl);
// };
/**
 * 리스트 영역 새로 고침.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListBox.prototype.refreshList = function(poDocument) {
  this.repaint(poDocument);
};
/**
 * 리스트 영역 innerHTML 반환.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 리스트 영역 innerHTML
 * @type String
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.getListInnerHTML = function(poCtrl,
    poDocument) {
  var voDf = this.df;
  this.bScrolled = false;
  // this.selectedItems.clear();
  // this.selectedIndex = -1;
  this.oldMultiselect = this.multiSelect;
  this.oldAppearance = this.appearance;

  if (this.appearance == "radio") {
    this.multiSelect = false;
    this.multiSelect = false;
  }

  var vaStrBuf = [];
  var vsKey = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voListItem = null;
  var vaIndex = new Array();
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    vaStrBuf.push(voListItem.getInnerHTML());
    for ( var j = 0; j < this.value.length; j++) {
      if (this.value[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    vaStrBuf.push(voListItem.getInnerHTML());
    for ( var j = 0; j < this.value.length; j++) {
      if (this.value[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voListItem = voIterator.next();
    if (voListItem.visible == false)
      continue;
    vaStrBuf.push(voListItem.getInnerHTML());
    for ( var j = 0; j < this.value.length; j++) {
      if (this.value[j] == voListItem.value) {
        voListItem.selected = true;
        break;
      }
    }
  }

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * 선택된 아이템의 배경 색상 변경.
 * @param {HTMLDiv} poDiv 아이템의 실체화 객체
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.changeRowColor = function(poDiv) {
  var voTable = poDiv.childNodes[0];
  this.setAttrCtrl("backgroundColor", this.focusBackgroundColor, poDiv);
  this.setAttrCtrl("color", this.focusColor, voTable);
};
/**
 * 변경된 아이템의 색상을 원래대로 되돌림.
 * @param {HTMLDiv} poDiv 아이템의 실체화 객체
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.restoreRowColor = function(poDiv) {
  var voTable = poDiv.childNodes[0];
  if(this.backgroundColor) this.setAttrCtrl("backgroundColor", this.backgroundColor, poDiv);
  else this.setAttrCtrl("backgroundColor", "", poDiv);
  if(this.color) this.setAttrCtrl("color", this.color, voTable);
  else this.setAttrCtrl("color", "", voTable);
};

/**
 * selectEventList
 * @param event
 * @return void
 * @type void
 * @private
 **/
eXria.controls.xhtml.ListBox.prototype.selectEventList = function(event) {
  var voEvent = null;

  if (event.type == "click") {
    voEvent = new eXria.event.Event(event, this.window);
    this.selectList(voEvent);
  } else {
    voEvent = event;
    this.selectListKeyDown(voEvent);
  }
};
/**
 * 아이템 선택 시 호출된는 메소드.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.selectList = function(poEvent) {
  // var voEvent = new eXria.event.Event(e, this.window);
  poEvent.object = this.control;
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  this.unselectListItem(poEvent, poEvent.ctrlKey || poEvent.shiftKey);

  voDiv = poEvent.target;
  while (voDiv.nodeName.toUpperCase() != "DIV") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null || voDiv["id"].indexOf(this.id + "_option") == -1)
    return;

  voTr = voDiv.parentNode.parentNode;

  var vnCurrentIdx = voTr.rowIndex;
  var vnLastIdx = this.selectedIndex;
  var vnFirstIdx = this.getFirstItemIndex();

  if (this.selectedIndex != voTr.rowIndex){//선택된 아이템이 마지막에 선택되었던 아이템과 같은지 체크
    this.bRowChanged = true;
    this.doitemchange(poEvent, this);
  }
  else
    this.bRowChanged = false;

  var voItem = this.getItem(vnCurrentIdx);
  if (this.appearance != "normal")
    voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;

  if(poEvent.shiftKey && this.selectedItems.size() != 0){
    if(!this.bRowChanged)return;  //마지막에 선택한 아이템과 동일한 아이템을 선택했을 때 리턴

      this.clearSelected();
      var vnTemp = vnFirstIdx;
      var vbChk = false;

      while(vnCurrentIdx != vnTemp){
        if(vbChk){
          if(vnCurrentIdx > vnTemp)++vnTemp;
          else --vnTemp;
        }

        if (voInput != null)
          voInput.checked = true;
        if(this.selectedItems.get(vnTemp) == undefined){
          this.selectedItems.put(vnTemp, "");
        }

        this.getItem(vnTemp).selected = true;

        this.selectedIndex = vnTemp;
        this.selectedIndex = vnTemp;

        vbChk = true;
      }

      if(vnFirstIdx == vnCurrentIdx){
        if (voInput != null)
          voInput.checked = true;

        this.getItem(vnFirstIdx).selected = true;

        this.selectedIndex = vnFirstIdx;
        this.selectedIndex = vnFirstIdx;
      }
  }else{
    if (this.selectedItems.get(vnCurrentIdx) == undefined) {//이전에 선택이 안되어 있는 아이템일 경우
      if (voInput != null)
        voInput.checked = true;
      this.selectedItems.put(voTr.rowIndex, "");
      voItem.selected = true;
      this.selectedIndex = vnCurrentIdx;
      this.selectedIndex = vnCurrentIdx;

    } else {//이전에 선택이 되어 있는 아이템 선택 해제
      if (voInput != null)
        voInput.checked = false;
      this.selectedItems.remove(vnCurrentIdx);
      voItem.selected = false;
    }
  }

  this.checkSelected();
  // this.value = this.getSelectedValue(true);
  // this.data.setData(this.value);
  if (this.bRowChanged)
    this.dochange(poEvent, this);
};

/**
 * shift로 다중선택된 아이탬중 기준이 되는 처음 선택된 아이템 index 리턴
 * @return 아이템 index
 * @type Number
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.getFirstItemIndex = function(){
  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var vnIdx = null;

  if(voIterator.hasNext()){
    vnIdx = voIterator.next();

    if(vnIdx == this.selectedIndex)
      vnIdx = voIterator.collection[voIterator.collection.length-1];
  }

  return vnIdx;
};


/**
 * 기존선택 되어있던 아이템 선택 해제
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.unselectListItem = function(poEvent, pbMultiSelectKey){
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  if (this.multiSelect == false || this.appearance != "normal"
    || (this.appearance == "normal" && pbMultiSelectKey == false)
    || this.selectedItems.size() == 0) {
    var voTable = this.lookup(this.id + "_list_table");
    var vnTableLen = voTable.rows.length;

    if (this.multiSelect == false
        || (this.appearance == "normal" && pbMultiSelectKey == false)
        || this.selectedItems.size() == 0) {
      this.selectedItems.clear();
      if (this.appearance != "normal") {// 체크박스, 라디오 타입일 경우
        for ( var i = 0; i < vnTableLen; i++) {
          voDiv = voTable.rows[i].cells[0].childNodes[0];
          voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
          voInput.checked = false;
        }
      }
    }
    this.clearSelected();
    for ( var i = 0; i < vnTableLen; i++) {
      voDiv = voTable.rows[i].cells[0].childNodes[0];
      this.restoreRowColor(voDiv);
    }
  }
};

/**
 * 아이템 선택 시 호출된는 메소드.(key event)
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.selectListKeyDown = function(poEvent) {
  // var voEvent = new eXria.event.Event(e, this.window);
  poEvent.object = this.control;
  var voTr = null;
  var voDiv = null;
  var voInput = null;

  this.unselectListItem(poEvent, poEvent.shiftKey);

  voDiv = poEvent.target;
  while (voDiv.nodeName.toUpperCase() != "DIV") {
    voDiv = voDiv.parentNode;
  }
  if (voDiv == null || voDiv["id"].indexOf(this.id + "_option") == -1)
    return;

  voTr = voDiv.parentNode.parentNode;
  if (this.selectedIndex != voTr.rowIndex){
    this.bRowChanged = true;
    this.doitemchange(poEvent, this);
  }
  else
    this.bRowChanged = false;
  var voItem = this.getItem(voTr.rowIndex);
  if (this.appearance != "normal")
    voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
  if (this.selectedItems.get(voTr.rowIndex) == undefined) {
    if (voInput != null)
      voInput.checked = true;
    this.selectedItems.put(voTr.rowIndex, "");
    this.changeRowColor(voDiv);
    voItem.selected = true;

  } else {
    if (voInput != null)
      voInput.checked = false;

    if(poEvent.shiftKey == true ){
      this.getItem(this.selectedIndex).selected = false;
      this.selectedItems.remove(this.selectedIndex);
    }else{
      this.selectedItems.remove(voTr.rowIndex);
      //this.restoreRowColor(voDiv);
      voItem.selected = false;
    }
  }
  this.selectedIndex = voTr.rowIndex;
  this.selectedIndex = voTr.rowIndex;

  this.checkSelected();
  // this.value = this.getSelectedValue(true);
  // this.data.setData(this.value);
  if (this.bRowChanged)
    this.dochange(poEvent, this);
};
/**
 * 마우스 오버시 호출된는 메소드.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.mouseOver = function(e, psItemId) {
  this.eventType = "item";
  this.eventObject = this.getItemById(psItemId);

  var voDiv = null;
  var voInput = null;

  var voTable = this.lookup(this.id + "_list_table");

  var voData = null;

  for ( var i = 0; i < voTable.rows.length; i++) {
    voDiv = voTable.rows[i].cells[0].childNodes[0];

    var voCollection = this.selectedItems.getKeyCollection().iterator();
    var vbSelected = false;

    while (voCollection.hasNext()) {
      var vnIndex = voCollection.next();
      var voData = this.getItem(vnIndex);

      if (voData.id == voDiv.id)
        vbSelected = true;
    }

    if (!vbSelected) {
      this.restoreRowColor(voDiv);
    }
  }
};
/**
 * 이전에 선택된 Tr 정보 얻기
 * @param pnIndex 선택된 인덱스
 * @return void
 * @type voTr
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.getSelectedTr = function(pnIndex) {
  // 이전에 선택된 아이템 정보 얻기
  var voTable = this.lookup(this.id+"_list_table");
  var voTr = voTable.rows[pnIndex];
  return voTr;
};
/**
 * 키다운 이벤트시 호출된는 메소드.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return void
 * @type void
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.keyDown = function(e) {
  // 기존 선택된 아이템이 있어야 함
  // 선택된게 한개 일 때와 여러개 일때 화살표 키다운시 처리
  var vnKeyCode = e.keyCode;

  var voEvent = new eXria.event.Event(e, this.window);

  if (vnKeyCode == 38 || vnKeyCode == 40) {
    // 이전에 선택된 아이템 정보 얻기
    var voTr = this.getSelectedTr(this.selectedIndex);

    var voNextTarget = null;

    if (vnKeyCode == 38) { // ↑ key
      voNextTarget = voTr.previousSibling;
    } else if (vnKeyCode == 40) { // ↓ key
      voNextTarget = voTr.nextSibling;
    }

    if (voNextTarget != null) {
      voEvent.target = voNextTarget.cells[0].childNodes[0].childNodes[0].rows[0].cells[0];

      this.selectEventList(voEvent);
    }
  }
};
/**
 * 선택된 리스트 아이템의 값 반환.
 * @return 선택된 아이템의 값
 * @type String|Array(String)
 */
eXria.controls.xhtml.ListBox.prototype.getSelectedValue = function() {
  var vnIndex = null;
  var vaValue = [];

  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var voListItem = null;
  while (voIterator.hasNext()) {
    vnIndex = voIterator.next();
    voListItem = this.getItem(vnIndex);
    vaValue.push(voListItem.value);
  }

  if (vaValue.length > 1)
    return vaValue;
  else
    return vaValue[0];
};
/**
 * 선택된 리스트 아이템들을 반환.
 * @return 선택된 리스트 아이템 배열
 * @type Array
 */
eXria.controls.xhtml.ListBox.prototype.getSelectedItems = function() {
  var vnIndex = null;
  var vaItem = [];

  var voIterator = this.selectedItems.getKeyCollection().iterator();
  var voListItem = null;
  while (voIterator.hasNext()) {
    vnIndex = voIterator.next();
    voListItem = this.getItem(vnIndex);
    vaItem.push(voListItem);
  }

  return vaItem;
};
/**
 * 지정된 라벨과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스 반환.
 * @param {String} psName 아이템 라벨 명
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.ListBox.prototype.getIndex = function(psName) {
  var voIterator = this.frontItems.getKeyCollection().iterator();
  var vsKey = null;
  var i = -1;
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  voIterator = this.itemset.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  voIterator = this.backItems.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    i++;
    vsKey = voIterator.next();
    if (vsKey == psName) {
      return i;
    }
  }
  return -1;
};
/**
 * 지정된 값과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스 반환.
 * @param {String} psValue 아이템 값
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.ListBox.prototype.getIndexByVal = function(psValue) {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var i = 0;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.value == psValue)
      return i;
    i++;
  }
  return -1;
};
/**
 * 지정된 ID과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스 반환.
 * @param {String} psId 아이템 아이디
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.ListBox.prototype.getIndexById = function(psId) {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var i = 0;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return i;
    i++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return i;
    i++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    if (voItem.id == psId)
      return i;
    i++;
  }
  return -1;
};
/**
 * 지정된 index를 통해 아이템을 선택하기 위한 메소드.
 * @param {Array(Number)} paIndex 선택될 아이템들의 인덱스를 저장하는 배열
 * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @param {Boolean} pbLoad 로드시에 불려지는지의 여부. 생략가능
 * @return void
 * @type void
 * @example
 * var index = new Array(2);<br/>
 * index[0] = 1;<br/>
 * index[1] = 3;<br/>
 * page.getControl("listbox").select(index);
 */
eXria.controls.xhtml.ListBox.prototype.select = function(paIndex, poCtrl, poDocument, pbLoad) {
  if (paIndex == null || paIndex.length == 0)
    return;
  if (poCtrl == null)
    poCtrl = this.getCtrl(poDocument);
  var voTable = poCtrl.childNodes[0];
  var voDiv = null;
  var voInput = null;
  var vnIndex = null;

  // TODO : this.showList(true);

  this.selectedItems.clear();
  for ( var i = 0; i < voTable.rows.length; i++) {
    voDiv = voTable.rows[i].cells[0].childNodes[0];
    if (this.appearance != "normal") {
      voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
      voInput.checked = false;
    }
    this.restoreRowColor(voDiv);
  }

  var vbSelected = false;
  for ( var i = 0; i < paIndex.length; i++) {
    vnIndex = paIndex[i];
    if (vnIndex == this.selectedIndex)
      vbSelected = true;
    voDiv = voTable.rows[vnIndex].cells[0].childNodes[0];
    this.selectedItems.put(vnIndex, "");
    if (this.appearance == "normal") {
      this.changeRowColor(voDiv);
    } else {
      voInput = voDiv.childNodes[0].rows[0].cells[0].firstChild;
      voInput.checked = true;
    }
    if (this.multiSelect == false)
      break;
  }
  if (voDiv != null && this.appearance != "normal")
    this.changeRowColor(voDiv);
  if (vbSelected == false) {
    // this.selectedIndex = vnIndex; //ctrl 키보드클릭시 오류때문에 주석처리 2009-03-26 hajubal
    // this.df.selectedIndex = vnIndex;
  }
  var vsSelectedValue = this.getSelectedValue();
  if(this.getItemByVal(vsSelectedValue) && pbLoad != true){
    if(this.getItemByVal(this.value) != this.getItemByVal(vsSelectedValue)) this.doitemchange(null, this);
  }

  var vsOldVal = this.value;
  if(vsOldVal instanceof Array) vsOldVal = vsOldVal.join();
  var vsNewVal = vsSelectedValue;
  if(vsNewVal instanceof Array) vsNewVal = vsNewVal.join();
  if(vsOldVal != vsNewVal) {
    this.value = vsSelectedValue;
    if(pbLoad != true) this.data.setData(this.value);
  }
};
/**
 * 컨트롤에 값을 설정.
 * @param {String|Array(String)} psValue 설정될 값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @return void
 * @type void
 */
eXria.controls.xhtml.ListBox.prototype.setValue = function(psValue, poDocument) {
  var voDf = this.df;
  var vaValue = [];
  this.selectedIndex = -1;
  if(this.getItemByVal(psValue)){
    if(this.getItemByVal(this.value) != this.getItemByVal(psValue)) this.doitemchange(null, this);
  }
  if (psValue instanceof Array) {
    vaValue = psValue
  } else {
    if (psValue != null)
      vaValue.push(psValue);
  }
  this.value = vaValue;
  this.data.setData(psValue);
  this.reloadData(null, poDocument);
};
/**
 * 컨트롤에 설정된 값을 반환.
 * @return 컨트롤 value 속성 값
 * @type String
 */
eXria.controls.xhtml.ListBox.prototype.getValue = function() {
  // var voDiv = voTable.rows[pnIndex].cells[0].childNodes[0];
  // var vsKey = voDiv.childNodes[0].rows[0].cells[0].lastChild.data;
  // var voValue = this.frontItems.get(vsKey) || this.itemset.get(vsKey) ||
  // this.backItems.get(vsKey);
  return this.value;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 해당 속성명의 디폴트 속성 값
 * @type String
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.getSpecificDefaultValue = function(
    psAttrName) {
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if (vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.ListBox[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.ListBox[vaAttrName[0]][vaAttrName[1]];
  }
  if (vsDefaultValue === undefined) {
    // alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 보여지는 아이템 개수를 반환
 * @return 보여지는 아이템 개수
 * @type Number
 * @private
 */
eXria.controls.xhtml.ListBox.prototype.getVisibleItemCount = function() {
  var vnCnt = 0;
  var voIterator = null;
  var voItem = null;
  voIterator = this.frontItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    if (voItem.visible == false)
      continue;
    vnCnt++;
  }
  return vnCnt;
};

//Ctrl을 제거.
//@param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.

// eXria.controls.xhtml.ListBox.prototype.clearCtrl = function(poDocument) {
// this.clearEvents(poDocument);
// var voCtrl = this.getCtrl(poDocument);
// var vsId = this.id;
// var voTable = this.lookup(vsId + "_listarea_table");
// var voTr = null;
// for(var i = 0; i < voTable.rows.length; i++) {
// voTr = voTable.rows[i];
// voTr.onclick = null;
// }
//
// if (voCtrl != null) {
// if(voCtrl.parentNode) voCtrl.parentNode.removeChild(voCtrl);
// }
// };
/**
 * 클래스 명을 반환.
 * @return "ListBox"
 * @type String
 */
eXria.controls.xhtml.ListBox.prototype.toString = function() {
  return "ListBox";
};

/**
 * @fileoverview
 * Concreate xhtml Object(XHTML Object 컨트롤)
 * @author 이종녕
 */

/**
 * @class images, audio, videos, Java applets, ActiveX, <br />
 * PDF, flash 등의 객체를 포함하는 컨트롤을 생성하는 class입니다.<br />
 * XHTML Object Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Object 객체
 * @type eXria.controls.xhtml.Object
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Object = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 300 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);

  //////////////////////////////////////////////////////////////////
  //  속성
  /**
   * 여백 문자로 분리된 URI들의 목록.
   * @type String
   */
  this.archive = null;
  /**
   * 오브젝트 클래스 아이디.
   * @type String
   */
  this.classid = null;
  /**
   * classid, data, archive의 기준 URI.
   * @type String
   */
  this.codebase = null;
  /**
   * 오브젝트  데이터 참조.
   * @type String
   */
  this.dataUrl = null;
  /**
   * 선언되나 즉시화가 되지 않음.
   * @type String
   */
  this.declare = null;
  /**
   * 로딩 중 보이는 메세지.
   * @type String
   */
  this.standby = null;
  /**
   * 데이터 컨텐트 타입.
   * @type String
   */
  this.type = null;
  /**
   * 코드(code) 컨텐트 타입.
   * @type String
   */
  this.codetype = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 파라미터의 리스트.
   * @type eXria.data.ArrayMap
   */
  this.params = new eXria.data.ArrayMap();
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Object);
/////////////////////////////////////////////////////////////////////////////////
///  메소드

/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.template = [];
  this.document = poDocument;
  this.ctrl = voCtrl;
  var vaTemplate = this.template;

  vaTemplate.push("<object id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_object' ");
  vaTemplate.push("@attrStrBuf");   //3
  vaTemplate.push(" style='");
  vaTemplate.push("position:absolute;padding:0px;margin:0px;border-style:none;");
  vaTemplate.push("border-width:0px;top:0px;left:0px;");
  vaTemplate.push("@cssStrBuf");    //7
  vaTemplate.push("'>");

  //if(navigator.appName != "Microsoft Internet Explorer") {
  //  vaTemplate.push("Sorry, if this text is displayed, your browser does not support Type and Error!!");
  //}

  return voCtrl;
};

/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);

  vaTemplate.push("<object class='" + vsClass + "' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_object' ");
  vaTemplate.push("@attrStrBuf");   //3
  vaTemplate.push(" style='");
  vaTemplate.push("position:absolute;padding:0px;margin:0px;border-style:none;");
  vaTemplate.push("border-width:0px;top:0px;left:0px;");
  vaTemplate.push("@cssStrBuf");    //7
  vaTemplate.push("'>");
  vaTemplate.push("@attrStrBuf");   //9

//  vaTemplate.push(this.getParamTemplate("wmode","transparent"));
//  vaTemplate.push(this.getParamTemplate("AutoSize","true"));
//  vaTemplate.push(this.getParamTemplate("autostart","true"));
//  vaTemplate.push(this.getParamTemplate("controller","true"));
};

/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.getInnerHTML = function(){
  var vaTemplate = [];
  if(this.params.get("wmode") == null) vaTemplate.push(this.getParamTemplate("wmode","transparent"));
  if(this.params.get("AutoSize") == null) vaTemplate.push(this.getParamTemplate("AutoSize","true"));
  if(this.params.get("autostart") == null) vaTemplate.push(this.getParamTemplate("autostart","true"));
  if(this.params.get("controller") == null) vaTemplate.push(this.getParamTemplate("controller","true"));

  var voIterator = this.params.getKeyCollection().iterator();
  var vsParamValue = null;
  var vsParamName = null;
  while (voIterator.hasNext()) {
    vsParamName = voIterator.next();
    vsParamValue = this.params.get(vsParamName);
    vaTemplate.push(this.getParamTemplate(vsParamName, vsParamValue));
  }

  return vaTemplate.join("");
}
/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.setSpecificDefaults = function(poCtrl,poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.archive = this.getAttrValue("archive",this.archive);
  this.classid = this.getAttrValue("classid",this.classid);
  this.codebase = this.getAttrValue("codebase",this.codebase);
  this.dataUrl = this.getAttrValue("dataUrl",this.dataUrl);
  this.declare = this.getAttrValue("declare",this.declare);
  this.standby = this.getAttrValue("standby",this.standby);
  this.type = this.getAttrValue("type",this.type);
  this.codetype =  this.getAttrValue("codetype",this.codetype);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.setSpecificAttrs = function(poCtrl,poDocument) {
  var voBtn = poCtrl.childNodes[0];
  //var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
//  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttrStrBuf = [];
  if(this.classid && this.canvas.page.metadata.browser.ie > 0) vfcSetAttStrBuf(vaAttrStrBuf, "classid", this.classid);
  vfcSetAttStrBuf(vaAttrStrBuf, "type", this.type);
  vfcSetAttStrBuf(vaAttrStrBuf, "codeBase", this.codebase);
  vfcSetAttStrBuf(vaAttrStrBuf, "codeType", this.codetype);
  vfcSetAttStrBuf(vaAttrStrBuf, "data", this.dataUrl);
  vfcSetAttStrBuf(vaAttrStrBuf, "archive", this.archive);
  vfcSetAttStrBuf(vaAttrStrBuf, "declare", this.declare);
  vfcSetAttStrBuf(vaAttrStrBuf, "standby", this.standby);
  vfcSetAttStrBuf(vaAttrStrBuf, "usemap", this.usemap);
  vaTemplate[3] = vaAttrStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vaTemplate[7] = vaCssStrBuf.join("");

  vaTemplate[9] = this.getInnerHTML();

  vaTemplate.push(this.getParamTemplate("FileName", this.dataUrl));
  vaTemplate.push(this.getParamTemplate("src", this.dataUrl));
  vaTemplate.push(this.getParamTemplate("movie", this.dataUrl));

  vaTemplate.push("</object>");
  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Object.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voObject = this.getSubCtrl("object",poCtrl);
  switch(psAttrName) {
    case "width" :
      this.setAttrCtrl("width", this.innerWidth, voObject);
      break;
    case "height" :
      this.setAttrCtrl("height", this.innerHeight, voObject);
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.setSpecificEvents = null;
/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Object.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl();
  var voObject = this.getSubCtrl("object");
  //var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "outerClassName":
  case "className":
    this.refresh(poDocument);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderTopHeight" :
    this.innerHeight = this.width - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderStyle" :
  case "borderColor" :
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  default:
    this.refresh(poDocument);
    break;
  }
};
/**
 * 파라미터를 설정합니다.
 * @param {String} psName 새로운 값이 설정될 파라미터 명
 * @param {String} psValue 설정될 새로운 파라미터 값
 */
eXria.controls.xhtml.Object.prototype.setParam = function(psName, psValue) {
  var vsParamName = this.params.get(psName);
  if (!vsParamName) {
    this.params.put(psName, psValue);
  } else {
    this.params.remove(psName);
    this.params.put(psName, psValue);
  }
};

/**
 * 새로운 파라미터를 추가합니다.
 * @param {String} psName 추가될 파라미터 명
 * @param {String} psValue 추가될 파라미터 값
 * @param {HTMLObject} poCtrl 실체화 컨트롤. 생략가능.
 */
eXria.controls.xhtml.Object.prototype.createParam = function(psName, psValue, poCtrl) {
  if (psName == null || psValue == null) {
    //  ERROR 처리   alert("정확한 값을 입력해주세요...");
    return false;
  }
  var voCtrl = this.getCtrl();
  if(poCtrl == null || poCtrl == "undefined")  poCtrl = this.getSubCtrl("object",voCtrl);
  var voParam = this.document.createElement("param");
  voParam.setAttribute("id", this.id + "_" + psName);
  voParam.setAttribute("name",psName);
  voParam.setAttribute("value",psValue);
  poCtrl.appendChild(voParam);
};
/**
 * 파라미터 HTML 코드를 반환합니다.
 * @param {String} psName 추가될 파라미터 명
 * @param {String} psValue 추가될 파라미터 값
 * @return HTML코드
 * @type String
 * @private
 */
eXria.controls.xhtml.Object.prototype.getParamTemplate = function(psName, psValue) {
  if (psName == null || psValue == null) {
    //  ERROR 처리   alert("정확한 값을 입력해주세요...");
    return;
  }
  return "<param id='" + this.id + "_" + psName + "' name='" + psName + "' value='" + psValue + "'/>";
};
///**
// * Embed 객체 생성 메소드.
// * @param {String} psSrc Embed src경로
// * @param {HTMLDiv} poCtrl 실체화 컨트롤
// */
//eXria.controls.xhtml.Object.prototype.createEmbed = function(poCtrl) {
//  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(this.document); }
//  if (psSrc == null || psType == null) {
//    alert("정확한 값을 입력해주세요...");
//    return false;
//  }
//  var voEmbed = this.document.createElement("embed");
//  voEmbed.setAttribute("src",psSrc);
//  voEmbed.setAttribute("pluginspage","http://www.macromedia.com/go/getflashplayer");
//  voEmbed.setAttribute("top",this.top);
//  voEmbed.setAttribute("left",this.left);
//  voEmbed.setAttribute("width",this.width);
//  voEmbed.setAttribute("height",this.height);
//  voEmbed.setAttribute("type",psType);
//  poCtrl.appendChild(voEmbed);
//};
/**
*  실체화 Object 객체를 반환합니다.
* @return 실체화 Object 객체
* @type HTMLObject
*/
eXria.controls.xhtml.Object.prototype.getObject = function(){
  var voCtrl = this.getCtrl();
  var voObject = voCtrl.getElementsByTagName("object")[0];
  // firefox에서 object가 exria plugin인지를 체크하여 plugin인 접근 object를 반환하도록 처리
  if(this.canvas.page.metadata.browser.gecko > 0) {
    var vsType = this.type;
    if(vsType == null) vsType = "";
    if(vsType.indexOf("application/npETBClient") != -1) voObject = voObject.nsIETBClientFox;
  }
  return voObject;
}
/**
* 서브 컨트롤 실체화 객체를 반환합니다.
* @param {String} psTagName
* @return 서브 컨트롤 실체화 객체
* @type HTMLObject
* @private
*/
eXria.controls.xhtml.Object.prototype.getSubCtrl = function(psTagName,poCtrl,poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};
/**
 * getCtrlClassName
 * @param {String} psClassName 참조 대상 클래스명
 * @param {String} psOuterClassName
 * @return vsClassName
 * @type String
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.getCtrlClassName = function(psClassName, psOuterClassName) {
  var vsClassName = "";
  if(psClassName == null) psClassName = "";
  if(psOuterClassName == null) psOuterClassName = "";
  vsClassName = psClassName + " " + psOuterClassName;
  vsClassName = eXria.util.StringUtil.trim(vsClassName);

  return vsClassName;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Object.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Object[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};

/**
 * 클래스 명을 반환합니다.
 * @return "Object"
 * @type String
 */
eXria.controls.xhtml.Object.prototype.toString = function() {
  return "Object";
};

/**
 * @fileoverview
 * Concreate xhtml Output(XHTML Output 컨트롤)
 * @author 이종녕
 */

/**
 * @class 텍스트필드를 화면상에 보여주는 컨트롤을 생성하는 class입니다. <br />
 * eXria.controls.xhtml.Label과 비슷하지만 포멧을 가진다는점이 다릅니다.<br />
 * XHTML Output Control.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Output 객체
 * @type eXria.controls.xhtml.Output
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Output = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 초기값을 null로 지정 시에 IE에서 null 자체가 문자로 표시됨.
   * @type String
   */
  this.value = null;
  /**
   * format을 지정하면 형식대로 출력된다 .. ex> ##-#,xx년xx월   #-숫자 , x-문자.
   * @type String
   */
  this.format = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 글꼴 사이의 간격 ex> 0.5em
   * @type Number
   */
  this.letterSpacing = null;
  /**
   * 줄 간격 ex> 14pt
   * @type Number
   */
  this.lineHeight = null;
  /**
   * 폰트에 밑줄 넣기.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * #,x 가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noMaskVal = /[^\#x]/g;
  /**
   * 숫자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noDigits = /[^\d]/gi;
  /**
   * 문자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noString = /[^A-Za-z]/g;
  /**
   * 공백 문자 정규식 표현.
   * @type String
   * @private
   */
  this.blank = /\s/g;
  /**
   * 컨트롤의 안쪽 여백(단위 px).
   * @type Number
   * @private
   */
  this.padding = null;
  /**
   * 컨트롤의 안쪽 상단여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 안쪽 우측여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 안쪽 하단여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 안쪽 좌측여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingLeft = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};

  this.cursor = null;
  /**
   * format 형태 분류 문자열("string"/"number"/"date");
   * @type String
   */
  this.formatType = null;
  /**
   * @private
   */
  this.editMask = new eXria.controls.xhtml.EditMask();
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Output);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["accesskey"] = this.accessKey;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;

  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<div id='" + this.id + "_label' class='" + vsClass + "' style=\"");
  vaTemplate.push("@cssStrBuf"); //0
  vaTemplate.push("\">");
  vaTemplate.push("@innStrBuf"); //1
  vaTemplate.push("</div>");
//  vaTemplate.push("<span style=\"position:absolute;visibility:hidden;");
//  vaTemplate.push("@cssStrBuf"); //2
//  vaTemplate.push("\"/>")

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.verticalAlign = this.getAttrValue("verticalAlign",this.verticalAlign);
  this.value = this.getAttrValue("value",this.value);
  this.formatType = this.getAttrValue("formatType", this.formatType);
  this.format = this.getAttrValue("format", this.format);
  if(this.formatType == "date") {
    if(this.regFormat == null || this.regFormat == "") {
      this.regFormat = "yyyy-MM-dd";
    }
  }
};



/**
* @ignore
*/
eXria.controls.xhtml.Output.prototype.setSpecificAttrs = function(poCtrl, poDocument){
var voDf = this.df;
var vaCssStrBuf = null;
var vaAttStrBuf = null;
var vaTemplate = this.template;
// 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
// 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
var vfcSetCssStrBuf = this.setCssStrBuf;
var vfcSetAttStrBuf = this.setAttStrBuf;
var voIndexMap = this.templateIndexMap;

poCtrl["tabIndex"] = this.tabIndex;
poCtrl["tooltip"] = this.tooltip;
if(this.disabled) poCtrl["disabled"] = true;

vaCssStrBuf = [];
vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
if(this.visible == false) vaCssStrBuf.push("display:none;");
else vaCssStrBuf.push("display:block;");
vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
poCtrl.style.cssText = vaCssStrBuf.join("");

vaCssStrBuf = [];
vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;");
vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight,"px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - this.paddingLeft - this.paddingRight), "px");
vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
vfcSetCssStrBuf(vaCssStrBuf, "letter-spacing", this.letterSpacing, "px");
vfcSetCssStrBuf(vaCssStrBuf, "line-height", this.lineHeight, "px");
vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");
var vsValue = this.value;
if(vsValue != null && vsValue != ""){
  switch(this.formatType) {
  case "number":
    break;
  case "date":
    vsValue = this.getDate(vsValue).getTime();
    break;
  case "string":
    break;
  }
  vsValue = TGP.GetString(vsValue, this.formatType, this.regFormat);
} else {
  vsValue = "";
}
vaTemplate[voIndexMap.get(1)] = vsValue;

poCtrl.innerHTML = vaTemplate.join("");
voIndexMap.clear();
vaCssStrBuf = null;
vaAttStrBuf = null;
vaTemplate = null;
this.template = null;

this.setSubElement(poDocument);
};

/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Output.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.div = this.getSubCtrl("div", voCtrl, poDocument);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Output.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  switch(psAttrName) {
  case "width" :
    var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
    if(vnWidth < 0) vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voDiv);
    break;
  case "height" :
    this.setVerticalAlign(voDiv, poCtrl, this.verticalAlign);
    break;
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Output.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
var voDf = this.df;
var voDivCtrl = this.subElement.div;
var vaCssStrBuf = null;
var vfcSetCssStrBuf = this.setCssStrBuf;

this.setDetailBorder(this);

poCtrl["tabIndex"] = this.tabIndex;
poCtrl["tooltip"] = this.tooltip;
if(this.disabled) poCtrl["disabled"] = true;

vaCssStrBuf = [];
vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
if(this.visible == false) vaCssStrBuf.push("display:none;");
else vaCssStrBuf.push("display:block;");
vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
poCtrl.style.cssText = vaCssStrBuf.join("");

vaCssStrBuf = [];
vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;");
vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight,"px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - this.paddingLeft - this.paddingRight), "px");
vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
vfcSetCssStrBuf(vaCssStrBuf, "letter-spacing", this.letterSpacing, "px");
vfcSetCssStrBuf(vaCssStrBuf, "line-height", this.lineHeight, "px");
vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
voDivCtrl.style.cssText = vaCssStrBuf.join("");

var vsValue = this.value;
if(vsValue != null && vsValue.length != 0) {
  switch(this.formatType) {
  case "number":
    break;
  case "date":
    vsValue = this.getDate(vsValue).getTime();
    break;
  case "string":
    break;
  }
  vsValue = TGP.GetString(vsValue, this.formatType, this.regFormat);
} else {
  vsValue = "";
}
voDivCtrl.innerHTML = vsValue;
};

/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Output.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  var voDf = this.df;
  var vaAttrName = psAttrName.split(".");

  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }

  switch(psAttrName) {
    case "visible" :
      this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "disabled" :
      this.setDisable(voCtrl, psAttrValue);
      break;
    case "left" :
    case "top" :
      voCtrl.style[psAttrName] = psAttrValue + "px";
      break;
    case "width" :
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      break;
    case "height" :
      this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      break;
    case "borderWidth" :
      this.borderLeftWidth = this.borderWidth;
      this.borderRightWidth = this.borderWidth;
      this.borderTopWidth = this.borderWidth;
      this.borderBottomWidth = this.borderWidth;
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
      this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
      this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
      this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      break;
   case "borderLeftWidth" :
   case "borderRightWidth" :
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
      break;
   case "borderTopWidth" :
   case "borderBottomWidth" :
      this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
      break;
   case "padding" :
      this.paddingTop = this.padding;
      this.paddingRight = this.padding;
      this.paddingBottom = this.padding;
      this.paddingLeft = this.padding;
      this.setAttrCtrl("paddingTop", this.paddingTop + "px", voDiv);
      this.setAttrCtrl("paddingRight", this.paddingRight + "px", voDiv);
      this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voDiv);
      this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voDiv);
      var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
      if(vnWidth < 0) vnWidth = 0;
      this.setAttrCtrl("width", vnWidth, voDiv);
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "paddingTop" :
    case "paddingBottom" :
      this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "paddingLeft" :
    case "paddingRight" :
      this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voDiv);
      var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
      if(vnWidth < 0) vnWidth = 0;
      this.setAttrCtrl("width", vnWidth, voDiv);
      break;
    case "textAlign":
      this.setAttrCtrl(psAttrName, psAttrValue, voDiv);
      break;
    case "fontFamily" :
    case "fontSize" :
    case "fontStyle" :
    case "fontWeight" :
    case "textDecoration":
      this.setAttrCtrl(psAttrName, psAttrValue, voDiv);
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "letterSpacing" :
    case "lineHeight":
      this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "verticalAlign" :
      this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
      break;
    case "formatType" :
      break;
    case "format" :
      if(this.formatType == "date") {
        if(this.format == null || this.format == "") this.format = "yyyyMMdd";
      }
      this.setValue(this.value);
//      this.applyFormat(psAttrValue, voDiv);
      break;
    case "value" :
      this.setValue(psAttrValue);
      break;
    case "outerClassName" :
    case "className" :
      this.refresh(poDocument);
      break;
    default :
      this.refresh(poDocument);
      break;
  }
};

/**
* @ignore
*/
eXria.controls.xhtml.Output.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  this.setValue(vsRefData);
};


/**
 * loadComplete
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Output.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  this.setVerticalAlign(voDiv, voCtrl, this.df.verticalAlign);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument);
};


/**
 * 컨트롤에 값을 설정해 줍니다.
 * @param {String} psValue 설정값
 */
eXria.controls.xhtml.Output.prototype.setValue = function(psData) {
var voDiv = this.subElement.div;
var vbChanged = false;
if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
  vbChanged = true;
}
this.onchangeInitValue = psData;
this.value = psData;
if(vbChanged) this.data.setData(this.value);
if(psData != null && psData != "") {
  switch(this.formatType) {
  case "number":
    break;
  case "date":
    psData = this.getDate(psData).getTime();
    break;
  case "string":
    break;
  }
  psData = TGP.GetString(psData, this.formatType, this.regFormat);
} else {
  psData = "";
}
this.setText(voDiv, psData);
this.refreshVerticalAlign();
};
/**
 * 컨트롤에 설정된 값을 반환합니다.
 * @return 컨트롤 value 속성 값
 * @type String
 */
eXria.controls.xhtml.Output.prototype.getValue = function() {
  return this.value;
};
/**
 * 컨트롤 설정 값에 출력 포맷을 지정해 줍니다.
 * @param {String} psFormat 포맷 문자열
 * @param {HTMLTd} poCtrl 출력 포맷이 적용될 실체화 객체
 * @return 작업수행 성공 여부
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.Output.prototype.applyFormat = function(psFormat, poCtrl){
  // 개체의 값 얻어오기
  var vsValue = this.value;
  var regVal = psFormat;
  //if(regVal == null) return null;
  vsValue = eXria.controls.xhtml.Util.parseLang(vsValue);
  //공백제거...
//  vsValue = vsValue.replace(this.blank,"");
  //데이터를 포맷형식으로 바꿈..
  if(regVal != null){
//    var vsFormat = vsValue.replace(this.blank,"");
//    vsFormat = vsFormat.replace(this.noDigits,"x");
//    vsFormat = vsFormat.replace(this.noString,"#");
//    //포맷 형식...
//    var vsCheck = regVal.replace(this.noMaskVal,"");
//    //데이터 포맷과 실제값이 형식이 일치 하지 않으면 반환...
//    if( vsCheck != vsFormat){
//      this.df.value = null;
//      this.value = null;
//      this.subElement.div.innerHTML = "";
//      alert(this.toString()+": 출력형식과 실제 데이터 값이  같지 않습니다.");
//      return false;
//    }
      if(/(YYYY)|(MM)|(DD)/g.test(regVal)) {
        this.formatType = "date";
        var vsYear = vsValue.substring(0, 4);
        var vsMonth = vsValue.substring(4, 6);
        var vsDate = vsValue.substring(6, 8);

        regVal = regVal.replace(/YYYY/, vsYear);
        regVal = regVal.replace(/MM/, vsMonth);
        regVal = regVal.replace(/DD/, vsDate);
      } else if(/x/.test(regVal) == false){
        var voEditMask = this.editMask;
        voEditMask.mask = regVal;
        regVal = voEditMask.setNumber(vsValue, true);
      } else {
        for(var i=0;i < vsValue.length;i++) {
          regVal = regVal.replace(/[#x]/i, vsValue.charAt(i));
        }
      }
  }else regVal = vsValue;
  this.setText(poCtrl, regVal);
  return true;
};
/**
 * refreshVerticalAlign
 * 컨트롤 텍스트 수직정렬을 새로고침 합니다.
 */
eXria.controls.xhtml.Output.prototype.refreshVerticalAlign = function() {
  var voCtrl = this.ctrl;
  if(voCtrl == null) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
};
/**
 * 각 속성에 따른 디폴트 값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Output[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Output.prototype.setSpecificEvents = function(poCtrl) {
  var voDiv = this.subElement.div;
  this.eventManager.addListener(voDiv, "onblur", this.mediateEvent);
  this.eventManager.addListener(voDiv, "onfocus", this.mediateEvent);
  voDiv.control = this;
};
/**
 * 클래스 명을 반환합니다.
 * @return "Output"
 * @type String
 */
eXria.controls.xhtml.Output.prototype.toString = function() {
  return "Output";
};

/**
 * @fileoverview
 * Concreate xhtml Print(XHTML 컨트롤의 프린트 담당 클래스)
 * @author 조영진
 */

/**
 * @class Concreate xhtml Print.<br>
 * XHTML 컨트롤의 프린트 담당 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.UIControl} poControl 프린트 대상 컨트롤 객체
 * @return 새로운 eXria.controls.xhtml.Print 객체
 * @type eXria.controls.xhtml.Print
 * @constructor
 * @private
 */
eXria.controls.xhtml.Print = function(poControl) {
  /**
   * 프린트 시 적용될 css파일명.
   * @type String
   */
  this.css = null;
  /**
   * 반복되는 프린트 출력 요소간의 상하 여백.
   * @type Number
   */
  this.formSpacing = null;
  /**
   * 출력용지와 출력물간의 상단 여백.
   * @type Number
   */
  this.marginTop = null;
  /**
   * 출력용지와 출력물간의 우측 여백.
   * @type Number
   */
  this.marginRight = null;
  /**
   * 출력용지와 출력물간의 하단 여백.
   * @type Number
   */
  this.marginBottom = null;
  /**
   * 출력용지와 출력물간의 좌측 여백.
   * @type Number
   */
  this.marginLeft = null;
  /**
   * 프린트 대상 컨트롤 객체.
   * @private
   */
  this.control = poControl;
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 용지의 가로길이(A4, 72dpi기준).
   * @type Number
   * @private
   */
  this.pageWidth = Math.floor(210 * 72 / 25.4);
  /**
   * 용지의 세로길이(A4, 72dpi기준).
   * @type Number
   * @private
   */
  this.pageHeight = Math.floor(297 * 72 / 25.4);
  /**
   * 리포트 헤더.<br>
   * 전체 출력물에서의 겉 페이지 내용을 담당하는 오브젝트.
   * @type eXria.controls.xhtml.HeaderFooter
   */
  this.reportHeader = null;
  /**
   * 리포트 footer.<br>
   * 전체 출력물에서의 마무리 페이지 내용을 담당하는 오브젝트.
   * @type eXria.controls.xhtml.HeaderFooter
   */
  this.reportFooter = null;
  /**
   * 페이지 헤더.<br>
   * 출력물의 각 페이지에서 머리말 부분 담당하는 오브젝트.
   * @type eXria.controls.xhtml.HeaderFooter
   */
  this.pageHeader = null;
  /**
   * 페이지 footer.<br>
   * 출력물의 각 페이지에서 꼬리말 부분 담당하는 오브젝트.
   * @type eXria.controls.xhtml.HeaderFooter
   */
  this.pageFooter = null;
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(poControl);
};
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 프린트 오브젝트 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.Print.prototype.create = function(poDocument) {
  this.document = poDocument;

  this.setDefault(poDocument);
  this.setAttr(poDocument);

  this.document = poDocument;
};
/**
 * 디폴트 속성 설정
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Print.prototype.setDefault = function(poDocument) {
  //xhtml.UIControls의 this.setUIGeneralDefault에 border설정부분이 있어 초기화 필요
  this.df = {};
  var voDf = this.df;
  voDf.css = this.getAttrValue("css", this.css);
  voDf.marginLeft = this.getAttrValue("marginLeft", this.marginLeft);
  voDf.marginTop = this.getAttrValue("marginTop", this.marginTop);
  voDf.marginRight = this.getAttrValue("marginRight", this.marginRight);
  voDf.marginBottom = this.getAttrValue("marginBottom", this.marginBottom);
  voDf.formSpacing = this.getAttrValue("formSpacing", this.formSpacing);

};
/**
 * 속성 설정
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Print.prototype.setAttr = function(poDocument) {

};
/**
 * 디폴트 속성값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 디폴트 속성값
 * @type String|Number
 * @private
 */
eXria.controls.xhtml.Print.prototype.getAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) {
    return psAttrValue;
  } else {
    var vsAttrValue = this.getSpecificDefaultValue(psAttrName);
    return vsAttrValue;
  }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 */
eXria.controls.xhtml.Print.prototype.getSpecificDefaultValue = function(psAttr) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Print[psAttrName];
  if(vsDefaultValue === undefined) {
    return null;
  }
  return vsDefaultValue;
};
/**
 * 반복 요소를 프린트 창에 디스플레이하는 메소드.<br>
 * this.control의 printForm 메소드에 의해 호출됨
 * @private
 */
eXria.controls.xhtml.Print.prototype.repeatForm = function() {
  if(this.control.getCtrl(this.document)) return;

  var voDf = this.df;
  var voControl = this.control;
  var vnLoop = 0;
  var vsDataSetId = voControl.datasetId;
  if(vsDataSetId) {
    var voDataSet = voControl.canvas.page.model.getDataSet(vsDataSetId);
    if(voDataSet == null) return;
    vnLoop = voDataSet.getRowCnt();
  } else {
    var voCollectionNode = this.data.getNodesetData2();
    if(voCollectionNode == null) return;
    vnLoop = voCollectionNode.getLength();
  }
  var vsId = voControl.id;
  var vnTop = voControl.top;
  var vnLeft = voControl.left;
  var vsPosition = voControl.position;

  var vnContentWidth = this.pageWidth - voDf.marginLeft - voDf.marginRight;
  var vnContentHeight = this.pageHeight - voDf.marginTop - voDf.marginBottom;
  if(this.pageHeader) {
    vnContentHeight -= this.pageHeader.df.height + voDf.formSpacing;
  }
  if(this.pageFooter) {
    vnContentHeight -= this.pageFooter.df.height + voDf.formSpacing;
  }

  voControl.left = this.marginLeft;
  voControl.position = "relative";

  var voCtrl = null;
  var vnHeight = 0;
  var vbNewPage = true;
  var pnPageNum = 1;
  var voDiv = null;
  var vnTmpTop = null;

  for(var i = 0; i < vnLoop; i++) {
    if(vbNewPage) {
      voDiv = this.document.createElement("div");
    var voStyle = voDiv.style;
      voStyle.position = "relative";
      voStyle.margin = "0px";
      voStyle.padding = "0px";
      voStyle.borderWidth = "0px";
      voStyle.width = this.pageWidth + "px";
      voStyle.height = this.pageHeight + "px";
      voStyle.overflow = "hidden"; // 중요설정 사항. 누락 시 IE이외 브라우저에서 pageBreak가 제대로 동작 안함.
      voStyle.pageBreakAfter = "always";
      this.document.body.appendChild(voDiv);
      vnHeight = 0;
      vnTmpTop = this.marginTop;
    }

    if(vbNewPage && this.pageHeader) {
      if(this.pageHeader.data) {
        if(this.pageHeader.nodesetInstancePath) {
          var voMapNode = this.pageHeader.data.getNodesetData2(i);
          this.pageHeader.setData(voMapNode.get("value"));
        } else {
          var psValue = this.pageHeader.data.getData();
          this.pageHeader.setData(psValue);
        }
      }
      this.pageHeader.pageNum = pnPageNum;
      voDiv.appendChild(this.pageHeader.create(this.document));
      vnTmpTop += this.formSpacing;
    }
    voControl.id = vsId + "_" + i;
    voControl.top = vnTmpTop;
//    var voCtrl = voControl.create(this.document);
//    voDiv.appendChild(voCtrl);
    var vsIdSuffix = "_" + i;
//    if(voControl.createChildren) {
//      voControl.createChildren(this.document, vsIdSuffix);
//      this.setChildrenData(i, vsIdSuffix, this.document);
//    } else {
//      this.setData(i, this.document);
//    }
    if(voControl.createChildren) {
      voControl.idSuffix = vsIdSuffix;
    }
    voControl.rowIndex = i + 1;
    voCtrl = voControl.create(this.document);
    voDiv.appendChild(voCtrl);
    vnTmpTop += voDf.formSpacing;
    vnHeight += voControl.height + voDf.formSpacing;
    if(vnContentHeight - vnHeight < voControl.height + voDf.formSpacing) {
      if(this.pageFooter) {
        vnTmpTop += vnContentHeight - vnHeight;
        this.pageFooter.df.top = vnTmpTop;
        this.pageFooter.pageNum = pnPageNum++;
        voCtrl = this.pageFooter.create(this.document);
        voDiv.appendChild(voCtrl);
      }
      vbNewPage = true;
    } else {
      vbNewPage = false;
    }

  }
  voControl.top = vnTop;
  voControl.left = vnLeft;
  voControl.id = vsId;
  voControl.position = vsPosition;

  if(!vbNewPage && this.pageFooter) {
    vnTmpTop += vnContentHeight - vnHeight;
    alert(vnContentHeight);
    this.pageFooter.top = vnTmpTop;
    voCtrl = this.pageFooter.create(this.document);
    voDiv.appendChild(voCtrl);
  }

};
/**
 * 인스턴스와 연결된 하위 컨트롤의 value설정.
 * @param {Number} pnIndex 데이타의 Row 인덱스
 * @param {String} psIdSuffix 실체화 객체에 아이디 뒤에 추가될 문자열(unique 아이디 부여를 위해)
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Print.prototype.setChildrenData = function(pnIndex, psIdSuffix, poDocument) {
  var voChild = null;
  var voIterator = this.control.controls.iterator();
  var vsPath = null;
  var vsParentPath = this.data.nodesetInstancePath + "[" + (pnIndex + 1) + "]";
  var vsId = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.data != null && voChild.data.instanceId != null) {
      vsId = voChild.id;
      vsPath = voChild.data.instancePath;
      vsPath = vsPath.split("/");
      vsPath = vsPath[vsPath.length - 1];
      voChild.id += psIdSuffix;
      voChild.data.setRef(this.data.nodesetInstanceId, vsPath, vsParentPath);
      voChild.load(this.document);
      voChild.id = vsId;
    }
  }
};
/**
 * Row 인덱스에 해당하는 값을 컨트롤에 설정.
 * @param {Number} pnIndex 데이타의 Row 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.Print.prototype.setData = function(pnIndex, poDocument) {
  var vsParentPath = this.data.nodesetInstancePath + "[" + (pnIndex + 1) + "]";
  var vsPath = this.control.data.instancePath;
  vsPath = vsPath.split("/");
  vsPath = vsPath[vsPath.length - 1];
  this.control.data.setRef(this.data.nodesetInstanceId, vsPath, vsParentPath);
  this.control.load(this.document);
};
/**
 * 클래스 명을 반환.
 * @return "Print"
 * @type String
 */
eXria.controls.xhtml.Print.prototype.toString = function() {
  return "Print";
};



/**
 * Concreate xhtml HeaderFooter
 * @author 조영진
 * @version 1.0
 * @param {eXria.controls.xhtml.Print} poPrint 상위 프린트 객체
 * @constructor
 * @private
 */
eXria.controls.xhtml.HeaderFooter = function(poPrint) {
  /**
   * 상위 프린트 객체.
   * @type eXria.controls.xhtml.Print
   */
  this.printObject = poPrint;
  /**
   * 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 보더 스타일.
   * @type String
   */
  this.borderStyle = null;

  /**
   * 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 배경 이미지.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * left 좌표.
   * @type Number
   * @private
   */
  this.left = null;
  /**
   * top 좌표.
   * @type Number
   * @private
   */
  this.top = null;
  /**
   * 영역의 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * 영역의 세로 길이.
   * @type Number
   */
  this.height = null;
  /**
   * 보더를 제외한 영역의 가로길이.
   * @Number
   * @private
   */
  this.innerWidth = null;
  /**
   * 보더를 제외한 영역의 세로길이.
   * @Number
   * @private
   */
  this.innerHeight = null;
  /**
   * 페이지 번호.
   * readOnly
   * @type Number
   * @private
   */
  this.pageNum = null;
  /**
   * id.
   * @type String
   * @private
   */
  this.id = null;
  /**
   * 아이디의 포함될 prefix 문자열.
   * @type String
   */
  this.idPrefix = null;
  /**
   * 컨트롤이 디스플레이 되는 document 객체
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 하위에 포함될 컨트롤 저장 객체.
   * @type eXria.data.ArrayCollection
   */
  this.items = new eXria.data.ArrayCollection();
  /**
   * 인스턴스 데이타 연동 객체
   * @type eXria.controls.DataRef
   */
  this.data = null;
  /**
   * 디폴트 값을 설정하기 위한 오브젝트
   * @type Object
   */
  this.df = {};

  this.setDefault();
};
/**
 * 머리말 부분의 실체화.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 실체화 객체
 * @type HTMLDiv
 */
eXria.controls.xhtml.HeaderFooter.prototype.create = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  var voStyle = voCtrl.style;
  this.id = this.idPrefix + this.pageNum;
  voCtrl.setAttribute("id", this.id);
  voStyle.position = "relative";
  voStyle.margin = "0px";
  voStyle.padding = "0px";
  var voTable = poDocument.createElement("table");
  voStyle = voTable.style;
  voTable.setAttribute("cellSpacing", "0px");
  voTable.setAttribute("cellPadding", "0px");
  voStyle.position = "relative";
  voStyle.left = "0px";
  voStyle.top = "0px";
  var voTbody = poDocument.createElement("tbody");
  var voTr = poDocument.createElement("tr");
  var voTd = poDocument.createElement("td");
  voStyle = voTd.style;
  voStyle.textAlign = "center";
  voStyle.verticalAlign = "middle";
  voTr.appendChild(voTd);
  voTbody.appendChild(voTr);
  voTable.appendChild(voTbody);
  voCtrl.appendChild(voTable);

  this.setDefault(voCtrl, poDocument);
  this.setAttrs(voCtrl, poDocument);

  this.document = poDocument;

  return voCtrl;
};
/**
 * 디폴트 값 설정
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.setDefault = function(poCtrl, poDocument) {
  this.df = {};
  var voPrintObject = this.printObject;
  var voDf = this.df;
  voDf.left = this.getAttrValue("left");
  voDf.top = this.getAttrValue("top");
  voDf.borderWidth = this.getAttrValue("borderWidth");
  voDf.borderStyle = this.getAttrValue("borderStyle");
  voDf.borderColor = this.getAttrValue("borderColor");
  voDf.backgroundColor = this.getAttrValue("backgroundColor");
  voDf.backgroundImage = this.getAttrValue("backgroundImage");
  voDf.width = this.getAttrValue("width");
  voDf.height= this.getAttrValue("height");
  this.innerWidth = voDf.width - 2 * voDf.borderWidth;
  this.innerHeight = voDf.height - 2 * voDf.borderWidth;
};
/**
 * 디폴트 속성값을 구함.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @return 해당 속성의 디폴트 속성값
 * @type String|Number
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.getAttrValue = function(psAttrName, psAttrValue) {
  if(psAttrValue != null) {
    switch(psAttrName) {
    case "width" :
      var vnWidth = this.getSpecificDefaultValue("width");
      if(psAttrValue > vnWidth) psAttrValue = vnWidth;
      break;
    case "height" :
      var vnHeight = this.getSpecificDefaultValue("height");
      if(psAttrValue > vnHeight) psAttrValue = vnHeight;
    }
    return psAttrValue;
  } else {
    var vsAttrValue = this.getSpecificDefaultValue(psAttrName);
    return vsAttrValue;
  }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.getSpecificDefaultValue = function(psAttrName) {
  var voPrintObject = this.printObject;
  var vsDefaultValue = null;
  switch(psAttrName) {
  case "left" :
    vsDefaultValue = voPrintObject.marginLeft;
    break;
  case "top" :
    vsDefaultValue = voPrintObject.marginTop;
    break;
  case "width" :
    vsDefaultValue = voPrintObject.pageWidth;
    vsDefaultValue -= voPrintObject.marginLeft + voPrintObject.marginRight;
    break;
  default :
    vsDefaultValue = eXria.controls.xhtml.Default.Print.HeaderFooter[psAttrName];
    break;
  }

  if(vsDefaultValue === undefined) {
    return null;
  }
  return vsDefaultValue;
};
/**
 * 속성값 설정.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.setAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voTable = poCtrl.childNodes[0];
  var voStyle = poCtrl.style;
  voStyle.left = voDf.left + "px";
  voStyle.top = voDf.top + "px";
  voStyle.width = this.innerWidth + "px";
  voStyle.height = this.innerHeight + "px";
  voTable.style.width = this.innerWidth + "px";
  voTable.style.height = this.innerHeight + "px";
  var voTd = voTable.rows[0].cells[0];
  voStyle.borderWidth = voDf.borderWidth + "px";
  voStyle.borderStyle = voDf.borderStyle;
  voStyle.borderColor = voDf.borderColor;
  poCtrl.className = this.className;
  voStyle.backgroundColor = voDf.backgroundColor;
  voStyle.backgroundImage = voDf.backgroundImage;

  var voNode = null;
  while(voTd.childNodes.length > 0) {
    voNode = voTd.childNodes[0];
    this.printObject.control.clearCtrlNode(voNode);
    if(voNode.nodeType == 1) {
      voTd.removeChild(voNode);
    }
  }
  var voIterator = this.items.iterator();
  var voControl = null;
  var voCtrl = null;
  var vsPosition = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    vsPosition = voControl.position;
    voControl.position = "relative";
    if(voControl.width > this.innerWidth) voControl.width = this.innerWidth;
    if(voControl.height > this.innerHeight) voControl.height = this.innerHeight;
    voCtrl = voControl.create(poDocument);
    voTd.appendChild(voCtrl);
    if(voControl.toString() == "Label") voControl.setValue(voControl.value, voCtrl, poDocument);
    voControl.position = vsPosition;
  }
};
/**
 * 새로고침.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.refresh = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  if(voCtrl == null) return;
  this.removeAttrDefault(voCtrl, poDocument);
  this.setAttrs(voCtrl, poDocument);
};
/**
 * removeAttrDefault
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.removeAttrDefault = function(poCtrl, poDocument) {
  this.df = {};
  var voTable = this.getCtrl(poDocument);
  var voTd = voTable.rows[0].cells[0];
  var voStyle = voTd.style;
  voStyle.borderWidth = "";
  voStyle.borderStyle = "";
  voStyle.borderColor = "";
  voStyle.backgroundColor = "";
  voStyle.backgroundImage = "";
};
/**
 * 실체화 객체 반환.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 실체화 객체
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.HeaderFooter.prototype.getCtrl = function(poDocument) {
  if(poDocument == null) poDocument = this.document;
  var voCtrl = poDocument.getElementById(this.id);

  return voCtrl;
};
/**
 * 영역에 지정된 문자열 표시.
 * @param {String} psTitle 표시될 문자열 값
 */
eXria.controls.xhtml.HeaderFooter.prototype.setTitle = function(psTitle) {
  if(this.width == null) this.width = this.getSpecificDefaultValue("width");
  if(this.height == null) this.height = this.getSpecificDefaultValue("height");
  if(this.borderWidth == null) this.borderWidth = this.getSpecificDefaultValue("borderWidth");
  var voLabel = new eXria.controls.xhtml.Label(this.printObject.control.id + "_header", 0, 0, this.innerWidth, this.innerHeight);
  voLabel.printMode = true;
  voLabel.value = eXria.controls.xhtml.Util.parseLang(psTitle);
  this.addItem(voLabel);
};
/**
 * 하위 영역에 컨트롤을 포함시키는 메소드.
 * @param {eXria.controls.xhtml.Control} poControl 포함될 컨트롤
 */
eXria.controls.xhtml.HeaderFooter.prototype.addItem = function(poControl) {
  this.items.add(poControl);
  var voCtrl = null;
  if(this.document) voCtrl = this.getCtrl(this.document);
  if(voCtrl != null) {
    var voTable = voCtrl.childNodes[0];
    var voTd = voTable.rows[0].cells[0];
    var vsPosition = poControl.position;
    poControl.position = "relative";
    poControl.width = this.innerWidth;
    poControl.height = this.innerHeight;
    voTd.appendChild(poControl.create(this.document));
    if(poControl.setValue) poControl.setValue(poControl.value);
    poControl.position = vsPosition;
  }
};



/**
 * Concreate xhtml ReportHeader
 * @author 조영진
 * @version 1.0
 * @param {eXria.controls.xhtml.Print} poPrint 상위 프린트 객체
 * @constructor
 * @base eXria.controls.xhtml.HeaderFooter
 * @private
 */
eXria.controls.xhtml.ReportHeader = function(poPrint) {

  eXria.controls.xhtml.HeaderFooter.call(this, poPrint);
  /**
   * id prefix.<br>
   * 디폴트 값 "RepoartHeader_"
   * @type String
   */
  this.idPrefix = "RepoartHeader_";
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.HeaderFooter, eXria.controls.xhtml.ReportHeader);


/**
 * Concreate xhtml ReportFooter
 * @author 조영진
 * @version 1.0
 * @param {eXria.controls.xhtml.Print} poPrint 상위 프린트 객체
 * @constructor
 * @base eXria.controls.xhtml.HeaderFooter
 * @private
 */
eXria.controls.xhtml.ReportFooter = function(poPrint) {

  eXria.controls.xhtml.HeaderFooter.call(this, poPrint);

  /**
   * id prefix.<br>
   * 디폴트 값 "RepoartFooter_"
   * @type String
   */
  this.idPrefix = "RepoartFooter_";
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.HeaderFooter, eXria.controls.xhtml.ReportFooter);


/**
 * Concreate xhtml PageHeader
 * @author 조영진
 * @version 1.0
 * @param {eXria.controls.xhtml.Print} poPrint 상위 프린트 객체
 * @constructor
 * @base eXria.controls.xhtml.HeaderFooter
 * @private
 */
eXria.controls.xhtml.PageHeader = function(poPrint) {

  /**
   * id prefix.<br>
   * 디폴트 값 "PageHeader_"
   * @type String
   */
  this.idPrefix = "PageHeader_";
  eXria.controls.xhtml.HeaderFooter.call(this, poPrint);
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.HeaderFooter, eXria.controls.xhtml.PageHeader);


/**
 * Concreate xhtml PageFooter
 * @author 조영진
 * @version 1.0
 * @param {eXria.controls.xhtml.Print} poPrint 상위 프린트 객체
 * @constructor
 * @base eXria.controls.xhtml.HeaderFooter
 * @private
 */
eXria.controls.xhtml.PageFooter = function(poPrint) {

  eXria.controls.xhtml.HeaderFooter.call(this, poPrint);

  /**
   * id prefix.<br>
   * 디폴트 값 "PageFooter_"
   * @type String
   */
  this.idPrefix = "PageFooter_";
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.HeaderFooter, eXria.controls.xhtml.PageFooter);

/**
 * @fileoverview
 * Concreate xhtml Progress(XHTML Progress 컨트롤)
 * @author 이종녕
 */

/**
 * @class 시간이 지남에따라 반응하는 프로그래스바 컨트롤을 생성하는 class입니다.<br>
 * XHTML Progress Control.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Progress 객체
 * @type eXria.controls.xhtml.Progress
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Progress = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 200 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 진행 표시 Bar의 색.
   * @type String
   */
  this.progressColor = null;
  /**
   * 한번에 증가되는 크기.
   * @type Number
   */
  this.step = null;
  /**
   * 맨처음 시작되는 Range상의 위치.
   * @type Number
   */
  this.startPos = null;
  /**
   * 진행바의 현재 위치 값.
   * @type Number
   * @private
   */
  this.currentPos = null;
  /**
   * Timer를 통한 동작 주기 (단위 milisecond = 1/1000초).
   * @type Number
   */
  this.interval = null;
  /**
   * 최소 범위.
   * @type Number
   */
  this.min = null;
  /**
   * 최대 범위.
   * @type Number
   */
  this.max = null;
  /**
   * 구동중인 Time ID.
   * @type String
   * @private
   */
  this.timeId = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 일시정지부울값.
   * @type Boolean
   * @private
   */
  this.mbpause = null;
  /**
   * 투명도 설정.
   * @type Number
   */
  this.opacity = 0.2;
  /**
   * 대기 모드 상태 여부
   * @type Boolean
   * @private
   */
  this.mbwaiting = null;
  /**
   * 실체화 컨트롤 객체 참조 변수
   * @type HTMLDiv
   * @private
   */
  this.loading_div = null;

  /**
   * 연계될 컨트롤 id.
   * @type String
   * @private
   */
  this.target = null;

  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};

  /**
   * 진행상태를 표시할때 나타내는 단위 문자
   * @member eXria.controls.xhtml.Progress
   * @type String
   * @private
   */
  this.unitStr = "%";

  this.cursor = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Progress);
//////////////////////////////////////////////////////////////////
// 메소드

/**
 * ProgressBar 의 최소값을 설정
 * @member eXria.controls.xhtml.Progress
 * @param {Number} min 최소값
 * @type void
 */
eXria.controls.xhtml.Progress.prototype.setMin = function(min){
  this.min = min;
}

/**
 * ProgressBar 의 최대값을 설정
 * @member eXria.controls.xhtml.Progress
 * @param {Number} max 최대값
 * @type void
 */
eXria.controls.xhtml.Progress.prototype.setMax = function(max){
  this.max = max;
}

/**
 * ProgressBar 의 진행상태를 나타내는 표시 단위 설정
 * @member eXria.controls.xhtml.Progress
 * @param {String} unit 표시단위 문자열
 * @type void
 */
eXria.controls.xhtml.Progress.prototype.setUnitStr = function(unit){
  this.unitStr = unit;
}

/**
 * ProgressBar 의 진행상태를 특정 위치만큼 이동
 * @member eXria.controls.xhtml.Progress
 * @param {Number} pos 이동할 위치 또는 현재까지의 진행상태 값
 * @type void
 */
eXria.controls.xhtml.Progress.prototype.setCurrentPos = function(pos){
  if (typeof(this.id) != undefined) {
      var voLabel = this.getSubCtrl("label");
      var voBar = this.getSubCtrl("div");

      // 프로그래스 바의 진행 표시...
    var prsPos = pos * this.width / this.max;

    if(prsPos >= this.innerWidth ) {
      prsPos = this.innerWidth;
      pos = this.max;
    }

    innerStr = commify(pos) + " / " + commify(this.max) + " " + this.unitStr;
      voLabel.innerHTML = innerStr;
      voBar.style.width = prsPos;
  }
}


function commify(n) {
  var reg = /(^[+-]?\d+)(\d{3})/;   // 정규식
  n += '';                          // 숫자를 문자열로 변환

  while (reg.test(n))
    n = n.replace(reg, '$1' + ',' + '$2');

  return n;
}

/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.createCtrl = function(poDocument){
  var voCtrl = poDocument.createElement("div");

  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.setTemplate = function(poCtrl, poDocument){
  // 진행수치  라벨 구성..
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<label class='" + vsClass + "' ");
  vaTemplate.push("@attStrBuf"); //1
  vaTemplate.push("style='position:absolute;z-index:2;background-color:transparent;");
  vaTemplate.push("@cssStrBuf");  //3
  vaTemplate.push("'>");
  vaTemplate.push("loading..");
  vaTemplate.push("</label>");

  // Progress bar 구성
  //vaTemplate.push("<div style='position:absolute;z-index:1;");
  // 2009.09.15 텍스트 겹치는 현상
  vaTemplate.push("<div style='position:absolute;z-index:1;");
  vaTemplate.push("border-width:1px;left:0px;top:0px;");
  vaTemplate.push("@cssStrBuf");  //9
  vaTemplate.push("'/>");
};
/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;
  this.startPos = this.getAttrValue("startPos", this.startPos);
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.step = this.getAttrValue("step",this.step);
  this.startPos = this.getAttrValue("startPos",this.startPos);
  this.interval = this.getAttrValue("interval",this.interval);
  this.min = this.getAttrValue("min",this.min);
  this.max = this.getAttrValue("max",this.max);
  this.progressColor = this.getAttrValue("progressColor",this.progressColor);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.setSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  if(this.disabled) vaAttStrBuf.push("disabled ")
  vaTemplate[1] = vaAttStrBuf.join("");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  //vfcSetCssStrBuf(vaCssStrBuf, "left", this.innerWidth / 2 - 7, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "left", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", "center");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vaTemplate[3] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.per_to_num(this.startPos), "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "width", this.width, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.progressColor);
  vaTemplate[9] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Progress.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voBar = this.getSubCtrl("div",poCtrl);
  var voLabel = this.getSubCtrl("label",poCtrl);

  switch(psAttrName) {
    case "disabled" :
    case "cursor":
      this.setAttrCtrl(psAttrName,psAttrValue, voLabel);
      break;
    case "width" :
      this.setAttrCtrl("width", this.per_to_num(this.startPos), voBar);
      this.setAttrCtrl("left", (this.innerWidth / 2 - 7), voLabel);
      break;
    case "height" :
      this.setAttrCtrl("height", this.innerHeight, voBar);
      this.setAttrCtrl("top", (this.innerHeight / 2 - 7), voLabel);
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Progress.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voBar = this.getSubCtrl("div",voCtrl);
  var voLabel = this.getSubCtrl("label",voCtrl);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }

  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
//  case "borderTopWidth" :
//  case "borderTopHeight" :
//    this.innerHeight = this.width - this.borderTopWidth - this.borderBottomWidth;
//    if(this.innerHeight < 0) this.innerHeight = 0;
//    this.setAttrCtrl("height", this.innerHeight, voCtrl);
//    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
//    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
     this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
     if(this.innerHeight < 0) this.innerHeight = 0;
     this.setAttrCtrl("height", this.innerHeight, voCtrl);
     this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
     break;
  case "backgroundColor":
    this.setAttrCtrl("backgroundColor", psAttrValue, voBar);
    this.refresh(poDocument);
    break;
  case "color" :
    this.setAttrCtrl("backgroundColor", psAttrValue, voLabel);
    break;
  case "outerClassName" :
  case "className" :
    this.refresh(poDocument);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
* 서브 컨트롤 실체화 객체를 얻어옵니다.
* @param {String} psTagName 얻어올 테그네임
* @return subControl 실체화 객체
* @type Object
* @private
*/
eXria.controls.xhtml.Progress.prototype.getSubCtrl = function(psTagName,poCtrl,poDocument){
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};
/**
 * 바를 실행시킵니다.
 * @private
 */
eXria.controls.xhtml.Progress.prototype.startbar = function(psId){
  var voControl = this.canvas.page.getControl(psId);
  if (voControl.currentPos >= 100) voControl.currentPos = 100;
  voControl.moveProgress(voControl.currentPos);
  if (voControl.currentPos == 100) voControl.stop();
  voControl.currentPos = voControl.currentPos + voControl.step;
}
/**
 * 퍼센트를 숫자로 계산합니다.
 * @private
 */
eXria.controls.xhtml.Progress.prototype.per_to_num = function(per){
  var num = (this.innerWidth / 100) * per;
  //return num + "px";
  return num;
};
/**
 * 프로그래스의 진행 표시를 이동시킵니다.
 * @param {Number} pnStep 진행률
 */
eXria.controls.xhtml.Progress.prototype.moveProgress = function(pnStep){
  //로딩 되어 있는지 확인한다..
  if (typeof(this.id) != "undefined") {
    var voDocument = this.document;
    var voLabel = this.getSubCtrl("label");
    var voBar = this.getSubCtrl("div");
    // 프로그래스 바의 진행 표시...
//    voLabel.innerHTML = pnStep + "%";
    voLabel.removeChild(voLabel.firstChild);
    voLabel.appendChild(voDocument.createTextNode(pnStep + "%"));
    voBar.style.width = this.per_to_num(pnStep) + "px";
  }
};
/**
 * 프로그래스를 시작합니다.
 * @param {String} psId 컨트롤 식별자
 */
eXria.controls.xhtml.Progress.prototype.start = function(psId){
  this.stop();
  this.target = psId;
  if(psId)this.startWaiting(psId);
  this.mbpause = true;
  this.currentPos = this.startPos;
  // setInterval함수로 구현
  var vaStrBuf = [];
  vaStrBuf.push("page.getControl('");
  vaStrBuf.push(this.id);
  vaStrBuf.push("').startbar('");
  vaStrBuf.push(this.id);
  vaStrBuf.push("');")

  this.timeId = this.window.setInterval(vaStrBuf.join(""), this.interval);
  vaStrBuf = null;
};
/**
 * 프로그래스를 일시정지상태로 만들어줍니다.
 */
eXria.controls.xhtml.Progress.prototype.pause = function(){
  if(this.mbpause == null)
    return null;
  var voWindow = this.window;
  if (this.mbpause) {
    voWindow.clearInterval(this.timeId);
    this.mbpause = false;
  }
  else{
    var vaStrBuf = [];
    vaStrBuf.push("page.getControl('");
    vaStrBuf.push(this.id);
    vaStrBuf.push("').startbar('");
    vaStrBuf.push(this.id);
    vaStrBuf.push("');")
    this.timeId = voWindow.setInterval(vaStrBuf.join(""), this.interval);
    this.mbpause = true;
  }
};
/**
 * 포로그래스 동작을 멈춥니다.
 */
eXria.controls.xhtml.Progress.prototype.stop = function(){
  this.window.clearInterval(this.timeId);
  this.stopWaiting(this.target);
  this.timeId = null;
  this.mbpause = null;
};
/**
 * 대기 모드를 시작합니다.
 * @param {String} element 적용 대상 실체화 객체 id
 * @private
 */
eXria.controls.xhtml.Progress.prototype.startWaiting = function(element) {
  if (typeof element == 'string') element = this.lookup(element);
  this.mbwaiting = true;
  var voStyle = null;

  if (!this.loading_div) {
    var voCtrl = this.document.createElement('div');
    voStyle = voCtrl.style;
    element.parentNode.appendChild(voCtrl);
    try {voStyle.opacity = this.opacity;} catch(e) {}
    try {voStyle.MozOpacity = this.opacity;} catch(e) {}
    try {voStyle.filter = 'alpha(opacity='+Math.round(this.opacity * 100)+')';} catch(e) {}
    try {voStyle.KhtmlOpacity = this.opacity;} catch(e) {}
  }
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  var left = element.offsetLeft;
  var top = element.offsetTop;
  voStyle = voCtrl.style;
  voStyle.position = 'absolute';
  voStyle.backgroundImage = 'url('+ this.canvas.page.metadata.resourceBaseUrl + 'eXria/controls/xhtml/images/bigWaiting.gif)';
  voStyle.backgroundRepeat = "no-repeat";
  voStyle.backgroundPosition = "center center";
  voStyle.backgroundColor = "yellow";
  voStyle.left = left+'px';
  voStyle.top = top+'px';
  voStyle.width = width+'px';
  voStyle.height = height+'px';
  voStyle.display = 'inline';
  this.loading_div = voCtrl;
};
/**
 * 대기 모드를 해제합니다.
 * @param {String} element 적용 대상 실체화 객체 id
 */
eXria.controls.xhtml.Progress.prototype.stopWaiting = function(element) {
  if (typeof element == 'string') element = this.lookup(element);
  if (this.mbwaiting) {
    this._waiting = false;
    if(this.loading_div) element.parentNode.removeChild(this.loading_div);
    this.loading_div = null;
  }
};
/**
 * oldclear
 * @private
 */
eXria.controls.xhtml.Progress.prototype.oldclear = eXria.controls.xhtml.Progress.prototype.clear;
/**
 * clear
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.clear = function(){
  this.stop();
  this.oldclear();
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Progress[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "Progress"
 * @type String
 */
eXria.controls.xhtml.Progress.prototype.toString = function() {
  return "Progress";
};
/**
 * loadComplete
 * @ignore
 */
eXria.controls.xhtml.Progress.prototype.loadComplete = function(poDocument) {
  var voLabel = this.getSubCtrl("label");
  if(voLabel && this.ctrl)
    this.setVerticalAlign(voLabel, this.ctrl, this.verticalAlign);
}
/**
 * @fileoverview
 * Concreate xhtml Select(XHTML Select 컨트롤)
 * @author 김경태
 */

/**
 * @class 아이템의 공통 속성을 저장하기 위한 오브젝트입니다.
 * @type eXria.controls.xhtml.Select
 * @version 2.0
 * @constructor
 */
eXria.controls.xhtml.Select_itemgroup = function(){
  /**
   * 라벨의 상대 위치를 지정
   * left/right/top/bottom
   * @type String
   */
  this.labelPos = null;
  /**
   * 아이템의 높이
   * @type number
   */
//  this.height = null; // 아이템의 높이 - number
  /**
   * 아이템의 넓이
   * @type number
   */
//  this.width = null; // 아이템의 넓이 - number
  /**
   * 아이템의 가로 정렬
   * "left"|"center"|"right"
   * @type String
   */
  this.textAlign = null;
  /**
   * 아이템의 세로 정렬
   * top/middle/bottom
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템의 글자색
   * @type String
   */
  this.color = null; // 아이템의 글자색
  /**
   * 아이템의 배경색
   * @type String
   */
  this.backgroundColor = null;
  /**
   * border의 폭
   * @type Number
   */
  this.borderWidth = null;
  /**
   * border의 스타일
   * none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset
   * @type String
   */
  this.borderStyle = null;
  /**
   * border의 색상
   * @type String
   */
  this.borderColor = null;
  /**
   * 텍스트 폰트패밀리
   * @type String
   */
  this.fontFamily = null;
  /**
   * 텍스트 폰트사이즈
   * @type Number
   */
  this.fontSize = null;
  /**
   * 텍스트 폰트스타일
   * @type String
   */
  this.fontStyle = null;
  /**
   * 텍스트 폰트두께
   * @type String
   */
  this.fontWeight = null;
  /**
   * CSS 클래스 이름
   * @type String
   */
  this.className = null;

  /**
   * border의 bottom폭
   * @type number
   */
  this.borderBottomWidth = null;
  /**
   * border의 top폭
   * @type number
   */
  this.borderTopWidth = null;
  /**
   * border의 left폭
   * @type number
   */
  this.borderLeftWidth = null;
  /**
   * border의 right폭
   * @type number
   */
  this.borderRightWidth = null;
  /**
   * @private
   */
  this.cursor = null;

  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflow = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowX = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowY = null;

  /**
   * css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};

/**
 * @class Concreate xhtml Select
 * XHTML Select 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Select 객체
 * @type eXria.controls.xhtml.Select
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Select = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.
  this.data = new eXria.controls.DataRefNodeset(this); // DataRef 생성 연결
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 수평 또는 수직 모드를 지정 - horizontal/vertical.
   * @type String
   */
  this.displayMode = null;
  /**
   * 해당 모드에서의 옵션 수.
   * @type Number
   */
  this.displayNum = null;
  /**
   * 선택 버튼 타입.
   * readonly
   * @type String
   */
  this.type = null;
  /**
   * 아이템 다중선택 여부.
   * readonly
   * @type String
   */
  this.multiple = null;
  /**
   * 선택된 옵션의 값.
   * @type String
   */
  this.value = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Nmuber
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 앞쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.frontItems = new eXria.data.ArrayMap();
  /**
   * 인스턴스로 부터 가져올 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.itemset = new eXria.data.ArrayMap();
  /**
   * 뒤쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.backItems = new eXria.data.ArrayMap();
  /**
   * 선택된 아이템의 리스트
   * @private
   */
  this.selectedItems = new eXria.data.ArrayMap();
  /**
   * ref의 값
   * @private
   */
  //this.refValue = null;
  /**
   * 가로 간격.
   * @type Number
   */
  this.horizontalGap = null;
  /**
   * 세로 간격.
   * @type Number
   */
  this.verticalGap = null;
  /**
   * 컨트롤내에서의 옵션의 left offset.
   * @type Number
   */
  this.offsetLeft = null;
  /**
   * 컨트롤내에서의 옵션의 top offset.
   * @type Number
   */
  this.offsetTop = null;
  /**
   * Data 연동 시의 Instance의 label Tag 명.
   * @type String
   */
  this.labelTagName = null;
  /**
   * Data 연동 시의 Instance의 value Tag 명.
   * @type String
   */
  this.valueTagName = null;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 아이템의 공통 속성 (아이템 생성 시 기본 값 적용).
   * @type Object
   */
  this.itemgroup = new eXria.controls.xhtml.Select_itemgroup();
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Select);
//////////////////////////////////////////////////////////////////
// 메소드
/*eXria.controls.xhtml.Select.prototype.createCtrl = function(poDocument){
  voCtrl.setAttribute("id", this.id);
  voCtrl.style.overflow = "hidden"; // 컨트롤 영역을 벗어난 하위 요소를 안보이게 처리
  return voCtrl;
};*/
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.createCtrl = function(poDocument){
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  vaTemplate.push("@innStrBuf");
};
/**
 * RidioButton 컨트롤의 개별 초기값 설정.
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voItemgroupDf = this.itemgroup;
  this.setStyleCurrentBorderValue(this);

  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  // CSS가 적용되지 않는 속성에 대한 초기값 설정(main 컨트롤)
  this.value = this.getAttrValue("value", this.value);
  this.offsetLeft = this.getAttrValue("offsetLeft", this.offsetLeft);
  this.offsetTop = this.getAttrValue("offsetTop", this.offsetTop);
  this.displayNum = this.getAttrValue("displayNum", this.displayNum);
  this.displayMode = this.getAttrValue("displayMode", this.displayMode);
  this.horizontalGap = this.getAttrValue("horizontalGap", this.horizontalGap);
  this.verticalGap = this.getAttrValue("verticalGap", this.verticalGap);
  if(this.offsetLeft == null) this.offsetLeft = 0;
  if(this.offsetTop == null) this.offsetTop = 0;

  voItemgroupDf.labelPos = this.getAttrValue("itemgroup.labelPos", this.itemgroup.labelPos);
};
///*eXria.controls.xhtml.Select.prototype.setSpecificAttrs = function(poCtrl, poDocument){
//  var voDf = this.df;
//  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
//  if(this.innerWidth < 0) this.innerWidth = 0;
//  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
//  if(this.innerHeight < 0) this.innerHeight = 0;
//
//  this.setAttrCtrl("borderColor", this.borderColor, poCtrl);
//  this.setAttrCtrl("borderStyle", this.borderStyle, poCtrl);
//  this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", poCtrl);
//  this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", poCtrl);
//  this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", poCtrl);
//  this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", poCtrl);
//  this.setAttrCtrl("name", this.name, poCtrl);
//  this.setAttrCtrl("value", this.value, poCtrl);
//  this.setAttrCtrl("fontFamily", this.fontFamily, poCtrl);
//  this.setAttrCtrl("fontSize", this.fontSize, poCtrl);
//  this.setAttrCtrl("fontStyle", this.fontStyle, poCtrl);
//  this.setAttrCtrl("fontWeight", this.fontWeight, poCtrl);
//  this.setAttrCtrl("color", this.color, poCtrl);
//  this.setAttrCtrl("backgroundColor", this.backgroundColor, poCtrl);
//  this.setAttrCtrl("width", this.innerWidth, poCtrl);
//  this.setAttrCtrl("height", this.innerHeight, poCtrl);
//};*/
/**
 * RidioButton 컨트롤의 개별 Attrs 적용.
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.setSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;

  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  poCtrl["name"] = this.name;
  poCtrl["value"] = this.value;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  poCtrl.style.cssText = vaCssStrBuf.join("");
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.dochange = function(e) {
  var voDf = this.df;
//this.atchange(e);
  if(this.onchange) {
    try {
      this.onchange(e);
    } catch(err) {
      if(this.debug){
        alert("onchange_" + e.object.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(this.changeEventCallback) this.changeEventCallback(e);
  this.finalchange(e);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.finalchange = function(e) {
  this.changed = false;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.atclick = function(e) {
  //if(e.target.tagName.toUpperCase() == "INPUT") {
  if(this.eventObject != null) {
    e.objectType = this.eventObjectType;
    e.object = this.eventObject;
    this.clearSelected();
    this.checkSelected();
    this.value = this.getValue();
    this.value = this.getValue();
    if(this.data.instanceId && this.data.instancePath) {
      this.data.setData(this.value);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.finalclick = function(e) {
  if(this.canvas) {
    var voCanvas = this.canvas;
    if(!this.isRClick(e)) voCanvas.hideContextMenu();
  }
  if(this.changed) {
    this.dochange(e);
  }
  this.eventObjectType = null;
  this.eventObject = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.removeSpecificDefaults = function(e) {
  this.template = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  this.setSpecificDefaults(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  this.setSpecificAttrs(poCtrl); // Select 컨트롤의 개별 속성들을 설정한다.
};
/**
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.reloadData = function(poCtrl, poDocument){
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  this.itemset.clear();
  //this.clearCtrlNode(poCtrl);
  for (var i = 0; i < poCtrl.childNodes.length;) {
    poCtrl.removeChild(poCtrl.childNodes[0]);
  }
  this.loadData(poDocument);
};
/**
 * 속성에 대한 하위 전파를 처리합니다.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Select.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl){
  switch (psAttrName) {
    case "disabled":
      for (var i = 0; i < poCtrl.childNodes.length; i++) {
        poCtrl.childNodes[i].disabled = psAttrValue;

        var voNode = poCtrl.childNodes[i];
        do {
          if(voNode.childNodes[0] == null)
            break;
          voNode = voNode.childNodes[0];
        } while(voNode != null)
        if(voNode.parentNode.parentNode) {  // table
          voNode = voNode.parentNode.parentNode;
          for (var j = 0; j < voNode.childNodes.length; j++)            // table의 td 2개
            voNode.childNodes[j].childNodes[0].disabled = psAttrValue;  // td의 input또는 span
        }
        /*for (var j = 0; j < poCtrl.childNodes[i].childNodes.length; j++) {
          poCtrl.childNodes[i].childNodes[j].disabled = psAttrValue;
        }*/
      }
      break;
    case "color":
      for (var i = 0; i < poCtrl.childNodes.length; i++) {
        poCtrl.childNodes[i].style.color = psAttrValue;
        var voNode = poCtrl.childNodes[i];
        do {
          if(voNode.childNodes[0] == null)
            break;
          voNode = voNode.childNodes[0];
        } while(voNode != null)
        if(voNode.parentNode.parentNode) {  // table
          voNode = voNode.parentNode.parentNode;
          for (var j = 0; j < voNode.childNodes.length; j++)              // table의 td 2개
            voNode.childNodes[j].childNodes[0].style.color = psAttrValue; // td의 input또는 span
        }
        /*for (var j = 0; j < poCtrl.childNodes[i].childNodes.length; j++) {
          poCtrl.childNodes[i].childNodes[j].style.color = psAttrValue;
        }*/
      }
      break;
    default:
      //      poCtrl.childNodes[i].setAttribute(psAttrName, psAttrValue);
      break;
  }
};
/**
 * refresh가 필요한 경우
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Select.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument){
  var voCtrl = this.getCtrl(poDocument);

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
//    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setDisable(voCtrl, psAttrValue);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * id와 위치를 재설정합니다.
 * @param {eXria.controls.xhtml.Item} poItemControl
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @private
 */
eXria.controls.xhtml.Select.prototype.setIdPos = function(poItemControl, pnIndex) {
  var voDf = this.df;
  var vnLeft = null;
  var vnTop = null;
  var vnWidth = poItemControl.width;
  var vnHeight = poItemControl.height
  var vnOffsetLeft = this.offsetLeft;
  var vnOffsetTop = this.offsetTop;
  var vnItemNum = pnIndex;
  var vsItemId = this.id + "_item" + vnItemNum;
  var vnBorderHWidth = poItemControl.borderLeftWidth + poItemControl.borderRightWidth;
  var vnBorderVWidth = poItemControl.borderTopWidth + poItemControl.borderBottomWidth;
  var vnDisplayNum = this.displayNum;
  var vsDisplayMode = this.displayMode;
  var vnHorizontalGap = this.horizontalGap;
  var vnVerticalGap = this.verticalGap;
  var vnQuotient = parseInt(vnItemNum / vnDisplayNum); // 몫
  var vnRemainder = vnItemNum % vnDisplayNum; // 나머지

//    this.offsetLeft = Math.abs(parseInt((this.width - ((vnDisplayNum * this.getAttrValue("itemgroup.width", this.itemgroup.width)) + ((vnDisplayNum-1) * vnHorizontalGap) + (vnDisplayNum * this.itemgroup.borderWidth)))/2));

  // 옵션의 좌표 계산
  if (vsDisplayMode == "horizontal") { // 수평모드
    vnLeft = vnOffsetLeft + (vnRemainder * vnWidth) + (vnRemainder * vnHorizontalGap);
    if(vnBorderHWidth) vnLeft = vnLeft + (vnRemainder * vnBorderHWidth);
    vnTop = vnOffsetTop + (vnQuotient * vnHeight) + (vnQuotient * vnVerticalGap);
    if(vnBorderVWidth) vnTop = vnTop + (vnQuotient * vnBorderVWidth);
  } else if (vsDisplayMode == "vertical") { // 수직모드
    vnLeft = (vnQuotient * vnWidth) + (vnQuotient * vnVerticalGap);
    vnTop = (vnRemainder * vnHeight) + (vnRemainder * vnHorizontalGap);
  }
  poItemControl.id = vsItemId;
  poItemControl.left = vnLeft;
  poItemControl.top = vnTop;
};
/**
 * frontItems혹은 backItems에 아이템을 추가 시킵니다.
 * @param {String} psType 아이템 타입
 * @param {String} psLabelText 아이템 라벨 텍스트
 * @param {String} psValue 컨트롤 disabled설정
 * @param {Number} pnIndex 전체 리스트에서의 인덱스(인덱스를 지정하지 않은 경우  아이템을 아이템 리스트의 맨 후미에 저장)
 * @param {HTMLDiv} poCtrl 실체화 컨트롤(생략가능)
 * @return 새롭게 생성된 eXria.controls.xhtml.Item 객체
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.Select.prototype.addItem = function(psType, psLabelText, psValue, pnIndex, poCtrl) {
  if(psValue == null || psValue === undefined) new Error("vlaue is Empty");
  if (poCtrl == null) poCtrl = this.ctrl;
  var voItemControl = null;
  var vsItemId = this.id + "_item";

  voItemControl = new eXria.controls.xhtml.Item(vsItemId, this, psLabelText, psValue, 0, 0, 0, 0);

  var voItemGroup = this.itemgroup;

  // 아이템의 공통 속성 설정
  voItemControl.height = this.getAttrValue("itemgroup.height", voItemGroup.height);
  voItemControl.width = this.getAttrValue("itemgroup.width", voItemGroup.width);
  voItemControl.labelPos = voItemGroup.labelPos;
  voItemControl.backgroundColor = voItemGroup.backgroundColor;
  voItemControl.borderWidth = voItemGroup.borderWidth;
  voItemControl.borderStyle = voItemGroup.borderStyle;
  voItemControl.borderColor = voItemGroup.borderColor;
  voItemControl.textAlign = voItemGroup.textAlign;
  voItemControl.verticalAlign = voItemGroup.verticalAlign;
  voItemControl.disabled = voItemGroup.disabled;
  // 공통 속성의 하위 전달
  //if(this.disabled) voItemControl.disabled = true;
  voItemControl.color = this.color;

  // 아이템 타입  속성의 하위 전달 (라디오/체크박스)
  voItemControl.type = this.type;

  var voItems = null;
  if(psType == "front") voItems = this.frontItems;
  else if(psType == "itemset") voItems = this.itemset;
  else if(psType == "back") voItems = this.backItems;
  else new Error("아이템이 추가되는 타입 front/itemset/Back을 지정하지 않았습니다.");

  if(pnIndex == null) {  // 인덱스를 지정하지 않은 경우  아이템을 아이템 리스트의 맨 후미에 저장
    voItems.put(voItems.size(), voItemControl);
  } else {               // 인덱스를 지정한 경우 아이템 리스트의 지정된 인덱스에 아이템을 저장
    var voNewItems = new eXria.data.ArrayMap();
    var vnIndex = 0;
    var voValue = null;
    var voIterator = voItems.getValueCollection().iterator();
    while(voIterator.hasNext()) {
      if(vnIndex == pnIndex) voNewItems.put(vnIndex++, voItemControl);
      voValue = voIterator.next();
      voNewItems.put(vnIndex, voValue);
      vnIndex++;
    }
    if(psType == "front") {
      this.frontItems.clear();
      this.frontItems = voNewItems;
    } else if(psType == "itemset") {
      this.itemset.clear();
      this.itemset = voNewItems;
    } else if(psType == "back") {
      this.backItems.clear();
      this.backItems = voNewItems;
    }
  }
  return voItemControl;
};
/**
 * frontItems에 아이템을 추가하 시킵니다.
 * @param {String} psLabelText 아이템 라벨 텍스트
 * @param {String} psValue 컨트롤 disabled설정
 * @param {Number} pnIndex 전체 리스트에서의 인덱스(인덱스를 지정하지 않은 경우  아이템을 아이템 리스트의 맨 후미에 저장)
 * @param {HTMLDiv} poCtrl 실체화 컨트롤(생략가능)
 * @return 새롭게 생성된 eXria.controls.xhtml.Item 객체
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.Select.prototype.addItemFront = function(psLabelText, psValue, pnIndex, poCtrl) {
  return this.addItem("front", psLabelText, psValue, pnIndex, poCtrl);
};
/**
 * itemset에 아이템을 추가 시킵니다.
 * @param {String} psLabelText 아이템 라벨 텍스트
 * @param {String} psValue 컨트롤 disabled설정
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 새롭게 생성된 eXria.controls.xhtml.Item 객체
 * @type eXria.controls.xhtml.Item
 * @private
 */
eXria.controls.xhtml.Select.prototype.addToItemset = function(psLabelText, psValue, poCtrl, poDocument){
   return this.addItem("itemset", psLabelText, psValue, null, poCtrl, poDocument);
};
/**
 * backItems에 아이템을 추가 시킵니다.
 * @param {String} psLabelText 아이템 라벨 텍스트
 * @param {String} psValue 컨트롤 disabled설정
 * @param {Number} pnIndex 전체 리스트에서의 인덱스(인덱스를 지정하지 않은 경우  아이템을 아이템 리스트의 맨 후미에 저장)
 * @param {HTMLDiv} poCtrl 실체화 컨트롤(생략가능)
 * @return 새롭게 생성된 eXria.controls.xhtml.Item 객체
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.Select.prototype.addItemBack = function(psLabelText, psValue, pnIndex, poCtrl) {
  return this.addItem("back", psLabelText, psValue, pnIndex, poCtrl);
};
/**
 * 아이템을 제거 시킵니다.
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.removeItem = function(psName, poDocument) {
//  this.frontItems.remove(psName);
//  this.itemset.remove(psName);
//  this.backItems.remove(psName);
  var voFrontItems = this.frontItems;
  var voItemset = this.itemset;
  var voBackItems = this.backItems;
  var vnIndex = this.getIndex(psName);
  if(vnIndex < voFrontItems.size()) {
    voFrontItems.remove(vnIndex);
  } else if(vnIndex < voFrontItems.size() + voItemset.size()) {
    voItemset.remove(vnIndex - voFrontItems.size());
  } else {
    voBackItems.remove(vnIndex - voFrontItems.size() - voItemset.size())
  }
  this.selectedItems.remove(vnIndex);
  var voCtrl = this.getCtrl(poDocument);
  this.refreshList(voCtrl, poDocument);
};
/**
 * 모든 리스트의 아이템을 제거 시킵니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.Select.prototype.removeAll = function(poDocument) {
  this.frontItems.clear();
  this.itemset.clear();
  this.backItems.clear();
  this.selectedItems.clear();
  this.refresh(poDocument);
};
/**
 * itemSet에 속한 모든 item의 disable 속성 지정후 refresh 처리
 * @param {String} pbDisable disable 속성
 */
eXria.controls.xhtml.Select.prototype.setDisableAllItems = function(pbDisable) {
  if(typeof pbDisable !== "boolean"){
    var voErrMsg = {};
    voErrMsg.name = "setDisableAllItems"
    voErrMsg.message = "pbDisable 가 boolean 타입이 아닙니다."
    throw voErrMsg;
  }

  this.disabled = pbDisable;
  this.itemgroup.disabled = pbDisable;

  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.disabled = pbDisable;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.disabled = pbDisable;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.disabled = pbDisable;
  }

  this.refresh();
}
/**
 * 지정된 라벨과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스를 반환합니다.
 * @param {String} psName 아이템 라벨 명
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.Select.prototype.getIndex = function(psName) {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var vsValue = null;
  var i = -1;
  while(voIterator.hasNext()) {
    i++;
    vsValue = voIterator.next();
    if(vsValue.text == psName) {
      return i;
    }
  }
  voIterator = this.itemset.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    i++;
    vsValue = voIterator.next();
    if(vsValue.text == psName) {
      return i;
    }
  }
  voIterator = this.backItems.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    i++;
    vsValue = voIterator.next();
    if(vsValue.text == psName) {
      return i;
    }
  }
  return -1;
};
/**
 * 지정된 아이템의 값과 일치되는 리스트 아이템의 전체 리스트에서의 인덱스를 반환합니다.
 * @param {String} psValue 아이템 값
 * @return 해당 아이템의 전체 리스트에서의 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.Select.prototype.getIndexByVal = function(psValue) {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var i = 0;
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    if(voItem.value == psValue) return i;
    i++;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    if(voItem.value == psValue) return i;
    i++;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    if(voItem.value == psValue) return i;
    i++;
  }
  return -1;
};
/**
 * 선택된 아이템 value를 반환합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 선택된 아이템 value
 * @type String|Array(String)
 */
eXria.controls.xhtml.Select.prototype.getValue = function(poDocument) {
  var vaRet = [];
  var voCtrl = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl(poDocument);
    if (voCtrl.checked) {
      if(this.multiple == false) return voItem.getValue();
      vaRet.push(voItem.getValue());
    }
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl(poDocument);
    if (voCtrl.checked) {
      if(this.multiple == false) return voItem.getValue();
      vaRet.push(voItem.getValue());
    }
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl(poDocument);
     if (voCtrl.checked) {
      if(this.multiple == false) return voItem.getValue();
      vaRet.push(voItem.getValue());
    }
  }

  if(vaRet.length == 0) {
    return null;
  } else {
    return vaRet;
  }
};
/**
 * 지정된 인덱스에 해당하는 아이템 value를 반환합니다.
 * @param {Number} pnIndex 인덱스 번호
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 지정된 인덱스에 해당하는 아이템 value
 * @type String
 */
eXria.controls.xhtml.Select.prototype.getItemValue = function(pnIndex, poDocument){
  var voCtrl = null;
  var voItems = null;
  if(pnIndex < this.frontItems.size()) voItems = this.frontItems;
  else if(pnIndex < this.frontItems.size() + this.itemset.size()) {
    voItems = this.itemset;
    pnIndex -= this.frontItems.size();
  } else {
    voItems = this.backItems;
    pnIndex -= this.frontItems.size() + this.itemset.size();
  }
  var voIterator =voItems.getValueCollection().iterator();
  var voItem = voIterator.collection[pnIndex];
  if(voItem != null) {
    return voItem.getValue();
  }
  return null;
};
/**
 * 지정된 라벨명에 해당하는 아이템을 반환합니다.
 * @param {String} psName 아이템 라벨 값
 * @return 인덱스로 지정된 eXria.controls.xhtml.Item 객체
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.Select.prototype.getItemByName = function(psName) {
  var voItems = null;
  var voItem = null;
  var voRet = null;
  var vbBreak = false;
  var vaItems = [this.frontItems, this.itemset, this.backItems];
  for(var i = 0; i < vaItems.length; i++) {
    voItems = vaItems[i];
    for(var j = 0; j < voItems.size(); j++) {
      voItem = voItems.get(j);
      if(voItem.text == psName) {
        voRet = voItem;
        vbBreak = true;
        break;
      }
    }
    if(vbBreak) break;
  }

  return voRet;
};
/**
 * 지정된 값을 포함한 아이템을 반환합니다.
 * @param {String} psValue 검색할 값
 * @return 지정된 값을 포함한 아이템
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.Select.prototype.getItemByVal = function(psValue) {
  var voItem = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.getValue() == psValue) return voItem;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.getValue() == psValue) return voItem;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.getValue() == psValue) return voItem;
  }
  return null;
};
/**
 * 지정된 값을 갖는 아이템을 선택합니다.
 * @param {Array(String)} paValue 컨트롤 disabled설정
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.Select.prototype.setValue = function(paValue, poDocument) {
  this.clearChecked();

  var voCtrl = null;
  var vsValue = null;
  var vbBreak = false;
  var vaValue = [];
  if(typeof paValue == "string") vaValue.push(paValue);
  else if(paValue != null && paValue.push) vaValue = paValue;
  for(var i = 0; i < vaValue.length; i++) {
    vsValue = vaValue[i];
    vbBreak = false;
    var voIterator = this.frontItems.getValueCollection().iterator();
    var voItem = null;
    while (voIterator.hasNext()) {
      voItem = voIterator.next();
      voCtrl = voItem.getItemCtrl(poDocument);
      voItem.selected = false;
      if (voItem.getValue() == vsValue) {
        voCtrl.checked = true;
        voItem.selected = true;
        vbBreak = true;
        break;
      }
    }
    if(vbBreak) continue;
    voIterator = this.itemset.getValueCollection().iterator();
    while (voIterator.hasNext()) {
      voItem = voIterator.next();
      voCtrl = voItem.getItemCtrl(poDocument);
      voItem.selected = false;
      if (voItem.getValue() == vsValue) {
        voCtrl.checked = true;
        voItem.selected = true;
        vbBreak = true;
        break;
      }
    }
    if(vbBreak) continue;
    voIterator = this.backItems.getValueCollection().iterator();
    while (voIterator.hasNext()) {
      voItem = voIterator.next();
      voCtrl = voItem.getItemCtrl(poDocument);
      voItem.selected = false;
      if (voItem.getValue() == vsValue) {
        voCtrl.checked = true;
        voItem.selected = true;
        vbBreak = true;
        break;
      }
    }
  }
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined) {
    var vsOldValue = this.onchangeInitValue;
    if(vsOldValue instanceof Array) vsOldValue = vsOldValue.join();
    if(vsOldValue != vaValue.join()) vbChanged = true;
  }
  this.onchangeInitValue = vaValue;
  this.value = vaValue;
  if(!!this.data.instanceId && !!this.data.instancePath) {
    if(vbChanged) this.data.setData(this.value);
  }
};
/**
 * 모든 아이템의 selected속성을 초기화 시킵니다.
 */
eXria.controls.xhtml.Select.prototype.clearSelected = function() {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.selected = false;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.selected = false;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    voItem.selected = false;
  }
};
/**
 * 모든 아이템의 체크버튼을 초기화 시킵니다.
 */
eXria.controls.xhtml.Select.prototype.clearChecked = function() {
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  var voCtrl = null;
  var voDocument = this.document;

  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    voCtrl = voItem.getItemCtrl(voDocument);
    voCtrl.checked = false;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    voCtrl = voItem.getItemCtrl(voDocument);
    voCtrl.checked = false;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voItem = voIterator.next();
    if(voItem.visible == false) continue;
    voCtrl = voItem.getItemCtrl(voDocument);
    voCtrl.checked = false;
  }
};
/**
 * 아이템의 선택 버튼을 체크하여 아이템의 selected 속성 값을 갱신합니다.
 */
eXria.controls.xhtml.Select.prototype.checkSelected = function() {
  var voCtrl = null;
  var voIterator = this.frontItems.getValueCollection().iterator();
  var voItem = null;
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl();
    if (voCtrl.checked == true) voItem.selected = true;
    else voItem.selected = false;
  }
  voIterator = this.itemset.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl();
    if (voCtrl.checked == true) voItem.selected = true;
    else voItem.selected = false;
  }
  voIterator = this.backItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    voCtrl = voItem.getItemCtrl();
    if (voCtrl.checked == true) voItem.selected = true;
    else voItem.selected = false;
  }
};
/**
 * 아이템 위치를 새로고침 합니다.
 * @param {String} psPosition 라벨의 상대 위치(left/right/top/bottom)
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.Select.prototype.setLabelPos = function(psPosition, poDocument) {
  this.itemgroup.labelPos = psPosition;
  this.refresh(poDocument);
};
/**
 * 각 속성에 따른 디폴트 값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.Select.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  var vaAttrName = psAttrName.split(".");
  var vsType = this.toString();
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default[vsType][psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default[vsType][vaAttrName[0]][vaAttrName[1]];
  }
  if(vsDefaultValue === undefined) { return null;}
  return vsDefaultValue;
};
/**
 * loadData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Select.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
  }
  if(poDocument == null) poDocument = document;
  var voCtrl = this.getCtrl(poDocument);

  this.loadNodesetData(poDocument, voCtrl);
  this.loadRefData();
  this.loadDataDisplay(poDocument, voCtrl);
};
/**
 * loadNodesetData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Select.prototype.loadNodesetData = function(poDocument, poCtrl) {
  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    this.loadNodesetDataFromPluginInstance(poDocument, poCtrl);
    return;
  }

  var voCollectionNode = null;
  if(this.data.nodesetInstanceId && this.data.nodesetInstancePath) voCollectionNode = this.data.getNodesetData2();
  var vsLabelTagName = this.getAttrValue("labelTagName", this.labelTagName);
  var vsVauleTagName = this.getAttrValue("valueTagName", this.valueTagName);

  if(voCollectionNode && vsLabelTagName && vsVauleTagName) {
    var vnLoop = voCollectionNode.getLength();
    var voMapNode = null;
    for (var i = 0; i < vnLoop; i++) {
      voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
      var vsLabel = voMapNode.get(vsLabelTagName);
      var vsValue = voMapNode.get(vsVauleTagName);
      if(vsLabel != null && vsValue != null) var voItem = this.addToItemset(vsLabel, vsValue, poCtrl, poDocument);
    }
  }
};
/**
 * loadNodesetDataFromPluginInstance
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Select.prototype.loadNodesetDataFromPluginInstance = function(poDocument, poCtrl) {
  var voCollectionNode = null;
  if(this.data.nodesetInstanceId && this.data.nodesetInstancePath) voCollectionNode = this.data.getNodesetStr();
  if(voCollectionNode) voCollectionNode = eval(voCollectionNode);
  var vsLabelTagName = this.getAttrValue("labelTagName", this.labelTagName);
  var vsVauleTagName = this.getAttrValue("valueTagName", this.valueTagName);

  if(voCollectionNode && vsLabelTagName && vsVauleTagName) {
    var vnLoop = voCollectionNode.length;
    var voMapNode = null;
    for (var i = 0; i < vnLoop; i++) {
      voMapNode = voCollectionNode[i];
      var vsLabel = voMapNode[vsLabelTagName];
      var vsValue = voMapNode[vsVauleTagName];
      if(vsLabel != null && vsValue != null) var voItem = this.addToItemset(vsLabel, vsValue, poCtrl, poDocument);
    }
  }
};
/**
 * loadRefData
 * @private
 */
eXria.controls.xhtml.Select.prototype.loadRefData = function() {
  this.selectedItems.clear();
  var vsRefValue = null;
  var vaValue = [];
  if(this.data.instanceId && this.data.instancePath) vsRefValue = this.data.getData();
  if(vsRefValue != null) {
    if(vsRefValue instanceof Array) vaValue = vsRefValue;
    else if(vsRefValue != null) vaValue.push(vsRefValue);
    //this.refValue = vaValue;
    this.value = vaValue;
  } else {
    //this.refValue = null;
    this.value = null;
  }
  if(this.value) this.clearSelected();
};

//eXria.controls.xhtml.Select.prototype.loadDataDisplay = function(poDocument, poCtrl) {
//  var vnIndex = 0;
//  var vnSelectedIndex = 0;
//  var voIterator = this.frontItems.getKeyCollection().iterator();
//  var voItem = null;
//  var vsKey = null;
//  while (voIterator.hasNext()) {
//    vsKey = voIterator.next();
//    voItem = this.frontItems.get(vsKey);
//
//   if(voItem.visible == false) continue;
//    if(this.refValue) {
//      for(var i = 0; i < this.refValue.length; i++) {
//        if(this.refValue[i] == voItem.value) {
//          voItem.selected = true;
//          this.selectedItems.put(vnSelectedIndex, voItem);
//          vnSelectedIndex = vnSelectedIndex + 1;
//          break;
//        }
//      }
//    }
//    this.setIdPos(voItem, vnIndex);
//    var voDivCtrl = voItem.createCtrl(poDocument);
//    voItem.setSpecificDefaults(voDivCtrl, poDocument);
//    voItem.setSpecificAttrs(voDivCtrl, poDocument);
//    poCtrl.appendChild(voDivCtrl);
//    vnIndex++;
//  }
//
//  voIterator = this.itemset.getKeyCollection().iterator();
//  while (voIterator.hasNext()) {
//    vsKey = voIterator.next();
//    voItem = this.itemset.get(vsKey);
//    if(voItem.visible == false) continue;
//
//    if(this.refValue) {
//      for(var i = 0; i < this.refValue.length; i++) {
//        if(this.refValue[j] == voItem.value) {
//          voItem.selected = true;
//          this.selectedItems.put(vnSelectedIndex, voItem);
//          vnSelectedIndex = vnSelectedIndex + 1;
//          break;
//        }
//      }
//    }
//
//    this.setIdPos(voItem, vnIndex);
//    var voDivCtrl = voItem.createCtrl(poDocument);
//    voItem.setSpecificDefaults(voDivCtrl, poDocument);
//    voItem.setSpecificAttrs(voDivCtrl, poDocument);
//    poCtrl.appendChild(voDivCtrl);
//    vnIndex++;
//  }
//
//  voIterator = this.backItems.getKeyCollection().iterator();
//  while (voIterator.hasNext()) {
//    vsKey = voIterator.next();
//    voItem = this.backItems.get(vsKey);
//    if(voItem.visible == false) continue;
//
//    if(this.refValue) {
//      for(var i = 0; i < this.refValue.length; i++) {
//        if(this.refValue[j] == voItem.value) {
//          voItem.selected = true;
//          this.selectedItems.put(vnSelectedIndex, voItem);
//          vnSelectedIndex = vnSelectedIndex + 1;
//          break;
//        }
//      }
//    }
//
//    this.setIdPos(voItem, vnIndex);
//    voDivCtrl = voItem.createCtrl(poDocument);
//    voItem.setSpecificDefaults(voDivCtrl, poDocument);
//    voItem.setSpecificAttrs(voDivCtrl, poDocument);
//    poCtrl.appendChild(voDivCtrl);
//    vnIndex++;
//  }
//
//  if(this.refValue) {
//    this.setValue(this.refValue, poDocument);
//  }
//};
/**
 * loadDataDisplay
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Select.prototype.loadDataDisplay = function(poDocument, poCtrl) {
  var vaInnStrBuf = [];
  var vnIndex = 0;
  var voIterator = this.frontItems.getKeyCollection().iterator();
  var voItem = null;
  var vsKey = null;
  var voValue = this.value;
  var voSelectedItems = this.selectedItems;
  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voItem = this.frontItems.get(vsKey);
    voItem.window = this.window;
    voItem.document = this.document;

   if(voItem.visible == false) continue;
    //if(this.refValue) {
   if(voValue) {
      for(var i = 0; i < voValue.length; i++) {
        if(voValue[i] == voItem.value) {
          if(voSelectedItems.size() > 0 && this.type == "radio") {
            this.clearSelected();
            this.selectedItems.clear();
          }
          voItem.selected = true;
          voSelectedItems.put(vnIndex, voItem);
          break;
        }
      }
    }
    this.setIdPos(voItem, vnIndex);
    vaInnStrBuf.push(voItem.getInnerHTML());
    vnIndex++;
  }

  voIterator = this.itemset.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voItem = this.itemset.get(vsKey);
    if(voItem.visible == false) continue;

    //if(this.refValue) {
    if(voValue) {
      for(var i = 0; i < voValue.length; i++) {
        if(voValue[i] == voItem.value) {
          if(voSelectedItems.size() > 0 && this.type == "radio") {
            this.clearSelected();
            this.selectedItems.clear();
          }
          voItem.selected = true;
          voSelectedItems.put(vnIndex, voItem);
          break;
        }
      }
    }

    this.setIdPos(voItem, vnIndex);
    vaInnStrBuf.push(voItem.getInnerHTML());
    vnIndex++;
  }

  voIterator = this.backItems.getKeyCollection().iterator();
  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voItem = this.backItems.get(vsKey);
    if(voItem.visible == false) continue;

    //if(this.refValue) {
    if(voValue) {
      for(var i = 0; i < voValue.length; i++) {
        if(voValue[i] == voItem.value) {
          if(voSelectedItems.size() > 0 && this.type == "radio") {
            this.clearSelected();
            this.selectedItems.clear();
          }
          voItem.selected = true;
          voSelectedItems.put(vnIndex, voItem);
          break;
        }
      }
    }

    this.setIdPos(voItem, vnIndex);
    vaInnStrBuf.push(voItem.getInnerHTML());
    vnIndex++;
  }

  var vaTemplate = this.template;
  vaTemplate[0] = vaInnStrBuf.join("");
  poCtrl.innerHTML = vaTemplate.join("");

  vaInnStrBuf = null;
  //vaTemplate = null;
  //this.template = null;

  if(voValue) {
    this.setValue(voValue, poDocument);
  }
};
/**
 * 로딩된 아이템을 새로고침 합니다.(아이템들을 리로딩 하지 않는다는 점에서 refresh메소드와 구별됨)
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Select.prototype.repaint = function(poDocument) {
  if(poDocument == null) poDocument = document;
  var voCtrl = this.getCtrl(poDocument);
//  for (var i = 0; i < voCtrl.childNodes.length;) {
//    voCtrl.removeChild(voCtrl.childNodes[i]);
//  }
  this.removeUIGeneralDefaults(voCtrl, poDocument);
  this.removeSpecificDefaults(voCtrl, poDocument);
  this.refreshTemplate(voCtrl, poDocument);
  this.refreshUIGeneralDefaults(voCtrl, poDocument);
  this.refreshSpecificDefaults(voCtrl, poDocument);
  this.refreshSpecificAttrs(voCtrl, poDocument);
  this.loadDataDisplay(poDocument, voCtrl);
};

/**
 * @fileoverview
 * Concreate xhtml RadioButton(XHTML RadioButton 컨트롤)
 * @author 김경태
 */

/**
 * @class 선택영역에서 어느 하나를 선택 또는 취소하기 위해 사용하는 컨트롤을 생성하는 class입니다. <br />
 * 선택 버튼과 같은 의미로 사용되며, 일련의 선택 사항 중 한 번에 하나씩만 선택하게 되어 있습니다.<br />
 * XHTML RadioButton Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.RadioButton 객체
 * @type eXria.controls.xhtml.RadioButton
 * @constructor
 * @base eXria.controls.xhtml.Select
 */
eXria.controls.xhtml.RadioButton = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 250 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.Select.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 선택 버튼 타입.
   * @ignore
   * @type String
   */
  this.type = "radio";
  /**
   * 아이템 다중선택 여부.
   * @ignore
   * @type Boolean
   */
  this.multiple = false;

  /**
   * @private
   */
  this.cursor = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Select, eXria.controls.xhtml.RadioButton);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 클래스 명을 반환합니다.
 * @return "RadioButton"
 * @type String
 */
eXria.controls.xhtml.RadioButton.prototype.toString = function(){
  return "RadioButton";
};


/**
 * @fileoverview
 * Concreate xhtml CheckBox(XHTML 체크박스 컨트롤)
 * @author 김경태
 */

/**
 * @class 선택영역에서 어느 하나를 선택 또는 취소하기 위해 사용하는 버튼입니다. <br />
 * 선택 버튼과 같은 의미로 사용되며, 동시에 여러개를 선택할 수 있습니다.<br />
 * XHTML CheckBox Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.CheckBox 객체
 * @type eXria.controls.xhtml.CheckBox
 * @constructor
 * @base eXria.controls.xhtml.Select
 */
 eXria.controls.xhtml.CheckBox = function(psId,pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 250 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.Select.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.

  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this); // DataRef 생성 연결

  //////////////////////////////////////////////////////////////////
  // 속성

  /**
   * 선택 버튼 타입('checkbox').
   * @type String
   * @private
   */
  this.type = "checkbox";

  /**
   * 다중선택 여부(true).
   * @type Boolean
   * @private
   */
  this.multiple = true;

  /**
   * 마우스 커서 스타일 설정
   * @type String
   */
  this.cursor = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Select, eXria.controls.xhtml.CheckBox);

//////////////////////////////////////////////////////////////////
// 메소드
/**
 * 클래스 명을 반환합니다.
 * @returns {String} "CheckBox"
 */
eXria.controls.xhtml.CheckBox.prototype.toString = function(){
  return "CheckBox";
};

/**
 * @fileoverview
 * Concreate xhtml Rectangle(XHTML Rectangle 컨트롤)
 * @author 이종녕
 */

/**
 * @class xhtml Rectangle Control.<br>
 * 사각형 도형을 표현하는 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Rectangle 객체
 * @type eXria.controls.xhtml.Rectangle
 * @constructor
 * @base eXria.controls.xhtml.ShapeControl
 */
eXria.controls.xhtml.Rectangle = function(psId, pnLeft, pnTop, pnWidth, pnHeight){
  /**
   * pnLeft 컨트롤 좌상단 점의 x좌표.
   * @type Number
   */
  pnLeft =  pnLeft == null ? 20 : pnLeft;
  /**
   * pnTop 컨트롤 좌상단 점의 y좌표.
   * @type Number
   */
  pnTop =  pnTop == null ? 20 : pnTop;
  /**
   * pnWidth 컨트롤의 가로 길이.
   * @type Number
   */
  pnWidth =  pnWidth == null ? 100 : pnWidth;
  /**
   * pnHeight 컨트롤의 세로 길이.
   * @type Number
   */
  pnHeight =  pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.ShapeControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 도형 채움 색상의 글라데이션 시작 값.
   * @type String
   */
  this.fillStartColor = null;
  /**
   * 도형 채움 색상의 글라데이션 마무리 값.
   * @type String
   */
  this.fillEndColor = null;
  /**
   * 도형 색상 채움 타입.<br>
   * "none" | "solid" | "gradient" | "gradientradial" (default:solid)
   * @type String
   */
  this.fillType = null;
  /**
   * 글라데이션 진행 각도.
   * @type Number
   */
  this.fillAngle = null;
  /**
   * 색상 채움 불투명도.
   * @type Number
   */
  this.fillOpacity = null;
  /**
   * 컨트롤의 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.ShapeControl, eXria.controls.xhtml.Rectangle);
//////////////////////////////////////////////////////////////////
//// 메소드
/**
 * 실체화 컨트롤 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return voDiv
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.createCtrl = function(poDocument){
  var voDiv = poDocument.createElement("div");
    var voStyle = voDiv.style;
    voDiv.setAttribute("id",this.id);
    voStyle.padding = "0px";
    voStyle.margin = "0px";
    voStyle.borderStyle = "none";
    voStyle.borderWidth = "0px";
    voStyle.overflow = "visible";

    this.ctrl = voDiv;
  return voDiv;
};
/**
 * 지정된 각도를 -90 ~ 90도 사이에 값으로 변환하는 메소드.
 * @param {Number} pnAngle 지정한 각도
 * @return 변경된 각도
 * @type Number
 */
eXria.controls.xhtml.Rectangle.prototype.quartAngle = function(pnAngle) {
  var vnNumber = pnAngle%180;
  if( vnNumber > 90) vnNumber = 180 - vnNumber;
  return vnNumber;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Rectangle.prototype.angleHeight = function(pnWidth,pnHeight) {
  /*
  var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.height/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.quartAngle(this.angle)));
  vnR = vnR*vnL;
  return Math.round(vnR);
  */
  var vnAngle = this.angle % 180;
  var vnR1 = pnWidth * Math.sin(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.cos(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Rectangle.prototype.angleWidth = function(pnWidth,pnHeight) {
  /* var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.width/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.quartAngle(this.angle)));
  vnR = vnR*vnL;
  return Math.round(vnR); */
  var vnAngle = this.angle % 180;
  var vnR1 = pnWidth * Math.cos(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.sin(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/**
 * 도형 객체 생성.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.createRectangleCtrl = function(poCtrl,poDocument){
  var voWindow = this.window;
  poCtrl.style.top = this.top + "px";
  poCtrl.style.left = this.left + "px";
  var vnDistanceY = this.angleHeight(this.width,this.height);
  var vnDistanceX = this.angleWidth(this.width,this.height);
  var vnHeight = vnDistanceY - this.height/2;
  var vnWidth = vnDistanceX - this.width/2;
  gCore.init(voWindow); // 초기화.....
  var voDf = this.df;
  var pane = new voWindow.Pane(this.id+"_draw",-vnWidth,-vnHeight,vnDistanceX*2,vnDistanceY*2,poDocument);
  var border = voDf.penWeight/2;
  /* if(this.df.angle == 0) var voCtrl = new Rectangle(this.id+"_rect", 0, 0, this.width, this.height);
  else */
  var vnCtrlHeight = this.height-voDf.penWeight;
  var vnCtrlWidth = this.width-voDf.penWeight;
  if(gCore.browser.msie && gCore.browser.msie < 9 && border%1 == 0){
    vnCtrlHeight -= 1;
    vnCtrlWidth -= 1;
  }
  var voCtrl = new voWindow.Rectangle(this.id+"_rect",border+vnWidth, border+vnHeight, vnCtrlWidth, vnCtrlHeight);
  var voCtrlStroke = voCtrl.stroke;
  var voCtrlFill = voCtrl.fill;
  voCtrlStroke.weight = voDf.penWeight + "px";
  voCtrlStroke.color = voDf.penColor;
  voCtrlStroke.type = this.toConstPenstyle(voDf.penStyle);
  voCtrlStroke.opacity = this.toPercent(voDf.penOpacity);
  if(voDf.penColor == "transparent") voCtrlStroke.opacity = 0;
  voCtrlStroke.lineCap = this.toConstPencap(voDf.penCap);
  voCtrlStroke.joinType = this.toConstJointype(voDf.joinType);
  voCtrlFill.color = voDf.fillStartColor;
  voCtrlFill.color2 = voDf.fillEndColor;
  voCtrlFill.type = voDf.fillType;
  voCtrlFill.angle = voDf.fillAngle;
  voCtrlFill.opacity = this.toPercent(voDf.fillOpacity);
  voCtrl.angle = voDf.angle;
  voCtrl.cursor = voDf.cursor;
  pane.addShape(voCtrl);
  pane.draw(poCtrl);
};
/**
 * setMainCtrlStyles.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
//eXria.controls.xhtml.Rectangle.prototype.setMainCtrlStyles = function(poCtrl,poDocument) {
//};
/**
 * setSpecificDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.setSpecificDefaults = function(poCtrl,poDocument) {
  var voDf = this.df;
  voDf.fillStartColor = this.getAttrValue("fillStartColor",this.fillStartColor);
  voDf.fillEndColor = this.getAttrValue("fillEndColor", this.fillEndColor);
  voDf.fillType = this.getAttrValue("fillType",this.fillType);
  voDf.fillAngle = this.getAttrValue("fillAngle",this.fillAngle);
  voDf.fillOpacity = this.getAttrValue("fillOpacity",this.fillOpacity);
};
/**
 * setSpecificAttrs.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.setSpecificAttrs = function(poCtrl,poDocument) {
  this.createRectangleCtrl(poCtrl,poDocument);
};
/**
 * setAttrSubCtrl.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
};
/**
 * setSpecificEvents.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.setSpecificEvents = function(poCtrl,poDocument) {
};
/**
 * removeSpecificDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.removeSpecificDefaults = function(poCtrl,poDocument) {
  this.df = {};
};
/**
 * refreshSpecificAttrs.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.refreshSpecificAttrs = function(poCtrl,poDocument){
  var voDiv = this.getCtrl(poDocument);
  var voPaneCtrl = voDiv.childNodes[0];
  voDiv.removeChild(voPaneCtrl);
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * applyAttrRefresh.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Rectangle.prototype.applyAttrRefresh = function(psAttrName, psAttrValue, poDocument) {
  this.setAttr(psAttrName, psAttrValue);
//  this.setAttrCtrl(psAttrName, psAttrValue);
//  var voDiv = this.getCtrl(poDocument);
//  var voPaneCtrl = voDiv.childNodes[0];
//  voDiv.removeChild(voPaneCtrl);
//  this.createRectangleCtrl(voDiv,poDocument);
  this.refresh(poDocument);
};
/**
* 서브 컨트롤 실체화 객체를 얻어온다.
* @param {String} psTagName
* @return (Object) subControl
* @private
*/
eXria.controls.xhtml.Rectangle.prototype.getSubCtrl = function(psTagName,poCtrl,poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 */
eXria.controls.xhtml.Rectangle.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Rectangle[psAttrName];
  if(vsDefaultValue == null) vsDefaultValue = this.getShapeDefaultValue(psAttrName);
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "Rectangle"
 * @type String
 */
eXria.controls.xhtml.Rectangle.prototype.toString = function() {
  return "Rectangle";
};

/**
 * @fileoverview
 * Concreate Shape Roundrect(XHTML Roundrect 컨트롤)
 * @author 이종녕
 */

/**
 * @class xhtml Roundrect Control.<br>
 * 모서리가 둥근 사각형 도형을 표현하는 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Roundrect 객체
 * @type eXria.controls.xhtml.Roundrect
 * @constructor
 * @base eXria.controls.xhtml.ShapeControl
 */
eXria.controls.xhtml.Roundrect = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  /**
   * pnLeft 컨트롤 좌상단 점의 x좌표.
   * @type Number
   */
  pnLeft =  pnLeft == null ? 20 : pnLeft;
  /**
   * pnTop 컨트롤 좌상단 점의 y좌표.
   * @type Number
   */
  pnTop =  pnTop == null ? 20 : pnTop;
  /**
   * pnWidth 컨트롤의 가로 길이.
   * @type Number
   */
  pnWidth =  pnWidth == null ? 100 : pnWidth;
  /**
   * pnHeight 컨트롤의 세로 길이.
   * @type Number
   */
  pnHeight =  pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.ShapeControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 도형 채움 색상의 글라데이션 시작 값.
   * @type String
   */
  this.fillStartColor = null;
  /**
   * 도형 채움 색상의 글라데이션 마무리 값.
   * @type String
   */
  this.fillEndColor = null;
  /**
   * 도형 색상 채움 타입.<br>
   * "none" | "solid" | "gradient" | "gradientradial"  (default:solid)
   * @type String
   */
  this.fillType = null;
  /**
   * 글라데이션 진행 각도.
   * @type Number
   */
  this.fillAngle = null;
  /**
   * 색상 채움 불투명도.
   * @type Number
   */
  this.fillOpacity = null;
  /**
   * 사각형 모서리 곡률.
   * @type Number
   */
  this.round = null;
  /**
   * 컨트롤의 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.ShapeControl, eXria.controls.xhtml.Roundrect);
//////////////////////////////////////////////////////////////////
//// 메소드
/**
 * 실체화 컨트롤 생성.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 실체화 객체의 최외곽 div
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.createCtrl = function(poDocument){
  var voDiv = poDocument.createElement("div");
  var voStyle = voDiv.style;
  voDiv.setAttribute("id",this.id);
  voStyle.padding = "0px";
  voStyle.margin = "0px";
  voStyle.borderStyle = "none";
  voStyle.borderWidth = "0px";
  this.ctrl = voDiv;
  return voDiv;
};
/**
 * 지정된 각도를 -90 ~ 90도 사이에 값으로 변환하는 메소드.
 * @param {Number} pnAngle 지정한 각도
 * @return 변경된 각도
 * @type Number
 */
eXria.controls.xhtml.Roundrect.prototype.quartAngle = function(pnAngle) {
  var vnNumber = pnAngle%180;
  if( vnNumber > 90) vnNumber = 180 - vnNumber;
  return vnNumber;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 세로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Roundrect.prototype.angleHeight = function(pnWidth,pnHeight) {
  /*var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.height/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.quartAngle(this.angle)));
  vnR = vnR*vnL;
  return Math.round(vnR);*/
  var vnAngle = this.angle % 90;
  var vnR1 = pnWidth * Math.sin(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.cos(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/**
  * 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2 반환.
  * @param {Number} pnWidth 컨트롤의 가로 길이
  * @param {Number} pnHeight 컨트롤의 세로 길이
  * @return 도형이 회전했을 때 회전된 div영역을 포함하는 사각형 영역의 가로 길이의 1/2
  * @type Number
  */
eXria.controls.xhtml.Roundrect.prototype.angleWidth = function(pnWidth,pnHeight) {
  /*var vnR = Math.pow(pnWidth,2) + Math.pow(pnHeight,2);
  vnR = (Math.sqrt(vnR)/2);
  var vnAngle = Math.asin(this.width/2/vnR)*180/Math.PI;
  var vnL = Math.sin(Math.PI/180*(vnAngle+this.quartAngle(this.angle)));
  vnR = vnR*vnL;
  return Math.round(vnR);*/
  var vnAngle = this.angle % 90;
  var vnR1 = pnWidth * Math.cos(vnAngle * Math.PI / 180);
  var vnR2 = pnHeight * Math.sin(vnAngle * Math.PI / 180);
  var vnR = (vnR1 + vnR2)/2;
  return vnR;
};
/*
 * 지정된 round값을 컨트롤의 크기에 맞는 round값으로 반환
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return vnRound
 * @type Number
 */
eXria.controls.xhtml.Roundrect.prototype.getRound = function(pnWidth, pnHeight){
  var vnL = pnHeight;
  if(pnWidth < pnHeight) vnL = pnWidth;
  var vnRound = this.df.round / vnL * 2;
  return vnRound;
};
/**
 * 도형 객체 생성.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.createRoundrectCtrl = function(poCtrl,poDocument){
  var voWindow = this.window;
  poCtrl.style.top = this.top ;
  poCtrl.style.left = this.left;
  var vnDistanceY = this.angleHeight(this.width,this.height);
  var vnDistanceX = this.angleWidth(this.width,this.height);
  var vnHeight = (vnDistanceY - this.height/2);
  var vnWidth = (vnDistanceX - this.width/2);
  gCore.init(voWindow); // 초기화.....
  var pane = new voWindow.Pane(this.id+"_draw",-vnWidth,-vnHeight,vnDistanceX*2,vnDistanceY*2,poDocument);
  var border = this.df.penWeight/2;
  //var voRound = this.toPercent(this.df.round);
  var voRound = this.getRound(this.width,this.height);
  /*if(this.angle != 0) var voCtrl = new RoundRect(this.id+"roundrect",border+vnWidth, border+vnHeight, this.width-(border*2), this.height-(border*2),voRound);
  else var voCtrl = new RoundRect(this.id+"roundrect", 0, 0, this.width, this.height,voRound); */
  var vnCtrlHeight = this.height-this.df.penWeight;
  var vnCtrlWidth = this.width-this.df.penWeight;
  if(gCore.browser.msie && gCore.browser.msie < 9 && border%1 == 0){
    vnCtrlHeight -= 1;
    vnCtrlWidth -= 1;
  }
  var voCtrl = new voWindow.RoundRect(this.id+"_roundrect",border+vnWidth, border+vnHeight, vnCtrlWidth, vnCtrlHeight,voRound);
  var voCtrlStroke = voCtrl.stroke;
  var voCtrlFill = voCtrl.fill;
  var voDf = this.df;
  voCtrlStroke.weight = voDf.penWeight + "px";
  voCtrlStroke.color = voDf.penColor;
  voCtrlStroke.type = this.toConstPenstyle(voDf.penStyle);
  voCtrlStroke.opacity = this.toPercent(voDf.penOpacity);
  if(voDf.penColor == "transparent") voCtrlStroke.opacity = 0;
  voCtrlStroke.lineCap = this.toConstPencap(voDf.penCap);
  voCtrlStroke.joinType = this.toConstJointype(voDf.joinType);
  voCtrlFill.color = voDf.fillStartColor;
  voCtrlFill.color2 = voDf.fillEndColor;
  voCtrlFill.type = voDf.fillType;
  voCtrlFill.angle = voDf.fillAngle;
  voCtrlFill.opacity = this.toPercent(voDf.fillOpacity);
  voCtrl.angle = voDf.angle;
  voCtrl.cursor = voDf.cursor;
  pane.addShape(voCtrl);
  pane.draw(poCtrl);
};

/**
 * setSpecificDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.setSpecificDefaults = function(poCtrl,poDocument) {
  var voDf = this.df;
  voDf.round = this.getAttrValue("round",this.round);
  voDf.fillStartColor = this.getAttrValue("fillStartColor",this.fillStartColor);
  voDf.fillEndColor = this.getAttrValue("fillEndColor", this.fillEndColor);
  voDf.fillType = this.getAttrValue("fillType",this.fillType);
  voDf.fillAngle = this.getAttrValue("fillAngle",this.fillAngle);
  voDf.fillOpacity = this.getAttrValue("fillOpacity",this.fillOpacity);
};
/**
 * setSpecificAttrs.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.setSpecificAttrs = function(poCtrl,poDocument) {
  this.createRoundrectCtrl(poCtrl,poDocument);
};
/**
 * setAttrSubCtrl.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
};
/**
 * setSpecificEvents.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.setSpecificEvents = function(poCtrl,poDocument) {
};
/**
 * removeSpecificDefaults.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.removeSpecificDefaults = function(poCtrl,poDocument) {
  this.df = {};
};
/**
 * refreshSpecificAttrs.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.refreshSpecificAttrs = function(poCtrl,poDocument){
  var voDiv = this.getCtrl(poDocument);
  var voPaneCtrl = voDiv.childNodes[0];
  voDiv.removeChild(voPaneCtrl);
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * applyAttrRefresh.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.Roundrect.prototype.applyAttrRefresh = function(psAttrName, psAttrValue, poDocument) {
  this.setAttr(psAttrName, psAttrValue);
//  this.setAttrCtrl(psAttrName, psAttrValue);
//  var voDiv = this.getCtrl(poDocument);
//  var voPaneCtrl = voDiv.childNodes[0];
//  voDiv.removeChild(voPaneCtrl);
//  this.createRoundrectCtrl(voDiv,poDocument);
  this.refresh(poDocument);
};
/**
* 서브 컨트롤 실체화 객체를 얻어온다.
* @param {String} psTagName
* @return (Object) subControl
* @private
*/
eXria.controls.xhtml.Roundrect.prototype.getSubCtrl = function(psTagName,poCtrl,poDocument) {
  if(poCtrl == null || poCtrl == undefined) { poCtrl = this.getCtrl(poDocument); }
  var subCtrl = poCtrl.getElementsByTagName(psTagName)[0];
  return subCtrl;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 */
eXria.controls.xhtml.Roundrect.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.Roundrect[psAttrName];
  if(vsDefaultValue == null) vsDefaultValue = this.getShapeDefaultValue(psAttrName);
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "Roundrect"
 * @type String
 */
eXria.controls.xhtml.Roundrect.prototype.toString = function() {
  return "Roundrect";
};

/**
 * @fileoverview
 * Concreate xhtml SecretBox(XHTML SecretBox 컨트롤)
 * @author 이종녕
 */

/**
 * @class 암호 입력필드이며 입력받은 모든문자를 *로 나타내어주는 컨트롤을 생성하는 class입니다.<br />
 * @XHTML SecretBox Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.SecretBox 객체
 * @type eXria.controls.xhtml.SecretBox
 * @constructor
 * @base eXria.controls.xhtml.InputCommon
 */

eXria.controls.xhtml.SecretBox = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.InputCommon.call(this, psId,pnLeft, pnTop, pnWidth, pnHeight);

  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.InputCommon, eXria.controls.xhtml.SecretBox);
////////////////////////////////////////////////////////
////  메소드
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<input class='" + vsClass + "' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_secret' type='password' ");
  vaTemplate.push("@attStrBuf"); //0
  vaTemplate.push("style=\"");
  vaTemplate.push("@cssStrBuf");  //1
  vaTemplate.push("\"/>");
  vaTemplate.push("<span class='" + vsClass + "'" + " style=\"");
  vaTemplate.push("@cssStrBuf"); //2
  vaTemplate.push("\"/>");
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  // loadcomplate에서 처리
  //if(this.textAlign == "right" && this.paddingRight == 0) this.paddingRight = 2;
  this.verticalAlign = this.getAttrValue("verticalAlign",this.verticalAlign);
  this.maxLength = this.getAttrValue("maxLength",this.maxLength);
  this.minLength = this.getAttrValue("minLength",this.minLength);
  this.value = this.getAttrValue("value",this.value);
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.setSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "value", this.value);
  if(this.readOnly) vfcSetAttStrBuf(vaAttStrBuf, "readOnly", this.readOnly);
  vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maxLength);
  vfcSetAttStrBuf(vaAttStrBuf, "minLength", this.minLength);
  vaTemplate[voIndexMap.get(0)] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transForm", this.textTransform);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  // loadcomplete에서 처리
  /*var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");*/
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(2)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  voIndexMap.clear();
  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;

  this.setSubElement(poDocument);
};

/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.SecretBox.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.input = this.getSubCtrl("input", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.SecretBox.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDf = this.df;
  var voSecret = this.subElement.input;
  var voSpan = this.subElement.span;
  switch(psAttrName) {
  case "width" :
    this.setInputWidth();
    break;
  case "height" :
    this.setVerticalAlign(voSecret, poCtrl, voDf.verticalAlign);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.dofocus = function() {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  try { voInput.focus(); }catch(err) {}
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.atchange = function(poCtrl){

  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vsValue = voInput.value;
  this.setValue(vsValue);
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.atkeydown = function(e){
  if(e.keyCode == 13) {
    this.isEnter = true;
    var voInput = this.subElement.input;
    var vsValue = voInput.value;
    this.setValue(vsValue);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.atfocus = function(e) {
  if(this.focused != true) this.selectText();
  this.focused = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.atblur = function(e) {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vsValue = voInput.value;

  if(!!this.inputMode){
  vsValue = eXria.controls.xhtml.Util.getValueFromInputMode(String(vsValue), this.inputMode);
  voInput.value = vsValue;
  }


  this.setValue(vsValue);
//  var voCtrl = page.getControl();
//  this.setVerticalAlign(voCtrl);
  this.focused = false;
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.atclick = function(e){
  var voDocument = this.document;
  this.focused = true;
  var voInput = this.subElement.input;
  if(e.target == voInput) {
    if(voDocument.selection && voDocument.selection.createRange) {
      this.textRange = voDocument.selection.createRange();
    }
  } else {
    if(this.textRange) {
      this.textRange.select();
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.dofocus = function() {
  var voInput = this.subElement.input;
  if(this.focused == false) {
    try { voInput.focus(); }catch(err) {}
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var voInputCtrl = this.subElement.input;
  var voSpanCtrl = this.subElement.span;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  var vsInputValue = this.value;
  if(vsInputValue == null) vsInputValue = "";
  voInputCtrl["value"] = vsInputValue;
  if(this.readOnly) voInputCtrl["readOnly"] = this.readOnly;
  if(this.maxLength != null) voInputCtrl["maxLength"] = this.maxLength;
  if(this.minLength != null) voInputCtrl["minLength"] = this.minLength;

  if(this.className != null) voInputCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;border-style:none;border-width:0px;top:0px;left:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "text-transForm", this.textTransform);
  vfcSetCssStrBuf(vaCssStrBuf, "text-direction", this.dir);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  // 아래에서 setInputWidth에서 처리
  /*var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  voInputCtrl.style.cssText = vaCssStrBuf.join("");*/

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");

  this.setInputWidth();
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.SecretBox.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voInput = this.subElement.input;
  var vaAttrName = psAttrName.split(".");
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "disabled" :
    if(psAttrValue == true) this.doblur();
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "textAlign" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    this.setInputWidth();
    break;
  case "readOnly" :
  case "maxLength" :
  case "minLength" :
  case "value" :
  case "color" :
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    break;
  case "verticalAlign":
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "fontFamily" :
  case "fontSize" :
  case "fontStyle" :
  case "fontWeight" :
  case "textDecoration":
  case "textTransform":
    this.setAttrCtrl(psAttrName, psAttrValue, voInput);
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voInput, voCtrl, this.verticalAlign);
    break;
  case "outerClassName":
  case "className":
    this.refresh(poDocument);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setInputWidth();
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setInputWidth();
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    this.setInputWidth();
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "padding" :
    this.paddingTop = this.padding;
    this.paddingRight = this.padding;
    this.paddingBottom = this.padding;
    this.paddingLeft = this.padding;
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voInput);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voInput);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voInput);
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voInput);
    this.setInputWidth();
    break;
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
    //this.setVerticalAlign(voInput, voCtrl, voDf.verticalAlign);
    break;
  case "paddingRight":
  case "paddingLeft" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voInput);
    this.setInputWidth();
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 컨트롤에 값을 설정합니다.
 * @param {String} psData 설정할 값
 */
eXria.controls.xhtml.SecretBox.prototype.setValue = function(psData){
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psData) {
    vbChanged = true;
  }
  this.onchangeInitValue = psData;
  this.value = psData;
  var voSecret = this.subElement.input;
  voSecret.value = psData;
  if(vbChanged) {
    this.data.setData(this.value);
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
    if(this.changeEventCallback) this.changeEventCallback(voEvent);
  }
};
/**
 * 각 속성에 따른 디폴트 값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.SecretBox.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.SecretBox[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "SecretBox"
 * @type String
 */
eXria.controls.xhtml.SecretBox.prototype.toString = function() {
  return "SecretBox";
};

/**
 * @fileoverview
 * Concreate xhtml TabHeader, TabButton, TabPage, Tab
 * @author 조영진
 */

/**
 * 탭 컨트롤 헤더의 탭 버튼 공통 속성을 저장하기 위한 클래스.
 * @version 2.0
 * @type eXria.controls.xhtml.TabHeader_tabbuttons
 * @constructor
 */
eXria.controls.xhtml.TabHeader_tabbuttons = function() {
  /**
   * 탭 버튼의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 탭 버튼의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 탭 버튼의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 탭 버튼의 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 탭 버튼의 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 탭 버튼의 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 탭 버튼의 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 탭 버튼에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 탭 버튼에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 탭 버튼에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 탭 버튼에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 탭 버튼에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 탭 버튼간 간격(px).
   * @type Number
   */
  this.cellSpacing = null;
  /**
   * 탭 버튼의 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * 탭 버튼의 세로 길이.
   * readOnly 속성.
   * @type Number
   * @private
   */
  this.height = null;
  /**
   * 탭 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 선택된 탭 버튼의 배경이미지 url.
   * @type String
   */
  this.imageFocused = null;
  /**
   * 탭 버튼 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 탭 버튼 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * 탭 버튼의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 탭 버튼이 선택되었을 때의 배경 색상.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * 탭 버튼의 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * 탭 버튼이 선택되었을 때의 텍스트 색상.
   * @type String
   */
  this.focusColor = null;
  /**
   * 탭 버튼에 표시될 텍스트의 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 탭 버튼에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 탭 버튼에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 탭 버튼에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 탭 버튼에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 밑줄 적용 속성.
   * @type String
   */
  this.textDecoration = null;
  /**
   * 탭 버튼에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 탭 버튼에 외곽에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * 탭 컨트롤 헤더의 탭 버튼 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  /**
   * 탭 컨트롤 헤더의 탭 버튼 cursor값
   * @type String
   * @private
   */
  this.cursor = null;

  this.df = {};
};


/**
 * @class Concreate xhtml TabButton
 * XHTML Tab 컨트롤 헤더에 포함되는 탭 버튼 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.TabButton 객체
 * @type eXria.controls.xhtml.TabButton
 * @constructor
 * @base eXria.controls.xhtml.Button
 */
eXria.controls.xhtml.TabButton = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  eXria.controls.xhtml.Button.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 탭 헤더 참조
   * @type eXria.controls.xhtml.TabHeader
   * @private
   */
  this.parent = null;
  /**
   * Button의 subId 참조(탭 컨트롤 id가 제외된 값)
   * @private
   */
  this.subId = null;
  /**
   * 링크된 페이지 아이디(탭 컨트롤 id와 조합된 값) 참조
   * @type String
   * @private
   */
  this.pageId = null;
  /**
   * 링크된 페이지 아이디 참조(탭 컨트롤 id가 제외된 값)
   * @type String
   * @private
   */
  this.pageSubId = null;
  /**
   * @ignore
   */
  this.position = "relative";

};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Button, eXria.controls.xhtml.TabButton);
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<button hidefocus='true' type='button' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' style=\"");
  vaTemplate.push("@cssStrbuf"); //setSpecificAttrs메소드에서  스타일 속성이 대체될  부분은 @cssStrBuf로 마크(Element 속성의 경우엔 @attStrBuf로 마크)
  vaTemplate.push("\" class='" + vsClass + "'>");
  vaTemplate.push("@innStrBuf"); //setSpecificAttrs메소드에서 innerHTML이 대체될 부분은 @innStrBuf로 마크
  vaTemplate.push("</button>");
//  vaTemplate.push("<div style=\"");
//  vaTemplate.push("@cssStrBuf");
//  vaTemplate.push("\"><table style=\"position:absolute;left:0px;top:0px;width:100%;height:100%;font-family:Arial;font-weight:bold;\">");
//  vaTemplate.push("<tr><td align=\"center\" vAlign=\"middle\">x</td></tr></table></div>");
  var vcTab = this.parent.parent;
    if(vcTab.type == "minimizedWindow") {
    vaTemplate.push("<input type=\"button\" value=\"x\" HIDEFOCUS=\"true\" style=\"");
    vaTemplate.push("@cssStrBuf");
    vaTemplate.push("\" onclick=\"");
    vaTemplate.push(this.getEHandler2(this.pageId));
    vaTemplate.push("\"/>");
  }
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\"/>");
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  ///////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  ///////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존에 이와같은 코드가 있었는데 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  //////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  //////////////////////////////////////////////////////////////////////////////////////////

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[2] + "')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[1] + "')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(poCtrl.style["filter"]) poCtrl.style["filter"] = "";
    }
  }

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");
  vaTemplate[voIndexMap.get(1)] = this.getLabelText(this.value);

  var vnIndex = 2;
  var vcTab = this.parent.parent;
  if(vcTab.type == "minimizedWindow") {
    vaCssStrBuf = [];
    vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;border-width:0px;left:" + (this.innerWidth - 20) + "px;top:0px;");
    vaCssStrBuf.push("border-style:none;font-family:Arial;font-weight:bold;text-align:center;outline-style:none;");
    vfcSetCssStrBuf(vaCssStrBuf, "width", 20, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
    vaTemplate[voIndexMap.get(vnIndex++)] = vaCssStrBuf.join("");
  }

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(vnIndex)] = vaCssStrBuf.join("");
  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
eXria.controls.xhtml.TabButton.prototype.setSpecificEvents = function(poCtrl) {
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.atmouseover = function(poEvent) {
}
/**
* @ignore
*/
eXria.controls.xhtml.TabButton.prototype.atmouseout = function(poEvent) {
}
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.atclick = function(poEvent) {
  // 조영진 선임 추가 코드
  var voTabHeader = this.parent;
  var voTab = voTabHeader.parent;
  var voButton = poEvent.object;
  var vnIndex = voTab.getIndexById(voButton.pageId);
  if(vnIndex != voTab.selectedIndex) voTabHeader.select(vnIndex);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voBtn = voCtrl.childNodes[0];
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
//    if(this.borderLeftWidth == null) this.borderLeftWidth = this.borderWidth;
//    if(this.borderRightWidth == null) this.borderRightWidth = this.borderWidth;
//    if(this.borderTopWidth == null) this.borderTopWidth = this.borderWidth;
//    if(this.borderBottomWidth == null) this.borderBottomWidth = this.borderWidth;
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;

    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  //case "borderTopHeight" :
  case "borderBottomWidth" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "value" :
    this.setValue(psAttrValue, voBtn, poDocument);
    break;
  case "backgroundImage" :
  case "imageFocused" :
    if(this.focused) this.setAttrCtrl("backgroundImage", this.imageFocused, voBtn);
    else this.setAttrCtrl("backgroundImage", this.backgroundImage, voBtn);
    break;
  case "backgroundPosition":
  case "backgroundRepeat":
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "outerClassName" :
  case "className" :
  case "borderWidth" :
    this.refresh(poDocument);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.Tab.TabHeader.tabbuttons) vsDefaultValue = eXria.controls.xhtml.Default.Tab.TabHeader.tabbuttons[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabButton.prototype.getEHandler2 = function(psPageId) {
  var voTabHeader = this.parent;
  var voTab = voTabHeader.parent;
  var vnIndex = voTab.getIndexById(psPageId);
  var vaStrBuf = [];
  vaStrBuf.push("var voControl=page.getControl('");
  vaStrBuf.push(voTab.id);
  vaStrBuf.push("');");
  vaStrBuf.push("voControl.")
  vaStrBuf.push("removeMinimizedWindowTab(" + vnIndex + ");");
  vaStrBuf.push("var voEvent = new eXria.event.Event(event);");
  vaStrBuf.push("voEvent.stopEvent();");
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * 클래스 명을 반환.
 * @return "TabButton"
 * @type String
 */
eXria.controls.xhtml.TabButton.prototype.toString = function() {
  return "Tab_TabHeader_TabButtons";
};


/**
 * @class Concreate xhtml TabHeader.<br>
 * XHTML Tab 컨트롤의 헤더부분 구성.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.TabHeader 객체
 * @type eXria.controls.xhtml.TabHeader
 * @constructor
 * @base eXria.controls.xhtml.Group
 */
eXria.controls.xhtml.TabHeader = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  eXria.controls.xhtml.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  // 데이타 연동 관련
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 인스턴스로 부터 라벨 데이타를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.labelTagName = "label";
  /**
   * 인스턴스로 부터 button id를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.bidTagName = "buttonid";
  /**
   * 인스턴스로 부터 page id를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.pidTagName = "pageid";
  /**
   * 탭 버튼 이동에 이용되는 인덱스 번호.
   * @type Number
   * @private
   */
  this.scrollIndex = 0;
  /**
   * 탭 버튼의 공통적인 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.TabHeader_tabbuttons
   */
  this.tabbuttons = new eXria.controls.xhtml.TabHeader_tabbuttons();
  /**
   * 탭 이동 버튼의 가로 길이.
   * @type Number
   * @private
   */
  this.scrollBtnWidth = 30;
  /**
   * 보더를 제외한 Tab Header의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 Tab Header의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 스크롤 버튼 영역의 가로 길이(컨트롤 내부 위치 계산에 이용).
   * @type Number
   * @private
   */
  this.scrollAreaWidth = 0;
  /**
   * 상위 탭 컨트롤 참조.
   * @type eXria.controls.xhtml.Tab
   * @private
   */
  this.parent = null;   //@private
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 왼쪽 탭스핀 버튼 비활성화 이미지
   * @type String
   *
   */
  this.tabSpinLeftDisabledImg = null;
  /**
   * 왼쪽 탭스핀 버튼 활성화 이미지
   * @type String
   *
   */
  this.tabSpinLeftImg = null;
  /**
   * 오른쪽 탭스핀 버튼 비활성화 이미지
   * @type String
   *
   */
  this.tabSpinRightDisabledImg = null;
  /**
   * 오른쪽 탭스핀 버튼 활성화 이미지
   * @type String
   *
   */
  this.cursor = null;

  this.tabSpinRightImg = null;

  /**
   * 왼쪽 탭스핀 버튼 width
   * @type Number
   */
  this.tabSpinLeftWidth = null;
  /**
   * 오른쪽 탭스핀 버튼 width
   * @type Number
   */
  this.tabSpinRightWidth = null;

};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Group, eXria.controls.xhtml.TabHeader);
//////////////////////////////////////////////////////////////////
// 메소드
eXria.controls.xhtml.TabHeader.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
eXria.controls.xhtml.TabHeader.prototype.createSubCtrl = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voTabbuttonsDf = this.tabbuttons;
  this.scrollBtnWidth = this.getAttrValue("scrollBtnWidth", this.scrollBtnWidth);
  this.tabSpinLeftWidth = this.getAttrValue("tabSpinLeftWidth", this.tabSpinLeftWidth);
  this.tabSpinLeftWidth = this.tabSpinLeftWidth == null ? 23 : this.tabSpinLeftWidth;   // default image가 23사이즈
  this.tabSpinRightWidth = this.getAttrValue("tabSpinRightWidth", this.tabSpinRightWidth);
  this.tabSpinRightWidth = this.tabSpinRightWidth == null ? 23 : this.tabSpinRightWidth;  // default image가 23사이즈

  voTabbuttonsDf.cellSpacing = this.getAttrValue("tabbuttons.cellSpacing", this.tabbuttons.cellSpacing);
  var voCssStyle = this.canvas.getCssStyle(this.outerClassName, poDocument);
  this.borderWidth = this.makeSpecificAttrValue(poCtrl, voCssStyle, "borderWidth");

  this.tabSpinLeftImg = this.getAttrValue("tabSpinLeftImg", this.tabSpinLeftImg);
  this.tabSpinRightImg = this.getAttrValue("tabSpinRightImg", this.tabSpinRightImg);
  this.tabSpinLeftDisabledImg = this.getAttrValue("tabSpinLeftDisabledImg", this.tabSpinLeftDisabledImg);
  this.tabSpinRightDisabledImg = this.getAttrValue("tabSpinRightDisabledImg", this.tabSpinRightDisabledImg);

  var vnBorderWidth = this.borderWidth;
  if(vnBorderWidth == null) vnBorderWidth = 0;
  this.innerWidth = this.width - 2 * vnBorderWidth;
  this.innerHeight = this.height - 2 * vnBorderWidth;
  this.tabbuttons.height = this.innerHeight - 2 * voTabbuttonsDf.cellSpacing;

  //if(this.tabSpinLeftImg || this.tabSpinRightImg || this.tabSpinLeftDisabledImg || this.tabSpinRightDisabledImg){
  if(this.tabSpinLeftWidth || this.tabSpinRightWidth){
    this.scrollAreaWidth = this.tabSpinLeftWidth + this.tabSpinRightWidth + voTabbuttonsDf.cellSpacing * 3;
  }else{
    this.scrollAreaWidth = this.scrollBtnWidth * 2 + voTabbuttonsDf.cellSpacing * 3;
  }
};
eXria.controls.xhtml.TabHeader.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voBtnDf = this.tabbuttons;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.scrollBtnWidth = this.getAttrValue("scrollBtnWidth", this.scrollBtnWidth);

  /*this.tabSpinLeftImg = eXria.controls.xhtml.Util.getBackgroundImagePath(this.getAttrValue("tabSpinLeftImg", this.tabSpinLeftImg), this.window);
  this.tabSpinRightImg = eXria.controls.xhtml.Util.getBackgroundImagePath(this.getAttrValue("tabSpinRightImg", this.tabSpinRightImg), this.window);
  this.tabSpinLeftDisabledImg = eXria.controls.xhtml.Util.getBackgroundImagePath(this.getAttrValue("tabSpinLeftDisabledImg", this.tabSpinLeftDisabledImg), this.window);
  this.tabSpinRightDisabledImg = eXria.controls.xhtml.Util.getBackgroundImagePath(this.getAttrValue("tabSpinRightDisabledImg", this.tabSpinRightDisabledImg), this.window);*/
  /*this.tabSpinLeftImg = this.getAttrValue("tabSpinLeftImg", this.tabSpinLeftImg);
  this.tabSpinRightImg = this.getAttrValue("tabSpinRightImg", this.tabSpinRightImg);
  this.tabSpinLeftDisabledImg = this.getAttrValue("tabSpinLeftDisabledImg", this.tabSpinLeftDisabledImg);
  this.tabSpinRightDisabledImg = this.getAttrValue("tabSpinRightDisabledImg", this.tabSpinRightDisabledImg);*/

  voBtnDf.cellSpacing = this.getAttrValue("tabbuttons.cellSpacing",this.tabbuttons.cellSpacing);
  if(voBtnDf.cellSpacing != null) voBtnDf.cellSpacing = parseInt(voBtnDf.cellSpacing);
  this.tabbuttons.height = this.innerHeight - 2 * voBtnDf.cellSpacing;
  voBtnDf.width = this.getAttrValue("tabbuttons.width",this.tabbuttons.width);
  if(voBtnDf.width != null) voBtnDf.width = parseInt(voBtnDf.width);
  voBtnDf.focusBackgroundColor = this.getAttrValue("tabbuttons.focusBackgroundColor",this.tabbuttons.focusBackgroundColor);
  voBtnDf.imageFocused = this.getAttrValue("tabbuttons.imageFocused",this.tabbuttons.imageFocused);
  voBtnDf.backgroundImageFocused = this.getAttrValue("tabbuttons.imageFocused",this.tabbuttons.backgroundImageFocused);
  //if(voBtnDf.imageFocused != null) {
  //  voBtnDf.imageFocused = eXria.controls.xhtml.Util.getBackgroundImagePath(voBtnDf.imageFocused, this.window);
  //}
  voBtnDf.focusColor = this.getAttrValue("tabbuttons.focusColor",this.tabbuttons.focusColor);
  
  this.getAttrValue("tabSpinRightImg", this.tabSpinRightImg);
  voBtnDf.fontFamily = this.getAttrValue("fontFamily", this.fontFamily);
  voBtnDf.fontSize = this.getAttrValue("fontSize", this.fontSize);
  voBtnDf.fontStyle = this.getAttrValue("fontStyle", this.fontStyle);
  voBtnDf.fontWeight = this.getAttrValue("fontWeight", this.fontWeight);
  voBtnDf.textDecoration = this.getAttrValue("tabbuttons.textDecoration", this.tabbuttons.textDecoration);
  voBtnDf.textAlign = this.getAttrValue("tabbuttons.textAlign", this.tabbuttons.textAlign);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voBtnDf = this.tabbuttons;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  var voIndexMap = null;
  var vaInnerDiv = this.createInnerDiv();
  var vaOuterDiv = this.createOuterDiv();
  var vaScrollDiv = this.createScrollDiv();
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  //var vsClass = this.getCSSClass(this.parent, 1, "tabHeader");
  var vsClass= "Default_Tab_TabHeader_Class " + this.className;
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  //vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  // OuterDiv
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - this.scrollAreaWidth), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  vaOuterDiv[3] = vaCssStrBuf.join("");

  // ScrollDiv
  voIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaScrollDiv);
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "left", (this.innerWidth - this.scrollAreaWidth), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.scrollAreaWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
  vfcSetCssStrBuf(vaCssStrBuf, "display", this.isScroll()?"block":"none");

  vaScrollDiv[voIndexMap.get(0)] = vaCssStrBuf.join("");

  // voTable
  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "cellSpacing", voBtnDf.cellSpacing, "px");

  vaScrollDiv[voIndexMap.get(1)] = vaAttStrBuf.join("");
  //  voScrollBtn
  vaScrollDiv[voIndexMap.get(2)] = this.makeSpinButtonStyle("left");
  vaScrollDiv[voIndexMap.get(3)] = this.makeSpinButtonStyle("right");
  voIndexMap.clear();

  // voInnerDiv
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vaInnerDiv[3] = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  vfcSetAttStrBuf(vaAttStrBuf, "cellSpacing", voBtnDf.cellSpacing, "px");

  vaInnerDiv[6] = vaAttStrBuf.join("");

  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vaInnerDiv[8] = vaCssStrBuf.join("");


  vaOuterDiv[5] = vaInnerDiv.join("");

  vaTemplate.push(vaOuterDiv.join(""));
  vaTemplate.push(vaScrollDiv.join(""));

  poCtrl.innerHTML = vaTemplate.join("");

  vaInnerDiv = null;
  vaOuterDiv = null;
  vaScrollDiv = null;
  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  voIndexMap = null;
  this.template = null;

  var voOuterDiv = poCtrl.childNodes[0];
  var voInnerDiv = voOuterDiv.childNodes[0];
  var voTable = voInnerDiv.childNodes[0];

  var voTabButton = null;
  var voTr = voTable.rows[0];
  var voTd = null;

  for(var i = 0; i < this.controls.size(); i++) {
    voTabButton = this.controls.get(i);
    voTabButton.canvas = this.canvas;
    voTabButton.window = this.window;
    voTabButton.document = this.document;
    voTabButton.className = voBtnDf.className;
    voTabButton.outerClassName = voBtnDf.outerClassName;
    voTabButton.width = voBtnDf.width;
    voTabButton.height = this.tabbuttons.height;
    voTabButton.backgroundColor = voBtnDf.backgroundColor;
    voTabButton.backgroundImage = voBtnDf.backgroundImage;
    voTabButton.backgroundPosition = voBtnDf.backgroundPosition;
    voTabButton.backgroundRepeat = voBtnDf.backgroundRepeat;
    voTabButton.imageFocused = voBtnDf.imageFocused;
    voTabButton.backgroundImageFocused = voBtnDf.backgroundImageFocused;
    voTabButton.color = voBtnDf.color;
    voTabButton.textAlign = voBtnDf.textAlign;
    voTabButton.textDirection = voBtnDf.textDirection;
    voTabButton.fontFamily = voBtnDf.fontFamily;
    voTabButton.fontSize = voBtnDf.fontSize;
    voTabButton.fontWeight = voBtnDf.fontWeight;
    voTabButton.fontStyle = voBtnDf.fontStyle;
    voTabButton.borderColor = voBtnDf.borderColor;
    voTabButton.borderStyle = voBtnDf.borderStyle;
    voTabButton.borderWidth = voBtnDf.borderWidth;
    voTabButton.borderLeftWidth = voBtnDf.borderLeftWidth;
    voTabButton.borderRightWidth = voBtnDf.borderRightWidth;
    voTabButton.borderTopWidth = voBtnDf.borderTopWidth;
    voTabButton.borderBottomWidth = voBtnDf.borderBottomWidth;
    voTabButton.padding = voBtnDf.padding;
    voTabButton.paddingLeft = voBtnDf.paddingLeft;
    voTabButton.paddingRight = voBtnDf.paddingRight;
    voTabButton.paddingTop = voBtnDf.paddingTop;
    voTabButton.paddingBottom = voBtnDf.paddingBottom;
    // yhkim tabbuttons의 속성을 button 에 전달
    voTabButton.cursor = voBtnDf.cursor;
    if(voTabButton.visible == false) continue;
    voTd = this.document.createElement("td");
    voTd.appendChild(voTabButton.create(poDocument));
    voTr.appendChild(voTd);
    voTabButton.load();
  }
};

eXria.controls.xhtml.TabHeader.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.ctrl;
  var voStyle = voCtrl.style;
  voStyle.backgroundColor = this.backgroundColor;
};
/**
 * yhkim 2009.11.25 tabheader의 spinbutton의 button style을 만드는 함수
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.makeSpinButtonStyle = function(poParam) {
  var vfcSetCssStrBuf = this.setCssStrBuf;
  vaCssStrBuf = [];
  var vbImageExist = false;
  if(this.tabSpinLeftDisabledImg || this.tabSpinRightDisabledImg)
    vbImageExist = true;

  if(vbImageExist == true) {
    vfcSetCssStrBuf(vaCssStrBuf, "border-width", 0, "px");  // image 있을 경우만
    vfcSetCssStrBuf(vaCssStrBuf, "border-style", "none"); // image 있을 경우만
    if(poParam == "left") vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.tabSpinLeftDisabledImg);
    else if(poParam == "right") vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.tabSpinRightDisabledImg);
  }

  if(poParam == "left")
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.tabSpinLeftWidth, "px");
  else if(poParam == "right")
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.tabSpinRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.tabbuttons.height, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", "no-repeat");
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", "center center");

  return vaCssStrBuf.join("");
};
eXria.controls.xhtml.TabHeader.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.tabbuttons.df = {};
  this.df = {};
};
eXria.controls.xhtml.TabHeader.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voOuterDiv = poCtrl.childNodes[0];
  var voInnerDiv = voOuterDiv.childNodes[0];
  var voTable = voInnerDiv.childNodes[0];
  var voTBody = voTable.childNodes[0];
  var voTr = voTBody.childNodes[0];

  var vnSize = this.controls.size();
  for(var i = 0; i < vnSize; i++) {
    this.controls.get(i).clearEvents(poDocument);
  }
  vnSize = voTr.childNodes.length;
  var voChild = null;
  for(var i = 0; i < vnSize; i++) {
    voChild = voTr.childNodes[0];
    //this.clearCtrlNode(voChild);
    voTr.removeChild(voChild);
  }

  this.setSpecificAttrs(poCtrl);

  if(this.controls.size() == 0) {
    this.applyAttr("visible", false);
  }
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  switch(psAttrName) {
  case "disabled" :
    //this.setDisable(poCtrl, psAttrValue);
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl();
  var voOuterDiv = voCtrl.childNodes[0];
  var voScrollDiv = voCtrl.childNodes[1];
  var voInnerDiv = voOuterDiv.childNodes[0];
  var voScrollTable = voScrollDiv.childNodes[0];
  var voTabTable = voInnerDiv.childNodes[0];
  var vsSubAttrName = null;
  var voDf = this.df;
  var voBtnDf = this.tabbuttons;
  var voTab = this.parent;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
  case "disabled" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "color" :
  case "fontFamily" :
  case "fontSize" :
  case "fontWeight" :
    var voScrollBtn = voScrollTable.rows[0].cells[0].childNodes[0];
    this.setAttrCtrl(psAttrName, psAttrValue, voScrollBtn);

    voScrollBtn = voScrollTable.rows[0].cells[1].childNodes[0];
    this.setAttrCtrl(psAttrName, psAttrValue, voScrollBtn);

    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      var vnIndex = voTab.getIndex(voTabButton.value);
      if(psAttrName != "color" || vnIndex != this.selectedIndex) {
        voTabButton.applyAttr(psAttrName, psAttrValue);
      }
    }
    break;
  case "backgroundColor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);

    var vnWidth = this.innerWidth - this.scrollAreaWidth;
    if(vnWidth < 0) vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voOuterDiv);
    this.setAttrCtrl("left", vnWidth, voScrollDiv);

    this.tabbuttons.height = this.innerHeight - 2 * voBtnDf.cellSpacing;
    this.setAttrCtrl("height", this.innerHeight, voOuterDiv);
    this.setAttrCtrl("height", this.innerHeight, voScrollDiv);
    this.setAttrCtrl("height", this.innerHeight, voScrollTable);
    var voScrollBtn = voScrollTable.rows[0].cells[0].childNodes[0];
    this.setAttrCtrl("height", this.tabbuttons.height, voScrollBtn);
    voScrollBtn = voScrollTable.rows[0].cells[1].childNodes[0];
    this.setAttrCtrl("height", this.tabbuttons.height, voScrollBtn);
    this.setAttrCtrl("height", this.innerHeight, voInnerDiv);
    this.setAttrCtrl("height", this.innerHeight, voTabTable);
    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      voTabButton.applyAttr("height", this.tabbuttons.height);
    }
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    var vnWidth = this.innerWidth - this.scrollAreaWidth;
    if(vnWidth < 0) vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voOuterDiv);
    this.setAttrCtrl("left", vnWidth, voScrollDiv);
    break;
  case "borderTopWidth" :
  case "borderTopHeight" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.tabbuttons.height = this.innerHeight - 2 * voBtnDf.cellSpacing;
    this.setAttrCtrl("height", this.innerHeight, voOuterDiv);
    this.setAttrCtrl("height", this.innerHeight, voScrollDiv);
    this.setAttrCtrl("height", this.innerHeight, voScrollTable);
    var voScrollBtn = voScrollTable.rows[0].cells[0].childNodes[0];
    this.setAttrCtrl("height", this.tabbuttons.height, voScrollBtn);
    voScrollBtn = voScrollTable.rows[0].cells[1].childNodes[0];
    this.setAttrCtrl("height", this.tabbuttons.height, voScrollBtn);
    this.setAttrCtrl("height", this.innerHeight, voInnerDiv);
    this.setAttrCtrl("height", this.innerHeight, voTabTable);

    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      voTabButton.applyAttr("height", this.tabbuttons.height);
    }
    break;
  case "tabbuttons.textAlign" :
  case "tabbuttons.backgroundImage" :
  case "tabbuttons.backgroundPosition" :
  case "tabbuttons.backgroundRepeat" :
  case "tabbuttons.focusImage" :
  case "tabbuttons.borderColor" :
  case "tabbuttons.borderStyle" :
  case "tabbuttons.borderWidth" :
  case "tabbuttons.borderBottomWidth" :
  case "tabbuttons.borderLeftWidth" :
  case "tabbuttons.borderRightWidth" :
  case "tabbuttons.borderTopWidth" :
  case "tabbuttons.backgroundColor" :
  case "tabbuttons.color" :
  case "tabbuttons.focusBackgroundColor" :
  case "tabbuttons.focusColor" :
  case "tabbuttons.textDecoration" :
  case "tabbuttons.fontFamily" :
  case "tabbuttons.fontSize" :
  case "tabbuttons.fontStyle" :
  case "tabbuttons.fontWeight" :
  case "tabbuttons.padding" :
  case "tabbuttons.paddingBottom" :
  case "tabbuttons.paddingLeft" :
  case "tabbuttons.paddingRight" :
  case "tabbuttons.paddingTop" :
  case "tabbuttons.cellSpacing" :
  case "tabbuttons.width" :
  case "tabbuttons.className" :
  case "tabbuttons.outerClassName" :
  // yhkim tabbuttons의 속성을 button 에 전달
  case "tabbuttons.cursor" :
    vsSubAttrName = psAttrName.split(".")[1];
    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      voTabButton.applyAttr(vsSubAttrName, psAttrValue);
    }
    break;
  case "scrollBtnWidth" :
    this.scrollAreaWidth = this.scrollBtnWidth * 2 + voBtnDf.cellSpacing * 3;
    this.setAttrCtrl("width", (this.innerWidth - this.scrollAreaWidth), voOuterDiv);
    this.setAttrCtrl("left", (this.innerWidth - this.scrollAreaWidth), voScrollDiv);
    this.setAttrCtrl("width", this.scrollAreaWidth, voScrollDiv);
    this.setAttrCtrl("width", this.scrollAreaWidth, voScrollTable);
    var voScrollBtn = voScrollTable.rows[0].cells[0].childNodes[0];
    this.setAttrCtrl("width", this.scrollBtnWidth, voScrollBtn);
    voScrollBtn = voScrollTable.rows[0].cells[1].childNodes[0];
    this.setAttrCtrl("width", this.scrollBtnWidth, voScrollBtn);
    break;
  case "tabbuttons.cellSpacing" :
    this.tabbuttons.height = this.innerHeight - 2 * voBtnDf.cellSpacing;
    this.scrollAreaWidth = this.scrollBtnWidth * 2 + voBtnDf.cellSpacing * 3;

    this.setAttrCtrl("width", (this.innerWidth - this.scrollAreaWidth), voOuterDiv);
    this.setAttrCtrl("left", (this.innerWidth - this.scrollAreaWidth), voScrollDiv);
    this.setAttrCtrl("width", this.scrollAreaWidth, voScrollDiv);
    voScrollTable.setAttribute("cellSpacing", voBtnDf.cellSpacing + "px");
    this.setAttrCtrl("width", this.scrollAreaWidth, voScrollTable);

    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      voTabButton.applyAttr("height", this.tabbuttons.height);
    }
    break;
  case "tabbuttons.width" :
    var voIterator = this.controls.iterator();
    var voTabButton = null;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      voTabButton.applyAttrRebuild("width", voBtnDf.width);
    }
    break;
  case "tabbuttons.backgroundColor" :
    var voIterator = this.controls.iterator();
    var voTabButton = null;
    var vnIndex = -1;
    while(voIterator.hasNext()) {
      voTabButton = voIterator.next();
      vnIndex = voTab.getIndex(voTabButton.value);
      if(vnIndex != this.selectedIndex) {
        voTabButton.applyAttr("backgroundColor", this.tabbuttons.backgroundColor);
      }
    }
    break;
  case "tabbuttons.focusBackgroundColor" :
    this.controls.get(this.selectedIndex).applyAttrRebuild("backgroundColor", voBtnDf.focusBackgroundColor);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 실체화 컨트롤 비활성화.
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @param {String} psValue 컨트롤 disabled설정
 */
eXria.controls.xhtml.TabHeader.prototype.setDisable = function(poCtrl, psValue) {
  if(poCtrl.disabled != undefined)  poCtrl.disabled = psValue;

  if(poCtrl.childNodes) {
    var voChild = null;
    for(var i = 0; i < poCtrl.childNodes.length; i++) {
      voChild = poCtrl.childNodes[i];
      this.setDisable(voChild, psValue);
    }
  }
};
/**
 * 오버플로우 타입이 hidden인 탭 버튼을 감싸는 div 생성.
 * @return div 객체
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.createOuterDiv = function() {
  var vaOuterDiv = [];
  vaOuterDiv.push("<div id='");
  vaOuterDiv.push(this.id);
  vaOuterDiv.push("_outerdiv' style='position:absolute; overflow:hidden; padding:0px; margin:0px; border-width:0px; left:0px; top:0px; ");
  vaOuterDiv.push("@cssStrbuf"); // 3
  vaOuterDiv.push("'>");
  vaOuterDiv.push("@innerDiv"); // 5
  vaOuterDiv.push("</div>");
  return vaOuterDiv;
};
/**
 * 탭 이동 버튼을 감싸는 영역 생성.
 * @return 탭 이동 버튼을 감싸는 div
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.createScrollDiv = function() {
  var voDf = this.df;
  var vaScrollDiv = [];

  vaScrollDiv.push("<div id='");
  vaScrollDiv.push(this.id);
  vaScrollDiv.push("_scrolldiv' style='position:absolute; padding:0px; margin:0px; border-width:0px; top:0px; ");
  vaScrollDiv.push("@cssStrbuf"); // 0
  vaScrollDiv.push("'>");

  vaScrollDiv.push("<table cellpadding='0px' ");
  vaScrollDiv.push("@attStrbuf"); // 1
  vaScrollDiv.push("style='position:absolute; left:0px; top:0px; ");
  vaScrollDiv.push("width:");
  vaScrollDiv.push(this.scrollAreaWidth + "px; ");
  vaScrollDiv.push("height:");
  vaScrollDiv.push(this.innerHeight + "px;");
  vaScrollDiv.push("'>");
  vaScrollDiv.push("<tbody><tr>");

  vaScrollDiv.push("<td>");
  vaScrollDiv.push("<input id='");
  vaScrollDiv.push(this.id + "_scrollleft' type='button' ");
  if(this.tabSpinLeftImg) {
    vaScrollDiv.push("value='' disabled='true' ");
  } else {
    vaScrollDiv.push("value='◀' disabled='true' ");
  }
  vaScrollDiv.push("onclick=\"");
  vaScrollDiv.push(this.getEHandler(this.parent.id, "tabSpinLeft"));
  vaScrollDiv.push("\" style=\"");
  vaScrollDiv.push("@cssStrbuf"); // 2
  vaScrollDiv.push("\"/>");
  vaScrollDiv.push("</td>");

  vaScrollDiv.push("<td>");
  vaScrollDiv.push("<input id='");
  vaScrollDiv.push(this.id + "_scrollright' type='button' ");
  if(this.tabSpinRightImg) {
    vaScrollDiv.push("value='' disabled='true' ");
  } else {
    vaScrollDiv.push("value='▶' disabled='true' ");
  }
  vaScrollDiv.push("onclick=\"");
  vaScrollDiv.push(this.getEHandler(this.parent.id, "tabSpinRight"));
  vaScrollDiv.push("\" style=\"");
  vaScrollDiv.push("@cssStrbuf"); // 3
  vaScrollDiv.push("\"/>");
  vaScrollDiv.push("</td>");

  vaScrollDiv.push("</tr></tbody>");
  vaScrollDiv.push("</table>");

  return vaScrollDiv;
};
/**
 * 탭 버튼을 감싸는 가로 길이가 한정되지 않은 영역 생성.
 * @return 탭 버튼을 감싸는 가로 길이가 한정되지 않은 div
 * @type HTMLDiv
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.createInnerDiv = function() {
  var vaInnerDiv = [];
  //var vsClass = this.getCSSClass(this.parent, 1, "TabHeader");
  var vsClass= "Default_Tab_TabHeader_Class";
  if(this.className) vsClass += " " + this.className
  vaInnerDiv.push("<div id='");
  vaInnerDiv.push(this.id + "_innerdiv' ");
  vaInnerDiv.push("class='" + vsClass + "' " + "style='position:absolute; padding:0px; margin:0px; border-width:0px; left:0px; top:0px; ");
  vaInnerDiv.push("@cssStrbuf"); // 3 - innerDiv 추가 스타일
  vaInnerDiv.push("'>");

  vaInnerDiv.push("<table cellPadding='0px' ");
  vaInnerDiv.push("@attStrbuf"); // 6 - innerDiv.table.cellSpacing
  vaInnerDiv.push("style='position:absolute; left:0px; top:0px; ");
  vaInnerDiv.push("@cssStrbuf"); // 8 - innerDiv.table.style
  vaInnerDiv.push("'>");

  vaInnerDiv.push("<tbody>");

  vaInnerDiv.push("<tr id=\"");
  vaInnerDiv.push(this.id + "_tab_tr");
  vaInnerDiv.push("\">");

  vaInnerDiv.push("</tr>");
  vaInnerDiv.push("</tbody>");
  vaInnerDiv.push("</table>");
  vaInnerDiv.push("</div>");

  return vaInnerDiv;
};
/**
 * 한 탭 버튼의 가로길이 만큼 탭 버튼 영역을 좌측으로 이동시킴.
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.tabSpinLeft = function() {
  var voInnerDiv = this.lookup(this.id + "_innerdiv");
  this.scrollIndex++;
  voInnerDiv.style.left = ((this.tabbuttons.width + this.tabbuttons.cellSpacing) * this.scrollIndex) + "px";
  this.checkScroll();
};
/**
 * 탭 한 탭 버튼의 가로길이 만큼 탭 버튼 영역을 우측으로 이동시킴.
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.tabSpinRight = function() {
  var voInnerDiv = this.lookup(this.id + "_innerdiv");
  this.scrollIndex--;
  voInnerDiv.style.left = ((this.tabbuttons.width + this.tabbuttons.cellSpacing) * this.scrollIndex) + "px";
  this.checkScroll();
};
/**
 * 탭 해더에 탭 버튼을 추가
 * @param {eXria.controls.xhtml.TabButton} poTabButton 탭 버튼
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.addTabButton = function(poTabButton) {
  var voCtrl = this.getCtrl();
  var voBtnDf = this.tabbuttons;
  if(this.visible == false) {
    this.visible = true;
  }

  poTabButton.parent = this;
  this.addItem(poTabButton);

  if(this.parent.loaded) {
    poTabButton.canvas = this.canvas;
    poTabButton.window = this.window;
    poTabButton.document = this.document;
    poTabButton.className = voBtnDf.className;
    poTabButton.outerClassName = voBtnDf.outerClassName;
    poTabButton.backgroundColor = voBtnDf.backgroundColor;
    poTabButton.backgroundImage = voBtnDf.backgroundImage;
    poTabButton.imageFocused = voBtnDf.imageFocused;
    poTabButton.backgroundPosition = voBtnDf.backgroundPosition;
    poTabButton.backgroundRepeat = voBtnDf.backgroundRepeat;
    poTabButton.color = voBtnDf.color;
    poTabButton.fontFamily = voBtnDf.fontFamily;
    poTabButton.fontSize = voBtnDf.fontSize;
    poTabButton.fontWeight = voBtnDf.fontWeight;
    poTabButton.fontStyle = voBtnDf.fontStyle;
    poTabButton.textDecoration = voBtnDf.textDecoration;
    poTabButton.borderColor = voBtnDf.borderColor;
    poTabButton.borderStyle = voBtnDf.borderStyle;
    poTabButton.borderWidth = voBtnDf.borderWidth;
    poTabButton.borderLeftWidth = voBtnDf.borderLeftWidth;
    poTabButton.borderRightWidth = voBtnDf.borderRightWidth;
    poTabButton.borderTopWidth = voBtnDf.borderTopWidth;
    poTabButton.borderBottomWidth = voBtnDf.borderBottomWidth;
    poTabButton.padding = voBtnDf.padding;
    poTabButton.paddingLeft = voBtnDf.paddingLeft;
    poTabButton.paddingRight = voBtnDf.paddingRight;
    poTabButton.paddingTop = voBtnDf.paddingTop;
    poTabButton.paddingBottom = voBtnDf.paddingBottom;
  poTabButton.position = "relative";
  // yhkim tabbuttons의 속성을 button 에 전달
  poTabButton.cursor = voBtnDf.cursor;
    if(poTabButton.visible != false) {
      var voTd =  this.document.createElement("td");
      voTd.appendChild(poTabButton.create());

      this.checkScroll();

      var voTr = this.lookup(this.id+"_tab_tr");
      voTr.appendChild(voTd);
      poTabButton.load();
    }
  }
};
/**
 * 지정된 인덱스의 탭을 선택
 * @param {Number} pnIndex 탭인덱스
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.select = function(pnIndex) {
  var voTab = this.parent;
  var voEvent = new eXria.event.Event(null);
  voEvent.object = voTab;
  var vbChangePage = true;
  if(voTab.onPreChange && voTab.loaded) vbChangePage = voTab.onPreChange(voEvent);
  if(vbChangePage == false) {
    var voBtn = this.controls.get(pnIndex);
    if(voBtn) voBtn.atblur();
    return;
  }

  var voCtrl = this.getCtrl(this.document);
  var voBtnDf = this.tabbuttons;
  if(voCtrl == null) {
  voTab.selectedIndex = pnIndex;
    return;
  }
  var voSelectedTab = null;
  var voTabCtrl = null;
  var voPage = null;

  if(voTab.selectedIndex != -1) {
    voSelectedTab = this.controls.get(voTab.selectedIndex);
    if(voSelectedTab.visible != false) {
      voTabCtrl = voSelectedTab.getSubCtrl("button");
      if(voSelectedTab != null) {
        if(voBtnDf.backgroundColor) voSelectedTab.setAttrCtrl("backgroundColor", voBtnDf.backgroundColor, voTabCtrl);
        else voSelectedTab.setAttrCtrl("backgroundColor", "", voTabCtrl);
        if(voBtnDf.color) voSelectedTab.setAttrCtrl("color", voBtnDf.color, voTabCtrl);
        else voSelectedTab.setAttrCtrl("color", "", voTabCtrl);
        if(voBtnDf.backgroundImage) voSelectedTab.setAttrCtrl("backgroundImage", voBtnDf.backgroundImage, voTabCtrl);
        else voSelectedTab.setAttrCtrl("backgroundImage", "", voTabCtrl);
        if(voBtnDf.backgroundImageFocused) voSelectedTab.setAttrCtrl("backgroundImage", "", voSelectedTab.ctrl);
      }
      voPage = voTab.tabPageSet.get(voTab.selectedIndex);

      if(voTab.canvas.page.metadata.browser.ie) {
        var voChild = null;
        var voIterator = voPage.controls.iterator();
        while(voIterator.hasNext()) {
          voChild = voIterator.next();
          if(voChild.toString() == "GridEx") {
            voChild.scrollLeft = 0;
            voChild.scrollTop = 0;
            try { voChild.scrollLeft = voChild.grid.GetScrollLeft(); } catch(err) {}
            try { voChild.scrollTop = voChild.grid.GetScrollTop(); } catch(err) {}
          }
        }
      }

      if(voPage) voPage.applyAttr("visible", false);
    }
  }

  voSelectedTab = this.controls.get(pnIndex);

  if(voSelectedTab.visible == false) {
  //tabHeader visible false 일경우 tabPage도 false 처리되게 수정
  //2010.04.08
  voTab.tabPageSet.get(pnIndex).applyAttr("visible", false);
  return;
  }

  voTabCtrl = voSelectedTab.getSubCtrl("button");
  if(voSelectedTab) {
    if(voBtnDf.focusBackgroundColor) voSelectedTab.setAttrCtrl("backgroundColor", voBtnDf.focusBackgroundColor, voTabCtrl);
    else voSelectedTab.setAttrCtrl("backgroundColor", "", voTabCtrl);
    if(voBtnDf.focusColor) voSelectedTab.setAttrCtrl("color", voBtnDf.focusColor, voTabCtrl);
    else voSelectedTab.setAttrCtrl("color", "", voTabCtrl);
    if(voBtnDf.imageFocused) {
      var voIterator = this.controls.iterator();
      while(voIterator.hasNext()) {
        voTabButton = voIterator.next();
        voTabButton.focused = false;
      }
      voSelectedTab.setAttrCtrl("backgroundImage", voBtnDf.imageFocused, voTabCtrl);
    }
    else voSelectedTab.setAttrCtrl("backgroundImage", "", voTabCtrl);
    if(voBtnDf.backgroundImageFocused) voSelectedTab.setAttrCtrl("backgroundImage", voBtnDf.backgroundImageFocused, voSelectedTab.ctrl);
    voSelectedTab.oldImage = voBtnDf.imageFocused;
  }
  var voPage = voTab.tabPageSet.get(pnIndex);
  if(voPage) {
    if(voPage.execFunc) {
      voPage.execFunc();
      voPage.execFunc = null;
    }
    voPage.applyAttr("visible", true);
    if(voPage.rendered == false) {
      voPage.createChildren();
      voPage.rendered = true;
    } else {

      if(voTab.canvas.page.metadata.browser.ie) {
        var voChild = null;
        var voFunc = null;
        var voIterator = voPage.controls.iterator();
        while(voIterator.hasNext()) {
          voChild = voIterator.next();
          if(voChild.toString() == "GridEx") {
            voFunc = function() {
              if(voChild.scrollLeft) voChild.grid.SetScrollLeft(voChild.scrollLeft);
              if(voChild.scrollTop) voChild.grid.SetScrollTop(voChild.scrollTop);
              voChild.scrollLeft = null;
              voChild.scrollTop = null;
            };
            setTimeout(voFunc, 100);
          }
        }
      }

    }
  }

  voTab.selectedIndex = pnIndex;
  if(voTab.onPostChange && voTab.loaded) voTab.onPostChange(voEvent);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.isScroll = function() {
  var vbScroll = false;
  var vnLen = this.innerWidth;
  var vnChilds = this.getVisibleCount();
  var voBtnDf = this.tabbuttons;
  if(vnLen < (voBtnDf.width + voBtnDf.cellSpacing) * vnChilds) {
    vbScroll = true;
    vnLen = this.innerWidth - this.scrollAreaWidth;
  }
  return vbScroll;
}
/**
 * 탭 이동 버튼 활성화 상태 지정 메소드.
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.checkScroll = function() {
  var voDf = this.df;
  var vbScroll = false;
  var voOuterDiv = this.lookup(this.id + "_outerdiv");
  var voScrollDiv = this.lookup(this.id + "_scrolldiv");
  var vnLen = this.innerWidth;
  var vnChilds = this.getVisibleCount();
  var voBtnDf = this.tabbuttons;
  if(vnLen < (voBtnDf.width + voBtnDf.cellSpacing) * vnChilds) {
    vbScroll = true;
    vnLen = this.innerWidth - this.scrollAreaWidth;
  }
  voOuterDiv.style.width = vnLen + "px";
  if(vbScroll) {
    voScrollDiv.style.display = "block";
  } else {
    voScrollDiv.style.display = "none";
    return;
  }

  var voScrollLeft = this.lookup(this.id + "_scrollleft");
  var voScrollRight = this.lookup(this.id + "_scrollright");

  voScrollLeft.disabled = true;
  voScrollRight.disabled = true;

  if(this.scrollIndex < 0) {
    voScrollLeft.disabled = false;
    if(this.tabSpinLeftImg) {
      voScrollLeft.value = "";
      voScrollLeft.style.backgroundImage = this.tabSpinLeftImg;
    } else {
      voScrollLeft.value = "◀";
      voScrollLeft.style.backgroundImage = "";
    }
  } else {
    if(this.tabSpinLeftDisabledImg) {
      voScrollLeft.value = "";
      voScrollLeft.style.backgroundImage = this.tabSpinLeftDisabledImg;
    } else {
      voScrollLeft.value = "◀";
      voScrollLeft.style.backgroundImage = ""
    }
  }

  var vnLeft = this.scrollIndex * (voBtnDf.width + voBtnDf.cellSpacing);
  if(vnLeft + (voBtnDf.width + voBtnDf.cellSpacing) * vnChilds > vnLen) {
    voScrollRight.disabled = false;
    if(this.tabSpinRightImg) {
      voScrollRight.value = "";
      voScrollRight.style.backgroundImage = this.tabSpinRightImg;
    } else {
      voScrollRight.value = "▶";
      voScrollRight.style.backgroundImage = "";
    }
  } else {
    if(this.tabSpinRightDisabledImg) {
      voScrollRight.value = "";
      voScrollRight.style.backgroundImage = this.tabSpinRightDisabledImg;
    } else {
      voScrollRight.value = "▶";
      voScrollRight.style.backgroundImage = ""
    }
  }

  var voCtrl = this.lookup(this.id);
  var voStyle = null;
  if(this.controls.size() == 0) {
    this.applyAttr("visible", false);
  }
};
/**
 * 활성화 된 탭 버튼 개수를 반환.
 * @return 활성화 된 탭 버튼 갯수
 * @type Number
 * @private
 */
eXria.controls.xhtml.TabHeader.prototype.getVisibleCount = function() {
  var vnCnt = 0;
  var voControls = this.controls;
  var vnSize = voControls.size();
  var voTabButton = null;
  for(var i = 0; i < vnSize; i++) {
    voTabButton = voControls.get(i);
    if(voTabButton.visible != false) {
      vnCnt++;
    }
  }
  return vnCnt;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number
 * @ignore
 */
eXria.controls.xhtml.TabHeader.prototype.getSpecificDefaultValue = function(psAttrName){
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.Tab.TabHeader[psAttrName] == null ? vsDefaultValue : eXria.controls.xhtml.Default.Tab.TabHeader[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.Tab.TabHeader[vaAttrName[0]][vaAttrName[1]] == null ? vsDefaultValue : eXria.controls.xhtml.Default.Tab.TabHeader[vaAttrName[0]][vaAttrName[1]];
  }
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "TabHeader"
 * @type String
 */
eXria.controls.xhtml.TabHeader.prototype.toString = function() {
  return "Tab_TabHeader";
};


/**
 * 탭 바디의 공통속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.Tab_tabpages = function() {
  /**
   * 탭 바디의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 탭 바디의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 탭 바디의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 탭 바디의 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 탭 바디의 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 탭 바디의 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 탭 바디의 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 탭 바디에 담긴 컨트롤이 영역을 벗어날때 스크롤 처리.
   * @type String
   */
  this.overflow = null;
  /**
   * 탭 바디에 담긴 컨트롤이 영역을 벗어날때 횡 스크롤 처리.
   * @type String
   */
  this.overflowX = null;
  /**
   * 탭 바디에 담긴 컨트롤이 영역을 벗어날때 종 스크롤 처리.
   * @type String
   */
  this.overflowY = null;
  /**
   * 탭 바디의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 탭 바디의 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 탭 바디의 외곽 div에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * 탭 바디의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};
/**
 * @class Concreate xhtml TabPage.<br>
 * 탭의 컨텐츠 패널 영역 담당 클래스.
 * @author 조영진
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.TabPage 객체
 * @type eXria.controls.xhtml.TabPage
 * @constructor
 * @base eXria.controls.xhtml.Group
 */
eXria.controls.xhtml.TabPage = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  eXria.controls.xhtml.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * 상위 Tab컨트롤 참조변수
   * @type eXria.controls.xhtml.Tab
   */
  this.parent = null;
  /**
   * TabPage의 sub Id참조
   * @type String
   */
  this.subId = null;
  /**
   * TabPage가 렌더링 되었는지 여부
   * @type Boolean
   * @private
   */
  this.rendered = false;

};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Group, eXria.controls.xhtml.TabPage);
/**
 * @ignore
 */
eXria.controls.xhtml.TabPage.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.TabPage.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.Tab.tabpages) vsDefaultValue = eXria.controls.xhtml.Default.Tab.tabpages[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "TabPage"
 * @type String
 */
eXria.controls.xhtml.TabPage.prototype.toString = function() {
  return "Tab_TabPages";
};


/**
 * @class Concreate xhtml Tab.<br>
 * XHTML Tab 컨트롤.
 * @author 조영진
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.Tab 객체
 * @type eXria.controls.xhtml.Tab
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.Tab = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight = pnHeight == null ? 300 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * @private
   */
  this.position = "absolute";
  /**
   * 선택된 탭 페이지의 인덱스 번호.
   * @type Number
    */
  this.selectedIndex = 0;
  /**
   * 선택된 탭 페이지의 ID.
   * @type String
   * @ignore
   */
  this.selectedPageId = null;
  /**
   * 탭 헤더 영역의 가로 길이.
   * @type Number
   */
  this.headerHeight = null;
  /**
   * 탭 헤더 객체.<br>
   * 탭 버튼을 관리하는 오브젝트.
   * readOnly
   * @type eXria.controls.xhtml.TabHeader
   */
  this.tabHeader = new eXria.controls.xhtml.TabHeader(this.id + "_tabheader", 0, 0, this.width, this.headerHeight);;
  this.tabHeader.parent = this;
  /**
   * 탭 바디(탭의 컨텐츠 패널 영역)을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   */
  this.tabPageSet = new eXria.data.ArrayCollection();
  /**
   * 탭 아이디 생성에 이용되는 순차적인 번호.
   * @type Number
   * @private
   */
  this.tabSeqNum = 0;
  /**
   * @type Number
   * @ignore
   */
  this.tabPageZindex = null;
  /**
   * 탭 헤더의 위치 지정.
   * "top" | "bottom"
   * @type String
   */
  this.headerPos = null;
  /**
   * 탭 바디의 공통속성을 저장하기 위한 오브젝트.
   * @type Object
   */
  this.tabpages = new eXria.controls.xhtml.Tab_tabpages();
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 초기에 모든 페이지를 렌더링할지 여부.
   * @type Boolean
   */
  this.renderAll = null;
  /**
   * data연동을 통해 생성된 탭 페이지 아이디 저장.
   * @type eXria.data.ArrayMap
   * @private
   */
  this.pageIdsInData = new eXria.data.ArrayMap();
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트.
   * @type Object
   * @private
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.Tab);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;
//if(vsType == "change")debugger
  switch(vsType) {
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
eXria.controls.xhtml.Tab.prototype.setSubCtrlStyles = function(poCtrl) {
  //var voTabPage = null;
  //var voIterator = this.tabPageSet.iterator();
  //while(voIterator.hasNext()) {
  //  voTabPage = voIterator.next();
  //  voTabPage.className = this.tabpages.className;
  //  voTabPage.outerClassName = this.tabpages.outerClassName;
  //}
};
eXria.controls.xhtml.Tab.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  this.type = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.type = voUserAttr.type;
    this.maxTabCount = voUserAttr.maxTabCount;
    if(!this.maxTabCount)
      this.maxTabCount = 5;

    this.impPosGap = voUserAttr.impPosGap;
    if(null === this.impPosGap || undefined === this.impPosGap)
      this.impPosGap = 5;

    this.impBorderWidth = voUserAttr.impBorderWidth;
    if(null === this.impBorderWidth
       || undefined === this.impBorderWidth
       || ''=== this.impBorderWidth)
      this.impBorderWidth = 1;

    if('minimizedWindow' === this.type)
      this.headerPos = "bottom";
    if(voUserAttr.tabbuttons) {
      if(voUserAttr.tabbuttons.backgroundImageFocused) this.tabHeader.tabbuttons.backgroundImageFocused = voUserAttr.tabbuttons.backgroundImageFocused;
    }
  }


  var voDf = this.df;
  var voPageDf = this.tabpages;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
  this.headerHeight = this.getAttrValue("headerHeight",this.headerHeight);
  this.tabPageZindex = this.getAttrValue("tabPageZindex",this.tabPageZindex);
  this.headerPos = this.getAttrValue("headerPos",this.headerPos);
};
eXria.controls.xhtml.Tab.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voPageDf = this.tabpages;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
//  if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  this.tabHeader.width = this.innerWidth;
  this.tabHeader.height = this.headerHeight;
  this.tabHeader.canvas = this.canvas;
  this.tabHeader.window = this.window;
  this.tabHeader.document = this.document;
  var vnTop = 0;
  if(this.headerPos == "bottom") {
    vnTop = this.innerHeight - this.headerHeight;
  }
  this.tabHeader.top = vnTop;
  this.tabHeader.parent = this;
  this.tabHeader.clearCtrl();
  poCtrl.appendChild(this.tabHeader.create());
  var voTabPage = null;
  for(var i = 0; i < this.tabPageSet.size(); i++) {
    voTabPage = this.tabPageSet.get(i);
    voTabPage.canvas = this.canvas;
    voTabPage.window = this.window;
    voTabPage.document = this.document;
    voTabPage.className = this.tabpages.className;
    voTabPage.outerClassName = this.tabpages.outerClassName;
    if(this.headerPos == "bottom") {
      voTabPage.top = 0;
    }
    voTabPage.width = this.innerWidth;
    voTabPage.height = this.innerHeight - this.headerHeight;
    voTabPage.backgroundColor = voPageDf.backgroundColor;
    voTabPage.borderStyle = voPageDf.borderStyle;
    voTabPage.borderColor = voPageDf.borderColor;
    voTabPage.borderWidth = voPageDf.borderWidth;
    voTabPage.borderLeftWidth = voPageDf.borderLeftWidth;
    voTabPage.borderRightWidth = voPageDf.borderRightWidth;
    voTabPage.borderTopWidth = voPageDf.borderTopWidth;
    voTabPage.borderBottomWidth = voPageDf.borderBottomWidth;
    voTabPage.overflow = voPageDf.overflow;
    voTabPage.overflowX = voPageDf.overflowX;
    voTabPage.overflowY = voPageDf.overflowY;
    voTabPage.visible = false;
    voTabPage.clearCtrl();
    poCtrl.appendChild(voTabPage.create(poDocument));
  }

  if(this.disabled) this.setDisable(poCtrl, this.disabled);

  vaCssStrBuf = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.tabpages.df = {};
  this.df = {};

  var vnSelectedIndex = this.selectedIndex;
  this.selectedIndex = -1;
  var voPageIdsInData = this.pageIdsInData;
  var vnSize = voPageIdsInData.size();
  var voPageIds = voPageIdsInData.getKeyCollection();
  var vsPageId = null;
  var vnIndex = null;
  for(var i = 0; i < vnSize; i++) {
    vsPageId = voPageIds.get(i);
    if(vnIndex) this.removeTab(vnIndex);
  }
  voPageIdsInData.clear();
  this.selectedIndex = vnSelectedIndex;
};
/**
 * @ignore
 */
//eXria.controls.xhtml.Tab.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
//  var voDf = this.df;
//  var voPageDf = this.tabpages.df;
//  this.setAttrCtrl("top", this.top, poCtrl);
//  this.setAttrCtrl("left", this.left, poCtrl);
//  this.setAttrCtrl("width", this.innerWidth, poCtrl);
//  this.setAttrCtrl("height", this.innerHeight, poCtrl);
//  this.setAttrCtrl("borderColor", this.borderColor, poCtrl);
//  this.setAttrCtrl("borderStyle", this.borderStyle, poCtrl);
//  this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", poCtrl);
//  this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", poCtrl);
//  this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", poCtrl);
//  this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", poCtrl);
//
//  this.tabHeader.width = this.innerWidth;
//  if(this.headerPos == "top") {
//    this.tabHeader.top = 0;
//  } else {
//    this.tabHeader.top = this.height - this.headerHeight;
//  }
//  this.tabHeader.refresh();
//
//  var voTabPage = null;
//  var voIterator = this.tabPageSet.iterator();
//  while(voIterator.hasNext()) {
//    voTabPage = voIterator.next();
//    if(this.headerPos == "top") {
//      voTabPage.top = this.headerHeight;
//    } else {
//      voTabPage.top = 0;
//    }
//    voTabPage.width = this.innerWidth;
//    voTabPage.height = this.innerHeight - this.headerHeight;
//    voTabPage.backgroundColor = this.backgroundColor;
//    voTabPage.borderStyle = voPageDf.borderStyle;
//    voTabPage.borderColor = voPageDf.borderColor;
//    voTabPage.borderWidth = voPageDf.borderWidth;
//    voTabPage.borderLeftWidth = voPageDf.borderLeftWidth;
//    voTabPage.borderRightWidth = voPageDf.borderRightWidth;
//    voTabPage.borderTopWidth = voPageDf.borderTopWidth;
//    voTabPage.borderBottomWidth = voPageDf.borderBottomWidth;
//    voTabPage.overflow = voPageDf.overflow;
//    voTabPage.overflowX = voPageDf.overflowX;
//    voTabPage.overflowY = voPageDf.overflowY;
//    voTabPage.refresh();
//  }
//
//  if(this.disabled) this.setDisable(this.disabled);
//
//  var voCover = this.lookup(this.id + "_cover");
//  if(voCover != null) {
//    if(this.visible == false) {
//      this.setAttrCtrl("display", "none", voCover);
//    } else {
//      this.setAttrCtrl("display", "", voCover);
//    }
//  }
//
//  this.loadComplete(poDocument);
//};
eXria.controls.xhtml.Tab.prototype.refreshSpecificAttrs = function(poCtrl, poDocument, pbChildRefresh) {
  var voDf = this.df;
  var voPageDf = this.tabpages;

  this.setAttrCtrl("top", this.top, poCtrl);
  this.setAttrCtrl("left", this.left, poCtrl);
  this.setAttrCtrl("width", this.innerWidth, poCtrl);
  this.setAttrCtrl("height", this.innerHeight, poCtrl);
  this.setAttrCtrl("borderColor", this.borderColor, poCtrl);
  this.setAttrCtrl("borderStyle", this.borderStyle, poCtrl);
  this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", poCtrl);
  this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", poCtrl);
  this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", poCtrl);
  this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", poCtrl);
  this.setAttrCtrl("cursor", this.cursor, poCtrl);

  this.tabHeader.width = this.innerWidth;
  if(this.headerPos == "top") {
    this.tabHeader.top = 0;
  } else {
    this.tabHeader.top = this.height - this.headerHeight;
  }
  this.tabHeader.refresh();

  var voTabPage = null;
  var voIterator = this.tabPageSet.iterator();
  while(voIterator.hasNext()) {
    voTabPage = voIterator.next();
    if(pbChildRefresh == true && voTabPage.rendered == false) continue;
    if(this.headerPos == "top") {
      voTabPage.top = this.headerHeight;
    } else {
      voTabPage.top = 0;
    }
    voTabPage.width = this.innerWidth;
    voTabPage.height = this.innerHeight - this.headerHeight;
    voTabPage.backgroundColor = voPageDf.backgroundColor;
    voTabPage.borderStyle = voPageDf.borderStyle;
    voTabPage.borderColor = voPageDf.borderColor;
    voTabPage.borderWidth = voPageDf.borderWidth;
    voTabPage.borderLeftWidth = voPageDf.borderLeftWidth;
    voTabPage.borderRightWidth = voPageDf.borderRightWidth;
    voTabPage.borderTopWidth = voPageDf.borderTopWidth;
    voTabPage.borderBottomWidth = voPageDf.borderBottomWidth;
    voTabPage.overflow = voPageDf.overflow;
    voTabPage.overflowX = voPageDf.overflowX;
    voTabPage.overflowY = voPageDf.overflowY;
    voTabPage.refresh(null, pbChildRefresh);
  }

  if(this.disabled) this.setDisable(this.ctrl, this.disabled);

  var voCover = this.lookup(this.id + "_cover");
  if(voCover != null) {
    if(this.visible == false) {
      this.setAttrCtrl("display", "none", voCover);
    } else {
      this.setAttrCtrl("display", "", voCover);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  switch(psAttrName) {
  case "width" :
    break;
  case "height" :
    break;
  case "borderWidth" :
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voDf = this.df;
  var voCtrl = this.getCtrl();
  var vaAttrName = null;
  var vsSubAttrName = null;
  this.setAttr(psAttrName, psAttrValue);

  //this.tabHeader.applyAttrRebuild(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "backgroundColor" :
//    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.tabpages[psAttrName] = psAttrValue;

    var voTabPage = null;
    var voIterator = this.tabPageSet.iterator();
    while(voIterator.hasNext()) {
      voTabPage = voIterator.next();
      voTabPage.applyAttrRebuild(psAttrName, psAttrValue);
    }
    break;
  case "headerPos" :
    if(this.headerPos == "top") {
      this.tabHeader.top = 0;
    } else {
      this.tabHeader.top = this.height - this.headerHeight;
    }
    this.tabHeader.refresh();

    var voTabPage = null;
    var voIterator = this.tabPageSet.iterator();
    while(voIterator.hasNext()) {
      voTabPage = voIterator.next();
      if(this.headerPos == "top") {
        voTabPage.top = this.headerHeight;
      } else {
        voTabPage.top = 0;
      }
      voTabPage.refresh();
    }
    break;
  case "tabpages.backgroundColor" :
  case "tabpages.borderStyle" :
  case "tabpages.borderColor" :
  case "tabpages.borderWidth" :
  case "tabpages.borderLeftWidth" :
  case "tabpages.borderRightWidth" :
  case "tabpages.borderTopWidth" :
  case "tabpages.borderBottomWidth" :
  case "tabpages.className" :
  case "tabpages.outerClassName" :
    vaAttrName = psAttrName.split(".");
    vsSubAttrName = vaAttrName[vaAttrName.length - 1];
    var voTabPage = null;
    var voIterator = this.tabPageSet.iterator();
    while(voIterator.hasNext()) {
      voTabPage = voIterator.next();
      voTabPage.applyAttrRebuild(psAttrName.replace(/tabpages./gi,""), psAttrValue, poDocument);
    }
    break;
  case "tabpages.overflow" :
  case "tabpages.overflowX" :
  case "tabpages.overflowY" :
    var voDf = voObj;
    //var voCssStyle = this.canvas.getCssStyle(this.className, this.document);
    if(this.overflow == null) this.overflow = "hidden";
    var vsOverflowX = this.makeSpecificAttrValue(voCtrl, voCssStyle, "tabpages.overflowX");
    var vsOverflowY = this.makeSpecificAttrValue(voCtrl, voCssStyle, "tabpages.overflowY");
    if(voObj.overflowX == null) this.overflowX = vsOverflowX ? vsOverflowX : this.overflow;
    if(voObj.overflowY == null) this.overflowY = vsOverflowY ? vsOverflowY : this.overflow;

    vaAttrName = psAttrName.split(".");
    vsSubAttrName = vaAttrName[vaAttrName.length - 1];
    var voTabPage = null;
    var voIterator = this.tabPageSet.iterator();
    while(voIterator.hasNext()) {
      voTabPage = voIterator.next();
      voTabPage.overflowX = this.overflowX;
      voTabPage.overflowY = this.overflowY;
      var voStyle = voTabPage.ctrl.style;
      voStyle.overflowX = this.overflowX;
      voStyle.overflowY = this.overflowY;
  //      voContentPane.applyAttrRebuild(vsSubAttrName, psAttrValue, poDocument);
    }
    break;
  case "tabHeader.tabbuttons.textAlign" :
  case "tabHeader.tabbuttons.backgroundImage" :
  case "tabHeader.tabbuttons.backgroundPosition" :
  case "tabHeader.tabbuttons.backgroundRepeat" :
  case "tabHeader.tabbuttons.focusImage" :
  case "tabHeader.tabbuttons.borderColor" :
  case "tabHeader.tabbuttons.borderStyle" :
  case "tabHeader.tabbuttons.borderWidth" :
  case "tabHeader.tabbuttons.borderBottomWidth" :
  case "tabHeader.tabbuttons.borderLeftWidth" :
  case "tabHeader.tabbuttons.borderRightWidth" :
  case "tabHeader.tabbuttons.borderTopWidth" :
  case "tabHeader.tabbuttons.backgroundColor" :
  case "tabHeader.tabbuttons.color" :
  case "tabHeader.tabbuttons.focusBackgroundColor" :
  case "tabHeader.tabbuttons.focusColor" :
  case "tabHeader.tabbuttons.textDecoration" :
  case "tabHeader.tabbuttons.fontFamily" :
  case "tabHeader.tabbuttons.fontSize" :
  case "tabHeader.tabbuttons.fontStyle" :
  case "tabHeader.tabbuttons.fontWeight" :
  case "tabHeader.tabbuttons.padding" :
  case "tabHeader.tabbuttons.paddingBottom" :
  case "tabHeader.tabbuttons.paddingLeft" :
  case "tabHeader.tabbuttons.paddingRight" :
  case "tabHeader.tabbuttons.paddingTop" :
  case "tabHeader.tabbuttons.cellSpacing" :
  case "tabHeader.tabbuttons.width" :
  case "tabHeader.tabbuttons.className" :
  case "tabHeader.tabbuttons.outerClassName" :
  // yhkim tabbuttons의 속성을 button 에 전달
  case "tabHeader.tabbuttons.cursor" :
  case "tabHeader.borderColor" :
  case "tabHeader.borderStyle" :
  case "tabHeader.borderWidth" :
  case "tabHeader.borderBottomWidth" :
  case "tabHeader.borderLeftWidth" :
  case "tabHeader.borderRightWidth" :
  case "tabHeader.borderTopWidth" :
  case "tabHeader.backgroundColor" :
  case "tabHeader.tabSpinLeftDisabledImg" :
  case "tabHeader.tabSpinLeftImg" :
  case "tabHeader.tabSpinRightDisabledImg" :
  case "tabHeader.tabSpinRightImg" :
    this.tabHeader.applyAttrRebuild(psAttrName.replace(/tabHeader./gi,""), psAttrValue, poDocument);

  break;
  default :
    this.refresh(poDocument);
    break;
  }

};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.loadData = function(poDocument) {
  if(this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null) return;

  var voCollectionNode = this.data.getNodesetData2();
  if(voCollectionNode == null) return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vsParentNode = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  var vaNodes = [];
  var voTreeNode = null;
  var voPage = null;
  for(var i = 0; i < vnLoop; i++) {
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    vsLabelNode = voMapNode.get(this.labelTagName);
    vsBidNode = voMapNode.get(this.bidTagName);
    vsPidNode = voMapNode.get(this.pidTagName);

    voPage = this.addTab(vsLabelNode, vsBidNode, vsPidNode);
    voPageIdsInData.put(voPage.id, "");
  }
};
eXria.controls.xhtml.Tab.prototype.reloadData = function(poCtrl, poDocument) {
  if(this.renderAll) {
    var voIterator = this.tabPageSet.iterator();
    var voPage = null;
    var voSelectedPage = this.getPage(this.selectedIndex);
    while(voIterator.hasNext()) {
      voPage = voIterator.next();
      if(voPage != voSelectedPage) voPage.applyAttr("visible", true);
      voPage.reloadData(voPage.ctrl, voPage.document);
      if(voPage != voSelectedPage) voPage.applyAttr("visible", false);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.loadComplete = function(poDocument) {
  this.tabHeader.loadComplete(poDocument);
  this.tabHeader.checkScroll();
  if(this.renderAll) {
    var voIterator = this.tabPageSet.iterator();
    var voPage = null;
    var vnIE = this.canvas.page.metadata.browser.id;
    while(voIterator.hasNext()) {
      voPage = voIterator.next();
      if(voPage.execFunc) {
        voPage.execFunc();
        voPage.execFunc = null;
      }
      if(vnIE < 8.0) voPage.setAttrCtrl("visibility", "hidden");
      voPage.applyAttr("visible", true);
      if(voPage.rendered){
        //voPage.refresh();
      } else {
        voPage.createChildren();
        voPage.rendered = true;
      }
      if(vnIE < 8.0) voPage.setAttrCtrl("visibility", "visible");
      voPage.applyAttr("visible", false);
    }
  } else if(!this.loadTabOnSelect) {
    var voIterator = this.tabPageSet.iterator();
    var voPage = null;
    while(voIterator.hasNext()) {
      voPage = voIterator.next();
      if(voPage.execFunc) {
        voPage.execFunc();
        voPage.execFunc = null;
      }
    }
  }
  this.loaded = true;

  if(this.tabPageSet.iterator().hasNext())
    this.selectTab(this.selectedIndex);

};

eXria.controls.xhtml.Tab.prototype.refreshComplete = function(poCtrl, poDocument) {
  this.tabHeader.checkScroll();
  if(this.renderAll) {
    var voIterator = this.tabPageSet.iterator();
    var voPage = null;
    var vnIE = page.metadata.browser.id;

    while(voIterator.hasNext()) {
      voPage = voIterator.next();
      if(vnIE < 8.0) voPage.setAttrCtrl("visibility", "hidden");
      voPage.applyAttr("visible", true);
      voPage.refreshComplete(voPage.ctrl, poDocument);
      if(vnIE < 8.0) voPage.setAttrCtrl("visibility", "visible");
      voPage.applyAttr("visible", false);
    }
  }

  if(0 === this.tabPageSet.cnt) return;

  this.selectTab(this.selectedIndex);
};

/**
 * 내부의 포함된 컨트롤을 순환적으로 참조하기 위해 사용되는 메소드
 * @return tabPageSet
 * @type eXria.data.ArrayCollection
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.getControls = function() {
  return this.tabPageSet;
};

/**
 * type 이 minimizedWindow 인 경우 사용될 탭 추가 메소드
 * 탭 버튼 및 그에 따른 탭 바디 추가 메소드.
 * @param {String} psTabName 탭 버튼 라벨
 * @param {String} psButtonId 탭 버튼 아이디
 * @param {String} psPageId 탭 페이지 아이디
 * @param {Boolean} pbVisible Visible 여부
 * @param {String} psSrc 불러오는 화면에 대한 URL 및 파일 경로.
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 추가된 탭의 인덱스
 * @type Number
 */
eXria.controls.xhtml.Tab.prototype.addMinimizedWindowTab = function(psTabName, psButtonId, psPageId, pbVisible, psSrc, pnLeft, pnTop, pnWidth, pnHeight) {
  if(!this.type || this.type !== 'minimizedWindow') {
    var voErrMsg;
    voErrMsg.name = "eXria.controls.xhtml.Tab.prototype.addMinimizedWindowTab";
    voErrMsg.message = "type 이  minimizedWindow 인 경우에만 사용이 가능 합니다.";
    throw voErrMsg;
  }

  var voIterator = this.tabPageSet.iterator();
  while(voIterator.hasNext()){
   var voTabPage = voIterator.next();
   var voCtlIterator = voTabPage.controls.iterator();
   while(voCtlIterator.hasNext()){
     var vcSbp = voCtlIterator.next()
     if(vcSbp.src === psSrc) {
      var vnTabIndex = this.getIndexBySubId(voTabPage.subId);
      this.selectTab(vnTabIndex);
      return vnTabIndex;
     }
   }
  }


  var vnMaxTabCount = this.maxTabCount;
  var vnSize = this.tabPageSet.size();

  if(vnSize >= vnMaxTabCount){
   this.selectTab(0);
   this.removeMinimizedWindowTab(0);
  }

  var vnPosGap = this.impPosGap;
  var vnBorderWidth = this.impBorderWidth;
  var vnIdx = this.addTab(psTabName, psButtonId, psPageId, pbVisible, pnLeft, pnTop, pnWidth, pnHeight);

  if(!!psSrc){
    var voPage = this.getPage(vnIdx);
    var vnWidth = this.innerWidth;
    var vnHeight = this.innerHeight- this.tabHeader.innerHeight;
    var voSbp = new eXria.controls.xhtml.SubPage("sbpMinimizedWindowTab"+this.tabSeqNum, vnPosGap, vnPosGap, vnWidth, vnHeight);
    voSbp.src = psSrc;
    voSbp.borderWidth = vnBorderWidth;
    voSbp.zIndex = 0;
    voPage.addChild(voSbp);
  }

  this.selectTab(vnIdx);

  return this.tabPageSet.size() - 1;
};
/**
 * type 이 minimizedWindow 인 경우 현재 활성화된 Tab 하위의 SubPage url을 지정된 url로 변경해주는 메소드.
 * @param {String} psSrc 변경 URL
 * @param {String} psLabel 변경 탭 버튼 라벨(생략가능).
 */
eXria.controls.xhtml.Tab.prototype.setCurrentMinimizedWindowSrc = function(psSrc, psLabel) {
  if(!this.type || this.type !== 'minimizedWindow') {
    var voErrMsg;
    voErrMsg.name = "eXria.controls.xhtml.Tab.prototype.addMinimizedWindowTab";
    voErrMsg.message = "type 이  minimizedWindow 인 경우에만 사용이 가능 합니다.";
    throw voErrMsg;
  }

  var vnIdx = this.selectedIndex;
  var voTabPage = this.getPage(vnIdx);
  var vcSbp = voTabPage.getItem(0);
  vcSbp.setSrc(psSrc);
  if(psLabel) {
    var voTabBtn = this.getButton(vnIdx);
    voTabBtn.setValue(psLabel);
  }
};
/**
 * 탭 버튼 및 그에 따른 탭 바디 추가 메소드.
 * @param {String} psTabName 탭 버튼 라벨
 * @param {String} psButtonId 탭 버튼 아이디
 * @param {String} psPageId 탭 페이지 아이디
 * @param {Boolean} pbVisible Visible 여부
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 추가된 탭의 인덱스
 * @type Number
 */
eXria.controls.xhtml.Tab.prototype.addTab = function(psTabName, psButtonId, psPageId, pbVisible, pnLeft, pnTop, pnWidth, pnHeight) {
  var voCtrl = this.getCtrl();
  var voDf = this.df;
  var voPageDf = this.tabpages;
  var voHeader = this.tabHeader;
  var vsButtonId = null;
  var vsPageId = null;

  if(this.headerHeight == null) this.headerHeight = this.getAttrValue("headerHeight", this.headerHeight);
  if(psButtonId == null) vsButtonId = this.id + "_button_" + this.tabSeqNum;
  else vsButtonId = this.id + "_page_" + psButtonId;
  if(psPageId == null) vsPageId = this.id + "_page_" + this.tabSeqNum;
  else vsPageId = this.id + "_page_" + psPageId;
  if(pnLeft == null) {
    pnLeft = 0;
    pnTop = this.headerHeight;
    if(this.headerPos == "bottom") pnTop = 0;
    pnWidth = this.innerWidth;
    pnHeight = this.innerHeight - this.headerHeight;
  }
  var voTabPage = new eXria.controls.xhtml.TabPage(vsPageId, pnLeft, pnTop, pnWidth, pnHeight);
  voTabPage.subId = psPageId;
  voTabPage.parent = this;
  //voCtrl.appendChild(voTabPage.create());
  //voTabPage.getCtrl().style.zIndex = this.tabSeqNum;
  if(pbVisible) voTabPage.visible = pbVisible;
  voTabPage.zIndex = this.tabSeqNum;
  this.tabPageZindex = this.tabSeqNum;
  this.tabPageSet.add(voTabPage);
  if(voCtrl) {
   voTabPage.canvas = this.canvas;
   voTabPage.window = this.window;
   voTabPage.document = this.document;
   voTabPage.backgroundColor = this.tabpages.backgroundColor;
   voTabPage.className = voPageDf.className;
   voTabPage.outerClassName = voPageDf.outerClassName;
   voTabPage.borderStyle = voPageDf.borderStyle;
   voTabPage.borderColor = voPageDf.borderColor;
   voTabPage.borderWidth = voPageDf.borderWidth;
   voTabPage.borderLeftWidth = voPageDf.borderLeftWidth;
   voTabPage.borderRightWidth = voPageDf.borderRightWidth;
   voTabPage.borderTopWidth = voPageDf.borderTopWidth;
   voTabPage.borderBottomWidth = voPageDf.borderWidth;
   voTabPage.overflow = voPageDf.overflow;
   voTabPage.overflowX = voPageDf.overflowX;
   voTabPage.overflowY = voPageDf.overflowY;
    voTabPage.visible = false;
    voCtrl.appendChild(voTabPage.create());
    voTabPage.getCtrl().style.zIndex = this.tabSeqNum;
  }
  var voTabButton = new eXria.controls.xhtml.TabButton(vsButtonId, 0, 0, voHeader.tabbuttons.width, voHeader.tabbuttons.height);
  voTabButton.subId = psButtonId;
  voTabButton.value = psTabName;
  voTabButton.pageId = vsPageId;
  voTabButton.pageSubId = psPageId;
  voTabPage.btn = voTabButton;
  if(pbVisible != null) voTabButton.visible = pbVisible;
  voHeader.addTabButton(voTabButton);
  this.tabSeqNum++;

  var vnIndex = this.tabPageSet.size() - 1;
  if(vnIndex == this.selectedIndex) this.selectTab(vnIndex);

  return this.tabPageSet.size() - 1;
};
/**
 * 미리 생성된 탭 바디를 탭에 추가하기 위한 메소드
 * @param {String} psTabName 탭 버튼 라벨
 * @param {String} psButtonId 생성할 버튼의 아이디
 * @param {eXria.controls.xhtml.TabPage} poTabPage 탭 바디
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.addTabPage = function(psTabName, psButtonId, poTabPage) {
  var voCanvas = this.canvas;
  var voHeader = this.tabHeader;
  var vsButtonId = null;

  poTabPage.canvas = voCanvas;
  poTabPage.window = this.window;
  poTabPage.document = this.document;
  poTabPage.getCtrl().style.zIndex = this.tabSeqNum;
  this.tabPageZindex = this.tabSeqNum;
  this.tabPageSet.add(poTabPage);
  if(psButtonId == null) vsButtonId = this.id + "_button_" + tabSeqNum++;
  else vsButtonId = this.id + "_button_" + psButtonId;
  var voTabButton = new eXria.controls.xhtml.TabButton(vsButtonId, 0, 0, voHeader.tabbuttons.width, voHeader.tabbuttons.height);
  voTabButton.subId = psButtonId;
  voTabButton.value = psTabName;
  voTabButton.pageId = poTabPage.id;
  voTabButton.pageSubId = poTabPage.subId;
  voHeader.addTabButton(voTabButton);
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 인덱스 번호 반환.
 * @param {String} psLabel 탭 버튼 라벨
 * @return 라벨에 해당하는 탭 버튼 인덱스
 * @type Number
 */
eXria.controls.xhtml.Tab.prototype.getIndex = function(psLabel) {
  var voHeader = this.tabHeader;
  var voIterator = voHeader.controls.iterator();
  var voTabButton = null;
  var i = 0;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.value.indexOf(psLabel) == 0) { return i; }
    i++;
  }
  return -1;
};
/**
 * 지정된 pageId에 해당하는 탭 인덱스 반환.
 * @param {String} psPageId 지정된 페이지 아이디.
 * @return pageId에 해당하는 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.Tab.prototype.getIndexById = function(psPageId) {
  var vnIndex = -1;
  var voIterator = this.tabPageSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == psPageId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};
/**
 * 지정된 subId에 해당하는 탭 인덱스 반환.
 * @param {String} pspageSubId 지정된 서브 아이디.
 * @return subId에 해당하는 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.Tab.prototype.getIndexBySubId = function(psPageSubId) {
  var vnIndex = -1;
  var voIterator = this.tabPageSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.subId == psPageSubId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};
/**
 * 모든 탭 제거.
 */
eXria.controls.xhtml.Tab.prototype.removeAll = function() {
  var voTabHeader = this.tabHeader;
  var voTabPageSet = this.tabPageSet;
  voTabHeader.controls.clear();
  voTabHeader.refresh();
  var vnSize = this.tabPageSet.size();
  for(var i = 0; i < vnSize; i++) {
    this.removeTabPage(0);
  };
};
/**
 * type 이 minimizedWindow 인 경우 사용될 탭 제거 메소드
 * @param {Number} pnIndex 탭의 인덱스
 */
eXria.controls.xhtml.Tab.prototype.removeMinimizedWindowTab = function(pnIndex) {
  if(!this.type || this.type !== 'minimizedWindow'){
    var voErrMsg;
    voErrMsg.name = "eXria.controls.xhtml.Tab.prototype."
    voErrMsg.message = "type 이  minimizedWindow 인 경우에만 사용이 가능 합니다."
    throw voErrMsg;
  };
  this.removeTab(pnIndex);
};
/**
 * 지정된 인덱스에 해당하는 탭 제거.
 * @param {Number} pnIndex 탭의 인덱스
 */
eXria.controls.xhtml.Tab.prototype.removeTab = function(pnIndex) {
  var voHeader = this.tabHeader;
  var voTabButton = voHeader.controls.remove(pnIndex);
  var voTd = voTabButton.getCtrl().parentNode;
  voTabButton.clear();

  var voTr = this.lookup(voHeader.id + "_tab_tr");
  voTr.removeChild(voTd);

  voHeader.checkScroll();
  this.removeTabPage(pnIndex);
  if(pnIndex == this.selectedIndex && voHeader.controls.size() > 0) {
    this.selectedIndex = -1;
    if(pnIndex >= voHeader.controls.size()) --pnIndex;
    this.selectTab(pnIndex);
  }
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 제거.
 * @param {String} psLabel 라벨명
 */
eXria.controls.xhtml.Tab.prototype.removeTabByLabel = function(psLabel) {
  var vnIndex = this.getIndex(psLabel);
  if(vnIndex != -1) this.removeTab(vnIndex);
};
/**
 * 지정된 페이지 subId에 해당하는 탭 제거.
 * @param {String} psPageSubId 페이지 서브 아이디
 */
eXria.controls.xhtml.Tab.prototype.removeTabById = function(psPageSubId) {
  var vnIndex = this.getIndexBySubId(psPageSubId);
  if(vnIndex != -1) this.removeTab(vnIndex);
};
/**
 * 지정된 인덱스의 탭 바디 제거.
 * @param {Number} pnIndex 탭 바디 인덱스
 * @private
 */
eXria.controls.xhtml.Tab.prototype.removeTabPage = function(pnIndex) {
  var voControl = this.tabPageSet.remove(pnIndex);
  voControl.clear();
};
/**
 * 지정된 인덱스의 탭 활성화.
 * @param {Number} pnIndex 탭 바디 인덱스
 */
eXria.controls.xhtml.Tab.prototype.selectTab = function(pnIndex) {
  this.tabHeader.select(pnIndex);
};
/**
 * 지정된 pageId에 해당하는 탭 활성화
 * @param {String} psPageId 페이지 아이디
 */
eXria.controls.xhtml.Tab.prototype.selectById = function(psPageId) {
  var vnIndex = -1;
  var vsId = this.id + "_page_" + psPageId;
  var voIterator = this.tabPageSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == vsId) {
      vnIndex = cnt;
      break;
    }
  }

  if(vnIndex != -1) this.selectTab(vnIndex);
};
/**
 * 지정된 인덱스에 해당하는 탭 버튼 반환.
 * @param {Number} pnIndex 탭 인덱스
 * @return 지정된 인덱스에 해당하는 탭 버튼
 * @type eXria.controls.xhtml.TabButton
 */
eXria.controls.xhtml.Tab.prototype.getButton = function(pnIndex) {
  var voHeader = this.tabHeader;
  var voTabButton = null;
  voTabButton = voHeader.controls.get(pnIndex);
  return voTabButton;
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 반환.
 * @param {String} psLabel 탭 버튼 라벨
 * @return 지정된 라벨에 해당하는 탭 버튼 객체
 * @type eXria.controls.xhtml.TabButton
 */
eXria.controls.xhtml.Tab.prototype.getButtonByLabel = function(psLabel) {
  var voHeader = this.tabHeader;
  var voIterator = voHeader.controls.iterator();
  var voTabButton = null;
  var i = 0;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.value == psLabel) { return voTabButton; }
  }
  return null;
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 반환.
 * @param {String} psButtonSubId 탭 버튼 아이디
 * @return 지정된 아이디에 해당하는 탭 버튼 객체
 * @type eXria.controls.xhtml.TabButton
 */
eXria.controls.xhtml.Tab.prototype.getButtonById = function(psButtonSubId) {
  var voHeader = this.tabHeader;
  var voIterator = voHeader.controls.iterator();
  var voTabButton = null;
  var i = 0;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.subId == psButtonSubId) { return voTabButton; }
  }
  return null;
};
/**
 * 지정된 인덱스에 해당하는 탭 페이지 반환.
 * @param {Number} pnIndex 탭 인덱스
 * @return 지정된 인덱스에 해당하는 탭 페이지
 * @type eXria.controls.xhtml.TabPage
 */
eXria.controls.xhtml.Tab.prototype.getPage = function(pnIndex) {
  var voPage = null;
  try {
    voPage = this.tabPageSet.get(pnIndex);
  } catch(err) {}
  return voPage;
};
/**
 * 지정된 페이지 ID에 해당하는 탭 페이지 반환.
 * @param {String} psPageSubId 탭 페이지 id
 * @return 지정된 페이지 ID에 해당하는 탭 페이지
 * @type eXria.controls.xhtml.TabPage
 */
eXria.controls.xhtml.Tab.prototype.getPageById = function(psPageSubId) {
  var vnIndex = this.getIndexBySubId(psPageSubId);

  var voPage = null;
  voPage = this.tabPageSet.get(vnIndex);
  return voPage;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.clear = function() {
  this.tabHeader.clear();
  var voTabPage = null;
  var voIterator = this.tabPageSet.iterator();
  while(voIterator.hasNext()) {
    voTabPage = voIterator.next();
    voTabPage.clear();
  }
  this.clearCtrl();
  this.clearControl();
};
/**
 * getCtrlClassName
 * @param {String} psClassName 참조 대상 클래스명
 * @param {String} psOuterClassName
 * @return vsClassName
 * @type String
 */
eXria.controls.xhtml.Tab.prototype.getCtrlClassName = function(psClassName, psOuterClassName) {
  var vsClassName = "";
  if(psClassName == null) psClassName = "";
  if(psOuterClassName == null) psOuterClassName = "";
  vsClassName = psClassName + " " + psOuterClassName;
  vsClassName = eXria.util.StringUtil.trim(vsClassName);

  return vsClassName;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.getSpecificDefaultValue = function(psAttrName){
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.Tab[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.Tab[vaAttrName[0]][vaAttrName[1]] || vsDefaultValue;
  }
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.tabSpinLeft = function(e){
  this.tabHeader.tabSpinLeft(e);
}
/**
 * @ignore
 */
eXria.controls.xhtml.Tab.prototype.tabSpinRight = function(e){
  this.tabHeader.tabSpinRight(e);
}
/**
 * 클래스 명을 반환.
 * @return "Tab"
 * @type String
 */
eXria.controls.xhtml.Tab.prototype.toString = function() {
  return "Tab";
};

/**
 * 지정됨 탭을 숨기거나 보임
 * @param  {Number} pnIndex 숨기거나 보이려고 하는 탭 인덱스
 * @param  {Boolean} pbShow true 이면 지정된 탭을 보이고 false 이면 탭을 숨김
 */
eXria.controls.xhtml.Tab.prototype.showTab = function(pnIndex, pbShow){
  var that = this;

  //내부함수 선언
  var showNextTab = function(pnIdx){
    var voControls = that.tabHeader.controls;
    var vnSize = voControls.size();
    var voTabButton = null;
    voTabButton = voControls.get(pnIdx);

    //가장 마자믹 tab 일경우 처음 부터
    if(pnIdx-1 >= vnSize-1){
      for(var i = 0; i < vnSize; i++) {
        voTabButton = voControls.get(i);
        if(voTabButton.visible != false) {
          that.selectTab(i);
          break;
        }
      }
    }else{
      if(voTabButton.visible != false) {
        that.selectTab(pnIdx);
      }
    }
  };

  if(typeof(pnIndex) === 'number'){
    if(!!pbShow){
      this.getButton(pnIndex).visible = true;
      this.refresh();
    }else{
      this.getButton(pnIndex).visible = false;
      this.refresh();

      //현재 보여지는 tab이 숨겨질 경우 다음탭을 활성화
      if(this.selectedIndex === pnIndex)
        showNextTab(pnIndex+1);
    }
  }
};
/**
 * @fileoverview
 * Concreate xhtml TextArea(XHTML TextArea 컨트롤)
 * @author 조동일 , 이종녕
 */

/**
 * @class 텍스트 입력필드를 여러줄 만들어주는 컨트롤을 생성하는 class입니다.<br />
 * XHTML TextArea Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.TextArea 객체
 * @type eXria.controls.xhtml.TextArea
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.TextArea = function(psId,pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 최대 표현 가능한 문자열의 줄 수.
   * @type Number
   */
  this.rows = null;
  /**
   * 한 줄에 최대 표현 가능한 문자열의 길이.
   * @type Number
   */
  this.cols = null;
  /**
   * 한 줄에 최대 표현 가능한 문자열의 길이, -1일 경우 제한없음.
   * @type Number
   */
  this.maxLength = null;
  /**
   * 텍스트 오버플로우 속성.<br>
   * "visible" | "scroll" | "hidden" | "auto"
   * @type String
   */
  this.overflow = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 가로 정렬 방식.<br>
   * "left" | "center" | "right"
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트에 밑줄을 넣을때.<br>
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 읽기 전용 여부.
   * @type String
   */
  this.readOnly = null;
  /**
   * 컨트롤의 설정된 값.
   * @type String
   */
  this.value = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  /**
   * 텍스트 오버플로우
   */
  this.inputOverFlow = false;
  /**
   * 한 줄에 최소 표현 가능한 문자열의 길이
   * @type Number
   */
  this.minLength = null;
  /**
   * 사용자 정의 nullable 속성
   * @type Boolean
   */
  this.nullable = true;
  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;
  /**
   * input element ime-mode 설정 속성
   * @type String
   */
  this.imeMode = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.TextArea);
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.createCtrl = function(poDocument){
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<textarea id='" + this.id + "_textarea' class='" + vsClass + "' ");
  vaTemplate.push("@attStrBuf");
  vaTemplate.push(" style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\">");
  vaTemplate.push("@innStrBuf");
  vaTemplate.push("</textarea>")
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.refreshTemplate = null;
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.maxLength = this.getAttrValue("maxLength",this.maxLength);
  this.minLength = this.getAttrValue("minLength",this.minLength);
  this.value = this.getAttrValue("value",this.value);
  this.readOnly = this.getAttrValue("readonly",this.readOnly);
  this.cols = this.getAttrValue("cols", this.cols);
  this.rows = this.getAttrValue("rows", this.rows);
};
eXria.controls.xhtml.TextArea.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];
  if(this.readOnly) vfcSetAttStrBuf(vaAttStrBuf, "readOnly", this.readOnly);
  if(this.maxLength != null) {
    vfcSetAttStrBuf(vaAttStrBuf, "maxLength", this.maxLength);
    this.textLengthCheck(poCtrl);
  }
   if(this.minLength != null) {
    vfcSetAttStrBuf(vaAttStrBuf, "minLength", this.minLength);
  }

  vfcSetAttStrBuf(vaAttStrBuf, "cols", this.cols);
  vfcSetAttStrBuf(vaAttStrBuf, "rows", this.rows);
  if(this.overflowX == "scroll") {
    vfcSetAttStrBuf(vaAttStrBuf, "wrap", "off");
  }
  //vaAttStrBuf.push("on")
  vaTemplate[1] = vaAttStrBuf.join("");

  var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
  if(vnWidth < 0) vnWidth = 0;

  var vnHeight = this.innerHeight - this.paddingTop - this.paddingBottom;
  if(vnHeight < 0) vnHeight = 0;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;padding:0px;border-style:none;top:0px;left:0px;");//overflow:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  //vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  // yhkim 2009.09.15 outer색깔에 적용
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  if(this.canvas.page.metadata.browser.ie <= 0) {     // ie가 아닌 브라우저에서 나타나는 resize 표시를 막음
    vfcSetCssStrBuf(vaCssStrBuf, "resize", "none");
  }
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vaTemplate[3] = vaCssStrBuf.join("");

  vaTemplate[5] = this.value;
  poCtrl.innerHTML = vaTemplate.join("");

  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
  if(this.canvas.page.metadata.browser.gecko != 0){
    new Observe(this.subElement.textarea);
  }
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.textarea = this.getSubCtrl("textarea", voCtrl, poDocument);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTextarea = this.subElement.textarea;
  switch(psAttrName) {
    case "disabled" :
      this.setDisable(voTextarea, psAttrValue);
      break;
    case "backgroundColor" :
    case "color" :
      this.setAttrCtrl(psAttrName, psAttrValue, voTextarea);
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.setSpecificEvents = function(poCtrl) {
  var voTextarea = this.subElement.textarea;
  voTextarea.control = this;

//  this.eventManager.addListener(voTextarea, "onchange", this.mediateEvent);
  this.eventManager.addListener(voTextarea, "onblur", this.mediateEvent);
  voTextarea.onfocus = function(event) {
    if(this.control == null) return;
    var voControl = this.control;
    voControl.runEvent(event, voControl);
    voControl.checkSkipEvent(event);
  }
  this.eventManager.addListener(voTextarea, "onselect", this.mediateEvent);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.atkeydown = function(e) {
//  var voDf = this.df;
//  var voCtrl = this.ctrl;
//  if(this.maxLength != null) {
//    if(this.inputOverFlow) {
//      var vnKeyCode = e.keyCode; //IE
//      if(vnKeyCode == null) {
//        e.charCode; //Mozilla
//      }
//      // BackSpace, Tab, Delete Key
//      if(vnKeyCode != 8 && vnKeyCode != 9 && vnKeyCode != 46) {
//        var voText = this.subElement.textarea;
//        voText.value = this.textBuffer;
//        e.returnValue = false; //IE;
//      } else {
//        e.returnValue = true; //IE;
//      }
//    }
//  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.atkeyup = function(e) {
  this.textLengthCheck();
  this.textByteLengthCheck();
  if(this.inputOverFlow) {
    this.inputOverFlow = false;
    this.skipEvent = true;
    var voCtrl = this.subElement.textarea;
    this.cursorPos = this.getCursorPosition();
    voCtrl.blur();
    voCtrl.value = this.textBuffer;
    voCtrl.setAttribute("trimValue",this.textBuffer);

  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.finalkeyup = function(e) {
  if(this.skipEvent) {
    var voCtrl = this.subElement.textarea;
    voCtrl.focus();
    this.setCursorPos(this.cursorPos);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.atclick = function(e) { /* 입력 length 체크 */
  var voDf = this.df;
  //if(this.maxLength != -1) {
  if(this.maxLength != null) {
    var voCtrl = this.ctrl;
    var voText = this.subElement.textarea;
    var vsText = voCtrl.value;
    if(this.inputOverFlow) {
      voText.value = this.textBuffer;
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.dofocus = function() {
  var voText = this.subElement.textarea;
  voText.focus();
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.atfocus = function(e) {
//  if(this.focused == false) this.selectText();
  this.focused = true;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.atblur = function(e) { /* 입력 length 체크 */
  var voCtrl = this.ctrl;
  var voText = this.subElement.textarea;
  this.textLengthCheck();
  this.textByteLengthCheck();
  if(this.inputOverFlow) {
    voText.value = this.textBuffer;
    this.inputOverFlow = false;
  }

  this.value = voText.value;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != voText.value) {
    vbChanged = true;
  }
  this.onchangeInitValue = voText.value;
  if(vbChanged) {
    this.data.setData(voText.value);
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
    if(this.changeEventCallback) this.changeEventCallback(voEvn)
  }

  this.focused = false;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.doblur = function() {
  var voText = this.subElement.textarea;
  voText.blur();
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.checkSkipEvent = function(poEvent) {
  if(this.skipEvent) {
    this.skipEvent = false;
  }
};
///**
// * @ignore
// */
//eXria.controls.xhtml.TextArea.prototype.atchange = function(e) {
//  var voCtrl = this.ctrl;
//  var voText = this.subElement.textarea;
//  var vsRefData = voText.value;
//  this.setValue(vsRefData, voCtrl);
//};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
  var voTextarea = this.subElement.textarea;
  var voStyle = voTextarea.style;
  voStyle.cssText = "";

//  this.eventManager.removeListener(voTextarea, "onchange", this.mediateEvent);
  this.eventManager.removeListener(voTextarea, "onblur", this.mediateEvent);
  voTextarea.onblur = null;
  this.eventManager.removeListener(voTextarea, "onselect", this.mediateEvent);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var voTextareaCtrl = this.subElement.textarea;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  if(this.readOnly) voTextareaCtrl["readOnly"] = this.readOnly;
  if(this.maxLength != null) {
    voTextareaCtrl["maxLength"] = this.maxLength;
    this.textLengthCheck(poCtrl);
  }
  if(voDf.minLength != null) {
    voTextareaCtrl["minLength"] = voDf.minLength;
  }
  if(this.overflowX == "scroll") voTextareaCtrl["wrap"] = "off";
  else voTextareaCtrl["wrap"] = "soft";
  if(this.className != null) voTextareaCtrl.className = this.getCSSClass(this, 1);

  voTextareaCtrl["cols"] = this.cols;
  voTextareaCtrl["rows"] = this.rows;

  // 2009. 09.24 리프레쉬시 textarea 영역이 넘치는 현상 방지
  var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
  if(vnWidth < 0) vnWidth = 0;

  var vnHeight = this.innerHeight - this.paddingTop - this.paddingBottom;
  if(vnHeight < 0) vnHeight = 0;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;padding:0px;border-style:none;top:0px;left:0px;");//overflow:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  //vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "ime-mode", this.imeMode);
  if(this.canvas.page.metadata.browser.ie <= 0) {   // ie가 아닌 브라우저에서 나타나는 resize 표시를 막음
    vfcSetCssStrBuf(vaCssStrBuf, "resize", "none");
  }
  voTextareaCtrl.style.cssText = vaCssStrBuf.join("");
  var vsValue = this.value;
  if(vsValue == null) vsValue = "";

};

// innerHtml로 넣을 경우 필요하다.
eXria.controls.xhtml.TextArea.prototype.getHtmlText = function(psValue) {
  if(psValue) {
    psValue = psValue.replace(/</g, "&lt;");
    psValue = psValue.replace(/>/g, "&gt;");
    psValue = psValue.replace(/\n/g, "<br/>");
  }
  return psValue;
};

/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
}
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voTextarea = this.subElement.textarea;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
    case "visible" :
      this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
      break;
    case "disabled" :
      this.setDisable(voCtrl, psAttrValue);
      break;
    case "outerClassName":
    case "className":
    case "borderWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderTopWidth":
    case "borderBottomWidth":
    case "padding":
    case "paddingLeft":
    case "paddingRight":
    case "paddingTop":
    case "paddingBottom":
      this.refresh(poDocument);
      break;
    case "maxLength":
      this.setAttrCtrl(psAttrName, psAttrValue, voTextarea);
      this.textLengthCheck(voCtrl, poDocument);
      break;
    case "minLength":
      this.setAttrCtrl(psAttrName, psAttrValue, voTextarea);
      break;
    case "value":
      this.setValue(psAttrValue, voCtrl);
      break;
    case "readOnly":
    case "textAlign":
    case "textDecoration":
    case "cols":
    case "rows":
      this.setAttrCtrl(psAttrName, psAttrValue, voTextarea);
      break;
    case "overflow":
    case "overflowX":
    case "overflowY":
      this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
      break;
    default: {
      this.refresh(poDocument);
      break;
    }
  }
};
/**
 * loadData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
//  if(this.data.instanceId == null || this.data.isRelativeRef()) return;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  var voTextAreaCtrl = this.subElement.textarea;
  voTextAreaCtrl.value = vsRefData;
  vsRefData = voTextAreaCtrl.value;
  voTextAreaCtrl.setAttribute("trimValue", vsRefData);
  this.setValue(vsRefData, voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
};
/**
 * 최대 입력가능 길이를 체크합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.textLengthCheck = function(poCtrl, poDocument) {
  var voDf = this.df
  if(this.maxLength == null) return;
  var voCtrl = this.getSubCtrl("textarea", poCtrl, poDocument);
  if(voCtrl == null) return;
  var vsText = voCtrl.value;
  var vnSize = vsText.length;
  if(vnSize <= this.maxLength) return;
  var vsSubText = vsText.substr(0, this.maxLength);
  this.textBuffer = vsSubText;
  this.inputOverFlow = true;
};
/**
 * 최대 입력가능 Byte길이를 체크합니다.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.textByteLengthCheck = function(poCtrl, poDocument) {
  var voDf = this.df
  if(this.maxByteLength == null) return;
  var voCtrl = this.getSubCtrl("textarea", poCtrl, poDocument);
  if(voCtrl == null) return;
  var vsText = voCtrl.value;
  if(this.inputOverFlow) vsText = this.textBuffer;
  var vnMultiCharLength = 0;
  if(!vsText) return;
  var vsByte = (escape(vsText)).match(/%u/g);
  if(!vsByte) vsByte = "";
  vnMultiCharLength = vsByte.length;
  var vnSize = (vsText.length - vnMultiCharLength) + (vnMultiCharLength*2);
  if(vnSize <= this.maxByteLength) return;
  var vnSubLength = 0;
  vnSize = vsText.length;
  var vsChar =null;
  var i = null;
  for(i = 0; i < vnSize; i++) {
    vsChar = escape(vsText.charAt(i));
    if (vsChar.length == 1) {
      vnSubLength++;
    } else if (vsChar.indexOf("%u") != -1)  {
      vnSubLength += 2;
    } else if (vsChar.indexOf("%") != -1)  {
      vnSubLength += vsChar.length/3;
    }
    if(vnSubLength > this.maxByteLength) {
      break;
    }
  }
  var vsSubText = vsText.substring(0, i);
  this.textBuffer = vsSubText;
  this.inputOverFlow = true;
};
/**
 * 텍스트를 선택상태로 만들어 줍니다.
 */
eXria.controls.xhtml.TextArea.prototype.selectText = function() {
  var voCtrl = this.ctrl;
  var voTextarea = this.subElement.textarea;
  var vnPos = voTextarea.value.length;
  if(vnPos == 0) {
    voTextarea.focus();
  }else {
    if (voTextarea.createTextRange) {
      var range = voTextarea.createTextRange();
      range.collapse(true);
      range.moveEnd('character', vnPos);
      range.moveStart('character', 0);
      range.select();
    } else if (voTextarea.selectionEnd) {
      voTextarea.selectionStart = 0;
      voTextarea.selectionEnd = vnPos;
    }
  }
};
/**
 * 커서 위치를 지정해주는 메소드.
 * @param {Number} pnPos 커서 위치
 * @private
 */
eXria.controls.xhtml.TextArea.prototype.setCursorPos = function(pnPos) {
  var voCtrl = this.ctrl;
  var voTextarea = this.subElement.textarea;
    if (voTextarea.createTextRange) {
      var range = voTextarea.createTextRange();
      range.collapse(true);
      range.moveEnd('character', pnPos);
      range.moveStart('character', pnPos);
      range.select();
    } else if (voTextarea.selectionEnd) {
      voTextarea.selectionStart = pnPos;
      voTextarea.selectionEnd = pnPos;
    }
};
/**
 * 현재 커서 위치를 반환해주는 메소드
 * @return 현재 커서 위치
 * @type Number
 */
eXria.controls.xhtml.TextArea.prototype.getCursorPosition = function() {
  var voDocument = this.document;
  var vnCaretPos = 0;
  var voCtrl = this.subElement.textarea;
  // IE Support
  if (voDocument.selection) {
    var voSel = voDocument.selection.createRange ();
    voSel.moveStart ('character', -voCtrl.value.length);
    vnCaretPos = voSel.text.length;
  }
  // Firefox support
  else if (voCtrl.selectionStart || voCtrl.selectionStart == '0')
    vnCaretPos = voCtrl.selectionStart;
  return (vnCaretPos);
};
/**
 * 컨트롤에 지정된 값을 설정합니다.
 * @param {String} psText 설정 값.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.TextArea.prototype.setValue = function(psText, poCtrl, poDocument) {
  if(poCtrl == null) poCtrl = this.ctrl;
  var voCurrentCtrl = this.getSubCtrl("textarea", poCtrl, poDocument);
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psText) {
    vbChanged = true;
  }
  this.onchangeInitValue = psText;
  this.value = psText;
  voCurrentCtrl.value = psText; //eXria.controls.xhtml.Util.parseLang(psText);
  if(vbChanged) {
    this.data.setData(this.value);
    var voEvent = new eXria.event.Event(null);
    voEvent.object = this;
    if(this.onchange) this.onchange(voEvent);
  }
};
/**
 * 컨트롤에 설정된 값을 반환합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 컨트롤의 할당된 값
 * @type String
 */
eXria.controls.xhtml.TextArea.prototype.getValue = function(poDocument) {
  return this.value;
};

/**
 * 입력필드에 보여지는 텍스트값을 반환합니다.
 * @return 입력필드에 보여지는값
 * @type String
 */
eXria.controls.xhtml.TextArea.prototype.getText = function() {
  var voCurrentCtrl = this.getSubCtrl("textarea");
  return voCurrentCtrl.value;
};

/**
 * 각 속성에 따른 디폴트 값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.TextArea.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.TextArea[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "TextArea"
 * @type String
 */
eXria.controls.xhtml.TextArea.prototype.toString = function() {
  return "TextArea";
};
/**
 * @fileoverview
 * Concreate xhtml Timer(XHTML Timer 컨트롤)
 * @author 조동일 , 이종녕
 */

/**
 * @class 설정한 Interval 수치에 따라서 원하는 동작을 반복할 수 <br />
 * 있는 컨트롤을 생성하는 class입니다.<br />
 * XHTML Timer Control.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @return 새로운 eXria.controls.xhtml.Timer 객체
 * @type eXria.controls.xhtml.Timer
 * @constructor
 * @base eXria.controls.Control
 */
eXria.controls.xhtml.Timer = function(psId) {

  eXria.controls.Control.call(this, psId);
  /**
   * 구동중인 Timer ID.
   * @type Number
   */
  this.timerID; //long
  /**
   * Timer 구동중 여부.
   * @type Boolean
   */
  this.isRun = false;
  /**
   * 타이머 유형을 지정하기 위한 상수.
   * TIMEOUT | INTERVAL
   * @type Object
   */
  this.TYPE = {
    TIMEOUT : 1,
    INTERVAL : 2
  };
  /**
   * 구동중인 Timer의 구분.
   * @type Number
   * @assert eXria.controls.xhtml.Timer.TYPE.TIMEOUT || eXria.controls.xhtml.Timer.TYPE.INTERVAL
   */
  this.runType = -1;
  /**
   * 타이머 호출 시간 간격(ms).
   * @type Number
   */
  this.interval = 1000;
  /**
   * 타이머 호출 중지 카운트.
   * @type Number
   */
  this.stopCount = 0; // -1 지정시 무한반복
  /**
   * 현재까지 반복된 카운트 저장.
   * @type Number
   */
  this.curCount = this.stopCount;
  /**
   * 타이머 반복 호출 시 수행될 사용자 지정 함수.
   * @type Number
   */
  this.ontimer = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.Control, eXria.controls.xhtml.Timer);
//////////////////////////////////////////////////////////////////
// 메소드

/**
 * @ignore
 */
eXria.controls.xhtml.Timer.prototype.getEHandler = function(psFuncName) {
  var vaStrBuf = [];
  //vaStrBuf.push("var e=null;");
  //vaStrBuf.push("if(arguments[0]) e=arguments[0];");
  vaStrBuf.push("var voPage=eXria.controls.xhtml.Util.getPage('");
  vaStrBuf.push(this.canvas.page.id);
  vaStrBuf.push("');");
  vaStrBuf.push("voPage.getControl('");
  vaStrBuf.push(this.id);
  vaStrBuf.push("').");
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("();");
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};

/**
 * 타이머를 시작합니다.
 */
eXria.controls.xhtml.Timer.prototype.start = function() {
  //this.setInterval(this.timeEvent,this.interval);
  this.curCount = this.stopCount;
  //this.setInterval(this.getEHandler("timeEvent"), this.interval);
  var voBase = this;
  var voFunc = function() {
    voBase.timeEvent();
  };
  this.setInterval(voFunc, this.interval);
};
/**
 * 타이머를 중지시킵니다.
 */
eXria.controls.xhtml.Timer.prototype.stop = function() {
  this.clearInterval();
};
/**
 * 속성 값을 설정합니다.
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 */
eXria.controls.xhtml.Timer.prototype.setAttr = function(psAttrName,psAttrValue) {
  switch(psAttrName){
    case "stopCount":
      this.stopCount = psAttrValue;
      this.curCount = psAttrValue;
      break;
    case "interval":
      this.interval = psAttrValue;
      break;
  };
};
/**
 * 속성 값을 설정하고 바로 적용합니다. (설정된 속성을 실체화 컨트롤에 바로 적용)
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 */
eXria.controls.xhtml.Timer.prototype.applyAttr = function(psAttrName,psAttrValue) {
  switch(psAttrName){
    case "stopCount":
      this.stopCount = psAttrValue;
      this.curCount = psAttrValue;
      break;
    case "interval":
      this.interval = psAttrValue;
      break;
  };
};
/**
 * start 메소드에 의해 수행되는 작업입니다.
 * @private
 */
eXria.controls.xhtml.Timer.prototype.timeEvent = function(e) {
  if(this.curCount == 0){
    this.clearInterval();
  } else if(this.curCount == -1){
    if(this.ontimer) this.ontimer(e);
  } else {
    if(this.ontimer) this.ontimer(e);
    this.curCount--;
  }
};
/**
 * 일정시간 후 지정함수를 호출합니다.
 * @param {String} psFuntion
 * @param {Number} pnDelay (단위 milisecond = 1/1000초)
 */
eXria.controls.xhtml.Timer.prototype.setTimeout = function(psFunction, pnDelay) {
  var voWindow = this.window;
  if(voWindow == null) voWindow = window;
  if(this.isRun == false) {
    //this.timerID = voWindow.setTimeout(eval(psFunction), pnDelay);
    this.timerID = voWindow.setTimeout(psFunction, pnDelay);
    this.isRun = true;
    this.runType = this.TYPE.TIMEOUT;
  } else {
    //TODO throw Exception
  }
};
/**
 * setTimeout()메소드에의해 수행되고 있는 함수를 중지시킵니다.
 */
eXria.controls.xhtml.Timer.prototype.clearTimeout = function() {
  var voWindow = this.window;
  if(voWindow == null) voWindow = window;
  if(this.isRun == true) {
    voWindow.clearTimeout(this.timerID);
    this.isRun = false;
    this.runType = -1;
  } else {
    //TODO throw Exception
  }
};
/**
 * 일정시간 간격으로 지정 메소드를 반복 호출합니다.
 * @param {String} psFuntion 호출될 메소드명
 * @param {Number} pnDelay 지연시간 (단위 milisecond = 1/1000초)
 */
eXria.controls.xhtml.Timer.prototype.setInterval = function(psFunction, pnDelay) {
  if(this.isRun == false) {
    //this.timerID = window.setInterval(eval(psFunction), pnDelay);
    var voWindow = this.window;
    if(voWindow == null) voWindow = window;
    this.timerID = voWindow.setInterval(psFunction, pnDelay);
    this.isRun = true;
    this.runType = this.TYPE.INTERVAL;
  } else {
    //TODO throw Exception
  }
};
/**
 * setInterval()메소드에의해 수행되고 있는 함수를 중지시킵니다.
 */
eXria.controls.xhtml.Timer.prototype.clearInterval = function() {
  if(this.isRun == true) {
    window.clearInterval(this.timerID);
    this.isRun = false;
    this.runType = -1;
    //this.stopCount = this.oriStopCount;
  } else {
    //TODO throw Exception
  }
};
/**
 * 실체화 컨트롤에 대한 소멸 처리를 수행합니다.
 */
eXria.controls.xhtml.Timer.prototype.clearCtrl = function() {
  if(this.isRun == true) {
    switch(this.runType) {
      case this.TYPE.TIMEOUT :
        this.clearTimeout();
        break;
      case this.TYPE.INTERVAL :
        this.clearInterval();
        break;
    }
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "Timer"
 * @type String
 */
//this.toString = function() {
eXria.controls.xhtml.Timer.prototype.toString = function() {
  return "Timer";
};
/**
 * @fileoverview
 * Concreate xhtml TreeView(XHTML TreeView 컨트롤)
 * @author 조영진
 */

/**
 * Concreate xhtml TreeNode
 * @author 조영진
 * @version 1.0
 * @param {String} psName
 * @constructor
 */
eXria.controls.xhtml.TreeNode = function(psName) {
  if(psName == null) psName = "";
  /**
   * 자신이 속한 트리뷰 컨트롤 참조 속성.
   * @type eXria.controls.xhtml.Tree
   */
  this.tree = null;
  /**
   * 트리노드 식별 index번호. <br>[readOnly]
   * @type Number
   */
  this.index = -1;
  /**
   * 트리노드 라벨 텍스트.
   * @type String
   */
  this.name = psName;
  /**
   * 현재 노드의 Depth.
   * @type Number
   * @private
   */
  this.depth = - 1;
  /**
   * leftside icons ( 0 : blank, 1: vertical line ).
   * @type Array(Number)
   * @private
   */
  this.leftside = new Array();
  /**
   * 펼쳐져있는지 여부.
   * @type Boolean
   */
  this.expand = false;
  /**
   * 자식 노드 허용 여부.
   * @type Number
   */
  this.isAllowsChildren = 0;
  /**
   * 아이콘 파일명.
   * @type String
   */
  this.icon = "";
  /**
   * 포커스 상태의 아이콘 파일명.
   * @type String
   */
  this.iconOpened = "";
  /**
   * 부모노드. [readOnly]
   * @type eXria.controls.xhtml.TreeNode
   */
  this.parent = null;
  /**
   * childCollection
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.childCollection = new eXria.data.ArrayCollection();
  /**
   * 자식 노드를 저장하는 배열.
   * @type Array
   */
  this.children = new Array();
  /**
   * 실제 자식 노드의 유무에 상관없이 true값을 가지면 자식 노드를 가지는 것으로 하기위한 속성.
   * @type Boolean
   */
  this.hasChild = null;
  /**
   * name이외의 속성을 저장하기 위한 Object. value속성도 이곳에 저장됨.
   * @type eXria.data.ArrayMap
   */
  this.extData = new eXria.data.ArrayMap();
  /**
   * 노드가 포함된 노드셋을 참조하기 위한 속성.
   * @type eXria.controls.xhtml.TreeNodeset
   * @private
   */
  this.nodeset = null;
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   * @private
   */
  this.data = new eXria.controls.DataRefNode();
  /**
   * 줄바꿈을 기준으로 라벨 텍스트를 분리한 문자열 배열 객체
   * @type Array(String)
   */
  this.names = psName.split("\\n");
};
/**
 * 자식 노드를 가지고 있는지 여부.
 * @return 자식 노드를 가지고 있는지 여부
 * @type Boolean
 */
eXria.controls.xhtml.TreeNode.prototype.isLeaf = function() {
  if(this.hasChild) return false;
  return this.children.length == 0 ? true : false;
};
/**
 * 지정된 노드의 부모노드 인지 여부 반환
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 노드
 * @return 대상 노드의 부모노드 인지 여부
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.isAncestor = function(poNode) {
  if(poNode == this.tree.root) return false;
  var parent = poNode.parent;
  var vbAncestor = false;
//  while(parent != this.tree.root) {
  while(parent != null) {
    if(parent == this) {
       vbAncestor = true;
       break;
    }
    parent = parent.parent;
    if(parent == null) break;
  }
  return vbAncestor;
};
/**
 * 노드 혹은 노드셋 추가 메소드
 * @param {eXria.controls.xhtml.TreeNode|eXria.controls.xhtml.TreeNodeset} poChild 추가할 노드 혹은 노드셋.
 * @example
 * var treeView = page.getControl("treeview");<br>
   var newNode = treeView.createTreeNode("nodeName");<br>
   var node = treeView.getNodeByVal("value");<br>
   node.addChild(newNode);<br>
 */
eXria.controls.xhtml.TreeNode.prototype.addChild = function(poChild) {
  this.childCollection.add(poChild);
};
/**
 * childCollection의 노드를 children 속성에 위치시키는 메소드
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.deployChildren = function() {
  this.removeAllChildren();
  var voIterator = this.childCollection.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild instanceof eXria.controls.xhtml.TreeNode) {
      voChild["parentValue"] = this.getValue();
      this.tree.addToItemValueMap(voChild);
      this.add(voChild);
    } else {
      this.addNodeset(voChild, this.tree.canvas);
    }
  }
};
/**
 * Removes newChild from its parent and makes it a child of this node by adding it to the end of this node's child array.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.add = function(poNode, pnIndex, pnSourceIndex) {
  if(pnIndex == null) {
    var voChild = null;
   poNode.index = this.tree.latestIdx++;
   this.tree.items.put(poNode.index, poNode);
   this.children[this.children.length] = poNode;
   poNode.tree = this.tree;
   var voData = poNode.data;
   voData.control = this.tree;
   if(voData.instanceId && voData.instancePath) {
     this.name = voData.getData();
   }
   if(poNode.selected) this.tree.selectedItems.put(poNode.index, poNode);
   poNode.parent = this;
   poNode.depth = this.depth + 1;
   for(var i = 0; i < poNode.children.length; i++) {
     voChild = poNode.children[i];
     voChild.depth++;
   }
   if(this.depth > 0) {
     poNode.leftside = new Array();
     for(var i = 0; i < this.leftside.length; i++) {
       poNode.leftside[poNode.leftside.length] = this.leftside[i];
     }
     poNode.leftside[poNode.leftside.length] = this.parent.getLastChild() == this ? 0 : 1;
   } else {
     poNode.leftside = new Array();
   }
   poNode.fixDecendantsInfo();
   if(this.getChildCount() > 1) this.children[this.children.length - 2].fixLeftsideOfChildren();
   if(this.tree != null) this.tree.addChangedNode(this);
  } else {
    poNode.index = this.tree.latestIdx++;
    this.tree.items.put(poNode.index, poNode);
    var voTarget = this.children[pnIndex - 1]
    for(var i = this.children.length - 1; i >= pnSourceIndex; i--) {
      this.children[i + 1] = this.children[i];
    }
    this.children[pnSourceIndex] = voTarget;
    this.children[pnIndex] = poNode;
    poNode.tree = this.tree;
    poNode.parent = this;
    poNode.depth = this.depth + 1;
    if(this.depth > 0) {
      poNode.leftside = new Array();
      for(var i = 0; i < this.leftside.length; i++) {
        poNode.leftside[poNode.leftside.length] = this.leftside[i];
      }
      poNode.leftside[poNode.leftside.length] = this.parent.getLastChild() == this ? 0 : 1;
    } else {
      poNode.leftside = new Array();
    }
    poNode.fixDecendantsInfo();
    if(this.tree != null) this.tree.addChangedNode(this);
  }
};
/**
 * addNodeset
 * @param {eXria.controls.xhtml.TreeNodeset} poNodeset
 * @param {eXria.form.xhtml.Canvas} poCanvas Canvas 객체
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.addNodeset = function(poNodeset, poCanvas) {
  //this.children[this.children.length] = poNodeset;
  poNodeset.tree = this.tree;
  if(this.tree != null) this.tree.addChangedNode(this);
  poNodeset.loadData(this, poCanvas);
};
/**
 * 자식 노드의 expand속성을 true로 갱신하는 메소드.<br>
 * 노드 새로고침 시 트리에 결과 반영.
 */
eXria.controls.xhtml.TreeNode.prototype.expandChildren = function() {
  this.expand = true;
  for(var i=0; i<this.children.length; i++){
    this.children[i].expand = true;
  }
};
/**
 * 자식 노드와 그 하위의 자식노드 모두의 expand속성을 true로 갱신하는 메소드.<br>
 * 노드 새로고침 시 트리에 결과 반영.
 */
eXria.controls.xhtml.TreeNode.prototype.expandDecendants = function() {
  this.expand = true;
  for(var i=0; i<this.children.length; i++){
    this.children[i].expand = true;
    this.children[i].expandDecendants();
  }
};
/**
 * Fix depth of decendants
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.fixDecendantsInfo = function() {
  for(var i = 0; i < this.children.length; i++) {
    this.children[i].tree = this.tree;
    this.children[i].depth = this.depth + 1;
    this.children[i].leftside = new Array();
    for(var j = 0; j < this.leftside.length; j++) {
      this.children[i].leftside[this.children[i].leftside.length] = this.leftside[j];
    }
    this.children[i].leftside[this.children[i].leftside.length] = this.parent.getLastChild() == this ? 0 : 1;
    this.children[i].fixDecendantsInfo();
  }
};
/**
 * Fix Leftside of Children
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.fixLeftsideOfChildren = function() {
  this.fixLeftsideOfDescendants(this.depth, this.parent.getLastChild() == this ? 0 : 1);
};
/**
 * fixLeftsideOfDescendants
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.fixLeftsideOfDescendants = function(pnDepth, pnValue) {
  for(var i = 0; i < this.children.length; i++) {
    this.children[i].leftside[pnDepth - 1] = pnValue;
    this.children[i].fixLeftsideOfDescendants(pnDepth, pnValue);
  }
};
/**
 * Removes aChild from this node's child array, giving it a null parent.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.remove = function(poNode) {
  for(var i = 0; i < this.children.length; i++) {
    if(this.children[i] == poNode) {
      poNode.parent = null;
      poNode.depth = - 1;
      poNode.tree = null;
      this.tree.remove(poNode);
      this.tree.removeFromChangedNode(poNode);
      this.tree.removeFromSelectedNode(poNode);
      if(this.tree.openedItem == poNode) {
        this.tree.openedItem = null;
      }
      this.children.splice(i, 1);
      break;
    }
  }
  if(this.getChildCount() > 0) this.children[this.children.length - 1].fixLeftsideOfChildren();
  if(this.tree != null) this.tree.addChangedNode(this);
};
/**
 * 하위노드(노드셋) 제거.
 * @param {eXria.controls.xhtml.TreeNode|eXria.controls.xhtml.TreeNodeset} poChild 하위노드(노드셋)
 */
eXria.controls.xhtml.TreeNode.prototype.removeChild = function(poChild) {
  var vnIndex = this.getChildCollectionIdx(poChild);
  if(vnIndex != -1) this.childCollection.remove(vnIndex);
};
/**
 * 하위노드(노드셋) 제거.
 * @param {eXria.controls.xhtml.TreeNode|eXria.controls.xhtml.TreeNodeset} poChild 하위노드(노드셋)
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.removeAll = function() {
  this.childCollection.clear();
};
/**
 * 하위노드(노드셋)의 인덱스 반환.
 * @param {eXria.controls.xhtml.TreeNode|eXria.controls.xhtml.TreeNodeset} poChild 하위노드(노드셋)
 * @return 하위노드(노드셋)의 인덱스
 * @type Number
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.getChildCollectionIdx = function(poChild) {
  var vnIndex = -1;
  var voIterator = this.childCollection.iterator();
  var voChild = null;
  var i = -1;
  while(voIterator.hasNext()) {
    i++;
    voChild = voIterator.next();
    if(voChild == poChild) {
      vnIndex = i;
      break;
    }
  }
  return vnIndex;
};

/**
 * Removes all of this node's children, setting their parents to null.
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.removeAllChildren = function() {
  var vnSize = this.children.length;
  for(var i = 0; i < vnSize; i++) {
    this.children[i].parent = null;
    this.children[i].depth = - 1;
    this.children[i].tree = null;
    if(this.tree && this.children[i].index) {
      this.tree.removeFromChangedNode(this.children[i]);
      this.removeFromTreeItems(this.children[i]);
    }
  }
  this.children = new Array();
  if(this.tree) this.tree.addChangedNode(this);
};
/**
 * Removes all of specified node's children include itself from tree items.
 * @param {eXria.controls.xhtml.TreeNode} poNode specified node
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.removeFromTreeItems = function(poNode) {
  this.tree.remove(poNode);
  var vnSize = poNode.children.length;
  for(var i = 0; i < vnSize; i++) {
    this.removeFromTreeItems(poNode.children[i]);
  }
};
/**
 * Removes the subtree rooted at this node from the tree, giving this node a null parent
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.removeFromParent = function() {
  this.parent.remove(this);
};
/**
 * 이 노드가 선택되었는지 여부 반환.
 * @Return 이 노드가 선택되었는지 여부
 * @type Boolean
 */
eXria.controls.xhtml.TreeNode.prototype.isSelected = function() {
  var vbSelected = false;
  if(this.tree != null) {
    //for(var i = 0; i < this.tree.selectedItems.size(); i++) {
    //  if(this.tree.selectedItems.get(i) == this) vbSelected = true;
    //}
    if(this.tree.selectedItems.get(this.index)) vbSelected = true;
  }
  return vbSelected;
};
/**
 * 노드가 열려져 있는지 여부 반환.
 * 현재 선택되어진 상태라는 점에서 expanded와는 구별됨.
 * @return 노드가 열려져 있는지 여부
 * @type Boolean
 */
eXria.controls.xhtml.TreeNode.prototype.isOpened = function() {
  var vbOpened = false;
  if(this.tree != null) {
    if(this.tree.openedItem.expand == true &&
        this.tree.openedItem.childCollection.length != 0) vbOpened = true;
  }
  return vbOpened;
};
/**
 * 자식 노드의 개수 반환.
 * @return 자식 노드의 개수
 * @type Number
 */
eXria.controls.xhtml.TreeNode.prototype.getChildCount = function() {
   return this.children.length;
};
/**
 * 지정된 노드의 다음 형제 노드 반환.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @return 지정된 노드의 다음 형제 노드
 * @type eXria.controls.xhtml.TreeNode
 * @example
 * var treeView = page.getControl("treeview");<br>
   var node = treeView.getNodeByVal("value");<br>
   node.getChildAfter(node);<br>
 */
eXria.controls.xhtml.TreeNode.prototype.getChildAfter = function(poNode) {
  var voAfter = null;
  for(var i = 0; i < this.children.length - 1; i++) {
    if(this.children[i] == poNode) {
      for(var j = i + 1; j < this.children.length; j++) {
        voAfter = this.children[j];
        if(voAfter.visible != false) {
          return voAfter;
        }
      }
    }
  }
  return null;
};
/**
 * 지정된 노드의 이전 형제 노드 반환.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @return 지정된 노드의 이전 형제 노드
 * @type eXria.controls.xhtml.TreeNode
 * @example
 * var treeView = page.getControl("treeview");<br>
   var node = treeView.getNodeByVal("value");<br>
   node.getChildBefore(node);<br>
 */
eXria.controls.xhtml.TreeNode.prototype.getChildBefore = function(poNode) {
   var voBefore = null;
   for(var i = 1; i < this.children.length; i++) {
      if(this.children[i] == poNode) voBefore = this.children[i - 1];
   }
   return voBefore;
};
/**
 * 첫 번째 자식 노드 반환.
 * @return 첫 번째 자식 노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeNode.prototype.getFirstChild = function() {
   return this.children[0];
};
/**
 * 마지막 자식 노드 반환.
 * @return 마지막 자식 노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeNode.prototype.getLastChild = function() {
  var voChild = null;
  for(var i = this.children.length - 1; i >= 0; i--) {
    voChild = this.children[i];
    if(voChild.visible != false) return voChild;
  }
  return null;
};
//this.getLastChild = function() {
//  return this.children[this.children.length - 1];
//};
/**
 * 지정된 인덱스에 해당하는 자식 노드를 반환.
 * @param pnIndex 자식의 인덱스
 * @return 지정된 인덱스에 해당하는 자식 노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeNode.prototype.getChildAt = function(pnIndex) {
   return this.children[pnIndex];
};
/**
 * 지정된 자식노드의 인덱스 번호 반환. 자식노드가 없으면 -1 반환.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 노드
 * @return 지정된 자식노드의 인덱스 번호
 * @type Number
 * @example
   var treeView = page.getControl("treeview");<br>
   var node = treeView.getNodeByVal("value");<br>
   var lastNode = node.getLastChild();<br>
   node.getIndex(lastNode);<br>
 */
eXria.controls.xhtml.TreeNode.prototype.getIndex = function(poNode) {
   var index = - 1;
   for(var i = 0; i < this.children.length; i++) {
      if(this.children[i] == poNode) index = i;
   }
   return index;
};
/**
 * Returns the path from the root, to get to this node.
 * @return 루트노드로 부터의 path값
 * @type String
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.getPath = function() {
  var vsPath = "";
  vsPath = this.updatePath(this, vsPath);

  return vsPath;
};
/**
 * path 속성 값 갱신
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @param {String} psPath 갱신될 path 값
 * @return vsPath
 * @type String
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.updatePath = function(poNode, psPath) {
  var vsPath = psPath;
  var vsNodePath = "/tn[@name='" + poNode.name + "']";
  vsPath = vsNodePath + vsPath;
  if(poNode.parent != null) {
    vsPath = this.updatePath(poNode.parent, vsPath);
  } else {
    vsPath = "/root" + vsPath;
  }

  return vsPath;
};
/**
 * 현재 노드가 소속되어 있는 루트노드 반환.
 * @return 현재 노드가 소속되어 있는 루트노드
 * @type eXria.controls.xhtml.TreeNode
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.getRoot = function() {
   return this.tree.root;
};
/**
 * value key 이외의 값을 저장할 수 있는 Map에 put.
 * @param {String} psKey 데이타의 키 값
 * @param {String} poValue 데이타
 */
eXria.controls.xhtml.TreeNode.prototype.put = function(psKey, poValue) {
   this.extData.put(psKey, poValue);
};
/**
 * 해당 키 값에 대한 value 값을 얻음.
 * @param {String} poKey extData에서 추출할 데이타의 키 값
 * @return 해당 키 값에 대한 value 값
 * @type String
 */
eXria.controls.xhtml.TreeNode.prototype.get = function(poKey) {
   var value = null;
   value = this.extData.get(poKey);
   return value;
};
/**
 * 트리노드에 할당된 값 반환.
 * @return 트리노드에 할당된 값
 * @type String
 */
eXria.controls.xhtml.TreeNode.prototype.getValue = function() {
  var vsValue = null;
  vsValue = this.extData.get("value");
  return vsValue;
};
/**
 * 트리노드에 value값 할당.
 * @param {String} psValue 할당될 value값.
 */
eXria.controls.xhtml.TreeNode.prototype.setValue = function(psValue) {
  this.extData.put("value", psValue);
};
/**
 * Clone of this
 * @return Clone of this
 * @type eXria.controls.xhtml.TreeNode
 * @private
 */
eXria.controls.xhtml.TreeNode.prototype.clone = function() {
   var voNode = new TreeNode(this.name);
   voNode.icon = this.icon;
   voNode.isAllowChildren = this.isAllowChildren;
   voNode.extData = this.extData;
   for(var i = 0; i < this.getChildCount(); i++) {
      voNode.add(this.children[i].clone());
   }
   return voNode;
};
/**
 * 트리노드의 스타일 속성값을 일괄적으로 변경하기 위한 메소드.
 * @param {Object} poStyleObject 변경될 속성값을 담은 오브젝트
 * @example
 * var data = new eXria.data.Map();
   data.put("name","newName");

   var node = treeView.getNodeByVal("value");
   node.setNodeStyle(data.getEntries());
 */
eXria.controls.xhtml.TreeNode.prototype.setNodeStyle = function(poStyleObject) {
  var vsAttr = null;
  for(vsAttr in poStyleObject) {
    this[vsAttr] = poStyleObject[vsAttr];
  }
  this.tree.addChangedNode(this);
};
/**
 * 클래스 명을 반환.
 * @return "TreeNode"
 * @type String
 */
eXria.controls.xhtml.TreeNode.prototype.toString = function() {
  return "TreeNode";
};

/**
 * @class Concreate xhtml TreeNodeset.<br>
 * TreeView 컨트롤을 구성하는 아이템의 속성정보를 담당하는 클래스.
 * 아이템의 실체화는 TreeView에서 담당.
 * @version 1.0
 * @return 새로운 eXria.controls.xhtml.TreeNodeset 객체
 * @type eXria.controls.xhtml.TreeNodeset
 * @constructor
 */
eXria.controls.xhtml.TreeNodeset = function() {
  /**
   * @private
   */
  //this.index = null;
  /**
   * 인스턴스 데이터로 부터 label 데이타를 가져오기 위한 element 태그명.
   * @type String
   */
  this.labelTagName = null;
  /**
   * 인스턴스 데이터로 부터 value 데이타를 가져오기 위한 element 태그명.
   * @type String
   */
  this.valueTagName = null;
  /**
   * 인스턴스 데이터로 부터 icon image path 데이타를 가져오기 위한 element 태그명.
   * @type String
   */
  this.iconTagName = null;
  /**
   * 인스턴스 데이터로 부터 iconOpened image path 데이타를 가져오기 위한 element 태그명.
   * @type String
   */
  this.iconOpenedTagName = null;
  /**
   * 부모 데이타 노드에서 라벨 데이타를 가져올 때 사용되는 DOM Element 명.
   * @type String
   */
  this.parentTagName = "parent";
  /**
   * tree 컨트롤 참조 변수. readOnly
   * @type eXria.controls.xhtml.TreeView
   */
  this.tree = null;
  /**
   * 데이타 연동 객체.
   * @type eXria.controls.DataRefNodeset()
   */
  this.data = new eXria.controls.DataRefNodeset();

};
/**
 * loadData
 * @param {eXria.controls.xhtml.TreeNode} poParentTreeNode
 * @param {eXria.form.xhtml.Canvas} poCanvas
 * @private
 */
eXria.controls.xhtml.TreeNodeset.prototype.loadData = function(poParentTreeNode, poCanvas) {
  var voTree = this.tree;
  if(voTree == null || (this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null)) return;
  if(voTree.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    this.loadDataFromPluginInstance(poParentTreeNode, poCanvas);
    return;
  }
  this.data.control = voTree;

  var vsRefValue = null;
  if(this.data.instanceId != null) vsRefValue = this.data.getData();
  var voCollectionNode = this.data.getNodesetData2();
  if(voCollectionNode == null) return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vsSelectNode = null;
  var vsDisableNode = null;
  var vsWbsType = null;
  var vsParentNode = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  var vaNodes = [];
  var voTreeNode = null;
  var vsIcon = null;
  var vsIconOpened = null;
  this.parent = poParentTreeNode;
  var vsParentValue = poParentTreeNode.getValue();
  for(var i = 0; i < vnLoop; i++) {
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    vsLabelNode = voMapNode.get(this.labelTagName);
    vsValueNode = voMapNode.get(this.valueTagName);
    vsParentNode = voMapNode.get(this.parentTagName);
    if(vsParentNode == null || vsParentNode == "") vsParentNode = vsParentValue;
    if(voTree.selectTagName) vsSelectNode = voMapNode.get(voTree.selectTagName);
    if(voTree.disableTagName) vsDisableNode = voMapNode.get(voTree.disableTagName);
    if(voTree.wbsTypeTagName) {
      vsWbsType = voMapNode.get(voTree.wbsTypeTagName);
    }
    vsIcon = voMapNode.get(this.iconTagName);
    vsIcon = eXria.controls.xhtml.Util.getImagePath(vsIcon, poCanvas.page.window);
    vsIconOpened = voMapNode.get(this.iconOpenedTagName);
    vsIconOpened = eXria.controls.xhtml.Util.getImagePath(vsIconOpened, poCanvas.page.window);
    voTreeNode = voTree.createTreeNode(vsLabelNode);
    voTreeNode.nodeset = this;
    voTreeNode.tree = this.tree;
    voTreeNode.put("value", vsValueNode);
    voTreeNode["parentValue"] = vsParentNode;
    if(vsSelectNode == "Y") voTreeNode.selected = true;
    if(vsDisableNode == "Y") voTreeNode.disabled = true;
    if(vsWbsType && voTree.wbsIconMap) {
      vsIcon = voTree.wbsIconMap[vsWbsType];
      vsIcon = eXria.controls.xhtml.Util.getImagePath(vsIcon, poCanvas.page.window);
      vsIconOpened = vsIcon;
    }
    voTreeNode.icon = vsIcon;
    voTreeNode.iconOpened = vsIconOpened;
    vaNodes.push(voTreeNode);
    this.tree.addToItemValueMap(voTreeNode, vsValueNode);
    //if(vsLabelNode == vsRefValue) {
    //  this.tree.selectedItems.add(voTreeNode);
    //}
    //this.checkParent(voTreeNode, vsParentNode);
  }
  var voMap = this.tree.itemValueMap;
  var voFunc = this.tree.mapBlockIdFunc;
  for(var i = 0; i < vaNodes.length; i++) {
    voTreeNode = vaNodes[i];
    vsParentNode = voTreeNode["parentValue"];
//    this.checkParent(voTreeNode, vsParentNode, vaNodes, i);
    this.checkParent(voTreeNode, vsParentNode, voMap, voFunc);
  }
};
/**
 * loadDataFromPluginInstance
 * @param {eXria.controls.xhtml.TreeNode} poParentTreeNode
 * @param {eXria.form.xhtml.Canvas} poCanvas
 * @private
 */
eXria.controls.xhtml.TreeNodeset.prototype.loadDataFromPluginInstance = function(poParentTreeNode, poCanvas) {
  var voTree = this.tree;
  if(voTree == null || (this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null)) return;
  this.data.control = voTree;

  var vsRefValue = null;
  if(this.data.instanceId != null) vsRefValue = this.data.getData();
  var voCollectionNode = this.data.getNodesetStr();
  if(voCollectionNode == null) return;
  voCollectionNode = eval(voCollectionNode);
  var vnLoop = voCollectionNode.length;
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vsParentNode = null;
  var vsSelectNode = null;
  var vsDisableNode = null;
  var vsWbsType = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  var vaNodes = [];
  var voTreeNode = null;
  var vsIcon = null;
  var vsIconOpened = null;
  this.parent = poParentTreeNode;
  var vsParentValue = poParentTreeNode.getValue();
  for(var i = 0; i < vnLoop; i++) {
    voMapNode = voCollectionNode[i];
    vsLabelNode = voMapNode[this.labelTagName];
    vsValueNode = voMapNode[this.valueTagName];
    vsParentNode = voMapNode[this.parentTagName];
    if(vsParentNode == null || vsParentNode == "") vsParentNode = vsParentValue;
    if(voTree.selectTagName) vsSelectNode = voMapNode[voTree.selectTagName];
    if(voTree.disableTagName) vsDisableNode = voMapNode[voTree.disableTagName];
    if(voTree.wbsTypeTagName) {
      vsWbsType = voMapNode[voTree.wbsTypeTagName];
    }
    vsIcon = voMapNode[this.iconTagName];
    vsIcon = eXria.controls.xhtml.Util.getImagePath(vsIcon, poCanvas.page.window);
    vsIconOpened = voMapNode[this.iconOpenedTagName];
    vsIconOpened = eXria.controls.xhtml.Util.getImagePath(vsIconOpened, poCanvas.page.window);
    voTreeNode = voTree.createTreeNode(vsLabelNode);
    voTreeNode.nodeset = this;
    voTreeNode.tree = this.tree;
    voTreeNode.put("value", vsValueNode);
    voTreeNode["parentValue"] = vsParentNode;
    if(vsSelectNode == "Y") voTreeNode.selected = true;
    if(vsDisableNode == "Y") voTreeNode.disabled = true;
    if(vsWbsType && voTree.wbsIconMap) {
      vsIcon = voTree.wbsIconMap[vsWbsType];
      vsIcon = eXria.controls.xhtml.Util.getImagePath(vsIcon, poCanvas.page.window);
      vsIconOpened = vsIcon;
    }
    voTreeNode.icon = vsIcon;
    voTreeNode.iconOpened = vsIconOpened;
    vaNodes.push(voTreeNode);
    this.tree.addToItemValueMap(voTreeNode, vsValueNode);
    //if(vsLabelNode == vsRefValue) {
    //  this.tree.selectedItems.add(voTreeNode);
    //}
    //this.checkParent(voTreeNode, vsParentNode);
  }
  var voMap = this.tree.itemValueMap;
  var voFunc = this.tree.mapBlockIdFunc;
  for(var i = 0; i < vaNodes.length; i++) {
    voTreeNode = vaNodes[i];
    vsParentNode = voTreeNode["parentValue"];
//    this.checkParent(voTreeNode, vsParentNode, vaNodes, i);
    this.checkParent(voTreeNode, vsParentNode, voMap, voFunc);
  }
};
/**
 * checkParent
 * @private
 */
//eXria.controls.xhtml.TreeNodeset.prototype.checkParent = function(poTreeNode, psParentNode, paNodes, pnBaseIdx) {
 eXria.controls.xhtml.TreeNodeset.prototype.checkParent = function(poTreeNode, psParentNode, poMap, poMapBlockIdFunc) {
    var voParentNode = null;
    if(psParentNode == null || psParentNode == "") {
      //if(this.tree) voParentNode = this.tree.root;
      voParentNode = this.parent;
      if(voParentNode) voParentNode.add(poTreeNode);
      return;
    }
//    var vsBlockId = "gen";
//    if(poMapBlockIdFunc) {
//      vsBlockId = poMapBlockIdFunc(psParentNode);
//    }
//    voParentNode = poMap[vsBlockId][psParentNode];
    voParentNode = poMap[psParentNode]
    if(!!voParentNode) voParentNode.add(poTreeNode);
};
/**
 * data 속성으로 부터 DOM 데이타를 얻어옴.
 * @return data 속성으로 부터 얻어온 DOM 데이타
 * @type XMLElement
 * @private
 */
eXria.controls.xhtml.TreeNodeset.prototype.getInstanceData =function() {
  var viInstance = this.data.getNodesetInstance();
  var voDataNode = null;
  if(viInstance) voDataNode = viInstance.selectSingleNode(this.data.nodesetInstancePath);
  return voDataNode;
};
/**
 * makeTreeByData
 * @param {eXria.controls.xhtml.TreeNode} poParentTreeNode
 * @param {XMLElement} poParentDataNode
 * @private
 */
eXria.controls.xhtml.TreeNodeset.prototype.makeTreeByData = function(poParentTreeNode, poParentDataNode) {
  var voTreeNode = null;
  var voChild = null;
  var vnNodeType = -1;
  for(var i = 0; i < poParentDataNode.childNodes.length; i++) {
    voChild = poParentDataNode.childNodes[i];
    vnNodeType = voChild.nodeType;
    if(vnNodeType == 1) {
      voTreeNode = this.makeTreeNodeByData(voChild);
      poParentTreeNode.add(voTreeNode);
      if(voChild.childNodes.length > 0) this.makeTreeByData(voTreeNode, voChild);
    }
  }
};
/**
 * makeTreeNodeByData
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @return poNode에 의해 새롭게 생성된 트리노드
 * @type eXria.controls.xhtml.TreeNode
 * @private
 */
eXria.controls.xhtml.TreeNodeset.prototype.makeTreeNodeByData = function(poNode) {
  var vsName = poNode.getAttribute(this.labelTagName);
  var voTreeNode = this.tree.createTreeNode(vsName);
  var voAttr = null;
  var vnNodeType, vsAttrName, vsAttrValue;
  for(var i = 0; i < poNode.attributes.length; i++) {
    voAttr = poNode.attributes[i];
    vsAttrName = voAttr.nodeName;
    if(vsAttrName == this.labelTagName) continue;
    vsAttrValue = voAttr.nodeValue;
    voTreeNode.put(vsAttrName, vsAttrValue);
  }
  return voTreeNode;
};
/**
 * 클래스 명을 반환.
 * @return "TreeNodes"
 * @type String
 */
eXria.controls.xhtml.TreeNodeset.prototype.toString = function() {
  return "TreeNodeset";
};


/**
 * 트리뷰 아이템의 공통 속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.TreeView_itemgroup = function() {
  /**
   * 아이템 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 아이템 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * 선택된 아이템의 배경 색상.
   * @type String
   */
  this.selectedBackgroundColor = null;
  /**
   * 선택된 아이템의 텍스트 색상.
   * @type String
   */
  this.selectedColor = null;
  /**
   * 아이템에 마우스 위치 시 커서 유형.
   * @type String
   */
  this.cursor = null;
  /**
   * 아이템 폰트 패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 아이템 폰트 사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 아이템 폰트 스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 아이템 폰트 두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 아이템 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 아이템 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 아이템에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 아이템의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};


/**
 * @class Concreate xhtml TreeView.<br>
 * XHTML TreeView 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return eXria.controls.xhtml.TreeView 새로운 객체
 * @type eXria.controls.xhtml.TreeView
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.TreeView = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft =  pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth =  pnWidth == null ? 200 : pnWidth;
  pnHeight =  pnHeight == null ? 250 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  // 데이타연동관련
  /**
   * Data 연동 객체.
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 인스턴스로 부터 라벨 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.labelTagName = "label";
  /**
   * 인스턴스로 부터 value 데이타를 가져올 때 사용될 DOM Element 명.
   * @type String
   */
  this.valueTagName = "value";
  // 데이타연동관련End
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 루트노드 전체 노드의 최상위 노드. 화면에 보여지지는 않음.
   * @private
   */
  this.root = null;
  /**
   * 전체 트리노드를 노드 index를 key로 해서 저장하는 eXria.data.ArrayMap 객체.
   * @type eXria.data.ArrayMap
   * @private
   */
  this.items = new eXria.data.ArrayMap();
  /**
   * 전체 트리노드를 노드 value를 key로 해서 저장 맵 객체.
   * @type Object
   * @private
   */
  this.itemValueMap = {};
  /**
   * 노드 생성 후 노드 간 관계 설정 시 순차적으로 증가하는 노드 인덱스(노드 ID 생성에 이용)의 최근값 저장.
   * @type Number
   * @private
   */
  this.latestIdx = 0;
  /**
   * 트리뷰에 사용될 아이콘 이미지 경로 속성들을 포함하는 오브젝트.<br>
   * blank : 여백을 표현하기 위해 사용되는 이미지.<br>
   * verticalLine : 노드 연결 선을 표현하는 이미지.<br>
   * closedLastnode : 트리의 가지끝에 위치하며 닫힌 하위 포함 노드를 표현하는 이미지.<br>
   * closedNode : 트리의 가지 중간에 위치하며 닫힌 하위 포함 노드를 표현하는 이미지.<br>
   * openedLastnode : 트리의 가지끝에 위치하며 펼쳐진 하위 포함 노드를 표현하는 이미지.<br>
   * openedNode : 트리의 가지 중간에 위치하며 펼쳐진 하위 포함 노드를 표현하는 이미지.<br>
   * lastnode : 트리의 가지끝에 위치하는 노드(하위 노드가 없음)를 표현하는 이미지.<br>
   * node : 트리의 가지 중간에 위치하는 노드를 표현하는 이미지.<br>
   * closedFolder : 닫힌 노드 옆에 위치하는 아이콘 이미지.<br>
   * openedFolder : 펼쳐진 노드 옆에 위치하는 아이콘 이미지<br>
   * leafItem : 노드(하위 노드가 없음) 옆에 위치하는 아이콘 이미지.<br>
   * selectedLeafItem : 선택된 노드(하위 노드가 없음) 옆에 위치하는 아이콘 이미지.<br>
   * @type Object
   */
  this.iconFiles = {
    blank : null, //0
    verticalLine : null, //1
    closedLastnode : null, //2
    closedNode : null, //3
    openedLastnode : null, //4
    openedNode : null, //5
    lastnode : null, //6
    node : null, //7
    closedFolder : null, //8
    openedFolder : null, //9
    leafItem : null, //10
    selectedLeafItem : null //11
  };
  /**
   * 아이콘 이미지 경로 상수에 해당하는 실체화 객체를 저장하는 Map.
   * @type eXria.data.ArrayMap
   */
  this.icons = new eXria.data.ArrayMap();
  /**
   * Selection Mode.<br>
   * 트리노드의 선택 유형[단일선택, 다중선택].
   * @type String
   * @ignore
   */
  this.selectionMode = null;//[single | multi]
  /**
   * Selected Node instance.<br>
   * 선택된 트리노드 리스트(펼쳐진 트리노드와는 구별됨. 텍스트가 선택된 트리노드).
   */
  this.selectedItems = new eXria.data.ArrayMap();
  /**
   * Opened Node.<br>
   * 열려진 트리노드(마지막으로 선택된 트리노드).
   * @type eXria.controls.xhtml.TreeNode
   * @private
   */
  this.openedItem = null;
  /**
   * 아이템 폰트 패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 아이템 폰트 사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 아이템 폰트 스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 아이템 폰트 두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 아이템 텍스트 컨텐츠 오버플로우 속성.
   * @type String
   */
  this.overflow = null;
  /**
   * 아이템 텍스트 컨텐츠 오버플로우X 속성.
   * @type String
   */
  this.overflowX = null;
  /**
   * 아이템 텍스트 컨텐츠 오버플로우Y 속성.
   * @type String
   */
  this.overflowY = null;
  /**
   * 이미지 파일이 위치한 디렉토리(절대경로).
   * @type String
   */
  this.iconDir = null;
  /**
   * 이미지 파일의 가로길이(사용되는 모든 이미지 파일에 사이즈는 동일해야함).
   * @type Number
   */
  this.iconWidth = null;
  /**
   * 이미지 파일의 세로길이.
   * @type Number
   */
  this.iconHeight = null;
  /**
   * Changed node list for repaint.<br>
   * redraw 해할야 트리노드 목록.
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.changedNodes = new eXria.data.ArrayCollection();
  /**
   * Name of Root Node
   * @type String
   * @private
   */
  this.rootName = "ROOT";
  /**
   * 선택된 트리노드의 값.
   * @type String
   */
  this.value = null;
  /**
   * 드래그&드랍을 허용할 지 여부.
   * @type Boolean
   */
  this.dragDrop = false;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 아이템 공통 속성 저장 오브젝트.
   * @type Object
   * @private
   */
  this.itemgroup = new eXria.controls.xhtml.TreeView_itemgroup();
  /**
   * 마우스가 텍스트에 위치해 있을 때의 마우스 커서 타입.
   * @type String
   * @private
   */
  this.spanCursor = "pointer";
  /**
   * 이벤트 target이 컨트롤인지 아이템인지를 구분하기 위한 속성.
   * @type String
   * @private
   */
   this.eventObjectType = null;
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type Object
   * @private
   */
  this.document = null;
  /**
   * 새로고침시 이전 노드 펼침상태를 유지할지 여부.
   * @type Boolean
   */
  this.keepExpandedState = null;
  /**
   * 펼쳐진 노드의 루트 노드로부터의 상대 위치를 저장하는 배열 .
   * @type Array(String)
   * @private
   */
  this.expandedIndexes = [];
  /**
   * 체크박스를 보여줄지 여부.
   * @type Boolean
   */
  this.showCheckBox = null;
  /**
   * @return 클릭 타임.
   * @type Number
   * @private
   */
  this.clickTime = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트.
   * @type Object
   * @private
   */
  this.df = {};

  this.init();
  /**
   * 컨트롤의 하위 HTMLElement 요소들.
   * @private
   */
  this.subElement = {};
  /**
   * 최대 노드의 길이.
   * @private
   */
  this.maxLen = 0;
  /**
   * 노드를 펼쳐 보일것인가의 여부
   * @type Boolean
   */
  this.expandAll = null;
  /**
   * 트리 형태 지정 문자열
   * @type String
   */
  this.trvType = null;
  /**
   * 라벨 배경색 정보 저장 배열
   * @type Array(String)
   */
  this.lblColors = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.TreeView);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.init = function() {
  this.root = this.createTreeNode(this.rootName);
  this.root.index = this.latestIdx++;
  this.root.setValue("");
  this.root.tree = this;
  this.root.depth = 0;
  this.root.expand = true;
  this.items.put(this.root.index, this.root);
};

eXria.controls.xhtml.TreeView.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  // ie브라우저일 경우 focus 시에 점선 테두리 안보이게 하기
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

//eXria.controls.xhtml.TreeView.prototype.createSubCtrl = function(poCtrl, poDocument) {
//  var voTable = poDocument.createElement("div");
//  voTable.setAttribute("id", this.id + "_table");
//  var voStyle = voTable.style;
//  voStyle.position = "absolute" ;
//  voStyle.margin = "0px";
//  voStyle.padding = "0px"
//  voStyle.left = "0px";
//  voStyle.top = "0px";
//
//  voTable.ondragstart = function(e) { return false; };
//  voTable.onselectstart = function(e) { return false; };
//  voTable.oncontextmenu = function(e) { return false; };
//  poCtrl.appendChild(voTable);
//
//  this.loadIcons();
//};

eXria.controls.xhtml.TreeView.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);

  vaTemplate.push("<div id='");
  vaTemplate.push(this.id);
  // yhkim 2009.09.04
  //vaTemplate.push("_table' style='position:absolute;margin:0px;padding:0px;left:0px;top:0px;width:" + this.innerWidth + "px;height:" + this.innerHeight + "px;'");
  vaTemplate.push("_table' style='position:absolute;margin:0px;padding:0px;left:0px;top:0px;width:0px;height:0px;'>");
  //vaTemplate.push(" ongragstart=\"return false;\" onselectstart=\"return false;\" oncontextmenu=\"return false;\"");
  //vaTemplate.push(" class='" + vsClass + "'>");
  vaTemplate.push("</div>");

  // yhkim 2009.09.15 span에 적용해줘야 동적으로 setNodeCtrl에서 font-size에 맞게 결정된다
  var vsClass = this.getCSSClass(this, 1, "itemgroup");

  vaTemplate.push("<span class = '" + vsClass + "' style=\"");
  vaTemplate.push("@cssStrBuf"); //0
  vaTemplate.push("\"/>");

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
//  poCtrl.innerHTML = vaTemplate.join("");
//  vaTemplate = null;
};

eXria.controls.xhtml.TreeView.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voIconFiles = this.iconFiles;
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  voIconFiles.blank = this.getAttrValue("iconFiles.blank",voIconFiles.blank);
  voIconFiles.verticalLine = this.getAttrValue("iconFiles.verticalLine",voIconFiles.verticalLine);
  voIconFiles.closedLastnode = this.getAttrValue("iconFiles.closedLastnode",voIconFiles.closedLastnode);
  voIconFiles.closedNode = this.getAttrValue("iconFiles.closedNode",voIconFiles.closedNode);
  voIconFiles.openedLastnode = this.getAttrValue("iconFiles.openedLastnode",voIconFiles.openedLastnode);
  voIconFiles.openedNode = this.getAttrValue("iconFiles.openedNode",voIconFiles.openedNode);
  voIconFiles.lastnode = this.getAttrValue("iconFiles.lastnode",voIconFiles.lastnode);
  voIconFiles.node = this.getAttrValue("iconFiles.node",voIconFiles.node);
  voIconFiles.closedFolder = this.getAttrValue("iconFiles.closedFolder",voIconFiles.closedFolder);
  voIconFiles.openedFolder = this.getAttrValue("iconFiles.openedFolder",voIconFiles.openedFolder);
  voIconFiles.leafItem = this.getAttrValue("iconFiles.leafItem",voIconFiles.leafItem);
  voIconFiles.selectedLeafItem = this.getAttrValue("iconFiles.selectedLeafItem",voIconFiles.selectedLeafItem);

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.iconDir = this.getAttrValue("iconDir",this.iconDir);
  this.iconWidth = this.getAttrValue("iconWidth",this.iconWidth);
  this.iconHeight = this.getAttrValue("iconHeight",this.iconHeight);
  this.expandAll = this.getAttrValue("expandAll",this.expandAll);
  this.showCheckBox = this.getAttrValue("showCheckBox", this.showCheckBox);
  this.selectionMode = this.getAttrValue("selectionMode",this.selectionMode);
  if(this.showCheckBox == true) this.selectionMode = "multi";
  this.keepExpandedState = this.getAttrValue("keepExpandedState", this.keepExpandedState);

  voItemgroupDf.className = this.getAttrValue("itemgroup.className",this.itemgroup.className);
  voItemgroupDf.selectedBackgroundColor = this.getAttrValue("itemgroup.selectedBackgroundColor",this.itemgroup.selectedBackgroundColor);
  voItemgroupDf.selectedColor = this.getAttrValue("itemgroup.selectedColor",this.itemgroup.selectedColor);
  voItemgroupDf.cursor = this.getAttrValue("itemgroup.cursor", this.itemgroup.cursor);
  if(voItemgroupDf.cursor == null) voItemgroupDf.cursor = "pointer";
};

//eXria.controls.xhtml.TreeView.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
//  //var voRuler = this.lookup(this.id + "_ruler");
//  //var voStyle = voRuler.style;
//  //voStyle.fontFamily = this.fontFamily;
//  //voStyle.fontSize = this.fontSize + "pt";
//
//  this.setAttrCtrl("width", this.innerWidth, poCtrl);
//  this.setAttrCtrl("height", this.innerHeight, poCtrl);
//  this.setAttrCtrl("borderColor", voDf.borderColor, poCtrl);
//  this.setAttrCtrl("borderStyle", voDf.borderStyle, poCtrl);
//  this.setAttrCtrl("borderLeftWidth", voDf.borderLeftWidth + "px", poCtrl);
//  this.setAttrCtrl("borderRightWidth", voDf.borderRightWidth + "px", poCtrl);
//  this.setAttrCtrl("borderTopWidth", voDf.borderTopWidth + "px", poCtrl);
//  this.setAttrCtrl("borderBottomWidth", voDf.borderBottomWidth + "px", poCtrl);
//  this.setAttrCtrl("backgroundColor", voDf.backgroundColor, poCtrl);
//  this.setAttrCtrl("color", voDf.color, poCtrl);
//  this.setAttrCtrl("overflowX", voDf.overflowX, poCtrl);
//  this.setAttrCtrl("overflowY", voDf.overflowY, poCtrl);
//  this.setAttrCtrl("cursor", voDf.cursor, poCtrl);
//  this.setAttrCtrl("textAlign", voDf.textAlign, poCtrl);
//  this.setAttrCtrl("fontFamily", voDf.fontFamily, poCtrl);
//  this.setAttrCtrl("fontSize", voDf.fontSize, poCtrl);
//  this.setAttrCtrl("fontStyle", voDf.fontStyle, poCtrl);
//  this.setAttrCtrl("fontWeight", voDf.fontWeight, poCtrl);
//
//  this.loadIcons();
//
//  this.changedNodes.clear();
//  var voTable = poCtrl.childNodes[0];
//  try {
//    var size = voTable.childNodes.length;
//    for(var j = 0; j < size; j++) {
//      this.deleteTreeNode(0, poDocument);
//    }
//  } catch(err) {
//  }
//};

eXria.controls.xhtml.TreeView.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.trvType = voUserAttr.trvType;
    this.lblColors = voUserAttr.lblColors;
    if(this.lblColors == null) this.lblColors = [];
    this.lblClasses = voUserAttr.lblClasses;
    if(this.lblClasses == null) this.lblClasses = [];
    this.getNodeColor = voUserAttr.getNodeColor;
    this.selectTagName = voUserAttr.selectTagName;
    this.disableTagName = voUserAttr.disableTagName;
    if(this.trvType == "WBS") {
      this.wbsTypeTagName = voUserAttr.wbsTypeTagName;
      this.wbsIconMap = voUserAttr.wbsIconMap;
    }
    this.isOneLine = voUserAttr.isOneLine;
    if(this.isOneLine) this.expandAll = false;
    this.labelName = voUserAttr.labelName;
    this.allowExpand = voUserAttr.allowExpand;
    this.mapBlockIdFunc = voUserAttr.mapBlockIdFunc;
  }

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
//  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  // ie브라우저가 아닐 경우 focus 시에 점선 테두리 안보이게 하기
  if(this.canvas.page.metadata.browser.ie == 0) vfcSetCssStrBuf(vaCssStrBuf, "outline", "none");
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vaCssStrBuf.push("white-space:nowrap;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", voItemgroupDf.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", voItemgroupDf.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", voItemgroupDf.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", voItemgroupDf.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", voItemgroupDf.textDecoration);
  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  voIndexMap.clear();
  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;

  this.setSubElement(poDocument);

  this.loadIcons();
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;

  voSubElement.tableDiv = this.getSubCtrl("div", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};

eXria.controls.xhtml.TreeView.prototype.refreshTemplate = function(poCtrl, poDocument) {
  this.setTemplate(poCtrl, poDocument);
};

eXria.controls.xhtml.TreeView.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
};

eXria.controls.xhtml.TreeView.prototype.setSpecificEvents = function(poCtrl) {
};

eXria.controls.xhtml.TreeView.prototype.startDrag = function(e) {
  if(this.sourceItem == null) return;

  var voDocument = this.document;
//  var voParent = this.canvas;
  var vnLeft = 0;
  var vnTop = 0;
  var vnAbsLeft = 0;
  var vnAbsTop = 0;
  var voParent = this.parent;
  var voPage = this.canvas.page;
  while(voParent) {
    vnLeft += voParent.left;
    vnTop += voParent.top - voParent.ctrl.scrollTop;
    voParent = voParent.parent;
  }
  while(voPage) {
    var voFrameElement = voPage.window.frameElement;
    if(voFrameElement) {
      vnLeft += voFrameElement.offsetLeft;
      vnTop += voFrameElement.offsetTop;
      vnAbsLeft += voFrameElement.offsetLeft;
      vnAbsTop += voFrameElement.offsetTop;
    }
    if(voPage.window.parent.page && voPage != voPage.window.parent.page) voPage = voPage.window.parent.page;
    else break;
  }
  this.clientAbsLeft = vnAbsLeft;
  this.clientAbsTop = vnAbsTop;

  if(voPage == null) voParent = this.canvas;
  else voParent = voPage.canvas;
  voDocument = voPage.window.document;

  var voCtrl = this.ctrl;
  var voItem = this.sourceItem;

  var vnScrollTop = this.ctrl.scrollTop + this.canvas.ctrl.scrollTop;
  vnLeft += this.left + voItem.left;
//  vnTop += this.top + voItem.top;
  vnTop += this.top + parseInt(this.document.getElementById(this.id + "_node" + voItem.index).style.top) - vnScrollTop;

  this.dragDropHandler.srcObject = this.sourceItem;
  this.dragDropHandler.srcObjectType = "item";
  var voGlassPane = new eXria.controls.xhtml.GlassPane(voParent);
  voGlassPane.id = voParent.id + "_glassPane";
  this.glassPane = voGlassPane;
  voGlassPane.opacity = 50;
  voParent.ctrl.parentNode.appendChild(voGlassPane.create(voDocument));

  var voDragDropHandler = this.dragDropHandler;
  var voPaneCtrl = voDragDropHandler.createPane(vnLeft, vnTop, voItem.width, voItem.height, voDocument);
  var voPaneStyle = voPaneCtrl.style;

  var voEvent = e;
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;

  var vnMouseX = voEvent.e.clientX + this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY + this.clientAbsTop;

  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;

  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "move";
  this.ctrl.style.cursor = "move";

  voPaneCtrl.control = this;
  voPaneCtrl.onmousemove = function(e) {
    this.control.onDrag(e);
  };
  voPaneCtrl.onmouseup = function(e) {
    this.control.stopDrag(e);
  };
  voDocument.control = this;
  voDocument.onmousemove = function(e) {
    this.control.onDrag(e);
  };
  voDocument.onmouseup = function(e) {
    this.control.stopDrag(e);
  };
  if (typeof voPaneCtrl.onselectstart != "undefined") {
    voPaneCtrl.onselectstart = function(e) {
      return false;
    };
  } else {
    voPaneCtrl.onmousedown = function(e) {
      return false;
    };
  }
  var vnScrAreaLeft = vnAbsLeft + this.left;
  var vnScrAreaTop = vnAbsTop + this.top;
  var vnScrAreaWidth = this.width;
  var vnScrAreaHeight = this.height;
  if(voCtrl.scrollWidth > voCtrl.clientWidth) {
    var voScrollAreaLeft = voDragDropHandler.createScrollArea(vnScrAreaLeft, vnScrAreaTop, vnScrAreaWidth, vnScrAreaHeight, voItem.width, voItem.height, "left", voDocument);
    var voScrollAreaRight = voDragDropHandler.createScrollArea(vnScrAreaLeft, vnScrAreaTop, vnScrAreaWidth, vnScrAreaHeight, voItem.width, voItem.height, "right", voDocument);
    voScrollAreaLeft.control = this;
    voScrollAreaRight.control = this;
    voScrollAreaLeft.onmouseover = function(e) {
      this.control.onAutoScroll(e, this, "left");
    };
    voScrollAreaRight.onmouseover = function(e) {
      this.control.onAutoScroll(e, this, "right");
    };
  }
  if(voCtrl.scrollHeight > voCtrl.clientHeight) {
    var voScrollAreaTop = voDragDropHandler.createScrollArea(vnScrAreaLeft, vnScrAreaTop, vnScrAreaWidth, vnScrAreaHeight, voItem.width, voItem.height, "top", voDocument);
    var voScrollAreaBottom = voDragDropHandler.createScrollArea(vnScrAreaLeft, vnScrAreaTop, vnScrAreaWidth, vnScrAreaHeight, voItem.width, voItem.height, "bottom", voDocument);
    voScrollAreaTop.control = this;
    voScrollAreaBottom.control = this;
    voScrollAreaTop.onmouseover = function(e) {
      this.control.onAutoScroll(e, this, "top");
    };
    voScrollAreaBottom.onmouseover = function(e) {
      this.control.onAutoScroll(e, this, "bottom");
    };
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.atmousedown = function(e) {
  e.objectType = this.eventObjectType;
  e.object = this.eventObject;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.atmouseup = function(e) {
  e.objectType = this.eventObjectType;
  e.object = this.eventObject;
  if(this.isRClick(e)) {
    if(e.objectType == "item" && e.object) this.selectNode(e.object, e, this.document);
  }
};

eXria.controls.xhtml.TreeView.prototype.finalmouseup = function(e) {
  var voDocument = this.document;
  this.sourceItem = null;
  this.targetItem = null;

  var voCanvas = this.canvas;
  voCanvas.doCollapseForAllFrame();
  if (!this.isRClick(e)) {
    return;
  } else {
    var posx=0,posy=0;
    if(e.pageX || e.pageY) {
      posx=e.pageX; posy=e.pageY;
    } else if(e.clientX || e.clientY) {
      if(voDocument.documentElement.scrollTop) {
        posx=e.clientX + voDocument.documentElement.scrollLeft;
        posy=e.clientY + voDocument.documentElement.scrollTop;
      } else {
        posx=e.clientX + voDocument.body.scrollLeft;
        posy=e.clientY + voDocument.body.scrollTop;
      }
    }
    this.showContextMenu(posx,posy);
    if(this.contextMenuId) e.stopEvent();       // TODO : 향후 변경할것
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.atclick = function(poEvent) {
  poEvent.objectType = this.eventObjectType;
  poEvent.object = this.eventObject;
  //if(poEvent.object && poEvent.objectType == "item") {
    //this.openedItem = poEvent.object;
  //}
  var voBase = this;
  //this.temp = function() {
    if(poEvent.object) {
      voBase.selectNode(poEvent.object, poEvent, voBase.document);
      if(!poEvent.object.isLeaf()) {
        if(poEvent.object.expand == false) voBase.toggleNode(poEvent.object, voBase.document);
      }
    }
    //voBase.temp = null;
  //};

  //setTimeout(this.temp, 300);
};

eXria.controls.xhtml.TreeView.prototype.finalclick = function(poEvent) {
  if(this.canvas) {
    var voCanvas = this.canvas;
    if(!this.isRClick(poEvent)) voCanvas.hideContextMenu();
  }
  this.eventObjectType = null;
  this.eventObject = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.atdblclick = function(poEvent) {
  poEvent.objectType = this.eventObjectType;
  poEvent.object = this.eventObject;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.finaldblclick = function(poEvent) {
  this.eventObjectType = null;
  this.eventObject = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.dochange = function(poEvent, poControl) {
  if(poControl.atchange) { poControl.atchange(poEvent); }
  if(poControl.cochange) { poControl.cochange(poEvent); }
  if(poControl.onchange) { poControl.onchange(poEvent); }
  if(poControl.changeEventCallback) { poControl.changeEventCallback(poEvent); }
};
/**
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.onAutoScroll = function(e, poCtrl, psPos) {
  var voDragDropHandler = this.dragDropHandler;
  var voItemCtrl = voDragDropHandler.ctrl;
  var vnGap = 0;
  var vnOverLen = Math.ceil(poCtrl.offsetHeight / 2);
  var vnScrollLen = Math.ceil(this.height / 100);
  var vnMaxLen = poCtrl.offsetHeight;
  var vnScrollPos = this.ctrl.scrollTop;
  switch(psPos) {
  case "top" :
    vnGap = voItemCtrl.offsetTop - poCtrl.offsetTop;
    break;
  case "bottom" :
    vnGap = poCtrl.offsetTop - voItemCtrl.offsetTop;
    vnScrollLen *= -1;
    break;
  case "left" :
    vnGap = voItemCtrl.offsetLeft - poCtrl.offsetLeft;
    vnOverLen = Math.ceil(poCtrl.offsetWidth / 2);
    vnScrollLen = Math.ceil(this.width / 100);
    vnMaxLen = poCtrl.offsetWidth;
    vnScrollPos = this.ctrl.scrollLeft;
    break;
  case "right" :
    vnGap = poCtrl.offsetLeft + poCtrl.offsetWidth - (voItemCtrl.offsetLeft + voItemCtrl.offsetWidth);
    vnOverLen = Math.ceil(poCtrl.offsetWidth / 2);
    vnScrollLen = -Math.ceil(this.width / 100);
    vnMaxLen = poCtrl.offsetWidth;
    vnScrollPos = this.ctrl.scrollLeft;
    break;
  }
  if(vnScrollLen == 0) vnScrollLen = 1;

  if(Math.abs(vnGap) < vnMaxLen) {
    if(vnGap < 0 && Math.abs(vnGap) > vnOverLen) vnScrollLen = vnScrollLen * 5;
    else if(vnGap < 0) vnScrollLen = vnScrollLen * 3;
    else if(Math.abs(vnGap) < vnOverLen) vnScrollLen = vnScrollLen * 2;
  } else {
    return;
  }

  vnScrollPos -= vnScrollLen;
  var vbOver = false;
  switch(psPos) {
  case "top" :
    if(vnScrollPos < 0) {
      vnScrollPos = 0;
      vbOver = true;
    }
    this.ctrl.scrollTop = vnScrollPos;
    break;
  case "bottom" :
    if(vnScrollPos > this.ctrl.scrollHeight) {
      vnScrollPos = this.ctrl.scrollHeight;
      vbOver = true;
    }
    this.ctrl.scrollTop = vnScrollPos;
    break;
  case "left" :
    if(vnScrollPos < 0) {
      vnScrollPos = 0;
      vbOver = true;
    }
    this.ctrl.scrollLeft = vnScrollPos;
    break;
  case "right" :
    if(vnScrollPos > this.ctrl.scrollWidth) {
      vnScrollPos = this.ctrl.scrollWidth;
      vbOver = true;
    }
    this.ctrl.scrollLeft = vnScrollPos;
    break;
  }
  if(vbOver) return;

  var voBase = this;
  var voFunc = function() {
    voBase.onAutoScroll(e, poCtrl, psPos);
  };
  this.window.setTimeout(voFunc, 500);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
  this.itemgroup.df = {};
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
  case "height" :
    this.refresh(poDocument);
    break;
  case "borderColor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "borderStyle" :
  case "borderWidth" :
  case "borderLeftWidth" :
  case "borderRightWidth" :
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.refresh(poDocument);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * loadData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.loadData = function(poDocument) {
  if(poDocument == null) poDocument = this.document;
  this.deployTreeNode(this.root);
//  var voCtrl = this.getCtrl(poDocument);
//  this.setSpecificAttrs(voCtrl, poDocument)
//  this.repaintNode(this.root, 0, true, voCtrl, poDocument);
//  this.changedNodes.clear();
//  if(this.data.instanceId != null && this.data.instancePath != null) {
//    var vsRefValue = this.data.getData();
//    var voIterator = this.items.getValueCollection().iterator();
//    var voTreeNode = null;
//    while(voIterator.hasNext()) {
//      voTreeNode = voIterator.next();
//      if(voTreeNode.getValue() == vsRefValue) {
//        this.toggleNode(voTreeNode);
//        break;
//      }
//    }
//  }
};

eXria.controls.xhtml.TreeView.prototype.reloadData = function(poCtrl, poDocument) {
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  this.markNodeLabel(null, null, false);
  this.changedNodes.clear();
  var voTable = poCtrl.childNodes[0];
  try {
    var size = voTable.childNodes.length;
    for(var j = 0; j < size; j++) {
      this.deleteTreeNode(0, poDocument);
    }
  } catch(err) {
  }
  this.openedItem = null;
  if(this.keepExpandedState) {
    if(!this.skipRemark) this.remarkExpand(this.root, "");
  }
  this.clearItems();
  this.deployTreeNode(this.root);
  this.value = null;
  this.restoreExpand();
  this.loadComplete(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.loadComplete = function(poDocument) {

  this.clickTime = new Date().getTime();
  if(poDocument == null) poDocument = this.document;
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;
  if(this.expandAll) this.expandAllNode();
  this.repaintNode(this.root, 0, true, voCtrl, poDocument);
  this.changedNodes.clear();

  var voCover = this.lookup(this.id + "_cover", poDocument);
  if(voCover != null) {
    if(this.visible == false) {
      this.setAttrCtrl("display", "none", voCover);
    } else {
      this.setAttrCtrl("display", "", voCover);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.clearItems = function() {
  this.latestIdx = 0;
  var voCollection = this.items.getValueCollection();
  var vnSize = voCollection.size();
  var voItem = null;
  for(var i = 0; i < vnSize; i++) {
    voItem = voCollection.get(i);
    voItem.index = null;
  }
  this.items.clear();
  this.itemValueMap = {};
  this.selectedItems.clear();
  this.root.index = 0;
  this.items.put(this.root.index, this.root);
  this.latestIdx = this.root.index + 1;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.deployTreeNode = function(poTreeNode) {
  poTreeNode.deployChildren();
  var voIterator = poTreeNode.childCollection.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild instanceof eXria.controls.xhtml.TreeNode) {
      this.deployTreeNode(voChild);
    }
  };
};
/**
 * 선택된 노드에 값을 바인딩 된 data에 반영하는 메소드.
 */
eXria.controls.xhtml.TreeView.prototype.checkSelected = function() {
  var voDf = this.df;
  var vaRet = [];
  var voSelectedItems = this.selectedItems.getValueCollection();
  var voNode = null;
  for(var i = 0; i < voSelectedItems.size(); i++) {
    voNode = voSelectedItems.get(i);
    vaRet.push(voNode.get("value"));
  }
  if(vaRet.length == 0) vaRet = null;
  if(this.selectionMode == "single" && this.showCheckBox == false) {
    if(vaRet) vaRet = vaRet[0];
  }
  this.value = vaRet;
  this.value = vaRet;
  if(this.data.instanceId !=null && this.data.instancePath != null) this.data.setData(vaRet);
};
/**
 * 해당노드의 value를 컨트롤에 설정. toggleNode()함수와 동일한 기능.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @example
 * var tree = page.getControl("treeview");<br>
   var node = tree.getNodeByVal("value1");<br>
   tree.setValue(node);<br>
 */
eXria.controls.xhtml.TreeView.prototype.setValue = function(poNode) {
  //this.value = poNode.get("value");
  //if(this.data.instanceId) this.data.setData(this.value);
  this.toggleNode(poNode);
};
/**
 * 컨트롤의 할당된 값 반환.
 * @return 컨트롤 value 속성 값
 * @type String
 */
eXria.controls.xhtml.TreeView.prototype.getValue = function() {
  return this.value;
};
/**
 * 트리노드 생성.
 * @param {String} psName 트리노드에 표시될 라벨명
 * @return 새롭게 생성된 트리노드 객체
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeView.prototype.createTreeNode = function(psName) {
  var voNode = new eXria.controls.xhtml.TreeNode(psName);
  //voNode.index = this.latestIdx++;
  //this.items.put(voNode.index, voNode);
  return voNode;
};
/**
 * 트리노드셋 생성.
 * @return 새롭게 생성된 트리노드셋 객체
 * @type eXria.controls.xhtml.TreeNodeset
 */
eXria.controls.xhtml.TreeView.prototype.createTreeNodeset = function() {
  var voNodeset = new eXria.controls.xhtml.TreeNodeset();
  //voNode.index = this.latestIdx++;
  //this.items.put(voNode.index, voNode);

  return voNodeset;
};
/**
 * 트리노드 제거.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.remove = function(poNode) {
  this.items.remove(poNode.index);
};
/**
 * 아이콘 이미지 경로 상수에 행당하는 실체화 객체를 생성하여 this.icons에 저장하는 메소드.<br>
 * Preload icons
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.loadIcons = function() {
  var voWindow = this.canvas.page.window;
  var voIcon = null;
  var vsIconTag = null;
  var voIconFiles = this.iconFiles;
  var voDefaultsIconFiles = null;
  if(eXria.controls.xhtml.Default.TreeView.iconFiles) voDefaultsIconFiles = eXria.controls.xhtml.Default.TreeView.iconFiles;
  for(vsIconTag in voDefaultsIconFiles) {
    if(voIconFiles[vsIconTag]) continue;
    if(voDefaultsIconFiles[vsIconTag]) {
      voIconFiles[vsIconTag] = voDefaultsIconFiles[vsIconTag];
    }
  }
  for(vsIconTag in this.iconFiles) {
    //voIcon = new Image();
    voIcon = {};
    voIcon.src = eXria.controls.xhtml.Util.getImagePath(voIconFiles[vsIconTag], voWindow);
    this.icons.put(vsIconTag, voIcon);
  }
};
/**
 * paint tree
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.paint = function(poDocument) {
  this.paintNode(this.root, poDocument);
};
/**
 * paint node
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.paintNode = function(poNode, poDocument) {
  var vsId = this.id;
  var voTable = this.lookup(this.id + "_table");
  var voDiv = poDocument.createElement("div");
  if(this.itemgroup.className) voDiv.setAttribute("class", this.itemgroup.className);
  var voStyle = voDiv.style;
  this.setAttrCtrl("backgroundColor", this.backgroundColor, voDiv);
  voDiv.setAttribute("id", vsId + "_node" + poNode.index);
  voStyle.position = "absolute";
  voStyle.left = "0px";
  voStyle.top = (voTable.childNodes.length * this.iconHeight) + "px";
  var vnLayer = poNode.names.length;
  voStyle.height = (this.iconHeight * vnLayer) + "px";
  this.setNodeCtrl(poNode, voDiv, poDocument);
  for(var i = 0; i < poNode.children.length && poNode.expand; i++) {
    this.paintNode(poNode.children[i], voDiv);
  }
};
/**
 * Get the index of row by specified row id.<br>
 * row id에 해당하는 row 인덱스 번호 반환
 * @param {String} psRowId row id
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return row 인덱스 번호
 * @type Number
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getRowIndexById = function(psRowId, poDocument) {
   var voTable = this.lookup(this.id + "_table", poDocument);
   var voRows = voTable.childNodes;
   for(var i = 0; i < voRows.length; i++) {
      if(voRows.item(i).id == psRowId)
      return i;
   }
   return - 1;
};
/**
 * 트리 새로 그리기.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 */
eXria.controls.xhtml.TreeView.prototype.repaint = function(poDocument) {
  this.markNodeLabel(null, null, false);
  var voCtrl = this.getCtrl(poDocument);
  this.repaintChanged(voCtrl, poDocument);

  this.changedNodes.clear();
};

//eXria.controls.xhtml.TreeView.prototype.resizeNodeDiv = function(){
//Node length setting
//  var voSubElement = this.subElement;
//
//  var vnLen = voSubElement.tableDiv.childNodes.length;
//
//  for(var i = 0 ; i<vnLen; i++){
//    //var voWidth = parseInt(voSubElement.tableDiv.childNodes[i].getElementsByTagName("table")[0].style.width);
//    var voWidth = this.innerWidth - (vnOffset * this.df.iconWidth)
//
//    voWidth += this.maxLen;
//    voSubElement.tableDiv.childNodes[i].getElementsByTagName("div")[0].style.width = voWidth+"px";
//    voSubElement.tableDiv.childNodes[i].getElementsByTagName("table")[0].style.width = voWidth+"px";
//  }
//
//  this.maxLen = 0;
//};

/**
 * Repaint nodes of which displays are changed.
 * @param {HTMLDiv} poCtrl 실체화 객체의 최외곽 DIV
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.repaintChanged = function(poCtrl, poDocument) {
  if(this.trvType == "MENU") {
    this.repaintChangedMenu(poCtrl, poDocument);
    return;
  }

  if(poDocument == null) poDocument = this.document;
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  var voTable = poCtrl.childNodes[0];
  var vsId = this.id;
  for(var i = 0; i < this.changedNodes.size(); i++) {
    var voNode = this.changedNodes.get(i);
    var vsRowId = vsId + "_node" + voNode.index;
    var nextRowId = - 1;
    var vnRowIndex1 = - 1;
    var vnRowIndex2 = - 1;
    if(voNode != this.root) {
      vnRowIndex1 = this.getRowIndexById(vsRowId, poDocument);
      if(vnRowIndex1 == -1) continue;
      try {
        if(voNode.parent.getChildAfter(voNode) == null) throw new Error(9999, "Null point exception!");
        nextRowId = vsId + "_node" + voNode.parent.getChildAfter(voNode).index;
        vnRowIndex2 = this.getRowIndexById(nextRowId, poDocument) - 1;
        if(vnRowIndex2 < 0) throw new Error(9999, "Index out of bound!");
      } catch(err) {
        try {
          if(this.getNextOpenedAncestor(voNode, poDocument) == null) throw new Error(9999, "Null point exception!");
          nextRowId = vsId + "_node" + this.getNextOpenedAncestor(voNode, poDocument).index;
          vnRowIndex2 = this.getRowIndexById(nextRowId, poDocument) - 1;
          if(vnRowIndex2 == -1) throw new Error(9999, "Index Out of bound!");
        } catch(err) {
          vnRowIndex2 = voTable.childNodes.length - 1;
        }
      }
    } else {
      vnRowIndex1 = 0;
      vnRowIndex2 = voTable.childNodes.length - 1;
    }
    var vbRepaintChildren = true;
    if(!voNode.expand) vbRepaintChildren = false;
    try {
      for(var j = 0; j <(vnRowIndex2 - vnRowIndex1); j++) {
        this.deleteTreeNode(vnRowIndex1 + 1, poDocument);
      }
    } catch(err) {
    }

    var vbRoot = false;
    if(voNode == this.root) vbRoot = true;
    this.repaintNode(voNode, vnRowIndex1, vbRoot, poCtrl, poDocument, vbRepaintChildren);
  }
};
/**
 * deleteTreeNode.
 * @param {Number} pnIndex 현재 보여지는 트리 리스트의 row 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.deleteTreeNode = function(pnIndex, poDocument) {
  if(this.trvType == "MENU") {
    this.deleteTreeNodeMenu(pnIndex, poDocument);
    return;
  }

  var voTable = this.lookup(this.id + "_table", poDocument);
  //this.clearCtrlNode(voTable.childNodes.item(pnIndex));
  var voNodeCtrl = voTable.childNodes.item(pnIndex);
  var vnHeight = parseInt(voNodeCtrl.style.height);
  voTable.removeChild(voNodeCtrl);
  var voDiv = null;
  var voStyle = null;
  for(var i = pnIndex; i < voTable.childNodes.length; i++) {
    voDiv = voTable.childNodes.item(i);
    voStyle = voDiv.style;
    voStyle.top = (parseInt(voStyle.top) - vnHeight) + "px";
  }
};
/**
 * repaint node.
 * @param {eXria.controls.xhtml.TreeNode} poNode 새로고침 대상 트리노드
 * @param {Number} pnIndex 현재 디스플레이된 트리노드 리스트에서의 인덱스 번호
 * @param {Boolean} pbRoot 루트노드인지 여부
 * @param {HTMLDiv} 실체화 컨트롤 객체의 최외곽 div 객체
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.repaintNode = function(poNode, pnIndex, pbRoot, poCtrl, poDocument, pbRepaintChildren) {
  if(this.trvType == "MENU") {
    this.repaintNodeMenu(poNode, pnIndex, pbRoot, poCtrl, poDocument, pbRepaintChildren);
    return;
  }

  if(poNode.visible == false || pnIndex < 0) return;
  if(poDocument == null) poDocument = this.document;
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  if(pbRepaintChildren == null) pbRepaintChildren = true;
  var voTable = poCtrl.childNodes[0];
  var vsId = this.id;
  var voDiv = poDocument.getElementById(vsId + "_node" + poNode.index);
  if(voDiv == null) {
    voDiv = poDocument.createElement("div");
    if(this.itemgroup.className) voDiv.setAttribute("class", this.itemgroup.className);
    var voStyle = voDiv.style;
    var voDf = this.df;
    var vaCssStrBuf = null;
    var vfcSetCssStrBuf = this.setCssStrBuf;

    voDiv["id"] = vsId + "_node" + poNode.index;

    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "padding", 0, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "margin", 0, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "position", "absolute");
    vfcSetCssStrBuf(vaCssStrBuf, "left", 0, "px");
    var vnTop = 0;
    if(pnIndex != 0) {
      var voPrevRow = voTable.childNodes.item(pnIndex - 1);
      vnTop += parseInt(voPrevRow.style.top);
      vnTop += parseInt(voPrevRow.style.height);
    }
//    vfcSetCssStrBuf(vaCssStrBuf, "top", (pnIndex * this.iconHeight), "px");
    vfcSetCssStrBuf(vaCssStrBuf, "top", vnTop, "px");
    var vnLayer = poNode.names.length;
    vfcSetCssStrBuf(vaCssStrBuf, "height", (this.iconHeight * vnLayer), "px");
    voStyle.cssText = vaCssStrBuf.join("");

    if(!pbRoot) {
      if(pnIndex == voTable.childNodes.length) voTable.appendChild(voDiv);
      else voTable.insertBefore(voDiv, voTable.childNodes.item(pnIndex));
      this.setNodeCtrl(poNode, voDiv, poDocument);

      for(var i = pnIndex + 1; i < voTable.childNodes.length; i++) {
        voDiv = voTable.childNodes.item(i);
        voStyle = voDiv.style;
        voStyle.top = (parseInt(voStyle.top) + (this.iconHeight * vnLayer)) + "px";
      }
    }
  } else {
    this.refreshNodeCtrl(poNode, voDiv, poDocument);
  }
  if(pbRepaintChildren == false) return;
  var voNextAncestor = null;
  var voPrevious = null;
  for(var i = 0; i < poNode.children.length && poNode.expand; i++) {
    // 하위노드(0) 추가 후 그 하위노드의 하위 노드들이 추가되었을 경우 하위노드(0)의 다음노드(1)은
    // 하위노드(0)의 NextOpenedAncestor에 위치하여야 한다.
    if(i == 0) {
       if(pbRoot) this.repaintNode(poNode.children[i], pnIndex, false, poCtrl, poDocument);
       else this.repaintNode(poNode.children[i], pnIndex + 1, false, poCtrl, poDocument);
    } else {
      var rowId = null;
      var rowIndex = null;
       try {
          voNextAncestor = this.getNextOpenedAncestor(voPrevious, poDocument);
          if(voNextAncestor == null) throw new Error(9999, "It has no next opened ancestor!");
          rowId = vsId + "_node" + voNextAncestor.index;
          rowIndex = this.getRowIndexById(rowId, poDocument);
          if(rowIndex == -1) throw new Error(9999, "Index out of bound!");
          this.repaintNode(poNode.children[i], rowIndex, false, poCtrl, poDocument);

       } catch(err) {
          rowIndex = voTable.childNodes.length;
          this.repaintNode(poNode.children[i], rowIndex, false, poCtrl, poDocument);
       }
    }
    if(poNode.children[i].visible != false) voPrevious = poNode.children[i];
  }
};
/**
 * generate leftside.<br>
 * 지정된 트리노드 렌더링.
 * @param {eXria.controls.xhtml.TreeNode} poNode 렌더링할 트리노드
 * @param {HTMLDiv} poDiv 트리노드가 렌더링될 div객체
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.setNodeCtrl = function(poNode, poDiv, poDocument){
  if(this.trvType == "MENU") {
    this.setNodeCtrlMenu(poNode, poDiv, poDocument);
    return;
  }

  var vaTemplate = [];
  var voIcon = null;
  var vaTagStrBuf = null;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vaStrBuf = null;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  var vnLayer = poNode.names.length;
  var vnLeftGap = poNode.leftside.length;
  var vbNBlank = true;
  for(var i = 0; i < vnLeftGap; i++) {
    voIcon = this.icons.get("blank");
    if(poNode.leftside[i] == 1) {
      voIcon = this.icons.get("verticalLine");
      vbNBlank = true;
    }
    vaTagStrBuf = [];
    if(vbNBlank && voIcon.src != "none") {
      for(var j = 0; j < vnLayer; j++) {
        vaTagStrBuf.push("<img border=0 src='");
        vaTagStrBuf.push(voIcon.src);
        vaTagStrBuf.push("' style='position:absolute;");
        vaCssStrBuf = [];
        vfcSetCssStrBuf(vaCssStrBuf, "top", (j * this.iconHeight), "px");
        vfcSetCssStrBuf(vaCssStrBuf, "left", (i * this.iconWidth), "px");
        vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
        vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
        vaTagStrBuf.push(vaCssStrBuf.join(""));
        vaTagStrBuf.push("'>");
      }
    }
    vaTemplate.push(vaTagStrBuf.join(""));
  }
  if(poNode != this.root) {
    if(poNode.isLeaf()) {
      vbNBlank = false;
      voIcon = this.icons.get("lastnode");
      if(poNode.parent.getLastChild() != poNode) {
         voIcon = this.icons.get("node");
         vbNBlank = true;
      }
      if(voIcon.src != "none") {
        vaTagStrBuf = [];
        vaTagStrBuf.push("<img name='node' border=0 src='");
        vaTagStrBuf.push(voIcon.src);
        vaTagStrBuf.push("' style='position:absolute;top:0px;");
        vaCssStrBuf = [];
        vfcSetCssStrBuf(vaCssStrBuf, "left", (vnLeftGap * this.iconWidth), "px");
        vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
        vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
        vaTagStrBuf.push(vaCssStrBuf.join(""));
        vaTagStrBuf.push("'>");
      }
      if(vbNBlank) voIcon = this.icons.get("verticalLine");
      else voIcon = this.icons.get("blank");
      if(vbNBlank && voIcon.src != "none") {
        for(var j = 1; j < vnLayer; j++) {
          vaTagStrBuf.push("<img border=0 src='");
          vaTagStrBuf.push(voIcon.src);
          vaTagStrBuf.push("' style='position:absolute;");
          vaCssStrBuf = [];
          vfcSetCssStrBuf(vaCssStrBuf, "top", (j * this.iconHeight), "px");
          vfcSetCssStrBuf(vaCssStrBuf, "left", (vnLeftGap * this.iconWidth), "px");
          vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
          vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
          vaTagStrBuf.push(vaCssStrBuf.join(""));
          vaTagStrBuf.push("'>");
        }
      }
      vaTemplate.push(vaTagStrBuf.join(""));
    } else {
      vbNBlank = false;
      if(poNode.expand) {
        voIcon = this.icons.get("openedLastnode");
        if(poNode.parent.getLastChild() != poNode) {
          voIcon = this.icons.get("openedNode");
          vbNBlank = true
        }
      } else {
        voIcon = this.icons.get("closedLastnode");
        if(poNode.parent.getLastChild() != poNode) {
          voIcon = this.icons.get("closedNode");
          vbNBlank = true;
        }
      }
      vaTagStrBuf = [];
      vaTagStrBuf.push("<img name='node' border=0 src='");
      vaTagStrBuf.push(voIcon.src);
      vaTagStrBuf.push("' style='");
      vaCssStrBuf = [];
      vfcSetCssStrBuf(vaCssStrBuf, "position", "absolute");
      vfcSetCssStrBuf(vaCssStrBuf, "left", (poNode.leftside.length * this.iconWidth), "px");
      vfcSetCssStrBuf(vaCssStrBuf, "top", 0, "px");
      vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
      vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
      vaTagStrBuf.push(vaCssStrBuf.join(""));
      vaTagStrBuf.push("' ");
      if(poNode.disabled != true || this.allowExpand) {
        vaTagStrBuf.push("onclick=\"");
        vaTagStrBuf.push(this.getEHandler(poNode.index, "nodeClick"));
        vaTagStrBuf.push("\"")
      };
      vaTagStrBuf.push(">");
      if(vbNBlank) voIcon = this.icons.get("verticalLine");
      else voIcon = this.icons.get("blank");
      if(vbNBlank && voIcon.src != "none") {
        for(var j = 1; j < vnLayer; j++) {
          vaTagStrBuf.push("<img border=0 src='");
          vaTagStrBuf.push(voIcon.src);
          vaTagStrBuf.push("' style='position:absolute;");
          vaCssStrBuf = [];
          vfcSetCssStrBuf(vaCssStrBuf, "top", (j * this.iconHeight), "px");
          vfcSetCssStrBuf(vaCssStrBuf, "left", (vnLeftGap * this.iconWidth), "px");
          vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
          vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
          vaTagStrBuf.push(vaCssStrBuf.join(""));
          vaTagStrBuf.push("'>");
        }
      }
      vaTemplate.push(vaTagStrBuf.join(""));
    }
  }
  var vbSelectedNode = false;
  if(this.selectedItems.get(poNode.index)) {
    vbSelectedNode = true;
  }
  if(this.openedItem == poNode) {
    if(poNode.isLeaf()) voIcon = this.icons.get("selectedLeafItem");
    else voIcon = this.icons.get("openedFolder_" + poNode.depth);
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.iconOpened && poNode.iconOpened != "") {
      voIcon = {};
      voIcon.src = poNode.iconOpened;
    }

  } else {
    if(poNode.isLeaf()) {
      voIcon = this.icons.get("leafItem_" + poNode.depth);
      if(voIcon == null) voIcon = this.icons.get("leafItem");
    } else{
      voIcon = this.icons.get("closedFolder_" + poNode.depth);
    }
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.icon && poNode.icon != "") {
      voIcon = {};
      voIcon.src = poNode.icon;
    }
  }
  var vnOffset = 0;

  vnOffset = vnLeftGap + 1;
  if(poNode == this.root) vnOffset = 0;
  if(voIcon.src != "none") {
    vaTagStrBuf = [];
    vaTagStrBuf.push("<img name='folder' border=0 src='");
    vaTagStrBuf.push(voIcon.src);
    vaTagStrBuf.push("' style='position:absolute;top:0px;");
    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
    if(poNode.disabled != true) vfcSetCssStrBuf(vaCssStrBuf, "cursor", voItemgroupDf.cursor);
    vaTagStrBuf.push(vaCssStrBuf.join(""));
    vaTagStrBuf.push("'");
    if(poNode.disabled != true) {
      vaTagStrBuf.push(" onmousedown=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMousedown"));
      vaTagStrBuf.push("return false;\" onmouseup=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMouseup"));
      vaTagStrBuf.push("\" onclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelClick"));
      vaTagStrBuf.push("\" ondblclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelDblClick"));
      vaTagStrBuf.push("\" ");
    }
    vaTagStrBuf.push(">");
    voIcon = this.icons.get("verticalLine");
    if(poNode.expand == false || poNode.isLeaf()) {
      voIcon = this.icons.get("blank");
    }
    for(var j = 1; j < vnLayer; j++) {
      vaTagStrBuf.push("<img name='blank' border=0 src='");
      vaTagStrBuf.push(voIcon.src);
      vaTagStrBuf.push("' style='position:absolute;");
      vaCssStrBuf = [];
      vfcSetCssStrBuf(vaCssStrBuf, "top", (j * this.iconHeight), "px");
      vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
      vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
      vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
      vaTagStrBuf.push(vaCssStrBuf.join(""));
      vaTagStrBuf.push("'>");
    }
    vaTemplate.push(vaTagStrBuf.join(""));
  } else {
    vnOffset--;
  }
  var vsFontColor = poNode.color;
  if(vsFontColor == null && this.getNodeColor) vsFontColor = this.getNodeColor(poNode);
  if(vsFontColor == null && voItemgroupDf.className) vsFontColor = this.getStyleCurrentValue(voItemgroupDf, "color", "color");
  if(vsFontColor == null) vsFontColor = voItemgroupDf.color;
  if(vsFontColor == null) vsFontColor = this.color;
  var vsBackgroundColor = poNode.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = voItemgroupDf.backgroundColor;
  if(vsBackgroundColor == null && voItemgroupDf.className) vsBackgroundColor = this.getStyleCurrentValue(voItemgroupDf, "background-color", "backgroundColor");
  if(vsBackgroundColor == null) vsBackgroundColor = this.backgroundColor;
  if(vbSelectedNode)
  {
    vsFontColor = voItemgroupDf.selectedColor;
    vsBackgroundColor = voItemgroupDf.selectedBackgroundColor;
  }

  if(this.showCheckBox) {
    vnOffset++;
    if(poNode == this.root) vnOffset = 0;
    vaTagStrBuf = [];
    vaTagStrBuf.push("<input type=checkbox hideFocus='true' ");
    if(this.selectedItems.get(poNode.index)) {
      vaTagStrBuf.push("checked ");
    }
    //vaTagStrBuf.push("style='position:absolute;top:0px;");
    // todo: yhkim 체크 깨지는 문제 아래처럼(IE8에서는 깨진다)
    vaTagStrBuf.push("style='position:absolute;top:0px;margin-top:0px;margin-left:0px;padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px;");
    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
//    vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
    vaTagStrBuf.push(vaCssStrBuf.join(""));
    vaTagStrBuf.push("' ");
    if(poNode.disabled != true) {
      vaTagStrBuf.push("onclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "cbClick"));
      vaTagStrBuf.push("\">");
    } else {
      vaTagStrBuf.push("disabled >");
    }
    if(voIcon.src == "none") {
      voIcon = this.icons.get("verticalLine");
      if(poNode.parent.getLastChild() == poNode && poNode.expand == false) {
        voIcon = this.icons.get("blank");
      }
      for(var j = 1; j < vnLayer; j++) {
        vaTagStrBuf.push("<img name='blank' border=0 src='");
        vaTagStrBuf.push(voIcon.src);
        vaTagStrBuf.push("' style='position:absolute;");
        vaCssStrBuf = [];
        vfcSetCssStrBuf(vaCssStrBuf, "top", (j * this.iconHeight), "px");
        vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
        vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
        vfcSetCssStrBuf(vaCssStrBuf, "height", this.iconHeight, "px");
        vaTagStrBuf.push(vaCssStrBuf.join(""));
        vaTagStrBuf.push("'>");
      }
    }
    vaTemplate.push(vaTagStrBuf.join(""));
  }

  var voSpan = this.subElement.span;
  voSpan.innerHTML = poNode.name;
  var vnLen = voSpan.offsetWidth;

  vnOffset++;
  vaTagStrBuf = [];
  vaTagStrBuf.push("<div onselectstart=\"return false;\" ");
  if(poNode.disabled) {
//    vaTagStrBuf.push("disabled ");
  } else if(this.trvType != "WBS") {
    vaTagStrBuf.push("onmousedown=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMousedown"));
    vaTagStrBuf.push("return false;\" onmouseup=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMouseup"));
    vaTagStrBuf.push("\" onclick=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelClick"));
    vaTagStrBuf.push("\" ondblclick=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelDblClick"));
    vaTagStrBuf.push("\" ");
  }

  vaTagStrBuf.push("style='position:absolute;margin:0px;padding:0px;top:0px;");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnLen, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", (this.iconHeight * vnLayer), "px");
  if(this.trvType != "WBS") {
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
    if(poNode.disabled != true) vfcSetCssStrBuf(vaCssStrBuf, "cursor", voItemgroupDf.cursor);
  }
  vaTagStrBuf.push(vaCssStrBuf.join(""));
  vaTagStrBuf.push("'>");

  vaTemplate.push(vaTagStrBuf.join(""));

  poNode.left = vnOffset * this.iconWidth;
//  poNode.top = parseInt(poDiv.style.top);
  poNode.width = vnLen;
  poNode.height = this.iconHeight * vnLayer;

  // yhkim 2009.09.04
  var vsClass = this.getCSSClass(this, 1, "itemgroup");
  vaTagStrBuf = [];
  vaTagStrBuf.push("<table class='" + vsClass + "' cellSpacing=0 cellPadding=0 style='position:absolute;left:0px;top:0px;");
  vaCssStrBuf = [];
  if(this.trvType != "WBS") {
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
    vfcSetCssStrBuf(vaCssStrBuf, "color", vsFontColor);
    if(poNode.disabled) vfcSetCssStrBuf(vaCssStrBuf, "color", this.disabledColor);//박상찬 수정(disabled color)
  }

  vfcSetCssStrBuf(vaCssStrBuf, "width", vnLen, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", (this.iconHeight * vnLayer), "px");
  var vuAttr = poNode.fontFamily;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontFamily;
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", vuAttr);
  vuAttr = poNode.fontSize;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontSize;
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vuAttr, "pt");
  vuAttr = poNode.fontStyle;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontStyle;
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", vuAttr);
  vuAttr = poNode.fontWeight;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontWeight;
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", vuAttr);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", voItemgroupDf.cursor);
  vaTagStrBuf.push(vaCssStrBuf.join(""));
  vaTagStrBuf.push("'>");

  vaTemplate.push(vaTagStrBuf.join(""));

  vaTagStrBuf = [];
  vaTagStrBuf.push("<tbody><tr><td style='white-space:nowrap;");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", voItemgroupDf.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", voItemgroupDf.verticalAlign);
  vaTagStrBuf.push(vaCssStrBuf.join(""));

  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
  }

  if(!!voUserAttr && !!voUserAttr.nodeTitle){
    vaTagStrBuf.push("' title='"+poNode.names.join('')+"'>");
  }else{
    vaTagStrBuf.push("'>");
  }

  if(this.trvType == "WBS") {
    vaCssStrBuf = [];
    vaTagStrBuf.push("<table border='0' cellSpacing=0 cellPadding=0 ");
    if(!poNode.disabled){
      vaTagStrBuf.push("onmousedown=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMousedown"));
      vaTagStrBuf.push("return false;\" onmouseup=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMouseup"));
      vaTagStrBuf.push("\" onclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelClick"));
      vaTagStrBuf.push("\" ondblclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelDblClick"));
      vaTagStrBuf.push("\" ");
    }
    vaTagStrBuf.push("style='");
    vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
    vfcSetCssStrBuf(vaCssStrBuf, "color", vsFontColor);
    if(poNode.disabled) vfcSetCssStrBuf(vaCssStrBuf, "color", this.disabledColor);//박상찬 수정(disabled color)
    vfcSetCssStrBuf(vaCssStrBuf, "cursor", voItemgroupDf.cursor);
    vfcSetCssStrBuf(vaCssStrBuf, "border-collapse", "collapse");
    vaTagStrBuf.push(vaCssStrBuf.join(""));
    vaTagStrBuf.push("'><tbody>");
    for(var j = 0; j < vnLayer; j++) {
      vaTagStrBuf.push("<tr><td ");
      if(this.lblClasses[j]) vaTagStrBuf.push("class=\"" + this.lblClasses[j] + "\" ");
      vaTagStrBuf.push("style='white-space:nowrap;");
      vaCssStrBuf = [];
      if(this.lblColors[j]) vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.lblColors[j]);
      if(vbSelectedNode) {
        vfcSetCssStrBuf(vaCssStrBuf, "color", voItemgroupDf.selectedColor);
      }
      vaTagStrBuf.push(vaCssStrBuf.join(""));
      vaTagStrBuf.push("'>" + poNode.names[j]);
      vaTagStrBuf.push("</td></tr>");
    }
    vaTagStrBuf.push("</tbody></table>");
  } else {
    vaTagStrBuf.push(poNode.names.join("<br>"));
  }
  vaTagStrBuf.push("</td></tr></tbody>");

  vaTemplate.push(vaTagStrBuf.join(""));
  poDiv.innerHTML = vaTemplate.join("");
  vaTemplate = null;
};
/**
 * refreshNodeCtrl
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.refreshNodeCtrl = function(poNode, poDiv, poDocument){
  if(this.trvType == "MENU") {
    this.refreshNodeCtrlMenu(poNode, poDiv, poDocument);
    return;
  }

  var voIcon = null;
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  var voBase = this;

  var voImgCtrl = null;
  var vaCtrl = null;
  if(poNode == this.root) return;
  if(poNode.isLeaf()) {
    voIcon = this.icons.get("lastnode");
    if(poNode.parent.getLastChild() != poNode) {
       voIcon = this.icons.get("node");
    }
  } else {
    if(poNode.expand) {
      voIcon = this.icons.get("openedLastnode");
      if(poNode.parent.getLastChild() != poNode) {
        voIcon = this.icons.get("openedNode");
      }
    } else {
      voIcon = this.icons.get("closedLastnode");
      if(poNode.parent.getLastChild() != poNode) {
        voIcon = this.icons.get("closedNode");
      }
    }
  }
  vaCtrl = poDiv.getElementsByTagName("img");
//    voImgCtrl = vaCtrl[vaCtrl.length - 2];
  voImgCtrl = this.getElementsByAttr(vaCtrl, "name", "node")[0];
  voImgCtrl.src = voIcon.src;
  if(poNode.disabled != true || this.allowExpand) {
    voImgCtrl.onclick = function(e) {
      e = e ? e : voBase.window.event;
      voBase.nodeClick(e, poNode.index);
    };
  } else {
    voImgCtrl.onclick = null;
  }

  var vbSelectedNode = false;
  if(this.selectedItems.get(poNode.index)) {
    vbSelectedNode = true;
  }
  if(this.openedItem == poNode) {
    if(poNode.isLeaf()) voIcon = this.icons.get("selectedLeafItem");
    else voIcon = this.icons.get("openedFolder_" + poNode.depth);
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.iconOpened && poNode.iconOpened != "") {
      voIcon = {};
      voIcon.src = poNode.iconOpened;
    }

  } else {
    if(poNode.isLeaf()) {
      voIcon = this.icons.get("leafItem_" + poNode.depth);
      if(voIcon == null) voIcon = this.icons.get("leafItem");
    } else{
      voIcon = this.icons.get("closedFolder_" + poNode.depth);
    }
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.icon && poNode.icon != "") {
      voIcon = {};
      voIcon.src = poNode.icon;
    }
  }

//  voImgCtrl = vaCtrl[vaCtrl.length - 1];
  if(voIcon.src != "none") {
    voImgCtrl = this.getElementsByAttr(vaCtrl, "name", "folder")[0];
    voImgCtrl.style.cursor = voItemgroupDf.cursor;
    voImgCtrl.src = voIcon.src;
    if(poNode.disabled != true) {
      voImgCtrl.onmousedown = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMousedown(e, poNode.index);
      };
      voImgCtrl.onmouseup = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMouseup(e, poNode.index);
      };
      voImgCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelClick(e, poNode.index);
      };
      voImgCtrl.ondblclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelDblClick(e, poNode.index);
      };
    } else {
      voImgCtrl.onmousedown = null;
      voImgCtrl.onmouseup = null;
      voImgCtrl.onclick = null;
      voImgCtrl.ondblclick = null;
    }
  }

  voIcon = this.icons.get("verticalLine");
  if(poNode.expand == false || poNode.isLeaf()) voIcon = this.icons.get("blank");
  var vaImgCtrl = this.getElementsByAttr(vaCtrl, "name", "blank");
  var vnSize = vaImgCtrl.length
  for(var i = 0; i < vnSize; i++) {
    vaImgCtrl[i].src = voIcon.src;
  }

  var vsFontColor = poNode.color;
  if(vsFontColor == null && voItemgroupDf.className) vsFontColor = this.getStyleCurrentValue(voItemgroupDf, "color", "color");
  if(vsFontColor == null) vsFontColor = voItemgroupDf.color;
  if(vsFontColor == null) vsFontColor = this.color;
  var vsBackgroundColor = poNode.backgroundColor;
  if(vsBackgroundColor == null && voItemgroupDf.className) vsBackgroundColor = this.getStyleCurrentValue(voItemgroupDf, "background-color", "backgroundColor");
  if(vsBackgroundColor == null) vsBackgroundColor = voItemgroupDf.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = this.backgroundColor;
  if(vbSelectedNode)
  {
    vsFontColor = voItemgroupDf.selectedColor;
    vsBackgroundColor = voItemgroupDf.selectedBackgroundColor;
  }
  if(vsFontColor == null) vsFontColor = "";
  if(vsBackgroundColor == null) vsBackgroundColor = "";

  if(this.showCheckBox) {
    var voChkCtrl = this.getSubCtrl("input", poDiv, poDocument);
    if(this.selectedItems.get(poNode.index)) voChkCtrl.checked = true;
    else voChkCtrl.checked = false;
//    this.setAttrCtrl("backgroundColor", vsBackgroundColor, voChkCtrl);
    if(poNode.disabled != true) {
      voChkCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.cbClick(e, poNode.index);
      };
      //voChkCtrl.setAttribute("disabled", false); false에 false를 설정하면 한 번은 true가 되어버리는 문제가 있음.
      voChkCtrl.disabled = false;
    } else {
      voChkCtrl.onclick = null;
      voChkCtrl.disabled = true;
    }
  }

  var voDivCtrl = this.getSubCtrl("div", poDiv, poDocument);
  var voTableCtrl =  this.getSubCtrl("table", voDivCtrl, poDocument);
  poNode.names = poNode.name.split("\\n");
  if(this.trvType != "WBS") {
    this.setAttrCtrl("backgroundColor", vsBackgroundColor, voDivCtrl);
    if(poNode.disabled) {
      voDivCtrl.onmousedown = null;
      voDivCtrl.onmouseup = null;
      voDivCtrl.onclick = null;
      voDivCtrl.ondblclick = null;
      if(poNode.disabled) this.setAttrCtrl("color", this.disabledColor, voTableCtrl); //박상찬 수정
      this.setAttrCtrl("cursor", "default", voDivCtrl);
    } else {
      voDivCtrl.onmousedown = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMousedown(e, poNode.index);
      };
      voDivCtrl.onmouseup = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMouseup(e, poNode.index);
      };
      voDivCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelClick(e, poNode.index);
      };
      voDivCtrl.ondblclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelDblClick(e, poNode.index);
      };
      this.setAttrCtrl("cursor", voItemgroupDf.cursor, voDivCtrl);
    }
    this.setAttrCtrl("backgroundColor", vsBackgroundColor, voTableCtrl);
    this.setAttrCtrl("color", vsFontColor, voTableCtrl);
//    voTableCtrl.rows[0].cells[0].innerHTML = poNode.name;
    voTableCtrl.rows[0].cells[0].innerHTML = poNode.names.join("<br>");
  } else {
    var voInnTblCtrl = voTableCtrl.rows[0].cells[0].childNodes[0];
    this.setAttrCtrl("backgroundColor", vsBackgroundColor, voInnTblCtrl);
    this.setAttrCtrl("color", vsFontColor, voInnTblCtrl);
    if(poNode.disabled) this.setAttrCtrl("color", this.disabledColor, voInnTblCtrl);
    var vnSize = voInnTblCtrl.rows.length;
    for(var i = 0; i < vnSize; i++) {
      voInnTblCtrl.deleteRow(0);
    }
//    poNode.names = poNode.name.split("\\n");
    var vnLayer = poNode.names.length;
    var voRow = null;
    var voCell = null;
    var vsCss = "white-space:nowrap;";
    vfcSetCssStrBuf = this.setCssStrBuf;
    vaCssStrBuf = null;
    for(var j = vnLayer - 1; j >= 0; j--) {
      voRow = voInnTblCtrl.insertRow(0);
      voCell = voRow.insertCell(0);
      if(this.lblClasses[j]) voCell.className = this.lblClasses[j];
      vaCssStrBuf = [];
      if(this.lblColors[j]) vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.lblColors[j]);
      if(vbSelectedNode) {
        vfcSetCssStrBuf(vaCssStrBuf, "color", voItemgroupDf.selectedColor);
      }
      voCell.style.cssText = vsCss + vaCssStrBuf.join("");
      voCell.innerHTML = poNode.names[j];
    }
    if(poNode.disabled) {
      voInnTblCtrl.onmousedown = null;
      voInnTblCtrl.onmouseup = null;
      voInnTblCtrl.onclick = null;
      voInnTblCtrl.ondblclick = null;
      this.setAttrCtrl("cursor", "default", voDivCtrl);
    } else {
      voInnTblCtrl.onmousedown = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMousedown(e, poNode.index);
      };
      voInnTblCtrl.onmouseup = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMouseup(e, poNode.index);
      };
      voInnTblCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelClick(e, poNode.index);
      };
      voInnTblCtrl.ondblclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelDblClick(e, poNode.index);
      };
      this.setAttrCtrl("cursor", voItemgroupDf.cursor, voInnTblCtrl);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.getEHandler = function(pnIndex, psFuncName) {
  var vaStrBuf = [];
  vaStrBuf.push("var voControl=page.getControl('");
  vaStrBuf.push(this.id);
  vaStrBuf.push("');");
  vaStrBuf.push("voControl.")
  vaStrBuf.push(psFuncName);
  vaStrBuf.push("(event, ");
  vaStrBuf.push(pnIndex);
  vaStrBuf.push(", this);");
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.cbClick = function(e, pnIndex, poCtrl) {
  /*
  var voItem = this.items.get(pnIndex);
  //this.treeSelectionListener(e, voItem, document);
  this.eventObjectType = "item";
  this.eventObject = voItem;
  */

  var voBase = this;
  var vsId = voBase.id;
  var voNode = voBase.items.get(pnIndex);
  var voNodeCtrl = voBase.lookup(vsId + "_node" + voNode.index);
  var voCb = voBase.getSubCtrl("input", voNodeCtrl);

  voBase.eventObjectType = "item";
  voBase.eventObject = voNode;
  e.objectType = voBase.eventObjectType;
  e.object = voBase.eventObject;

  ///// 2010.12.06 yjcho edit start
  //2010.05.03
  //selectNode 메소드 내부에서 voCb.checked 를 체크 하는 로직이
  //존재하기에 voCb.checked를 뒤바꿔서 처리 하는 로직 추가
//  if(voCb.checked)
//    voCb.checked = false;
//  else
//    voCb.checked = true;
//  voBase.selectNode(voNode, e, voBase.document);
  ///// 2010.12.06 yjcho edit end
  //e.stopPropagation();
  /*
  var voItem = this.items.get(pnIndex);
  if(poCtrl.checked) this.selectedItems.put(voItem.index, voItem);
  else this.selectedItems.remove(voItem.index);


  //2010.03.24 노드클릭과 동일한 기능을 하게 수정
  var voEvent = new eXria.event.Event(e, this.window);
  this.dochange(voEvent, this);
  this.addChangedNode(voItem);
  this.repaint(this.document);
  this.checkSelected();
  */

};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.labelMousedown = function(e, pnIndex) {
  var voItem = this.items.get(pnIndex);
  this.sourceItem = voItem;
  this.eventObjectType = "item";
  this.eventObject = voItem;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.labelMouseup = function(e, pnIndex) {
  var voItem = this.items.get(pnIndex);
  this.targetItem = voItem;
  this.eventObjectType = "item";
  this.eventObject = voItem;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.labelClick = function(e, pnIndex) {
  var voItem = this.items.get(pnIndex);
  //this.treeSelectionListener(e, voItem, document);
  this.eventObjectType = "item";
  this.eventObject = voItem;
  ///// 2010.12.06 yjcho edit start
  if(this.showCheckBox) {
    var voDocument = this.document;
    voDiv = voDocument.getElementById(this.id + "_node" + pnIndex);
    var voChkCtrl = this.getSubCtrl("input", voDiv, voDocument);
    if(voChkCtrl.checked) voChkCtrl.checked = false;
    else voChkCtrl.checked = true;
  }
  ///// 2010.12.06 yjcho edit end
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.nodeClick = function(e, pnIndex) {
  var vnClickTime = new Date().getTime();
  var voControl = this;
  var voItem = this.items.get(pnIndex);
  //this.treeSelectionListener(e, voItem, document);
  this.eventObjectType = "item";
  this.eventObject = voItem;
  this.toggleNode(voItem);
  var voEvent = new eXria.event.Event(e, this.window);
  if(this.onexpand && voItem.expand) {
    voEvent.objectType = "item";
    voEvent.object = voItem;
    this.onexpand(voEvent);
  }
  voEvent.stopEvent();
  this.eventObjectType = null;
  this.eventObject = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.dodblclick = function(e, pnIndex) {
  this.labelDblClick(e, pnIndex);
  if(this.ondblclick) {
    try {
      this.ondblclick(e);
    } catch(err) {
      if(this.debug){
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }

}
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.labelDblClick = function(e, pnIndex) {
  var voItem = this.items.get(pnIndex);
  this.eventObjectType = "item";
  this.eventObject = voItem;
};
/**
 * 현재 랜더링된 트리노드 리스트에서 지정된 트리노드의 다음번 상위노드를 찾는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poNode 기준 트리노드
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @Returns next opened ancestor
 * @type eXria.controls.xhtml.TreeNode
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getNextOpenedAncestor = function(poNode, poDocument) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table", poDocument);
  var vnRowIndex = this.getRowIndexById(vsId + "_node" + poNode.index, poDocument);
  var voNextNode = null;
  var voTempNode = null;
  var vsRowId = null;
  var vnPrefixLen = (vsId + "_node").length;
  for(var i = vnRowIndex + 1; i < voTable.childNodes.length; i++)
  {
    vsRowId = voTable.childNodes.item(i).id;
    voTempNode = this.items.get(vsRowId.substring(vnPrefixLen));
    if(voTempNode.parent == null) continue;
    if(!poNode.isAncestor(voTempNode) && !voTempNode.isAncestor(poNode))
    {
      voNextNode = voTempNode;
      break;
    }
  }
  return voNextNode;
};
/**
 * Returns the number of rows that are currently being displayed
 * @Return the number of rows that are currently being displayed.
 * @type Number
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getRowCount = function() {
  var voTable = this.lookup(this.id + "_table");
  return voTable.childNodes.length;
};
/**
 * Returns the path to the first selected node
 * @Return the path to the first selected node.
 * @type String
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getSelectionPath = function() {
};
/**
 * Move node
 * @param {eXria.controls.xhtml.TreeNode} poSource 트리노드가 원래 위치한 상위 노드
 * @param {eXria.controls.xhtml.TreeNode} poTarget 옮겨진 트리노드를 포함할 상위 노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.moveNode = function(poSource, poTarget) {
  poSource.parent.remove(poSource);
  poTarget.add(poSource);
};
/**
 * Copy node
 * @param {eXria.controls.xhtml.TreeNode} poSource 복제될 노드
 * @param {eXria.controls.xhtml.TreeNode} poTarget 복제될 노드를 포함할 상위 노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.copyNode = function(poSource, poTarget) {
  var voNode = poSource.clone();
  poTarget.add(voNode);
};
/**
 * Returns true if the node at the specified display row is collapsed.
 * @param {Number} pnIndex 현재 디스플레이된 트리노드 리스트에서의 인덱스 번호
 * @return true if the node at the specified display row is collapsed.
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.isCollapsed = function(pnIndex) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table");
  var vsRowId = voTable.rows[pnIndex].id;
  var vnPrefixLen = (vsId + "_node").length;
  vsRowId = vsRowId.substring(vnPrefixLen);

  return this.items.get(parseInt(vsRowId)).expand ? false : true;
};
/**
 * Returns true if the node at the specified display row is currently expanded.
 * @param {Number} pnIndex 현재 디스플레이된 트리노드 리스트에서의 인덱스 번호
 * @return true if the node at the specified display row is currently expanded.
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.isExpanded = function(pnIndex) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table");
  var vsRowId = voTable.rows[pnIndex].id;
  var vnPrefixLen = (vsId + "_node").length;
  vsRowId = vsRowId.substring(vnPrefixLen);

  return this.items.get(parseInt(vsRowId)).expand ? true : false;
};
/**
 * Returns true if the node at the specified display row is currently selected.
 * @param {Number} pnIndex 현재 디스플레이된 트리노드 리스트에서의 인덱스 번호
 * @return true if the node at the specified display row is currently selected.
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.isSelected = function(pnIndex) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table");
  var vsRowId = voTable.rows[pnIndex].id;
  var vnPrefixLen = (vsId + "_node").length;
  vsRowId = vsRowId.substring(vnPrefixLen);

  return this.items.get(parseInt(vsRowId)).isSelected() ? false : false;
};
/**
 * Ensures that the node in the specified row is expanded and viewable.
 * @param {Number} pnIndex
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.expandRow = function(pnIndex) {
};
/**
 * Ensures that the node identified by the specified path is expanded and viewable.
 * @param {String} psPath
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.expandPath = function(psPath) {
};
/**
 * 모든 노드를 펼침.
 */
eXria.controls.xhtml.TreeView.prototype.expandAllNode = function() {
  this.root.expandDecendants();
};
/**
 * Returns true if the node identified by row is selected.
 * @param {Number} pnIndex
 * @return this.selectedItems
 * @type Boolean
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.isRowSelected = function(pnIndex) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table");
  var vsRowId = voTable.rows[pnIndex].id;
  var vnPrefixLen = (vsId + "_node").length;
  vsRowId = vsRowId.substring(vnPrefixLen);

  //return this.selectedItems.get(0) == this.items.get(parseInt(vsId)) ? true : false;
  return this.selectedItems.get(vsRowId) ? true : false;
};
/**
 * Removes the row at the index row from the current selection.
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.removeSelectionRow = function() {
};
/**
 * 현재 보여지는 트리 상에서 지정된 row를 선택하는 메소드.
 * @param {Number} pnIndex 현재 보여지는 트리 상에서 지정된 row 인덱스 번호
 */
eXria.controls.xhtml.TreeView.prototype.setSelectionRow = function(pnIndex) {
  var vsId = this.id;
  var voTable = this.lookup(vsId + "_table");
  var vsRowId = voTable.rows[pnIndex].id;
  var vnPrefixLen = (vsId + "_node").length;
  vsRowId = vsRowId.substring(vnPrefixLen);

  this.selectNode(this.items.get(parseInt(vsRowId)));
};
/**
 * 지정된 트리노드 선택 해제.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 트리노드
 * @example
 * var tree = page.getControl("treeview");<br>
   var node = tree.getNodeByVal("value1");<br>
   tree.unselectNode(node);<br>
 */
eXria.controls.xhtml.TreeView.prototype.unselectNode = function(poNode) {
  //for(var i = 0; i < this.selectedItems.size(); i++) {
  //  if(this.selectedItems.get(i) == poNode) {
  //    this.selectedItems.remove(i);
  //    this.addChangedNode(poNode);
  //    return;
  //  }
  //}
  this.selectedItems.remove(poNode.index);
  this.addChangedNode(poNode);
  this.openedItem = null;
  return;
};
/**
 * Selects the specified node
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 노드
 * @param {eXria.event.Event} poEvent 이벤트 객체
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.TreeView.prototype.selectNode = function(poNode, poEvent, poDocument) {
  if(poEvent == null) {
    poEvent = {};
    poEvent.object = poNode;
    poEvent.objectType = "item";
  }
  if(this.showCheckBox) {
    this.selectNodeCb(poNode, poEvent, poDocument);
  } else {
    this.selectNodeNoCb(poNode, poEvent, poDocument);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.selectNodeNoCb = function(poNode, poEvent, poDocument) {
  var vnTop = this.ctrl.scrollTop;
  if(this.selectionMode == "single") {
    var voSelectedItems = this.selectedItems.getValueCollection();
    if(voSelectedItems.get(0) != null) {
       this.addChangedNode(voSelectedItems.get(0));
    }
    //this.selectedItems.set(0, poNode);
    this.selectedItems.clear();
    this.selectedItems.put(poNode.index, poNode)
    if(this.openedItem != poNode) {
      this.dochange(poEvent, this);
    }
    this.openedItem = poNode;
  } else {
    var vbCtrl = false;
    if(poEvent) vbCtrl = poEvent.ctrlKey;
    if(vbCtrl) {
      if(poNode.isSelected()) {
         this.unselectNode(poNode);
      } else {
        //this.selectedItems.add(poNode);
        this.selectedItems.put(poNode.index, poNode);
        this.openedItem = poNode;
      }
    } else {
      var voSelectedItems = this.selectedItems.getValueCollection();
      for(var i = 0; i < voSelectedItems.size(); i++) {
         this.addChangedNode(voSelectedItems.get(i));
      }
//      if(this.openedItem != null) this.addChangedNode(this.openedItem);
      this.selectedItems.clear()
      //this.selectedItems.set(0, poNode);
      this.selectedItems.put(poNode.index, poNode);
      if(this.openedItem != poNode) {
        this.dochange(poEvent, this);
      }
      this.openedItem = poNode;
    }
  }
  this.addChangedNode(poNode);
  this.repaint(poDocument);
  //this.setValue(poNode);
  this.checkSelected();
  this.ctrl.scrollTop = vnTop;
};
/**
 * @ignore
 */
eXria.controls.xhtml.TreeView.prototype.selectNodeCb = function(poNode, poEvent, poDocument) {
  var vnTop = this.ctrl.scrollTop;
  var vsId = this.id;
  var voNodeCtrl = this.lookup(vsId + "_node" + poNode.index);
  var voCb = this.getSubCtrl("input", voNodeCtrl);
  ///// 2010.12.06 yjcho edit start
//  if(voCb.checked) {
//    this.selectedItems.remove(poNode.index);
//    voCb.checked = false;
//  } else {
//    this.selectedItems.put(poNode.index, poNode);
//    voCb.checked = true;
//  }
  if(voCb.checked) {
    this.selectedItems.put(poNode.index, poNode);
  } else {
    this.selectedItems.remove(poNode.index);
  }
  ///// 2010.12.06 yjcho edit end
  if(this.openedItem) this.addChangedNode(this.openedItem);
//  if(this.openedItem != poNode) {
    this.dochange(poEvent, this);
//  }
  this.openedItem = poNode;

  this.addChangedNode(poNode);
  this.repaint(poDocument);
  this.checkSelected();
  this.ctrl.scrollTop = vnTop;
};
/**
 * remove node from selected node
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.removeFromSelectedNode = function(poNode) {
  //for(var i = 0; i < this.selectedItems.size(); i++) {
  //  if(poNode == this.selectedItems.get(i)) {
  //    this.selectedItems.remove(i)
  //    return;
  //  }
  //}
  this.selectedItems.remove(poNode.index);
};
/**
 * 지정된 트리노드를 선택하는 메소드.(노드를 펼치는 것과는 다름).
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 */
eXria.controls.xhtml.TreeView.prototype.openNode = function(poNode) {
  if(this.openedItem != null) this.addChangedNode(this.openedItem);
  this.openedItem = poNode;
  this.selectedItems.put(poNode.index, poNode)
  this.addChangedNode(poNode);
};
/**
 * 노드 선택.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능
 * @example
   var tree = page.getControl("treeview");<br>
   var node = tree.getNodeByVal("value1");<br>
   tree.toggleNode(node);<br>
 */
eXria.controls.xhtml.TreeView.prototype.toggleNode = function(poNode, poDocument) {
  var vbExpand = poNode.expand ? false : true;
  poNode.expand = vbExpand;
  ///// 2010.12.06 yjcho edit start
//  if(vbExpand == false) {
//    //var setSelected = false;
//    var voSelectedItems = this.selectedItems.getValueCollection();
//    //for(var i = 0; i < this.selectedItems.size(); i++) {
//    //  if(poNode.isAncestor(this.selectedItems.get(i))) {
//    //    this.unselectNode(this.selectedItems.get(i));
//    //    setSelected = true;
//    //    i--;
//    //  }
//    //}
//    //if(setSelected) this.selectedItems.add(poNode);
//    for(var i = 0; i < voSelectedItems.size(); i++) {
//      if(poNode.isAncestor(voSelectedItems.get(i))) {
//        this.unselectNode(voSelectedItems.get(i));
//      }
//    }
//    if(this.openedItem != null && poNode.isAncestor(this.openedItem)) this.openNode(poNode);
//  }
  ///// 2010.12.06 yjcho edit end
  if(this.isOneLine && vbExpand) {
    if(this.prevExpandNode == null) this.prevExpandNode = this.root;
    if(!this.prevExpandNode.isAncestor(poNode) && !poNode.isAncestor(this.prevExpandNode)) {
      var voParent = this.prevExpandNode.parent;
      var voCollapseNode = this.prevExpandNode;
      while(!voParent.isAncestor(poNode)) {
        voCollapseNode = voParent;
        voParent = voParent.parent;
      }
      voCollapseNode.expand = false;
      this.addChangedNode(voCollapseNode);
    }
    this.prevExpandNode = poNode;
  }
  this.addChangedNode(poNode);
//  var voNodeCtrl = this.document.getElementById(this.id + "_node" + poNode.index);
//  var vnClientHeight01 = voNodeCtrl.clientHeight;
  this.repaint(poDocument);
//  voNodeCtrl = this.document.getElementById(this.id + "_node" + poNode.index);
//  var vnScrollHeight02 = voNodeCtrl.scrollHeight;
//  var vnScrollTop = vnScrollHeight02 - vnClientHeight01;
//  if(vnScrollTop > 0) this.ctrl.scrollTop = vnScrollTop;
};
/**
 * add node to changed node.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.addChangedNode = function(poNode) {
//  if(!this.hasChangedAncestor(poNode)) this.changedNodes.add(poNode);
  this.changedNodes.add(poNode);
};
/**
 * remove node from changed node
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.removeFromChangedNode = function(poNode) {
  for(var i = 0; i < this.changedNodes.size(); i++) {
    if(poNode == this.changedNodes.get(i)) {
      this.changedNodes.remove(i);
      return;
    }
  }
};
/**
 * Returns true if node has changed ancestor
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @return 변경 사항이 존재하는 부모 트리노드
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.hasChangedAncestor = function(poNode) {
  var voParent = poNode;
  if(voParent == null) return true;
  var vbHasChangedAncestor = false;
  while(voParent != this.root) {
    if(voParent.parent == null) return true;
    voParent = voParent.parent;
    if(this.isChangedNode(voParent)) {
      vbHasChangedAncestor = true;
      break;
    }
  }
  return vbHasChangedAncestor;
};
/**
 * Returns true is node is changed
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상노드
 * @return vbChanged
 * @type Boolean
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.isChangedNode = function(poNode) {
  var vbChanged = false;
  for(var i = 0; i < this.changedNodes.size(); i++) {
    if(this.changedNodes.get(i) == poNode) vbChanged = true;
  }
  return vbChanged;
};

//treeSelectionListener
//@param {HTMLEvent} e 윈도우이벤트
//@param {eXria.controls.xhtml.TreeNode} poNode 대상노드
//@param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
//@private

//eXria.controls.xhtml.TreeView.prototype.treeSelectionListener = function(e, poNode, poDocument) {
//  var voEvent = new eXria.event.Event(e);
//  this.selectNode(poNode, voEvent, poDocument);
//  voEvent.stopEvent();
//};
/**
 * refresh시 해당 노드의 이전의 펼쳐진 상태로 복원하기 위해
 * 해당 노드와 그 하위 노드의 펼쳐진 상태를 인덱스를 통해 기록하는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poNode 펼쳐진 상태를 체크할 노드
 * @param {String} psIndexes 노드의 위치를 root로 부터의 상대적 인덱스 형태로 표현한 값
 * root 노드는 "", this.root.children[0].childrent[0]은 "0,0" 인 형태
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.remarkExpand =  function(poNode, psIndexes) {
  var voChild = null;
  var vsIndexes = null;
  if(psIndexes != "") psIndexes += ","
  for(var i = 0; i < poNode.children.length; i++) {
    voChild = poNode.children[i];
    vsIndexes = psIndexes + i;
    if(voChild.expand) {
      this.expandedIndexes.push(vsIndexes);
      this.remarkExpand(voChild, vsIndexes);
    }
  }
};
/**
 * root로 부터의 상대적 위치 값을 통해 노드를 검색하는 메소드.
 * @param {String} psIndexes 노드의 위치를 root로 부터의 상대적 인덱스 형태로 표현한 값
 * @return 검색된 노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeView.prototype.getNodeFromRoot = function(psIndexes) {
  var vaIndex = psIndexes.split(",");
  var vnIndex = null;
  var voNode = this.root;
  for(var i = 0; i < vaIndex.length; i++) {
    vnIndex = parseInt(vaIndex[i]);
    voNode = voNode.children[vnIndex];
    if(voNode == null) return null;
  }
  return voNode;
};
/**
 * 트리의 펼쳐진 상태를 refresh 이전의 펼쳐진 상태로 복원시켜 주기위한 메소드.
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.restoreExpand = function() {
  if(this.expandedIndexes == null) {
    this.expandedIndexes = [];
    return;
  }
  var voNode =  null;
  var vsIndexes = null;
  for(var i = 0 ; i < this.expandedIndexes.length; i++) {
    vsIndexes = this.expandedIndexes[i];
    voNode = this.getNodeFromRoot(vsIndexes);
    if(voNode) {
      voNode.expand = true;
    }
  }
  this.expandedIndexes = [];
};
/**
 * 해당 노드에 매핑된 인스턴스 element의 인덱스(그 상위 노드를 기준)를 반환하는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poNode 대상 노드
 * @return 해당 노드에 매핑된 인스턴스 element의 인덱스
 * @type Number
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getInstanceIndex = function(poNode) {
  if(poNode.nodeset) {
   var voCollectionNode = poNode.nodeset.data.getNodesetData2();
   var vnSize = voCollectionNode.getLength();
   var voMapNode = null;
   var vsLabelNode = poNode.nodeset.labelTagName;
   var vsValueNode = poNode.nodeset.valueTagName;
   var vsLabel = null;
    var vsValue = null;
   for(var i = 0; i < vnSize; i++) {
     voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
     vsLabel = voMapNode.get(vsLabelNode);
     vsValue = voMapNode.get(vsValueNode);
     if(poNode.name == vsLabel && poNode.getValue() == vsValue) {
      return i;
     }
   }
  }
  return -1;
};
/**
 * 노드를 위, 아래로 이동시켜주는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poNode 이동시킬 노드
 * @param {Boolean} pbUp 위로 이동시킬지 여부
 * @example
 * var tree = page.getControl("treeview");<br>
   var node = tree.getNodeByVal("value1");<br>
   tree.upDownNode(node, true);<br>
 */
eXria.controls.xhtml.TreeView.prototype.upDownNode = function(poNode, pbUp) {
  var vnSourceIndex = poNode.parent.getIndex(poNode);
  var voTargetNode = null;
  if(pbUp) {
    if(vnSourceIndex == 0) return;
    voTargetNode = poNode.parent.children[vnSourceIndex - 1];
  } else {
    voTargetNode = poNode.parent.children[vnSourceIndex + 1];
  }
  if(voTargetNode == null) return;
  this.switchNode(poNode, voTargetNode);
};
/**
 * 두 노드의 위치를 상호 교환시켜주는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poSourceNode 이동시킬 노드
 * @param {eXria.controls.xhtml.TreeNode} poTargetNode 이동시킬 위치의 기존 노드
 * @example
 * var tree = page.getControl("treeview");<br>
   var node1 = tree.getNodeByVal("value1");<br>
   var node2 = tree.getNodeByVal("value2");<br>
   tree.switchNode(node1, node2);<br>
 */
eXria.controls.xhtml.TreeView.prototype.switchNode = function(poSourceNode, poTargetNode) {
  if(poSourceNode == poTargetNode) return;
  if(poSourceNode.parent != poTargetNode.parent) return;
  var vnSourceIndex = poSourceNode.parent.getIndex(poSourceNode);
  var vnTargetIndex = poTargetNode.parent.getIndex(poTargetNode);
  var vnAdjust = 1;
//  if(vnTargetIndex < vnSourceIndex) vnAdjust = 0;

  vnSourceIndex = poTargetNode.parent.getIndex(poSourceNode);
  vnTargetIndex = poTargetNode.parent.getIndex(poTargetNode);

  if(vnSourceIndex > vnTargetIndex){
    var vnTemp = vnSourceIndex;
    vnSourceIndex = vnTargetIndex;
    vnTargetIndex = vnTemp;
    poSourceNode.parent.remove(poTargetNode);
    poSourceNode.parent.add(poTargetNode, vnTargetIndex, vnSourceIndex);
  }else{
    poSourceNode.parent.remove(poSourceNode);
    poTargetNode.parent.add(poSourceNode, vnTargetIndex, vnSourceIndex);
  }
//  poTargetNode.parent.add(poSourceNode, vnTargetIndex, vnSourceIndex);
  this.repaintChanged();
  this.switchInstanceNode(poSourceNode, poTargetNode);
};
//eXria.controls.xhtml.TreeView.prototype.switchNode = function(poSourceNode, poTargetNode) {
//  if(poSourceNode == poTargetNode) return;
//  if(poSourceNode.parent != poTargetNode.parent) return;
//  var vnSourceIndex = poSourceNode.parent.getIndex(poSourceNode);
//  var vnTargetIndex = poTargetNode.parent.getIndex(poTargetNode);
//  var vnAdjust = 1;
//  if(vnTargetIndex < vnSourceIndex) vnAdjust = 0;
//
//  poSourceNode.parent.remove(poSourceNode);
//  vnTargetIndex = poTargetNode.parent.getIndex(poTargetNode);
//  poTargetNode.parent.add(poSourceNode, vnTargetIndex + vnAdjust);
//  this.repaintChanged();
//  this.switchInstanceNode(poSourceNode, poTargetNode);
//};
/**
 * 두 노드의 인스턴스 위치를 상호 교환시켜주는 메소드.
 * @param {eXria.controls.xhtml.TreeNode} poSourceNode 이동시킬 노드
 * @param {eXria.controls.xhtml.TreeNode} poTargetNode 이동시킬 위치의 기존 노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.switchInstanceNode = function(poSourceNode, poTargetNode) {
  if(poSourceNode == poTargetNode) return;
  if(poSourceNode.nodeset != poTargetNode.nodeset) return;
  var vnSourceIndex = this.getInstanceIndex(poSourceNode);
  var vnTargetIndex = this.getInstanceIndex(poTargetNode);
  if(vnSourceIndex == -1 || vnTargetIndex == -1) return;
  var voCollectionNode = poSourceNode.nodeset.data.getNodesetData2();
  var voSourceMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(vnSourceIndex));
  var voTargetMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(vnTargetIndex));
  var vsLabelTag = poTargetNode.nodeset.labelTagName;
  var vsValueTag = poTargetNode.nodeset.valueTagName;
  var vsParentTag = poTargetNode.nodeset.parentTagName;
  var vsTargetLabel = voTargetMapNode.get(vsLabelTag);
  var vsTargetValue = voTargetMapNode.get(vsValueTag);
  var vsTargetParent = voTargetMapNode.get(vsParentTag);
  voTargetMapNode.put(vsLabelTag, voSourceMapNode.get(vsLabelTag));
  voTargetMapNode.put(vsValueTag, voSourceMapNode.get(vsValueTag));
  voTargetMapNode.put(vsParentTag, voSourceMapNode.get(vsParentTag));
  voSourceMapNode.put(vsLabelTag, vsTargetLabel);
  voSourceMapNode.put(vsValueTag, vsTargetValue);
  voSourceMapNode.put(vsParentTag, vsTargetParent);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number|Object
 */
eXria.controls.xhtml.TreeView.prototype.getSpecificDefaultValue = function(psAttrName){
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.TreeView[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.TreeView[vaAttrName[0]][vaAttrName[1]];
  }
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
//  if(psAttrName == "iconDir") {
//    vsDefaultValue = (this.canvas.page.metadata.resourceBaseUrl + vsDefaultValue;
//  }
  return vsDefaultValue;
};
/**
 * 지정된 값을 포함한 트리노드를 얻어오기 위한 메소드.
 * @param {String} psValue 검색할 값
 * @return 지정된 값을 포함한 트리노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeView.prototype.getNodeByVal = function(psValue) {
  var voIterator = this.items.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    voNode = voIterator.next();
    if(voNode.getValue() == psValue) {
      return voNode;
    }
  }
  return null;
};
/**
 * 지정된 값을 포함한 트리노드를 얻어오기 위한 메소드.
 * @param {String} psValue 검색할 값
 * @return 지정된 값을 포함한 트리노드
 * @type eXria.controls.xhtml.TreeNode
 */
eXria.controls.xhtml.TreeView.prototype.openNodeByVal = function(psValue) {
  var voIterator = this.items.getValueCollection().iterator();
  var voNode = null;
  var voRet = null;
  while(voIterator.hasNext()) {
    voNode = voIterator.next();
    if(voNode.getValue() == psValue) {
      voRet = voNode;
      break;
    }
  }
  if(voRet == null) return;
  voRet.expand = true;
  var voParent = null;
  var voChangedRoot = null;
  if(voRet.parent) voParent = voRet.parent;
  while(voParent) {
    //if(voParent.expand) break;
    voParent.expand = true;
    //voChangedRoot = voParent;
    voParent = voParent.parent;
  }
  this.addChangedNode(this.root);
  this.repaint();

  //2010.12.15 추가
  var voDiv = null;
  var voDocument = this.document;
  voDiv = voDocument.getElementById(this.id + "_node" + voRet.index);
  if(this.showCheckBox) {
    var voChkCtrl = this.getSubCtrl("input", voDiv, voDocument);
    if(voChkCtrl.checked) voChkCtrl.checked = false;
    else voChkCtrl.checked = true;
  }
  this.selectNode(voRet);
  this.ctrl.scrollTop = parseInt(voDiv.style.top);
  return voRet;
};
/**
 * 지정된 위치(document.body를 기준)의 item을 반환하는 메소드
 * @param {Number} pnIndex 현재 보여지는 트리 리스트의 row 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.getItemByPos = function(pnX, pnY, pbChkParent) {
  var voDocument = this.document;
  var voCtrl = this.ctrl;
  var voTable = this.lookup(this.id + "_table", this.document);
  var vnSize = voTable.childNodes.length;
  var voDiv = null;
  var voStyle = null;
  var vsIdx = null;
  var voItems = this.items;
  var voItem = null;

  if(pbChkParent) {
    var voParent = this.parent;
    while(voParent) {
      pnX -= voParent.left;
      pnY -= voParent.top;
      voParent = voParent.parent;
    }
  }
  pnX -= this.left;
  pnY -= this.top;

  var vnTop = null;
  for(var i = 0; i < vnSize; i++) {
    voDiv = voTable.childNodes.item(i);
    vsIdx = voDiv.id;
    vsIdx = vsIdx.replace(this.id + "_node", "");
    voItem = voItems.get(vsIdx);
    vnTop = parseInt(voDocument.getElementById(this.id + "_node" + voItem.index).style.top) - voCtrl.scrollTop;
    if((pnX >= voItem.left && pnX <= voItem.left + voItem.width) &&
        (pnY >= vnTop && pnY <= vnTop + voItem.height)) {
      break;
    }
    voItem = null;
  }
  return voItem;
};







eXria.controls.xhtml.TreeView.prototype.repaintChangedMenu = function(poCtrl, poDocument) {
  if(poDocument == null) poDocument = this.document;
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  var voTable = poCtrl.childNodes[0];
  var vsId = this.id;
  for(var i = 0; i < this.changedNodes.size(); i++) {
    var voNode = this.changedNodes.get(i);
    var vsRowId = vsId + "_node" + voNode.index;
    var nextRowId = - 1;
    var vnRowIndex1 = - 1;
    var vnRowIndex2 = - 1;
    if(voNode != this.root) {
      vnRowIndex1 = this.getRowIndexById(vsRowId, poDocument);
      try {
        if(voNode.parent.getChildAfter(voNode) == null) throw new Error(9999, "Null point exception!");
        nextRowId = vsId + "_node" + voNode.parent.getChildAfter(voNode).index;
        vnRowIndex2 = this.getRowIndexById(nextRowId, poDocument) - 1;
        if(vnRowIndex2 < 0) throw new Error(9999, "Index out of bound!");
      } catch(err) {
        try {
          if(this.getNextOpenedAncestor(voNode, poDocument) == null) throw new Error(9999, "Null point exception!");
          nextRowId = vsId + "_node" + this.getNextOpenedAncestor(voNode, poDocument).index;
          vnRowIndex2 = this.getRowIndexById(nextRowId, poDocument) - 1;
          if(vnRowIndex2 == -1) throw new Error(9999, "Index Out of bound!");
        } catch(err) {
          vnRowIndex2 = voTable.childNodes.length - 1;
        }
      }
    } else {
      vnRowIndex1 = 0;
      vnRowIndex2 = voTable.childNodes.length - 1;
    }
    var vbRepaintChildren = true;
    if(!voNode.expand) vbRepaintChildren = false;
    try {
      for(var j = 0; j <(vnRowIndex2 - vnRowIndex1); j++) {
         this.deleteTreeNode(vnRowIndex1 + 1, poDocument);
      }
    } catch(err) {
    }

    var vbRoot = false;
    if(voNode == this.root) vbRoot = true;
    this.repaintNode(voNode, vnRowIndex1, vbRoot, poCtrl, poDocument, vbRepaintChildren);
  }

  var voCtrl = this.ctrl;
  var vnSize = voTable.childNodes.length;
  var voNodeCtrl = null;
  var vnHeight = 0;
  for(var i = 0; i < vnSize; i++) {
    voNodeCtrl = voTable.childNodes.item(i);
    vnHeight += parseInt(voNodeCtrl.style.height);
  }
  if(vnHeight > this.innerHeight && this.scrolled != true) {
    var vnSize = voTable.childNodes.length;
    var voNodeCtrl = null;
    var voSubCtrl = null;
    for(var i = 0; i < vnSize; i++) {
      var vnSpanWidth = this.innerWidth - this.window.scrollBarWidth;
      voNodeCtrl = voTable.childNodes.item(i);
      voNodeCtrl.style.width = vnSpanWidth + "px";
      voSubCtrl = voNodeCtrl.getElementsByTagName("div");
      if(voSubCtrl.length == 1) voSubCtrl = voSubCtrl[0];
      else voSubCtrl = voSubCtrl[1];
      if(voNodeCtrl.firstChild != voSubCtrl) {
        vnSpanWidth -= this.iconWidth;
      }
      voSubCtrl.style.width = vnSpanWidth + "px";
      voSubCtrl = voSubCtrl.childNodes.item(0);
      voSubCtrl.style.width = vnSpanWidth + "px";
    }
    this.scrolled = true;
  } else if(vnHeight <= this.innerHeight && this.scrolled) {
    var vnSize = voTable.childNodes.length;
    var voNodeCtrl = null;
    var voSubCtrl = null;
    for(var i = 0; i < vnSize; i++) {
      var vnSpanWidth = this.innerWidth;
      voNodeCtrl = voTable.childNodes.item(i);
      voNodeCtrl.style.width = vnSpanWidth + "px";
      voSubCtrl = voNodeCtrl.getElementsByTagName("div");
      if(voSubCtrl.length == 1) voSubCtrl = voSubCtrl[0];
      else voSubCtrl = voSubCtrl[1];
      if(voNodeCtrl.firstChild != voSubCtrl) {
        vnSpanWidth -= this.iconWidth;
      }
      voSubCtrl.style.width = vnSpanWidth + "px";
      voSubCtrl = voSubCtrl.childNodes.item(0);
      voSubCtrl.style.width = vnSpanWidth + "px";
    }
    this.scrolled = false;
  }
};

eXria.controls.xhtml.TreeView.prototype.deleteTreeNodeMenu = function(pnIndex, poDocument) {
  var voTable = this.lookup(this.id + "_table", poDocument);
  //this.clearCtrlNode(voTable.childNodes.item(pnIndex));
  var voNodeCtrl = voTable.childNodes.item(pnIndex);
  var vnHeight = parseInt(voNodeCtrl.style.height);
  voTable.removeChild(voNodeCtrl);

  var voDiv = null;
  var voStyle = null;
  for(var i = pnIndex; i < voTable.childNodes.length; i++) {
    voDiv = voTable.childNodes.item(i);
    voStyle = voDiv.style;
    voStyle.top = (parseInt(voStyle.top) - vnHeight) + "px";
  }
};

eXria.controls.xhtml.TreeView.prototype.repaintNodeMenu = function(poNode, pnIndex, pbRoot, poCtrl, poDocument, pbRepaintChildren) {
  if(poNode.visible == false || pnIndex < 0) return;
  if(poDocument == null) poDocument = this.document;
  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
  if(pbRepaintChildren == null) pbRepaintChildren = true;
  var vaMenuAttr = window.maMenuAttr;
  var voMenuAttr = null;
  if(poNode.depth == 1) voMenuAttr = vaMenuAttr[0];
  else if(poNode.isLeaf()) voMenuAttr = vaMenuAttr[2];
  else voMenuAttr = vaMenuAttr[1];
  var vnNodeHeight = voMenuAttr.height;
  var voTable = poCtrl.childNodes[0];
  var voPreviousNodeCtrl = null;
  if(pnIndex - 1 >= 0) voPreviousNodeCtrl = voTable.childNodes[pnIndex - 1];
  var vnTop = 0;
  if(voPreviousNodeCtrl) {
    vnTop = parseInt(voPreviousNodeCtrl.style.top);
    vnTop += parseInt(voPreviousNodeCtrl.style.height);
  }

  var vsId = this.id;
  var voDiv = poDocument.getElementById(vsId + "_node" + poNode.index);
  if(voDiv == null) {
    voDiv = poDocument.createElement("div");
    if(this.itemgroup.className) voDiv.setAttribute("class", this.itemgroup.className);
    var voStyle = voDiv.style;
    var voDf = this.df;
    var vaCssStrBuf = null;
    var vfcSetCssStrBuf = this.setCssStrBuf;

    voDiv["id"] = vsId + "_node" + poNode.index;

    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "padding", 0, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "margin", 0, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "position", "absolute");
    vfcSetCssStrBuf(vaCssStrBuf, "left", 0, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "top", vnTop, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", vnNodeHeight, "px");
    voStyle.cssText = vaCssStrBuf.join("");

    if(!pbRoot) {
      if(pnIndex == voTable.childNodes.length) voTable.appendChild(voDiv);
      else voTable.insertBefore(voDiv, voTable.childNodes.item(pnIndex));
      this.setNodeCtrl(poNode, voDiv, poDocument);

      for(var i = pnIndex + 1; i < voTable.childNodes.length; i++) {
        voDiv = voTable.childNodes.item(i);
        voStyle = voDiv.style;
        voStyle.top = (parseInt(voStyle.top) + vnNodeHeight) + "px";
      }
    }
  } else {
    this.refreshNodeCtrl(poNode, voDiv, poDocument);
  }
  if(pbRepaintChildren == false) return;
  var voNextAncestor = null;
  var voPrevious = null;
  for(var i = 0; i < poNode.children.length && poNode.expand; i++) {
    // 하위노드(0) 추가 후 그 하위노드의 하위 노드들이 추가되었을 경우 하위노드(0)의 다음노드(1)은
    // 하위노드(0)의 NextOpenedAncestor에 위치하여야 한다.
    if(i == 0) {
       if(pbRoot) this.repaintNode(poNode.children[i], pnIndex, false, poCtrl, poDocument);
       else this.repaintNode(poNode.children[i], pnIndex + 1, false, poCtrl, poDocument);
    } else {
      var rowId = null;
      var rowIndex = null;
       try {
          voNextAncestor = this.getNextOpenedAncestor(voPrevious, poDocument);
          if(voNextAncestor == null) throw new Error(9999, "It has no next opened ancestor!");
          rowId = vsId + "_node" + voNextAncestor.index;
          rowIndex = this.getRowIndexById(rowId, poDocument);
          if(rowIndex == -1) throw new Error(9999, "Index out of bound!");
          this.repaintNode(poNode.children[i], rowIndex, false, poCtrl, poDocument);

       } catch(err) {
          rowIndex = voTable.childNodes.length;
          this.repaintNode(poNode.children[i], rowIndex, false, poCtrl, poDocument);
       }
    }
    if(poNode.children[i].visible != false) voPrevious = poNode.children[i];
  }
};

eXria.controls.xhtml.TreeView.prototype.setNodeCtrlMenu = function(poNode, poDiv, poDocument){
  var vaTemplate = [];
  var voIcon = null;
  var vaTagStrBuf = null;
  var vaAttStrBuf = null;
  var vaCssStrBuf = null;
  var vaStrBuf = null;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  var vnNodeHeight = parseInt(poDiv.style.height);
  var vaMenuAttr = window.maMenuAttr;
  var voMenuAttr = null;
  if(poNode.depth == 1) voMenuAttr = vaMenuAttr[0];
  else if(poNode.isLeaf()) voMenuAttr = vaMenuAttr[2];
  else voMenuAttr = vaMenuAttr[1];
  var vsMenuBg = eXria.controls.xhtml.Util.getBackgroundImagePath(voMenuAttr.backgroundImage, this.window);
  var vsClassName = voMenuAttr.className;

  var vbSelectedNode = false;
  if(this.selectedItems.get(poNode.index)) {
  //if(this.openedItem == poNode) {
    vbSelectedNode = true;
  }
  if(this.openedItem == poNode) {
    if(poNode.isLeaf()) voIcon = this.icons.get("selectedLeafItem");
    else voIcon = this.icons.get("openedFolder_" + poNode.depth);
    if(voIcon == null) {
//      if(poNode.isLeaf()) {
//        voIcon = this.icons.get("selectedLeafItem");
//      } else{
        if(poNode.expand) {
          voIcon = this.icons.get("openedFolder");
        } else {
          voIcon = this.icons.get("closedFolder_" + poNode.depth);
          if(voIcon == null) voIcon = this.icons.get("closedFolder");
        }
//      }
    }
    if(poNode.iconOpened && poNode.iconOpened != "") {
      voIcon = {};
      voIcon.src = poNode.iconOpened;
    }

  } else {
    if(poNode.isLeaf()) {
      voIcon = this.icons.get("leafItem_" + poNode.depth);
      if(voIcon == null) voIcon = this.icons.get("leafItem");
    } else{
      voIcon = this.icons.get("closedFolder_" + poNode.depth);
    }
    if(voIcon == null) {
//      if(poNode.isLeaf()) {
//        voIcon = this.icons.get("leafItem_" + poNode.depth);
//        if(voIcon == null) voIcon = this.icons.get("leafItem");
//      } else{
        if(poNode.expand) {
          voIcon = this.icons.get("openedFolder_" + poNode.depth);
          if(voIcon == null) voIcon = this.icons.get("openedFolder");
        } else {
          voIcon = this.icons.get("closedFolder");
        }
//      }
    }
    if(poNode.icon && poNode.icon != "") {
      voIcon = {};
      voIcon.src = poNode.icon;
    }
  }
  var vnOffset = 0;

  if(poNode == this.root) vnOffset = 0;
  if(poNode.depth > 1 && voIcon.src != "none") {
    vaTagStrBuf = [];
    vaTagStrBuf.push("<div ");
    vaTagStrBuf.push("' style='position:absolute;top:0px;background-repeat:no-repeat;background-position:center center;");
    vaCssStrBuf = [];
    vfcSetCssStrBuf(vaCssStrBuf, "background-image", eXria.controls.xhtml.Util.getBackgroundImagePath(voIcon.src, this.window));
    vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
    vfcSetCssStrBuf(vaCssStrBuf, "width", this.iconWidth, "px");
    vfcSetCssStrBuf(vaCssStrBuf, "height", vnNodeHeight, "px");
    if(poNode.disabled != true) vfcSetCssStrBuf(vaCssStrBuf, "cursor", "pointer");
    vaTagStrBuf.push(vaCssStrBuf.join(""));
    vaTagStrBuf.push("'");
    if(poNode.disabled != true) {
      vaTagStrBuf.push(" onmousedown=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMousedown"));
      vaTagStrBuf.push("return false;\" onmouseup=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMouseup"));
      if(poNode.isLeaf()) {
        vaTagStrBuf.push("\" onclick=\"");
        vaTagStrBuf.push(this.getEHandler(poNode.index, "labelClick"));
      } else {
        vaTagStrBuf.push("\" onclick=\"");
        vaTagStrBuf.push(this.getEHandler(poNode.index, "nodeClick"));
      }
      vaTagStrBuf.push("\" ondblclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelDblClick"));
      vaTagStrBuf.push("\" ");
    }
    vaTagStrBuf.push(">");

    vaTemplate.push(vaTagStrBuf.join(""));
  } else {
    vnOffset--;
  }
  var vsFontColor = voMenuAttr.fontColor;
  if(vsFontColor == null) vsFontColor = voItemgroupDf.color;
  if(vsFontColor == null) vsFontColor = this.color;
  var vsBackgroundColor = voMenuAttr.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = voItemgroupDf.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = this.backgroundColor;
  if(vbSelectedNode)
  {
    vsFontColor = voItemgroupDf.selectedColor;
    vsClassName = voMenuAttr.focusClassName;
//    vsBackgroundColor = voItemgroupDf.selectedBackgroundColor;
  } else if(poNode.expand) {
    if(voMenuAttr.focusClassName) vsClassName = voMenuAttr.focusClassName;
  }
//  if(poNode.depth == 1) vsBackgroundColor = "transparent";

  var vnLen = this.ctrl.clientWidth;
  if(poNode.depth > 1 && voIcon.src != "none") {
//    var voSpan = this.subElement.span;
//    voSpan.innerHTML = poNode.name;
//    vnLen = voSpan.offsetWidth;
      vnLen -= this.iconWidth;
  }

  vnOffset++;
  vaTagStrBuf = [];
  vaTagStrBuf.push("<div onselectstart=\"return false;\" ");
  if(poNode.disabled) {
    vaTagStrBuf.push("disabled ");
  } else {
    vaTagStrBuf.push("onmousedown=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMousedown"));
    vaTagStrBuf.push("return false;\" onmouseup=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelMouseup"));
    if(poNode.isLeaf()) {
      vaTagStrBuf.push("\" onclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "labelClick"));
    } else {
      vaTagStrBuf.push("\" onclick=\"");
      vaTagStrBuf.push(this.getEHandler(poNode.index, "nodeClick"));
    }
    vaTagStrBuf.push("\" ondblclick=\"");
    vaTagStrBuf.push(this.getEHandler(poNode.index, "labelDblClick"));
    vaTagStrBuf.push("\" ");
    if(vsClassName) {
      vaTagStrBuf.push(" class=\"");
      vaTagStrBuf.push(vsClassName);
      vaTagStrBuf.push("\" ");
    }
  }

  vaTagStrBuf.push("style='position:absolute;overflow:hidden;margin:0px;padding:0px;top:0px;");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "left", (vnOffset * this.iconWidth), "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - (vnOffset * voDf.iconWidth)), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnLen, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnNodeHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", vsMenuBg);
  if(poNode.disabled != true) vfcSetCssStrBuf(vaCssStrBuf, "cursor", "pointer");
  vaTagStrBuf.push(vaCssStrBuf.join(""));
  vaTagStrBuf.push("'>");

  vaTemplate.push(vaTagStrBuf.join(""));

  // yhkim 2009.09.04
  var vsClass = this.getCSSClass(this, 1, "itemgroup");
  vaTagStrBuf = [];
  vaTagStrBuf.push("<table class='" + vsClass + "' cellSpacing=0 cellPadding=0 style='position:absolute;left:0px;top:0px;");
  vaCssStrBuf = [];
  //vfcSetCssStrBuf(vaCssStrBuf, "width", (this.innerWidth - (vnOffset * voDf.iconWidth)), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", vsBackgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnLen, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnNodeHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", vsFontColor);
  var vuAttr = poNode.fontFamily;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontFamily;
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", vuAttr);
  vuAttr = voMenuAttr.fontSize;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontSize;
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", vuAttr, "pt");
  vuAttr = poNode.fontStyle;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontStyle;
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", vuAttr);
  vuAttr = poNode.fontWeight;
  if(vuAttr == null) vuAttr = voItemgroupDf.fontWeight;
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", vuAttr);
  vaTagStrBuf.push(vaCssStrBuf.join(""));
  vaTagStrBuf.push("'>");

  vaTemplate.push(vaTagStrBuf.join(""));

  vaTagStrBuf = [];
  vaTagStrBuf.push("<tbody><tr><td style='");
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", voItemgroupDf.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "vertical-align", voItemgroupDf.verticalAlign);
  vaTagStrBuf.push(vaCssStrBuf.join(""));
  vaTagStrBuf.push("'>");
  vaTagStrBuf.push(eXria.controls.xhtml.Util.parseLang(poNode.name));
  vaTagStrBuf.push("</td></tr></tbody>");

  vaTemplate.push(vaTagStrBuf.join(""));
  poDiv.innerHTML = vaTemplate.join("");
  vaTemplate = null;
};

eXria.controls.xhtml.TreeView.prototype.refreshNodeCtrlMenu = function(poNode, poDiv, poDocument){
  var voIcon = null;
  var voDf = this.df;
  var voItemgroupDf = this.itemgroup;
  var voBase = this;
  var vaMenuAttr = window.maMenuAttr;
  var voMenuAttr = null;
  if(poNode.depth == 1) voMenuAttr = vaMenuAttr[0];
  else if(poNode.isLeaf()) voMenuAttr = vaMenuAttr[2];
  else voMenuAttr = vaMenuAttr[1];
  var vsMenuBg = eXria.controls.xhtml.Util.getBackgroundImagePath(voMenuAttr.backgroundImage, this.window);
  var vsClassName = voMenuAttr.className
  var voImgCtrl = null;
  var vaCtrl = null;

  var vbSelectedNode = false;
  if(this.selectedItems.get(poNode.index)) {
    vbSelectedNode = true;
  }
  if(this.openedItem == poNode) {
    if(poNode.isLeaf()) voIcon = this.icons.get("selectedLeafItem");
    else voIcon = this.icons.get("openedFolder_" + poNode.depth);
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.iconOpened && poNode.iconOpened != "") {
      voIcon = {};
      voIcon.src = poNode.iconOpened;
    }

  } else {
    if(poNode.isLeaf()) {
      voIcon = this.icons.get("leafItem_" + poNode.depth);
      if(voIcon == null) voIcon = this.icons.get("leafItem");
    } else{
      voIcon = this.icons.get("closedFolder_" + poNode.depth);
    }
    if(voIcon == null) {
      if(poNode.expand) {
        voIcon = this.icons.get("openedFolder_" + poNode.depth);
        if(voIcon == null) voIcon = this.icons.get("openedFolder");
      } else {
        voIcon = this.icons.get("closedFolder");
      }
    }
    if(poNode.icon && poNode.icon != "") {
      voIcon = {};
      voIcon.src = poNode.icon;
    }
  }

  var vnIdx = 0;
  if(poNode.depth > 1 && voIcon.src != "none") {
    vnIdx = 1;
    var vaCtrl = poDiv.getElementsByTagName("div");
    voImgCtrl = vaCtrl[0];
    voImgCtrl.style.backgroundImage = eXria.controls.xhtml.Util.getBackgroundImagePath(voIcon.src, this.window);
    if(poNode.disabled != true) {
      voImgCtrl.onmousedown = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMousedown(e, poNode.index);
      };
      voImgCtrl.onmouseup = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelMouseup(e, poNode.index);
      };
      if(poNode.isLeaf()) {
        voImgCtrl.onclick = function(e) {
          e = e ? e : voBase.window.event;
          voBase.labelClick(e, poNode.index);
        };
      } else {
        voImgCtrl.onclick = function(e) {
          e = e ? e : voBase.window.event;
          voBase.nodeClick(e, poNode.index);
        };
      }
      voImgCtrl.ondblclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelDblClick(e, poNode.index);
      };
    } else {
      voImgCtrl.onmousedown = null;
      voImgCtrl.onmouseup = null;
      voImgCtrl.onclick = null;
      voImgCtrl.ondblclick = null;
    }
  }

  var vsFontColor = voMenuAttr.fontColor;
  if(vsFontColor == null) vsFontColor = voItemgroupDf.color;
  if(vsFontColor == null) vsFontColor = this.color;
  var vsBackgroundColor = voMenuAttr.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = voItemgroupDf.backgroundColor;
  if(vsBackgroundColor == null) vsBackgroundColor = this.backgroundColor;
  if(vbSelectedNode)
  {
    vsFontColor = voItemgroupDf.selectedColor;
    vsClassName = voMenuAttr.focusClassName;
//    vsBackgroundColor = voItemgroupDf.selectedBackgroundColor;
  } else if(poNode.expand) {
    if(voMenuAttr.focusClassName) vsClassName = voMenuAttr.focusClassName;
  }
  if(vsFontColor == null) vsFontColor = "";
  if(vsBackgroundColor == null) vsBackgroundColor = "";
//  if(poNode.depth == 1) vsBackgroundColor = "transparent";

  var voDivCtrl = this.getSubCtrl("div", poDiv, poDocument, vnIdx);
  this.setAttrCtrl("className", vsClassName, voDivCtrl)
  this.setAttrCtrl("backgroundColor", vsBackgroundColor, voDivCtrl);
  this.setAttrCtrl("backgroundImage", vsMenuBg, voDivCtrl);
  if(poNode.disabled) {
    voDivCtrl.onmousedown = null;
    voDivCtrl.onmouseup = null;
    voDivCtrl.onclick = null;
    voDivCtrl.ondblclick = null;
    this.setAttrCtrl("cursor", "pointer", voDivCtrl);
  } else {
    voDivCtrl.onmousedown = function(e) {
      e = e ? e : voBase.window.event;
      voBase.labelMousedown(e, poNode.index);
    };
    voDivCtrl.onmouseup = function(e) {
      e = e ? e : voBase.window.event;
      voBase.labelMouseup(e, poNode.index);
    };
    if(poNode.isLeaf()) {
      voDivCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.labelClick(e, poNode.index);
      };
    } else {
      voDivCtrl.onclick = function(e) {
        e = e ? e : voBase.window.event;
        voBase.nodeClick(e, poNode.index);
      };
    }
    voDivCtrl.ondblclick = function(e) {
      e = e ? e : voBase.window.event;
      voBase.labelDblClick(e, poNode.index);
    };
    this.setAttrCtrl("cursor", "default", voDivCtrl);
  }

  var voTableCtrl =  this.getSubCtrl("table", voDivCtrl, poDocument);
  this.setAttrCtrl("backgroundColor", vsBackgroundColor, voTableCtrl);
  this.setAttrCtrl("color", vsFontColor, voTableCtrl);
};
/**
 * 해당 item 위치로 스크롤 이동.
 * @param {String|eXria.controls.xhtml.TreeNode} psValue 스크롤 타겟 노드 혹은 노드 값
 */
eXria.controls.xhtml.TreeView.prototype.scrollToItem = function(psValue) {
  var voItem = null;
  if(typeof(psValue) == "string") voItem = this.getNodeByVal(psValue);
  else voItem = psValue;
  if(voItem == null) return;
  var voCtrl = this.document.getElementById(this.id + "_node" + voItem.index);
  if(voCtrl == null) {
    voItem.expand = true;
    var voParent = voItem.parent;
    while(voParent) {
      voParent.expand = true;
      voParent = voParent.parent;
    }
    this.addChangedNode(this.root);
    this.repaint();
    voCtrl = this.document.getElementById(this.id + "_node" + voItem.index);
  }
  this.ctrl.scrollTop = parseInt(voCtrl.style.top);
};
/**
 * 주어진 depth 이전의 모든 노드를 펼쳐주는 메소드
 * @param {Number} pnDepth 노드 depth
 * @param {Boolean} pbCollapseChild 주어진 Depth 이하의 노드를 닫을 지 여부.
 * 값 미지정 혹은 false일 경우 주어진 Depth 이하의 노드들의 펼침 상태가 그대로 유지됨.
 */
eXria.controls.xhtml.TreeView.prototype.expandToDepth = function(pnDepth, pbCollapseChild) {
  if(pbCollapseChild == null) pbCollapseChild = false;
  var vnDepth = pnDepth + 1;
  var voMap = this.items;
  var voCollection = voMap.getValueCollection();
  var vnSize = voCollection.size();
  var voItem = null;
  for(var i = 0; i < vnSize; i++) {
    voItem = voCollection.get(i);
    if(voItem.depth < vnDepth) voItem.expand = true;
    else if(pbCollapseChild) voItem.expand = false;
  }
  this.addChangedNode(this.root);
  this.repaint();
};
/**
 * 특정 노드의 label 색상을 주어진 색상으로 변경하여 해당 노드에 강조효과를 주기위한 메소드.
 * 하나의 이미 그려진 노드만을 강조할 수 있음.
 * @param {eXria.controls.xhtml.TreeNode|String} poNode 대상 노드 혹은 노드 인덱스
 * @param {String} psColor 강조 색상
 */
eXria.controls.xhtml.TreeView.prototype.markNodeLabel = function(poNode, psColor, pbMark) {
  if(pbMark == null) pbMark = true;
  if(pbMark == false) {
    if(this.markedNode) {
      poNode = this.markedNode;
      psColor = this.markedPrevColor;
    } else {
      return;
    }
  }
  var voItem = null;
  if(typeof(poNode) == "string") voItem = this.getNodeByVal(poNode);
  else voItem = poNode;
  if(pbMark && voItem == this.markedNode) return;
  else if(pbMark && this.markedNode) this.markNodeLabel(null, null, false);
  this.markedNode = voItem;

  var vsId = voItem.index;
  vsId = this.id + "_node" + vsId;
  var voDocument = this.document;
  var voNodeCtrl = this.document.getElementById(vsId);
  var voDivCtrl = this.getSubCtrl("div", voNodeCtrl, voDocument);
  var voTableCtrl =  this.getSubCtrl("table", voDivCtrl, voDocument);
  if(this.trvType != "WBS") {
    this.markedPrevColor = voTableCtrl.style.color;
    this.setAttrCtrl("color", psColor, voTableCtrl);
  } else {
    var voInnTblCtrl = voTableCtrl.rows[0].cells[0].childNodes[0];
    this.markedPrevColor = voInnTblCtrl.style.color;
    this.setAttrCtrl("color", psColor, voInnTblCtrl);
    var vnSize = voInnTblCtrl.rows.length;
    for(var i = 0; i < vnSize; i++) {
      voInnTblCtrl.rows[i].cells[0].style.color = psColor;
    }
  }
  if(pbMark == false) {
   this.markedNode = null;
   this.markedColor = null;
  }
};
/**
 * 주어진 노드를 itemValueMap에 등록하는 메소드.
 * 반드시 해당 노드의 parentValue이 지정된 상태에서 호출되야됨.
 * @param {eXria.controls.xhtml.TreeNode} poNode 트리노드
 * @private
 */
eXria.controls.xhtml.TreeView.prototype.addToItemValueMap = function(poNode, psValue) {
  var voMap = this.itemValueMap;
//  if(vsParentValue == null || vsParentValue == "") vsParentValue = "root";
  if(psValue == null) psValue = poNode.getValue();
//  var vsBlockId = "gen";
//  if(this.mapBlockIdFunc) {
//    vsBlockId = this.mapBlockIdFunc(vsValue);
//  }
//  if(voMap[vsBlockId] == null) voMap[vsBlockId] = {};
//  voMap[vsBlockId][vsValue] = poNode;
  voMap[psValue] = poNode;
};
/**
 * 클래스 명을 반환.
 * @return "TreeView"
 * @type String
 */
eXria.controls.xhtml.TreeView.prototype.toString = function() {
  return "TreeView";
};


/**
 * @fileoverview
 * Concreate xhtml SlideTab_slideButtons, SlideButton, SlideTab_slidePages, SlidePage, SlideTab
 * @author 조영진
 */

/**
 * 슬라이드 탭 컨트롤의 슬라이드 버튼 공통 속성을 저장하기 위한 클래스.
 * @version 2.0
 * @type eXria.controls.xhtml.SlideTab_slideButtons
 * @constructor
 */
eXria.controls.xhtml.SlideTab_slideButtons = function() {
  /**
   * 버튼의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 버튼의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 버튼의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 버튼의 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 버튼의 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 버튼의 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 버튼의 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 버튼에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 버튼에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 버튼에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 버튼에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 버튼에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 버튼의 세로 길이.
   * @type String
   */
  this.height = null;
  /**
   * 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 선택된 버튼의 배경이미지 url.
   * @type String
   */
  this.imageFocused = null;
  /**
   * 버튼 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 버튼 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * 버튼의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 버튼이 선택되었을 때의 배경 색상.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * 버튼의 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * 버튼이 선택되었을 때의 텍스트 색상.
   * @type String
   */
  this.focusColor = null;
  /**
   * 버튼에 표시될 텍스트의 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 버튼에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 버튼에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 버튼에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 버튼에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 밑줄 적용 속성.
   * @type String
   */
  this.textDecoration = null;
  /**
   * 버튼에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 버튼에 외곽에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * 슬라이드 버튼의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.cursor = null;

  this.df = {};
};


/**
 * @class Concreate xhtml SlideButton
 * XHTML SlideTab 컨트롤에 포함되는 슬라이드 버튼 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.SlideButton 객체
 * @type eXria.controls.xhtml.SlideButton
 * @constructor
 * @base eXria.controls.xhtml.Button
 */
eXria.controls.xhtml.SlideButton = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poSlide) {

  eXria.controls.xhtml.Button.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * 슬라이드 탭 참조
   * @type eXria.controls.xhtml.SlideTab
   * @private
   */
  this.parent = poSlide;
  /**
   * 슬라아드 버튼의 subId 참조(슬라이드 탭 컨트롤 id가 제외된 값)
   * @type String
   * @private
   */
  this.subId = null;
  /**
   * 링크된 페이지 아이디(슬라이드 탭 컨트롤 id와 조합된 값) 참조
   * @type String
   * @private
   */
  this.pageId = null;
  /**
   * 링크된 페이지 아이디 참조(슬라이드 탭 컨트롤 id가 제외된 값)
   * @type String
   * @private
   */
  this.pageSubId = null;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Button, eXria.controls.xhtml.SlideButton);
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number
 * @private
 */
eXria.controls.xhtml.SlideButton.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.SlideTab.slideButtons) vsDefaultValue = eXria.controls.xhtml.Default.SlideTab.slideButtons[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.SlideButton.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SlideButton.prototype.atblur = null;
/**
 * @ignore
 */
eXria.controls.xhtml.SlideButton.prototype.atmouseover = null;
/**
 * @ignore
 */
eXria.controls.xhtml.SlideButton.prototype.atmouseout = null;

eXria.controls.xhtml.SlideButton.prototype.toString = function(){
  return "SlideButton";
}

/**
 * 슬라이드 탭 컨트롤의 슬라이드 페이지 공통 속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.SlideTab_slidePages = function() {
  /**
   * 슬라이드 페이지의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 슬라이드 페이지의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 슬라이드 페이지 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 슬라이드 페이지 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 슬라이드 페이지 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 슬라이드 페이지 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 슬라이드 페이지 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 슬라이드 페이지에 담긴 컨트롤이 영역을 벗어날때 스크롤 처리.
   * @type String
   */
  this.overflow = null;
  /**
   * 슬라이드 페이지에 담긴 컨트롤이 영역을 벗어날때 횡 스크롤 처리.
   * @type String
   */
  this.overflowX = null;
  /**
   * 슬라이드 페이지에 담긴 컨트롤이 영역을 벗어날때 종 스크롤 처리.
   * @type String
   */
  this.overflowY = null;
  /**
   * 슬라이드 바디의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 슬라이드 페이지의 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 슬라이드 페이지의 외곽 div에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * 슬라이드 페이지의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};


/**
 * 슬라이드 탭 페이지
 * @type eXria.controls.xhtml.SlidePage
 * @constructor
 * @base eXria.controls.xhtml.Group
 */
eXria.controls.xhtml.SlidePage = function(psId, pnLeft, pnTop, pnWidth, pnHeight, poSlide) {
  eXria.controls.xhtml.Group.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * 상위 SlideTab컨트롤 참조변수
   * @type eXria.controls.xhtml.SlideTab
   */
  this.parent = poSlide;
  /**
   * 상위 SlideTab컨트롤 참조변수
   * @type eXria.controls.xhtml.SlideTab
   */
  this.control = poSlide;
  /**
   * SlidePage의 sub Id참조
   * @type String
   */
  this.subId = null;
  /**
   * SlidePage가 렌더링 되었는지 여부
   * @type Boolean
   * @private
   */
  this.rendered = false;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Group, eXria.controls.xhtml.SlidePage);
/**
 * @ignore
 */
eXria.controls.xhtml.SlidePage.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number
 * @private
 */
eXria.controls.xhtml.SlidePage.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  if(eXria.controls.xhtml.Default.SlideTab.slidePages) vsDefaultValue = eXria.controls.xhtml.Default.SlideTab.slidePages[psAttrName];
  if(vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환.
 * @return "TabPage"
 * @type String
 */
eXria.controls.xhtml.SlidePage.prototype.toString = function() {
  return "SlidePage";
};


/**
 * @class Concreate xhtml SlideTab.<br>
 * XHTML SlideTab 컨트롤.
 * @author 조영진
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.SlideTab 객체
 * @type eXria.controls.xhtml.SlideTab
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.SlideTab = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 200 : pnWidth;
  pnHeight = pnHeight == null ? 350 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  // 데이타 연동 관련
  /**
   * Data 연동 객체(노드 셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 인스턴스로 부터 라벨 데이타를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.labelTagName = "label";
  /**
   * 인스턴스로 부터 button id를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.bidTagName = "buttonid";
  /**
   * 인스턴스로 부터 page id를 가져올 때 사용될 DOM Element 명
   * @type String
   */
  this.pidTagName = "pageid";
  /**
   * 슬라이드 버튼과 페이지 생성 시 이용되는 순차적인 번호
   * @type Number
   * @private
   */
  this.seqNum = 0;
  /**
   * 컨트롤이 디스플레이 되는 document 객체.
   * @type Object
   * @private
   */
  this.document = null;
  /**
   * 버튼 선택 시 버튼이 움직이는 방향 지정('top'|'bottom')
   * @type String
   */
  this.expandDirection = "bottom"; //'top'|'bottom'
  /**
   * 선택된 슬라이드 버튼의 인덱스.
   * @type Number
   */
  this.selectedIndex = null;
  /**
   * 선택된 슬라이드 페이지의 ID.
   * @type Number
   */
  this.selectedPageId = null;
  /**
   * 버튼들을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.buttonSet = new eXria.data.ArrayCollection();

  /**
   * 보여지는 버튼들만을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   * @ignore
   */
  this.buttonVisibleSet = new eXria.data.ArrayCollection();

  /**
   * 버튼에 종속된 컨텐츠 패널들을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   * @private
   */
  this.contentPaneSet = new eXria.data.ArrayCollection();
  /**
   * 버튼들의 공통속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.SlideTab_slideButtons
   */
  this.slideButtons = new eXria.controls.xhtml.SlideTab_slideButtons();
  /**
   * 컨텐츠 패널들의 공통속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.SlideTab_slidePages
   */
  this.slidePages = new eXria.controls.xhtml.SlideTab_slidePages();
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 초기에 모든 페이지를 렌더링할지 여부
   */
  this.renderAll = null;
  /**
   * data연동을 통해 생성된 탭 페이지 아이디 저장
   * @type eXria.data.ArrayMap
   * @private
   */
  this.pageIdsInData = new eXria.data.ArrayMap();
  /**
   * 모든 탭이 닫힐수 있는지 여부
   * @type Boolean
   * @private
   */
  this.closable = false;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */

  this.cursor = null;

  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.SlideTab);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.SlideTab.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;

  switch(vsType) {
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

eXria.controls.xhtml.SlideTab.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;

  this.document = poDocument;
  this.ctrl = voCtrl;

  return voCtrl;
};
eXria.controls.xhtml.SlideTab.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voBtnDf = this.slideButtons;
  var voPageDf = this.slidePages;

  this.setStyleCurrentBorderValue(this);

  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.selectedIndex = this.getAttrValue("selectedIndex", this.selectedIndex);
  if(this.selectedIndex == null){
    this.selectedIndex = -1;
  }

  this.renderAll = this.getAttrValue("renderAll", this.renderAll);
  voBtnDf.height = this.getAttrValue("slideButtons.height",this.slideButtons.height);
  voBtnDf.focusBackgroundColor = this.getAttrValue("slideButtons.focusBackgroundColor",this.slideButtons.focusBackgroundColor);
  voBtnDf.focusColor = this.getAttrValue("slideButtons.focusColor",this.slideButtons.focusColor);
  voBtnDf.imageFocused = this.getAttrValue("slideButtons.imageFocused",this.slideButtons.imageFocused);
};

eXria.controls.xhtml.SlideTab.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voBtnDf = this.slideButtons;
  var vaCssStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  vaCssStrBuf = null;

  var vnSize = this.buttonSet.size();
  var voIterator = this.buttonSet.iterator();
  while(voIterator.hasNext()) {
    voButton = voIterator.next();
    if(voButton.visible != false) this.buttonVisibleSet.add(voButton);
  }
  var voButton = null;
  var voContentPane = null;
  var voButtonCtrl = null;
  var voContentPaneCtrl = null;
  for(var i = 0; i < vnSize; i++) {
    voButton = this.buttonSet.get(i);
    voButton.canvas = this.canvas;
    voButton.window = this.window;
    voButton.document = this.document;
    voButton.top = voBtnDf.height * (i);
    voButton.width = this.innerWidth;
    voContentPane = this.contentPaneSet.get(i);
    voContentPane.canvas = this.canvas;
    voContentPane.window = this.window;
    voContentPane.document = this.document;
    if(this.expandDirection == "top") voContentPane.top = voBtnDf.height * (i);
    else voContentPane.top = voBtnDf.height * (i + 1);
    voContentPane.width = this.innerWidth;
    voContentPane.height = this.innerHeight - voBtnDf.height * vnSize;

    this.createItemCtrl(i, poCtrl, poDocument);
  }
};

eXria.controls.xhtml.SlideTab.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
  this.slideButtons.df = {};
  this.slidePages.df = {};

  var voPageIdsInData = this.pageIdsInData;
  var vnSize = voPageIdsInData.size();
  var voPageIds = voPageIdsInData.getKeyCollection();
  var vsPageId = null;
  var vnIndex = null;
  for(var i = 0; i < vnSize; i++) {
    vsPageId = voPageIds.get(i);
    if(vnIndex) {
      var voButton = this.buttonSet.remove(pnIndex);
      voButton.clear();
      var voContentPane = this.contentPaneSet.remove(pnIndex);
      voContentPane.clear();
    }
  }
  voPageIdsInData.clear();
};

eXria.controls.xhtml.SlideTab.prototype.refreshSubStyles = function(poCtrl, poDocument) {
  this.setSubCtrlStyles(poCtrl, poDocument);
};

eXria.controls.xhtml.SlideTab.prototype.refreshSpecificAttrs = function(poCtrl, poDocument, pbChildRefresh) {
  var voBtnDf = this.slideButtons;
  var voPageDf = this.slidePages;
  this.setAttrCtrl("top", this.top, poCtrl);
  this.setAttrCtrl("left", this.left, poCtrl);
  this.setAttrCtrl("width", this.innerWidth, poCtrl);
  this.setAttrCtrl("height", this.innerHeight, poCtrl);
  this.setAttrCtrl("borderColor", this.borderColor, poCtrl);
  this.setAttrCtrl("borderStyle", this.borderStyle, poCtrl);
  this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", poCtrl);
  this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", poCtrl);
  this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", poCtrl);
  this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", poCtrl);
  this.setAttrCtrl("cursor", this.cursor, poCtrl);
  this.setAttrCtrl("visible", this.visible, poCtrl);

  var vnSize = this.buttonSet.size();
  this.buttonVisibleSet.clear();
  var voIterator = this.buttonSet.iterator();
  while(voIterator.hasNext()) {
    voButton = voIterator.next();
    if(voButton.visible != false) this.buttonVisibleSet.add(voButton);
  }
  var vnVisibleSize = this.buttonVisibleSet.size();
  var voButton = null;
  var voContentPane = null;
  var voButtonCtrl = null;
  var voContentPaneCtrl = null;
  var vnVisible = 0;
  for(var i = 0; i < vnSize; i++) {
    voButton = this.buttonSet.get(i);
    voContentPane = this.contentPaneSet.get(i);
    if(voButton.visible != false) {
      voButton.top = voBtnDf.height * (vnVisible);
      voButton.width = this.innerWidth;
      voButton.height = voBtnDf.height;
      voButton.borderStyle = voBtnDf.borderStyle;
      voButton.borderColor = voBtnDf.borderColor;
      voButton.borderWidth = voBtnDf.borderWidth;
      voButton.borderLeftWidth = voBtnDf.borderLeftWidth;
      voButton.borderRightWidth = voBtnDf.borderRightWidth;
      voButton.borderTopWidth = voBtnDf.borderTopWidth;
      voButton.borderBottomWidth = voBtnDf.borderBottomWidth;
      voButton.padding = voBtnDf.padding;
      voButton.paddingLeft = voBtnDf.paddingLeft;
      voButton.paddingRight = voBtnDf.paddingRight;
      voButton.paddingTop = voBtnDf.paddingTop;
      voButton.paddingBottom = voBtnDf.paddingBottom;
      voButton.backgroundColor = voBtnDf.backgroundColor;
      voButton.backgroundImage = voBtnDf.backgroundImage;
      voButton.backgroundPosition = voBtnDf.backgroundPosition;
      voButton.backgroundRepeat = voBtnDf.backgroundRepeat;
      voButton.color = voBtnDf.color;
      voButton.fontFamily = voBtnDf.fontFamily;
      voButton.fontSize = voBtnDf.fontSize;
      voButton.fontStyle = voBtnDf.fontStyle;
      voButton.fontWeight = voBtnDf.fontWeight;
      voButton.textAlign = voBtnDf.textAlign;
      voButton.textDecoration = voBtnDf.textDecoration;
      voButton.cursor = voBtnDf.cursor;

      if(this.expandDirection == "top") voContentPane.top = voBtnDf.height * (vnVisible);
      else voContentPane.top = voBtnDf.height * (vnVisible + 1);
      voContentPane.width = this.innerWidth;
      voContentPane.height = this.innerHeight - voBtnDf.height * vnVisibleSize;
      voContentPane.borderStyle = voPageDf.borderStyle;
      voContentPane.borderColor = voPageDf.borderColor;
      voContentPane.borderWidth = voPageDf.borderWidth;
      voContentPane.borderLeftWidth = voPageDf.borderLeftWidth;
      voContentPane.borderRightWidth = voPageDf.borderRightWidth;
      voContentPane.borderTopWidth = voPageDf.borderTopWidth;
      voContentPane.borderBottomWidth = voPageDf.borderBottomWidth;
      voContentPane.overflow = voPageDf.overflow;
      voContentPane.overflowX = voPageDf.overflowX;
      voContentPane.overflowY = voPageDf.overflowY;
      voContentPane.cursor = this.cursor;
      voContentPane.backgroundColor = voPageDf.backgroundColor;

      voButtonCtrl = voButton.getCtrl(poDocument);
      if(voButtonCtrl) {
        voButton.refresh(poDocument);
        if(voContentPane.rendered) {
          voContentPane.refresh(poDocument, pbChildRefresh);
        }
      } else {
        this.createItemCtrl(i, poCtrl, poDocument);
      }
      vnVisible = vnVisible + 1;
    }
  }
  this.expandButton(this.selectedIndex);
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.SlideTab.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  switch(psAttrName) {
  case "width" :
    break;
  case "height" :
    break;
  case "borderWidth" :
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치할 Doucment에 대한 참조
 */
eXria.controls.xhtml.SlideTab.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl();
  var vaAttrName = null;
  var vsSubAttrName = null;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "backgroundColor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "slideButtons.backgroundColor" :
  case "slideButtons.color" :
  case "slideButtons.borderStyle" :
  case "slideButtons.borderColor" :
  case "slideButtons.borderWidth" :
  case "slideButtons.borderLeftWidth" :
  case "slideButtons.borderRightWidth" :
  case "slideButtons.borderTopWidth" :
  case "slideButtons.borderBottomWidth" :
  case "slideButtons.padding" :
  case "slideButtons.paddingLeft" :
  case "slideButtons.paddingRight" :
  case "slideButtons.paddingTop" :
  case "slideButtons.paddingBottom" :
  case "slideButtons.fontFamily" :
  case "slideButtons.fontSize" :
  case "slideButtons.fontStyle" :
  case "slideButtons.fontWeight" :
  case "slideButtons.textAlign" :
  case "slideButtons.textDecoration" :
    vaAttrName = psAttrName.split(".");
    vsSubAttrName = vaAttrName[vaAttrName.length - 1];
    var voButton = null;
    var voIterator = this.buttonSet.iterator();
    while(voIterator.hasNext()) {
      voButton = voIterator.next();
      voButton.applyAttrRebuild(vsSubAttrName, psAttrValue, poDocument);
    }
    break;
  case "slidePages.backgroundColor" :
  case "slidePages.borderStyle" :
  case "slidePages.borderColor" :
  case "slidePages.borderWidth" :
  case "slidePages.borderLeftWidth" :
  case "slidePages.borderRightWidth" :
  case "slidePages.borderTopWidth" :
  case "slidePages.borderBottomWidth" :
    vaAttrName = psAttrName.split(".");
    vsSubAttrName = vaAttrName[vaAttrName.length - 1];
    var voContentPane = null;
    var voIterator = this.contentPaneSet.iterator();
    while(voIterator.hasNext()) {
      voContentPane = voIterator.next();
      voContentPane.applyAttrRebuild(vsSubAttrName, psAttrValue, poDocument);
    }
    break;
  case "slidePages.overflow" :
  case "slidePages.overflowX" :
  case "slidePages.overflowY" :
    var voCssStyle = this.canvas.getCssStyle(this.className, this.document);
    if(this.overflow == null) this.overflow = "hidden";
    var vsOverflowX = this.makeSpecificAttrValue(voCtrl, voCssStyle, "slidePages.overflowX");
    var vsOverflowY = this.makeSpecificAttrValue(voCtrl, voCssStyle, "slidePages.overflowY");
    if(voObj.overflowX == null) this.overflowX = vsOverflowX ? vsOverflowX : this.overflow;
    if(voObj.overflowY == null) this.overflowY = vsOverflowY ? vsOverflowY : this.overflow;

    vaAttrName = psAttrName.split(".");
    vsSubAttrName = vaAttrName[vaAttrName.length - 1];
    var voContentPane = null;
    var voIterator = this.contentPaneSet.iterator();
    while(voIterator.hasNext()) {
      voContentPane = voIterator.next();
      voContentPane.overflowX = this.overflowX;
      voContentPane.overflowY = this.overflowY;
      var voStyle = voContentPane.ctrl.style;
      voStyle.overflowX = this.overflowX;
      voStyle.overflowY = this.overflowY;
//      voContentPane.applyAttrRebuild(vsSubAttrName, psAttrValue, poDocument);
    }
    break;
  default :
    this.refresh(poDocument);
    break;
  }

};

eXria.controls.xhtml.SlideTab.prototype.loadData = function(poDocument) {
  if(this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null) return;

  var voCollectionNode = this.data.getNodesetData2();
  if(voCollectionNode == null) return;
  var vnLoop = voCollectionNode.getLength();
  var voMapNode = null;
  var vsLabelNode = null;
  var vsValueNode = null;
  var vsParentNode = null;
  var vaIndex = new Array();
  var vnIndex = 0;
  var voItem = null;
  var vaNodes = [];
  var voTreeNode = null;
  var voButton = null;
  for(var i = 0; i < vnLoop; i++) {
    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
    vsLabelNode = voMapNode.get(this.labelTagName);
    vsBidNode = voMapNode.get(this.bidTagName);
    vsPidNode = voMapNode.get(this.pidTagName);

    voButton = this.addTab(vsLabelNode, vsBidNode, vsPidNode);
    voPageIdsInData.put(voButton.pageId, "");
  }
};
eXria.controls.xhtml.SlideTab.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);

  var voSelectedPage = this.getPage(this.selectedIndex);
  if(this.renderAll) {
    var voIterator = this.contentPaneSet.iterator();
    var voContentPane = null;
    while(voIterator.hasNext()) {
      voContentPane = voIterator.next();
      if(voContentPane != voSelectedPage) {
        voContentPane.setAttrCtrl("visibility", "hidden");
        voContentPane.applyAttr("visible", true);
      }
      if(voContentPane.rendered){
        voContentPane.refresh(poDocument);
      } else {
        voContentPane.createChildren();
        voContentPane.rendered = true;
      }
      if(voContentPane != voSelectedPage) {
        voContentPane.setAttrCtrl("visibility", "visible");
        voContentPane.applyAttr("visible", false);
      }
    }
  } else {
    if(voSelectedPage) {
      voSelectedPage.refresh(poDocument);
    }
  }

  // yhkim  2009.07.07 : detail view에서 default값 설정
  if(this.selectedPageId)
    this.selectById(this.selectedPageId)
  else {
    if(this.selectedIndex != -1) this.expandButton(this.selectedIndex);
    else if(this.selectedIndex == -1 && this.selectedPageId != null) this.selectById(this.selectedPageId);
  }
};
/**
 * loadComplete
 * @ignore
 */
eXria.controls.xhtml.SlideTab.prototype.loadComplete = function(poDocument) {
  if(this.renderAll) {
    var voIterator = this.contentPaneSet.iterator();
    var voContentPane = null;
    var vnIE = this.canvas.page.metadata.browser.id;
    while(voIterator.hasNext()) {
      voContentPane = voIterator.next();
      if(vnIE < 8.0) voContentPane.setAttrCtrl("visibility", "hidden");
      voContentPane.setAttrCtrl("visible", true);
      if(voContentPane.rendered){
        voContentPane.refresh();
      } else {
        voContentPane.createChildren();
        voContentPane.rendered = true;
      }
      if(vnIE < 8.0) voContentPane.setAttrCtrl("visibility", "visible");
      voContentPane.setAttrCtrl("visible", false);
    }
  }

  // yhkim  2009.07.07 : detail view에서 default값 설정
  if(this.selectedPageId)
    this.selectById(this.selectedPageId)
  else {
    if(this.selectedIndex != -1) this.expandButton(this.selectedIndex);
    else if(this.selectedIndex == -1 && this.selectedPageId != null) this.selectById(this.selectedPageId);
  }

};
/**
 * 내부의 포함된 컨트롤을 순환적으로 참조하기 위해 사용되는 메소드
 * @return 버튼에 종속된 컨텐츠 패널들을 저장하기 위한 eXria.data.ArrayCollection
 * @type eXria.data.ArrayCollection
 * @private
 */
eXria.controls.xhtml.SlideTab.prototype.getControls = function() {
  return this.contentPaneSet;
};
/**
 * 탭 버튼 및 그에 따른 탭 바디 추가 메소드.
 * @param {String} psButtonName 탭 버튼 라벨
 * @param {String} psButtonId 탭 버튼 아이디
 * @param {String} psPageId 탭 페이지 아이디
 * @return 추가된 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.SlideTab.prototype.addTab = function(psButtonName, psButtonId, psPageId) {
  var vsButtonId = null;
  var vsPageId = null;
  if(psButtonId == null) vsButtonId = this.id + "_button_" + this.seqNum;
  else vsButtonId = this.id + "_button_" + psButtonId;
  if(psPageId == null) vsPageId = this.id + "_page_" + this.seqNum;
  else vsPageId = this.id + "_page_" + psPageId;
  this.seqNum++;
  var voButton = new eXria.controls.xhtml.SlideButton(vsButtonId, 0, 0, this.width, this.slideButtons.height, this);
  voButton.subId = psButtonId;
  voButton.pageId = vsPageId;
  voButton.pageSubId = psPageId;
  voButton.value = psButtonName
  var voContentPane = new eXria.controls.xhtml.SlidePage(vsPageId, 0, 0, this.width, this.height, this);
  voContentPane.subId = psPageId;
  voContentPane.parent = this;
  this.buttonSet.add(voButton);
  this.contentPaneSet.add(voContentPane);

  var voCtrl = this.getCtrl();
  if(voCtrl) {
    voButton.canvas = this.canvas;
    voButton.window = this.window;
    voButton.document = this.document;
    voContentPane.canvas = this.canvas;
    voContentPane.window = this.window;
    voContentPane.document = this.document;
    var vnSize = this.buttonSet.size();
    this.createItemCtrl((vnSize - 1), voCtrl, this.document);
    for(var i = 0; i < vnSize - 1; i++) {
      voContentPane = this.contentPaneSet.get(i);
      voContentPane.applyAttrRebuild("height", (this.innerHeight - this.slideButtons.height * vnSize));
    }
  }

  return this.buttonSet.size() - 1;
};
/**
 * 슬라이드 버튼과 페이지의 실체화 객체 생성
 * @param {Number} pnIndex 슬라이드 버튼/탭의 인덱스
 * @param {HTMLDiv} poCtrl 슬라이드 탭 실체화 객체
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 생성될 document
 * @private
 */
eXria.controls.xhtml.SlideTab.prototype.createItemCtrl = function(pnIndex, poCtrl, poDocument) {
  var vnSize = this.buttonSet.size();
  var voButton = this.buttonSet.get(pnIndex);
  var voBtnDf = this.slideButtons;
  var voPageDf = this.slidePages;
  voButton.top = voBtnDf.height * (pnIndex)
  voButton.width = this.innerWidth;
  voButton.height = voBtnDf.height;
  voButton.atclick = this.click;
  voButton.borderStyle = voBtnDf.borderStyle;
  voButton.borderColor = voBtnDf.borderColor;
  voButton.borderWidth = voBtnDf.borderWidth;
  voButton.borderLeftWidth = voBtnDf.borderLeftWidth;
  voButton.borderRightWidth = voBtnDf.borderRightWidth;
  voButton.borderTopWidth = voBtnDf.borderTopWidth;
  voButton.borderBottomWidth = voBtnDf.borderBottomWidth;
  voButton.padding = voBtnDf.padding;
  //voButton.paddingLeft = voBtnDf.paddingLeft;
  //voButton.paddingRight = voBtnDf.paddingRight;
  //voButton.paddingTop = voBtnDf.paddingTop;
  //voButton.paddingBottom = voBtnDf.paddingBottom;
  voButton.paddingLeft = this.paddingLeft;
  voButton.paddingRight = this.paddingRight;
  voButton.paddingTop = this.paddingTop;
  voButton.paddingBottom = this.paddingBottom;
  voButton.backgroundColor = voBtnDf.backgroundColor;
  voButton.backgroundImage = voBtnDf.backgroundImage;
  voButton.backgroundPosition = voBtnDf.backgroundPosition;
  voButton.backgroundRepeat = voBtnDf.backgroundRepeat;
  voButton.imageFocused = voBtnDf.imageFocused;
  voButton.color = voBtnDf.color;
  voButton.fontFamily = voBtnDf.fontFamily;
  voButton.fontSize = voBtnDf.fontSize;
  voButton.fontStyle = voBtnDf.fontStyle;
  voButton.fontWeight = voBtnDf.fontWeight;
  voButton.textAlign = voBtnDf.textAlign;
  voButton.textDecoration = voBtnDf.textDecoration;
  // slidebuttons의 속성을 버튼속성으로
  voButton.cursor = voBtnDf.cursor;
  voButton.control = this;

  // TODO: yhkim 2009.09.15 버튼 클래스를 사실상 아래와 같이 전달해줘야 한다.
  if(this.slideButtons) {
    voButton.className = this.slideButtons.className;
    voButton.outerClassName = this.slideButtons.outerClassName;
  }

  var voContentPane = this.contentPaneSet.get(pnIndex);
  voContentPane.borderStyle = voPageDf.borderStyle;
  voContentPane.borderColor = voPageDf.borderColor;
  voContentPane.borderWidth = voPageDf.borderWidth;
  voContentPane.borderLeftWidth = voPageDf.borderLeftWidth;
  voContentPane.borderRightWidth = voPageDf.borderRightWidth;
  voContentPane.borderTopWidth = voPageDf.borderTopWidth;
  voContentPane.borderBottomWidth = voPageDf.borderBottomWidth;
  voContentPane.cursor = this.cursor;
  voContentPane.overflow = voPageDf.overflow;
  voContentPane.overflowX = voPageDf.overflowX;
  voContentPane.overflowY = voPageDf.overflowY;
  voContentPane.backgroundColor = voPageDf.backgroundColor;
  if(this.expandDirection == "top") voContentPane.top = voBtnDf.height * (pnIndex);
  else voContentPane.top = voBtnDf.height * (pnIndex + 1);
  voContentPane.width = this.innerWidth;
  voContentPane.height = this.innerHeight - voBtnDf.height * vnSize;
  poCtrl.appendChild(voButton.create(poDocument));
  voButton.load(poDocument)
  poCtrl.appendChild(voContentPane.create(poDocument));
};
/**
 * 해당 인덱스의 탭을 제거
 * @param {Number} pnIndex 제거할 탭의 인덱스
 */
eXria.controls.xhtml.SlideTab.prototype.removeTab = function(pnIndex) {
  var voButton = this.buttonSet.remove(pnIndex);
  voButton.clear();
  var voContentPane = this.contentPaneSet.remove(pnIndex);
  voContentPane.clear();
  var voCtrl = this.getCtrl();
  if(voCtrl) {
    this.refresh(this.document);
  }
};
/**
 * 지정된 버튼의 인덱스 값을 반환
 * @param {eXria.controls.xhtml.SlideButton} poButton 탭 버튼
 * @return 탭 버튼 인덱스
 * @type Number
 */
eXria.controls.xhtml.SlideTab.prototype.getItemIndex = function(poButton) {
  var voIterator = this.buttonSet.iterator();
  var voButton = null;
  while(voIterator.hasNext()) {
    voButton = voIterator.next();
    if(voButton == poButton) return voIterator.cursor;
  }
  return -1;
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 인덱스 번호 반환.
 * @param {String} psLabel 탭 버튼 라벨
 * @return 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.SlideTab.prototype.getIndex = function(psLabel) {
  var voIterator = this.buttonSet.iterator();
  var voTabButton = null;
  var i = 0;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.value.indexOf(psLabel) == 0) { return i; }
    i++;
  }
  return -1;
};
/**
 * 지정된 pageId에 해당하는 탭 인덱스 반환.
 * @param {String} psPageId 탭 페이지 아이디
 * @return 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.SlideTab.prototype.getIndexById = function(psPageId) {
  var vnIndex = -1;
  var vsPageId = this.id + "_page_" + psPageId;
  var voIterator = this.contentPaneSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == vsPageId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};
/**
 * 지정된 pageId에 해당하는 탭 인덱스 반환.
 * @param {String} psPageSubId 페이지 아이디.
 * @return 탭 인덱스
 * @type Number
 */
eXria.controls.xhtml.SlideTab.prototype.getIndexBySubId = function(psPageSubId) {
  var vnIndex = -1;
  var voIterator = this.contentPaneSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.subId == psPageSubId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};
/**
 * 모든 탭 제거.
 */
eXria.controls.xhtml.SlideTab.prototype.removeAll = function() {
  var vnSize = this.buttonSet.size();
  for(var i = 0; i < vnSize; i++) {
    this.removeTab(0);
  };
};
/**
 * 지정된 라벨에 해당하는 탭 제거.
 * @param {String} psLabel 탭 버튼 레이블명.
 */
eXria.controls.xhtml.SlideTab.prototype.removeTabByLabel = function(psLabel) {
  var vnIndex = this.getIndex(psLabel);
  this.removeTab(vnIndex);
};
/**
 * 지정된 페이지 아이디에 해당하는 탭 버튼 제거.
 * @param {String} psPageSubId 텝 페이지 아이디.
 */
eXria.controls.xhtml.SlideTab.prototype.removeTabById = function(psPageSubId) {
  var vnIndex = this.getIndexBySubId(psPageSubId);
  this.removeTab(vnIndex);
};
/**
 * 지정된 인덱스에 해당하는 탭 버튼 반환.
 * @param {Number} pnIndex 탭 인덱스
 * @return 지정된 인덱스에 해당하는 탭 버튼
 * @type eXria.controls.xhtml.SlideButton
 */
eXria.controls.xhtml.SlideTab.prototype.getButton = function(pnIndex) {
  var voTabButton = this.buttonSet.get(pnIndex);
  return voTabButton;
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 반환.
 * @param {String} psLabel 탭 버튼 레이블명
 * @return 지정된 라벨에 해당하는 탭 버튼 객체
 * @type eXria.controls.xhtml.SlideButton
 */
eXria.controls.xhtml.SlideTab.prototype.getButtonByLabel = function(psLabel) {
  var voIterator = this.buttonSet.iterator();
  var voTabButton = null;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.value == psLabel) { return voTabButton; }
  }
  return null;
};
/**
 * 지정된 라벨에 해당하는 탭 버튼 반환.
 * @param {String} psButtonSubId 탭 버튼 아이디
 * @return 지정된 아이디에 해당하는 탭 버튼 객체
 * @type eXria.controls.xhtml.SlideButton
 */
eXria.controls.xhtml.SlideTab.prototype.getButtonById = function(psButtonSubId) {
  var voIterator = this.buttonSet.iterator();
  var voTabButton = null;
  while(voIterator.hasNext()) {
    voTabButton = voIterator.next();
    if (voTabButton.subId == psButtonSubId) { return voTabButton; }
  }
  return null;
};
/**
 * 지정된 인덱스에 해당하는 탭 페이지 반환.
 * @param {Number} pnIndex 탭 인덱스
 * @return 지정된 인덱스에 해당하는 탭 페이지
 * @type eXria.controls.xhtml.SlidePage
 */
eXria.controls.xhtml.SlideTab.prototype.getPage = function(pnIndex) {
  var voContentPane = null;
  try {
    voContentPane = this.contentPaneSet.get(pnIndex);
  } catch(err) {}
  return voContentPane;
};
/**
 * 지정된 페이지 ID에 해당하는 탭 페이지 반환.
 * @param {String} psPageId 탭 인덱스
 * @return 지정된 페이지 ID에 해당하는 탭 페이지
 * @type eXria.controls.xhtml.SlidePage
 */
eXria.controls.xhtml.SlideTab.prototype.getPageById = function(psPageId) {
  var vnIndex = -1;
  var vsId = this.id + "_page_" + psPageId;
  var voIterator = this.contentPaneSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == vsId) {
      vnIndex = cnt;
      break;
    }
  }

  var voContentPane = null;
  voContentPane = this.contentPaneSet.get(vnIndex);
  return voContentPane;
};
/**
 * 슬라이드 버튼의 atclick 이벤트 핸들러
 * @private
 */
eXria.controls.xhtml.SlideTab.prototype.click = function(poEvent) {
  var voButton = poEvent.object;
  var voButtonSelected = null;
  var voControl = this.control;
  if(voControl.selectedIndex != -1 && voControl.selectedIndex < voControl.buttonSet.size()) voButtonSelected = voControl.buttonSet.get(voControl.selectedIndex);

  if(voButton == voButtonSelected){
    if(voControl.closable && voControl.selectedPageId) {
      voControl.collapseButton(voControl.selectedIndex);
      voControl.selectedPageId = null;
      return;
    } else if(voControl.closable && voControl.selectedPageId == null) {
      var vnIndex = voControl.getItemIndex(voButton);
      var vsPageId = voControl.contentPaneSet.get(vnIndex).id;
      voControl.selectedPageId = vsPageId.slice(voControl.id.length + 6);
      voControl.expandButton(vnIndex);
      return;
    } else {
      return;
    }
  }

  var vnIndex = voControl.getItemIndex(voButton);
  voControl.expandButton(vnIndex);
  voControl.selectedIndex = vnIndex;
  this.selectedIndex = vnIndex;
  var vsPageId = voControl.contentPaneSet.get(vnIndex).id;
  voControl.selectedPageId = vsPageId.slice(voControl.id.length + 6);
};
/**
 * 지정된 인덱스에 해당하는 탭 페이지 펼침
 * @param {Number} pnIndex 탭 버튼/페이지 인덱스
 * @private
 */
eXria.controls.xhtml.SlideTab.prototype.expandButton = function(pnIndex) {
  var voButton = null;
  var voButtonCtrl = null;
  var voContentPane = null;
  var vnTop = null;
  var vnSize = this.buttonSet.size();
  var vnVisibleSize = this.buttonVisibleSet.size();
  var vnVisibleIndex = 0;
  var voBtnDf = this.slideButtons;

  if(pnIndex < 0 || pnIndex > vnSize - 1) return;
  for(var i = 0; i < vnSize; i++) {
    voButton = this.buttonSet.get(i);
    voButtonCtrl = voButton.getCtrl(this.document).childNodes[0];
    voContentPane = this.contentPaneSet.get(i);
    if(this.expandDirection == "top") {
      if(i >= pnIndex) {
        vnTop = this.innerHeight - voBtnDf.height * (vnVisibleSize);
      } else {
        vnTop = voBtnDf.height * (vnVisibleIndex);
      }
    } else {
      if(i > pnIndex) {
        vnTop = this.innerHeight - voBtnDf.height * (vnVisibleSize);
      } else {
        vnTop = voBtnDf.height * (vnVisibleIndex);
      }
    }
    voButton.applyAttrRebuild("top", vnTop);
    if(voButton.visible == false) {
      voContentPane.applyAttr("visible", false);
      voButton.applyAttr("visible", false);
    } else {
      vnVisibleSize = vnVisibleSize - 1;
      vnVisibleIndex = vnVisibleIndex + 1;
      if(i == pnIndex) {
        voButton.imageFocused = voBtnDf.imageFocused;
        voButton.oldImage = voBtnDf.imageFocused;
        voButton.setAttrCtrl("backgroundColor", voBtnDf.focusBackgroundColor, voButtonCtrl);
        voButton.setAttrCtrl("color", voBtnDf.focusColor, voButtonCtrl);
        voButton.setAttrCtrl("backgroundImage", voBtnDf.imageFocused, voButtonCtrl);
        if(voButton.visible != null) {
          voContentPane.applyAttr("visible", voButton.visible);
        } else {
          voContentPane.setAttrCtrl("visible", true);
          var vsPageId = this.voContentPane.id;
          this.selectedPageId = vsPageId.slice(this.id.length + 6);
        }
        if(voContentPane.rendered == false) {
          voContentPane.createChildren(this.document);
          voContentPane.rendered = true;
        }
      } else {
        if(i == this.selectedIndex) {
          if(voBtnDf.backgroundColor) voButton.setAttrCtrl("backgroundColor", voBtnDf.backgroundColor, voButtonCtrl);
          else voButton.setAttrCtrl("backgroundColor", "", voButtonCtrl);
          //voButton.setAttrCtrl("color", voBtnDf.color, voButtonCtrl);
          // 이렇게 하게 되면 css 클래스를 따르게 된다
          voButton.setAttrCtrl("color", "", voButtonCtrl);
          if(voBtnDf.backgroundImage == null) voBtnDf.backgroundImage = "";
          voButton.setAttrCtrl("backgroundImage", voBtnDf.backgroundImage, voButtonCtrl);
        }
        voContentPane.setAttrCtrl("visible", false);
      }
    }
  }
};
/**
 * 지정된 인덱스에 해당하는 탭 선택
 * @param {String} pnIndex 지정된 탭의 인덱스
 */
eXria.controls.xhtml.SlideTab.prototype.selectTab = function(pnIndex) {
  this.expandButton(pnIndex);
  this.selectedIndex = pnIndex;
  var vsPageId = this.contentPaneSet.get(pnIndex).id;
  this.selectedPageId = vsPageId.slice(this.id.length + 6);
}
/**
 * 지정된 페이지 아이디에 해당하는 탭 페이지 선택
 * @param {String} psPageId 지정된 페이지의 아이디
 */
eXria.controls.xhtml.SlideTab.prototype.selectById = function(psPageId) {
  var vnIndex = -1;
  var vsId = this.id + "_page_" + psPageId;
  var voIterator = this.contentPaneSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == vsId) {
      vnIndex = cnt;
      break;
    }
  }

  this.selectedIndex = vnIndex;
  var voCtrl = this.getCtrl(this.document);
  if(voCtrl) this.expandButton(vnIndex);
};
/**
 * 지정된 인덱스에 해당하는 탭 페이지 닫음
 * @param {Number} pnIndex
 */
eXria.controls.xhtml.SlideTab.prototype.collapseButton = function(pnIndex) {
  var voButton = null;
  var voButtonCtrl = null;
  var voContentPane = null;
  var vnTop = null;
  var vnSize = this.buttonSet.size();
  var voBtnDf = this.slideButtons;
  for(var i = 0; i < vnSize; i++) {
    voButton = this.buttonSet.get(i);
    voButtonCtrl = voButton.getCtrl(this.document).childNodes[0];
    if(this.expandDirection == "top")  {
      if(i >= pnIndex) {
        vnTop = voBtnDf.height * (i);
        voButton.applyAttrRebuild("top", vnTop);
      }
    } else {
      if(i > pnIndex) {
        vnTop = voBtnDf.height * (i);
        voButton.applyAttrRebuild("top", vnTop);
      }
    }
    voContentPane = this.contentPaneSet.get(i);
    if(i == pnIndex) {
      voButton.imageFocused = voBtnDf.backgroundImage;
      voButton.oldImage = voBtnDf.backgroundImage;
      voButton.setAttrCtrl("backgroundColor", voBtnDf.backgroundColor, voButtonCtrl);
      voButton.setAttrCtrl("color", voBtnDf.color, voButtonCtrl);
      voButton.setAttrCtrl("backgroundImage", voBtnDf.backgroundImage, voButtonCtrl);
      voContentPane.setAttrCtrl("visible", false);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.SlideTab.prototype.clear = function() {
  var voButton = null;
  var voContentPane = null;
  var voIterator = this.buttonSet.iterator();
  while(voIterator.hasNext()) {
    voButton = voIterator.next();
    voButton.clear();
  }
  voIterator = this.contentPaneSet.iterator();
  while(voIterator.hasNext()) {
    voContentPane = voIterator.next();
    voContentPane.clear();
  }
  this.clearCtrl();
  this.clearControl();
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number
 * @ignore
 */
eXria.controls.xhtml.SlideTab.prototype.getSpecificDefaultValue = function(psAttrName){
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.SlideTab[psAttrName];
  } else if (vaAttrName.length == 2) {
    if(eXria.controls.xhtml.Default.SlideTab[vaAttrName[0]]) vsDefaultValue = eXria.controls.xhtml.Default.SlideTab[vaAttrName[0]][vaAttrName[1]] == null ? vsDefaultValue : eXria.controls.xhtml.Default.SlideTab[vaAttrName[0]][vaAttrName[1]];
  }
  if(vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};

/**
 * 지정된 탭을 보이거나 숨기기
 * @param  {Number} pnIndex 탭의 인덱스
 * @param  {Boolean} pbShow 탭을 보이거나 숨길지의 여부
 */
eXria.controls.xhtml.SlideTab.prototype.showTab = function(pnIndex, pbShow){
  if(pbShow){
    this.getButton(pnIndex).visible = true;
    this.getPage(pnIndex).visible = true;
    this.refresh();
    this.selectTab(pnIndex);
  } else {
    var voVisibleButton = null;
    var voButton = this.getButton(pnIndex);
    var vnSize = this.buttonVisibleSet.size();

    for(var i = 0; i < vnSize; i++) {
      voVisibleButton = this.buttonVisibleSet.get(i);
      if(voVisibleButton == voButton) {
        if(i == (vnSize-1)) voVisibleButton = this.buttonVisibleSet.get(0);
        else voVisibleButton = this.buttonVisibleSet.get(i+1);
        break;
      }
    }

    voButton.visible = false;
    this.getPage(pnIndex).visible = false;
    this.refresh();
    var vnIndex = this.getItemIndex(voVisibleButton);
    this.selectTab(vnIndex);
  }
}

/**
 * 클래스 명을 반환.
 * @return "SlideTab"
 * @type String
 */
eXria.controls.xhtml.SlideTab.prototype.toString = function() {
  return "SlideTab";
};

/**
 * @fileoverview
 * Concreate xhtml FileSelector(XHTML FileSelector 컨트롤)
 * @author 고정원
 */

/**
 * @class 원하는 파일을 업로드 할 수있는 컨트롤을 생성하는 class입니다.<br />
 * XHTML FileSelector Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.FileSelector 객체
 * @type eXria.controls.xhtml.FileSelector
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.FileSelector = function(psId, pnLeft, pnTop, pnWidth, pnHeight){

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 150 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 컨트롤에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 컨트롤의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 컨트롤의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 컨트롤의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 컨트롤의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * css를 통해 지정된 컨트롤의 배경 색상.
   * @type String
   */
  this.cssBackgroundColor = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = null;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * css를 통해 지정된 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.cssFontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 박스를 둘러싼 보더의 두께.
   * @type Number
   * @private
   */
  this.subBorderWidth = 1;
  /**
   * 컨트롤의 안쪽 여백(단위 px).
   * @type Number
   * @private
   */
  this.padding = null;
  /**
   * 컨트롤의 안쪽 상단여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 안쪽 우측여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 안쪽 하단여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 안쪽 좌측여백(단위 px).
   * @type Number
   * @private
   */
  this.paddingLeft = null;
  /**
   * 텍스트 박스의 좌우 여백(단위 px).
   * @private
   * @type Number
   */
  this.hPadding = 2;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  /**
   * 파일첨부 버튼의 속성을 저장하기 위한 오브젝트.
   */
  this.browseBtn = new eXria.controls.xhtml.FileSelector_browseBtn(this);
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.FileSelector);

//////////////////////////////////////////////////////////////////
//// 메소드

eXria.controls.xhtml.FileSelector.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.ctrl = voCtrl;
  return voCtrl;
};

eXria.controls.xhtml.FileSelector.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vfcGetEHandler = this.getEHandler;              // 추가
  var vaStrBuf = null;
  var vsClass = this.getCSSClass(this, 1);
  var vsBtnClass = this.getCSSClass(this, 1, "BrowseButton");

  vaTemplate.push("<input class='" + vsClass + "' type='text' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_text' readOnly='true' ");
  vaTemplate.push("style='");
  vaTemplate.push("border-style:none;border-width:0px;margin:0px;padding:0px;");
  vaTemplate.push("@cssStrBuf");  //5
  vaTemplate.push("'/>");

  vaTemplate.push("<div class='" + vsBtnClass + "' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' ");
  vaTemplate.push("style=\"position:absolute;overflow:hidden;margin:0px;padding:0px;");
  vaTemplate.push("top:0px;right:0px;text-align:center;vertical-align:middle;cursor:pointer;");
  vaTemplate.push("@cssStrBuf");  //12
  vaTemplate.push("\">");

  vaTemplate.push("<label for='" + this.id + "_file' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_label' ");
  vaTemplate.push("style='position:absolute;width:100%;margin:0px;padding:0px;cursor:pointer;left:0px;z-index:1;'>");
  vaTemplate.push("@innStrBuf"); //18
  vaTemplate.push("</label>");

  vaTemplate.push("<input type='file' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_file' name='");
  vaTemplate.push(this.id);
  vaTemplate.push("_file' ");
  vaTemplate.push("style='position:absolute;top:0px;right:0px;margin:0px;padding:0px;cursor:pointer;width:0px;height:0px;");

  vaStrBuf = [];
  if(this.canvas.page.metadata.browser.ie > 0) {
    vaStrBuf.push("filter:alpha(opacity:0);");
  } else {
    vaStrBuf.push("opacity:0.0;");
  }
  vaStrBuf.push("cursor:pointer;");
  vaTemplate.push(vaStrBuf.join(""));

  vaTemplate.push("@cssStrBuf");  //27
  vaTemplate.push("' /></div>");

  vaStrBuf = null;
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.getFileFontSize = function(pnBtnWidth) {
  return Math.round(pnBtnWidth/4);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.refreshSubStyle = function(poCtrl, poDocument) {
  this.setSubCtrlStyles(poCtrl);
};

eXria.controls.xhtml.FileSelector.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  var voBtnDf = this.browseBtn;
  voBtnDf.width = this.getAttrValue("browseBtn.width",this.browseBtn.width);
  var vsValue = voBtnDf.value;
  var voData = voBtnDf.data;
  if(voData.instanceId && voData.instancePath) vsValue = voData.getData();
  voBtnDf.value = this.getAttrValue("browseBtn.value", vsValue);
};

eXria.controls.xhtml.FileSelector.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voBtnDf = this.browseBtn;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;overflow:hidden;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  // voText
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSiz, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, "px");
  vaTemplate[5] = vaCssStrBuf.join("");

  // voBtn
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "color", voBtnDf.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voBtnDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", voBtnDf.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", voBtnDf.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", voBtnDf.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", voBtnDf.borderWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", voBtnDf.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", voBtnDf.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", voBtnDf.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", voBtnDf.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", voBtnDf.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", voBtnDf.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "border-width", voBtnDf.borderWidth, "px");
  var vnWidth = voBtnDf.width;
  if(voBtnDf.borderWidth) vnWidth = vnWidth - 2 * voBtnDf.borderWidth;
  var vnHeight = this.innerHeight;
  if(voBtnDf.borderWidth) vnHeight = vnHeight - 2 * voBtnDf.borderWidth;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");

  vaTemplate[12] = vaCssStrBuf.join("");

  vaTemplate[18] = this.getLabelText(voBtnDf.value);

  // voFile
//  var vnFontSize = this.getFileFontSize(voBtnDf.width);
  vaCssStrBuf = [];
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight - 2 * voBtnDf.borderWidth, "px");
  vaTemplate[27] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;

  voSubElement.text = this.getSubCtrl("input", voCtrl, null, 0);
  voSubElement.btn = voCtrl.childNodes[1];
  voSubElement.file = this.getSubCtrl("input", voCtrl, null, 1);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voBtn = this.subElement.btn;
  var voTxt = this.subElement.text;
  var voLabel = this.getSubCtrl("label");
  this.setbrowseBtnSize();
  this.setVerticalAlign(voLabel, voBtn, "middle");
  this.setVerticalAlign(voTxt, voCtrl, "middle");
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.setbrowseBtnSize = function(){
  var voSubElements = this.subElement;
  var vnBtnWidth = this.getStyleCurrentValue(voSubElements.btn, "width", "width");
  //var vnBtnWidth = this.getAttrValue("browseBtn.width",this.browseBtn.width);
  var vnBtnBorderLeftWidth = this.getStyleCurrentValue(voSubElements.btn, "border-left-width", "borderLeftWidth");
  var vnBtnBorderRightWidth = this.getStyleCurrentValue(voSubElements.btn, "border-right-width", "borderRightWidth");
  var vnBtnBorderTopWidth = this.getStyleCurrentValue(voSubElements.btn, "border-top-width", "borderTopWidth");
  var vnBtnBorderBottomWidth = this.getStyleCurrentValue(voSubElements.btn, "border-bottom-width", "borderBottomWidth");
  var voBtnStyle = voSubElements.btn.style;
//  voBtnStyle.width = parseInt(vnBtnWidth, 10) - parseInt(vnBtnBorderLeftWidth, 10) - parseInt(vnBtnBorderRightWidth, 10) + "px";
  voBtnStyle.height = this.innerHeight - parseInt(vnBtnBorderTopWidth, 10) - parseInt(vnBtnBorderBottomWidth, 10) + "px";

  var vnWidthTemp = this.innerWidth - parseInt(vnBtnWidth, 10) - (2 * this.subBorderWidth) - 5;

  var vsWidth = this.innerWidth - parseInt(vnBtnWidth, 10) - (2 * this.subBorderWidth) - 5 + "px";

  if(vnWidthTemp <= 0)
    vsWidth = this.innerWidth + "px";

  voSubElements.text.style.width = parseInt(vsWidth, 10) - (2 * this.subBorderWidth) + "px";

  var voFileStyle = voSubElements.file.style;
  var vnFontSize = this.getFileFontSize(parseInt(vnBtnWidth, 10));
  voFileStyle.fontSize = vnFontSize + "px";
};

eXria.controls.xhtml.FileSelector.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadComplete(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.setSpecificEvents = function(poCtrl) {
  var voText = this.subElement.text;
  var voFile = this.subElement.file

  this.eventManager.addListener(voFile, "onchange", this.mediateEvent);

  voFile.control = this;
  voText.control = this;
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.atchange = function(e) {
  var voCtrl = this.ctrl;
  var voText = this.subElement.text;
  var voFile = this.getSubCtrl("input", voCtrl, null, 1);

//  var vsFileValue = voFile.value.substring(voFile.value.lastIndexOf("\\")+1);
  var vsFileValue = voFile.value;
  voText.value = vsFileValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.click = function(e) {
  var voLabel = this.getSubCtrl("label");
  voLabel.click();
};

eXria.controls.xhtml.FileSelector.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
//  this.browseBtn.df = {};

  var voFile = this.getSubCtrl("input", poCtrl, null, 1);
  this.eventManager.removeListener(voFile, "onchange", this.mediateEvent);
};

eXria.controls.xhtml.FileSelector.prototype.refreshSpecificAttrs = function(poCtrl, poDocument){
  this.setSpecificAttrs(poCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.FileSelector.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voText = this.subElement.text;
  var voBtn = this.subElement.btn;
  var voFile = this.getSubCtrl("input", voCtrl, null, 1);
  var voDf = this.df;
  var vaAttrName = psAttrName.split(".");
  var voBtnDf = this.browseBtn;

  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;

  switch(psAttrName) {
    case "visible" :
      this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
      break;
    case "disabled" :
      this.setDisable(voCtrl, psAttrValue);
      break;
    case "backgroundColor" :
    case "color" :
      this.setAttrCtrl(psAttrName, psAttrValue, voText);
      break;
    case "fontFamily" :
    case "fontSize" :
    case "fontStyle" :
    case "fontWeight" :
      this.setAttrCtrl(psAttrName, psAttrValue, voText);
      break;
    case "borderColor" :
    case "borderStyle" :
    case "outerClassName":
    case "className":
      this.refresh(poDocument);
      break;
    case "width" :
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setAttrCtrl("width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, voText);
      var voLabel = this.getSubCtrl("label");
      this.setVerticalAlign(voLabel, voBtn, this.verticalAlign);
      break;
    case "height" :
      this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setAttrCtrl("height", this.innerHeight-(parseInt(voBtn.style.borderBottomWidth) + parseInt(voBtn.style.borderTopWidth)), voBtn);
      //this.setVerticalAlign(voCtrl);
      var voLabel = this.getSubCtrl("label");
      this.setVerticalAlign(voLabel, voBtn, this.verticalAlign);
      break;
    case "borderWidth" :
      this.borderLeftWidth = this.borderWidth;
      this.borderRightWidth = this.borderWidth;
      this.borderTopWidth = this.borderWidth;
      this.borderBottomWidth = this.borderWidth;
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
      this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
      this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
      this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setAttrCtrl("width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, voText);
      //this.setAttrCtrl("width", this.innerWidth-(parseInt(voText.style.borderBottomWidth) + parseInt(voText.style.borderTopWidth) + this.paddingLeft + this.paddingRight+5), voText);
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setAttrCtrl("height", this.innerHeight-(parseInt(voBtn.style.borderBottomWidth) + parseInt(voBtn.style.borderTopWidth)), voBtn);
      
      var voLabel = this.getSubCtrl("label");
      this.setVerticalAlign(voLabel, voBtn, this.verticalAlign);

      break;
   case "borderLeftWidth" :
   case "borderRightWidth" :
      this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
      if(this.innerWidth < 0) this.innerWidth = 0;
      this.setAttrCtrl("width", this.innerWidth, voCtrl);
      this.setAttrCtrl("width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, voText);
      this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
      break;
   case "borderTopWidth" :
   case "borderBottomWidth" :
      this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
      if(this.innerHeight < 0) this.innerHeight = 0;
      this.setAttrCtrl("height", this.innerHeight, voCtrl);
      this.setAttrCtrl("height", this.innerHeight-(parseInt(voBtn.style.borderBottomWidth) + parseInt(voBtn.style.borderTopWidth)), voBtn);
      this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);

      this.setVerticalAlign(voText, voCtrl, this.verticalAlign);
      var voLabel = this.getSubCtrl("label");
      this.setVerticalAlign(voLabel, voBtn, this.verticalAlign);
      break;
   case "padding" :
      this.paddingTop = this.padding;
      this.paddingRight = this.padding;
      this.paddingBottom = this.padding;
      this.paddingLeft = this.padding;
      this.setAttrCtrl("paddingTop", this.paddingTop + "px", voText);
      this.setAttrCtrl("paddingRight", this.paddingRight + "px", voText);
      this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voText);
      this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voText);
      this.setAttrCtrl("width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, voText);
      break;
    case "paddingTop" :
    case "paddingRight" :
    case "paddingBottom" :
    case "paddingLeft" :
      this.setAttrCtrl(psAttrName, psAttrValue + "px", voText);
      this.setAttrCtrl("width", this.innerWidth - voBtnDf.width - (2 * this.subBorderWidth) - this.paddingLeft - this.paddingRight - 5, voText);
      break;
    default :
      this.refresh(poDocument);
      break;
  }
};
/**
 * 컨트롤에 할당된 값을 반환
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 * @return 텍스트 박스의 입력 값
 * @type String
 */
eXria.controls.xhtml.FileSelector.prototype.getValue = function(poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voFile = this.getSubCtrl("input", voCtrl, null, 1);
  return voFile.value;
};

eXria.controls.xhtml.FileSelector.prototype.getSpecificDefaultValue = function(psAttrName){
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.FileSelector[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.FileSelector[vaAttrName[0]][vaAttrName[1]] != null ? eXria.controls.xhtml.Default.FileSelector[vaAttrName[0]][vaAttrName[1]] : vsDefaultValue;
  }
  if( vsDefaultValue == undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
///**
// * 컨트롤에 값 설정.
// * @param {String} psLabel 컨트롤에 설정할 라벨 값
// * @param {HTMLDiv} poCtrl 실체화 컨트롤. 생략가능.
// * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
// */
//eXria.controls.xhtml.FileSelector.prototype.setValue = function(psLabel, poCtrl, poDocument) {
//  if(poDocument == null) poDocument = document;
//  if(poCtrl == null) poCtrl = this.getCtrl(poDocument);
//  var voCtrl = poCtrl.getCtrl();
//  var voLabel = this.getSubCtrl("div", voCtrl, null, 1);
//
//  //this.browseBtn.value = psLabel;
//  this.browseBtn.df.value = psLabel;
//
//  this.setText(voLabel, eXria.controls.xhtml.Util.parseLang(psLabel));
//};
/**
 * 버튼에 라벨(아이콘 이미지 포함) 값에 줄발꿈을 값을 적용하여 반환하는 메소드.
 * @param {String} psLabel 라벨명
 * @return 버튼에 라벨(아이콘 이미지 포함) 값에 줄발꿈이 적용된 값
 * @type String
 * @private
 */
eXria.controls.xhtml.FileSelector.prototype.getLabelText = function(psLabel) {
  var vsStr = eXria.controls.xhtml.Util.parseLang(psLabel);
  if(vsStr == null) return "";
  vsStr = vsStr.replace("\n", "<br>");
  return vsStr;
};
/**
 * 클래스 명을 반환.
 * @return "FileSelector"
 * @type String
 */
eXria.controls.xhtml.FileSelector.prototype.toString = function() {
  return "FileSelector";
};

/**
 * 파일첨부 버튼의 속성을 저장하기 위한 오브젝트.
 */
eXria.controls.xhtml.FileSelector_browseBtn = function(poParent){
  /**
  * FileSelector Control 참조 변수.
  * @type eXria.controls.xhtml.FileSelector
  */
  this.parent = poParent;
  /**
   * 파일첨부 버튼에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * 파일첨부 버튼의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * CSS를 통해 지정된 파일첨부 버튼의 보더 두께.
   * @type Number
   */
  this.cssBorderWidth = null;
  /**
   * 파일첨부 버튼의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * 파일첨부 버튼의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 파일첨부 버튼의 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * 파일첨부 버튼의 세로 길이.
   * @type Number
   */
  this.height = null;
  /**
   * 파일첨부 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 파일첨부 버튼 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 파일첨부 버튼 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * 파일첨부 버튼의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 파일첨부 버튼의 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * 파일첨부 버튼에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 파일첨부 버튼에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * CSS를 통해 지정된 파일첨부 버튼에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.cssFontSize = null;
  /**
   * 파일첨부 버튼에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 파일첨부 버튼에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 파일첨부 버튼에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 파일첨부 버튼에 설정된 값.
   * @type String
   */
  this.value = null;
  /**
   * 파일첨부 버튼 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this.parent);
};
/**
 * @fileoverview
 * Concreate xhtml ContextMenu(XHTML ContextMenu 컨트롤)
 * @author 김경태
 */

/**
 * @class Concreate xhtml ContextMenu
 * XHTML ContextMenu 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표(개발 편의를 위한 좌표)
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표(개발 편의를 위한 좌표)
 * @param {Number} pnWidth 컨트롤의 가로 길이(개발 편의를 위한 좌표)
 * @param {Number} pnHeight 컨트롤의 세로 길이(개발 편의를 위한 좌표)
 * @return 새로운 eXria.controls.xhtml.ContextMenu 객체
 * @type eXria.controls.xhtml.ContextMenu
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.ContextMenu = function(psId, pnLeft, pnTop, pnWidth, pnHeight){
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.

  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * DataRef 생성 연결.
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * 전체 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.items = new eXria.data.ArrayMap();
  /**
   * 선택된 아이템.
   * @type Object
   */
  this.selectedItem = null;
  /**
   * 컨텍스트 메뉴를 활성화시킨 컨트롤.
   * @type String
   */
  this.baseControlId = null;
  /**
   * 서브 메뉴를 보여주고 있는 Item.
   * @type String
   */
  this.showedItem = null;
  /**
   * 컨트롤의 z 인덱스.
   * @type Number
   */
  this.zIndex = 1100000;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = null;
  /**
   * 컨텍스트 메뉴 그림자의 표시 여부.
   * @type Boolean
   */
  this.shadowEnable = null;
  /**
   * 아이콘 영역의 공통 속성 (아이콘 영역 생성 시 기본값 적용).
   * @type Object
   */
  this.iconarea = {
    width: null,
    backgroundColor: null,
    className: null, // CSS 클래스 이름 - string
    verticalAlign: null
  };
  /**
   * 아이템의 공통 속성 (아이템 생성 시 기본 값 적용).
   * height : 아이템의 높이 - Number<br>
   * width : 아이템의 넓이 - Number
   * textIndent : 아이템의 들여쓰기 - Number
   * textAlign : 아이템의 가로 정렬 - String(left/center/right)
   * verticalAlign : 아이템의 세로 정렬 - String(top/middle/bottom)
   * borderWidth : border의 폭 - Number
   * borderStyle : border 스타일 - String(none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset)
   * borderColor : border색 - String
   * fontFamily : 폰트패밀리 - String
   * fontSize : 폰트사이즈 - Number
   * fontStyle : 폰트스타일 - String
   * fontWeight : 폰트굵기 - String
   * color : 아이템의 글자색 - String
   * backgroundColor : 아이템의 배경색 - String
   * focusColor : 포커스시의 아이템의 글자색 - String
   * focusBackgroundColor : 포커스시의 아이템의 배경색 - String
   * separatorColor : 구분선의 색 - String
   * separatorHeight : 구분선의 높이 - Number
   * className : CSS 클래스 이름 - string
   * @type Object
   */
  this.itemgroup = {
    height: null,
    width: null,
    textIndent: null,
    textAlign: null,
    verticalAlign: null,
    borderWidth: null,
    borderStyle: null,
    borderColor: null,
    fontFamily: null,
    fontSize: null,
    fontStyle: null,
    fontWeight: null,
    color: null,
    backgroundColor: null,
    focusColor: null,
    focusBackgroundColor: null,
    separatorColor: null,
    separatorHeight: null,
    className: null
  };
  /**
   * 컨텍스트 메뉴의 그림자를 표시하기 위한 속성
   * backgroundColor : 그림자 배경 색상 - String
   * borderWidth : 그림자 영역 테두리 두께 - Number
   * borderStyle : 그림자 영역 테두리 종류 - String
   * borderColor : 그림자 영역 테두리 색상 - String
   * filter : 투명도 설정 값(ie용) - String
   * opacity : 그림자 영역 투명도 - Number
   * left : 좌측 상단의 x좌표 - Number
   * top : 좌측 상단의 y좌표 - Number
   */
  this.shadow = {
    backgroundColor : null,
    borderWidth : null,
    borderStyle : null,
    borderColor : null,
    filter : null,
    opacity : null,
    left : null,
    top : null
  };
  /**
   * @ignore
   */
  this.df = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.ContextMenu);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.ContextMenu.prototype.createCtrl = function(poDocument) {
  var voCtrl = this.createMenuCtrl(poDocument, this.id);
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

eXria.controls.xhtml.ContextMenu.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voItemgroupDf = this.itemgroup;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  // CSS가 적용되지 않는 속성에 대한 초기값 설정(main 컨트롤)
  this.shadowEnable = this.getAttrValue("shadowEnable", this.shadowEnable);
  this.value = this.getAttrValue("value", this.value);
};

eXria.controls.xhtml.ContextMenu.prototype.setSpecificAttrs = function(poCtrl, poDocument){
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  //poCtrl["className"] = this.getCSSClass(this, 1);
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(voDf.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(voDf.visible == false) {
    vaCssStrBuf.push("display:none;");
  } else {
    if(this.isShowing) vaCssStrBuf.push("display:block;");
    else vaCssStrBuf.push("display:none;");
  }
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  poCtrl.style.cssText = vaCssStrBuf.join("");
};

eXria.controls.xhtml.ContextMenu.prototype.setSpecificEvents = function(poCtrl) {};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.atclick = function(poEvent) {
  this.focused = true;
  if(this.selectedItem) {
     poEvent.objectType = "item";
     poEvent.object = this.selectedItem;
     poEvent.baseControlId = this.baseControlId;
   }
 };
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  this.setSpecificDefaults(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.setAttrCtrl("height", "", poCtrl);
  this.setAttrCtrl("width", "", poCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.reloadData = function(poCtrl, poDocument) {};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl){
  switch (psAttrName) {
    case "disabled":
      for (var i = 0; i < poCtrl.childNodes.length; i++) {
        poCtrl.childNodes[i].disabled = psAttrValue;
        for (var j = 0; j < poCtrl.childNodes[i].childNodes.length; j++) {
          poCtrl.childNodes[i].childNodes[j].disabled = psAttrValue;
        }
      }
      break;
    default:
      //      poCtrl.childNodes[i].setAttribute(psAttrName, psAttrValue);
      break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.applyAttrRefresh = function(psAttrName, psAttrValue, poDocument){
  var vsAttrName = psAttrName.split('.');
//  if(psAttrName == "visible"){
//    if(this.isShowing == false) return;
//  }
  if (vsAttrName.length == 1) {
    this.setAttr(psAttrName, psAttrValue);
    this.setAttrCtrl(psAttrName, psAttrValue);
    this.refresh(poDocument);
  }
  else if (vsAttrName.length == 2) {
    if (vsAttrName[0] == "itemgroup" || vsAttrName[0] == "iconarea") {
      if (this.setAttr(psAttrName, psAttrValue)) {
        this.refreshItems(poDocument);
      }
    }
  }
};

eXria.controls.xhtml.ContextMenu.prototype.setDisable = function(poCtrl, psValue) {
  this.disabled = psValue;
  if(psValue == true){
    if(poCtrl.tagName == "TR")  {
      poCtrl.style.color = this.disabledColor;
    }

    if(poCtrl.childNodes) {
      var voChild = null;
      for(var i = 0; i < poCtrl.childNodes.length; i++) {
        voChild = poCtrl.childNodes[i];
        this.setDisable(voChild, psValue);
      }
    }
  }else{
    if(poCtrl.disabled != undefined) poCtrl.removeAttribute("disabled");

    if(poCtrl.childNodes) {
      var voChild = null;
      for(var i = 0; i < poCtrl.childNodes.length; i++) {
        voChild = poCtrl.childNodes[i];
        this.setDisable(voChild, psValue);
      }
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.createMenuCtrl = function(poDocument, psId) {
  var voMenuDiv = poDocument.createElement("div");
  voMenuDiv["id"] = psId;
  voMenuDiv["tabIndex"] = 0;
  if(this.canvas.page.metadata.browser.ie > 0) voMenuDiv["hideFocus"] = true;
  return voMenuDiv;
};
/**
 * mouseover 시에 호출되어 하위 메뉴를 보여줌
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {eXria.controls.xhtml.MenuItem} poItem mouseover된 아이템 객체
 * @privatre
 */
eXria.controls.xhtml.ContextMenu.prototype.showSubMenu = function(poDocument, poItem) {
  var voDocument = this.document;
  if(poItem.parentControl.visible == false) return;
  var voSubMenuDiv = voDocument.getElementById(poItem.id + "_SubMenu");
  if(voSubMenuDiv !== undefined && voSubMenuDiv != null) {
    //this.clearCtrlNode(voSubMenuDiv);
    voSubMenuDiv.parentNode.removeChild(voSubMenuDiv);
  }

  voSubMenuDiv = this.createMenuCtrl(poDocument, poItem.id + "_SubMenu");
  this.setMainCtrlStyles(voSubMenuDiv, poDocument);
  this.setSpecificDefaults(voSubMenuDiv, poDocument);
  this.setSpecificAttrs(voSubMenuDiv, poDocument);

  var voChildItem = null;
  var vnIndex = 0;
  var vnHIndex = 0;
  var voParent = poItem.parent;
  var voPosItem = poItem;
  var voIterator = null;
  while(voParent) {
      vnHIndex++;
      voIterator = voParent.items.getValueCollection().iterator();
      var i = 0;
      while(voIterator.hasNext()) {
        voChildItem = voIterator.next();
        if((voChildItem != voPosItem) && (voChildItem.toString() == "MenuItem") && voChildItem.value != "-") {
          i++;
        } else {
          break;
        }
      }
      vnIndex += i;
      voPosItem = voParent;
      voParent = voParent.parent
  }
  var voStyle = voSubMenuDiv.style;
  voStyle.left = (this.getCtrl().offsetLeft + vnHIndex * this.getCtrl().offsetWidth - 10) + "px";
  voStyle.top = (this.getCtrl().offsetTop) + (vnIndex * poItem.height) + "px";
  voStyle.zIndex = 1100000;

  voDocument.getElementById(this.canvas.id).appendChild(voSubMenuDiv);

  this.showedItem = poItem;

  var vaStrBuf = [];
  var voChildItem = null;
  var voIterator = poItem.items.getValueCollection().iterator();
  vaStrBuf.push("<table cellSpacing=0 cellPadding=0 ");
  vaStrBuf.push("style='left:0px;top:0px'>");
  vaStrBuf.push("<tbody>");
  while (voIterator.hasNext()) {
    voChildItem = voIterator.next();
    vsType = voChildItem.toString();
    if(vsType== "MenuItem") {
      vaStrBuf.push(voChildItem.getInnerHTML(voParent))
    } else if(vsType == "MenuItemSet") {
      voChildItem.items.clear();
      voChildItem.loadData();
      vaStrBuf.push(voChildItem.getInnerHTML(voParent));
    }
  }
  vaStrBuf.push("</tbody>");
  vaStrBuf.push("</table>");
  voSubMenuDiv.innerHTML = vaStrBuf.join("");

  var voParentCtrl = voDocument.getElementById(poItem.id);
  var vnLeft = 0;
  var vnTop = 0;
  if(this.getPositionLeft(voSubMenuDiv, voParentCtrl) > 0) vnLeft = this.getPositionLeft(voSubMenuDiv, voParentCtrl);
  if(this.getPositionTop(voSubMenuDiv, voParentCtrl) > 0) vnTop = this.getPositionTop(voSubMenuDiv, voParentCtrl);
  voStyle.left = vnLeft + "px";
  voStyle.top = vnTop + "px";

  this.createShadow(voSubMenuDiv);

  vaStrBuf = null;
};
/**
 * 하위 메뉴를 숨김
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {eXria.controls.xhtml.MenuItem} poItem mouseover된 아이템 객체
 * @privatre
 */
eXria.controls.xhtml.ContextMenu.prototype.hideSubMenu = function(poDocument, poItem) {
  var voDocument = this.document;
  var voSubMenuDiv = voDocument.getElementById(poItem.id + "_SubMenu");
  if(voSubMenuDiv !== undefined && voSubMenuDiv != null) {
    //this.clearCtrlNode(voSubMenuDiv);
    voSubMenuDiv.parentNode.removeChild(voSubMenuDiv);
    this.showedItem = null;
  }
  var voIterator = poItem.items.getValueCollection().iterator();
  var voChildItem = null;
  while (voIterator.hasNext()) {
    voChildItem = voIterator.next();
    this.hideSubMenu(poDocument, voChildItem);
  }
};
/**
 * 컨텍스트 메뉴에 추가할 아이템을 생성.
 * @param {String} psLabel 아이템 라벨명
 * @param {String} psValue 아이템 값
 * @param {String} psImage 이미지 경로
 * @param {String} psHotKey 단축키 값
 * @return 생성된 메뉴 아이템
 * @type eXria.controls.xhtml.MenuItem
 * @example page.getControl("contextmenu").createMenuItem("제목", "value", ".img/icon_new.png", "F3");
 */
eXria.controls.xhtml.ContextMenu.prototype.createMenuItem = function(psLabel, psValue, psImage, psHotKey) {
  var voItem = new eXria.controls.xhtml.MenuItem(psLabel, psValue, psImage, psHotKey, this);
  var voItemgroup = this.itemgroup;

  // 메뉴아이템의 공통 속성에 대한 기본값 설정
  voItem.height = this.getAttrValue("itemgroup.height", voItemgroup.height);
//  voItem.backgroundColor = this.getAttrValue("itemgroup.backgroundColor", voItemgroup.backgroundColor);
  voItem.backgroundColor = voItemgroup.backgroundColor;
  voItem.borderWidth = voItemgroup.borderWidth;
  voItem.borderStyle = voItemgroup.borderStyle;
  voItem.borderColor = voItemgroup.borderColor;
  voItem.textAlign = voItemgroup.textAlign;
  voItem.verticalAlign = voItemgroup.verticalAlign;
  voItem.focusBackgroundColor = voItemgroup.focusBackgroundColor;

  // 컨트롤이 가진 속성을 메뉴아이템에 전달
  voItem.disabled = this.disabled;
  voItem.color = this.color;

  return voItem;
};
/**
 * 컨텍스트 메뉴에 아이템 추가.
 * @param {eXria.controls.xhtml.MenuItem} poItem 컨텍스트 메뉴에 추가할 아이템.
 * @example
 * var item = page.getControl("contextmenu").createMenuItem("제목", "value", ".img/icon_new.png", "F3");<br>
 * page.getControl("contextmenu").addChild(item);
 */
eXria.controls.xhtml.ContextMenu.prototype.addChild = function(poItem) {
  this.items.put(this.items.size(), poItem);
  poItem.parent = this;
};
/**
 * 컨텍스트 메뉴의 아이템들 전체 삭제.
 */
eXria.controls.xhtml.ContextMenu.prototype.removeAll = function() {
  this.items.clear();
};
/**
 * 지정된 id를 갖는 아이템을 얻어오기 위한 메소드.
 * @param {String} psId 검색할 아이디
 * @param {eXria.data.ArrayMap} poItems 검색할 아이템 맵, 생략시 현재 contextmenu item
 * @return 지정된 값을 포함한 아이템
 * @type eXria.controls.xhtml.Item
 */
eXria.controls.xhtml.ContextMenu.prototype.getItemById = function(psId, poItems) {
  if(poItems == null) poItems = this.items;
  var vsKey = null;
  var voItem = null;
  var vsType = 0;
  var voIterator = poItems.getValueCollection().iterator();
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    vsType = voItem.toString();
    if(vsType == "MenuItem") {
      if(voItem.id == psId) {
        return voItem;
      } else {
        voItem = this.getItemById(psId, voItem.items);
        if(voItem) return voItem;
      }
    } else if(vsType == "MenuItemSet") {
      voItem = this.getItemById(psId, voItem.items);
      if(voItem) return voItem;
    }
  }
  return null;
};
/**
 * 컨텍스트 메뉴에 추가할 아이템셋을 생성.
 * @param {String} psLabelPath 아이템 라벨명 경로
 * @param {String} psValuePath 아이템 값 경로
 * @param {String} psImagePath 아이템 이미지 경로
 * @param {String} psHotKeyPath 단축키 경로
 * @param {String} psParentPath 부모아이템 경로
 * @param {String} psInstanceId 인스턴스 아이디
 * @param {String} psNodeSet 노드셋 경로
 * @return 생성된 메뉴 아이템
 * @type eXria.controls.xhtml.MenuItemSet
 * @example
 * var item = page.getControl("contextmenu").createMenuItemSet("label", "value", "img", "hotkey", null);<br>
 * item.data.setNodesetRef("instance", "/root/ct/list");
 */
eXria.controls.xhtml.ContextMenu.prototype.createMenuItemSet = function(psLabelPath, psValuePath, psImagePath, psHotKeyPath, psParentPath, psInstanceId, psNodeSet) {
  var voItemSet = new eXria.controls.xhtml.MenuItemSet(psLabelPath, psValuePath, psImagePath, psHotKeyPath, psParentPath, psInstanceId, psNodeSet, this);
  return voItemSet;
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  var vaAttrName = psAttrName.split(".");
  if(vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.ContextMenu[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.ContextMenu[vaAttrName[0]][vaAttrName[1]];
  }
  if(vsDefaultValue === undefined) { return null;}
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.getPositionLeft = function(poCtrl, poParent){
  var vnLeft = poCtrl.offsetLeft;
  var vnWidth = poCtrl.offsetWidth;
  var vnParentWidth = null;

  if(poParent){
    vnParentWidth = poParent.offsetWidth;
    vnLeft = poParent.offsetWidth + poParent.parentNode.parentNode.parentNode.offsetLeft;

    if((vnLeft + vnWidth) > this.canvas.width) vnLeft = vnLeft - vnWidth - vnParentWidth + 10;
    else vnLeft -= 10;
  } else {
    if((vnLeft + vnWidth) > this.canvas.width) vnLeft = vnLeft - vnWidth + 2;
  }

  return vnLeft;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.getPositionTop = function(poCtrl, poParent){
  var vnTop = poCtrl.offsetTop;
  var vnHeight = poCtrl.offsetHeight;

  if(poParent){
    var vnParentHeight = poParent.offsetHeight;
    vnTop = poParent.offsetTop + poParent.parentNode.parentNode.parentNode.offsetTop;

    if((vnTop + vnHeight) > this.canvas.height) vnTop = vnTop - vnHeight + vnParentHeight - 5;
    else vnTop += 5;
  } else {
    if((vnTop + vnHeight) > this.canvas.height) vnTop = vnTop - vnHeight + 2;
  // FF에서 최초 Event가 발생한 cursor의 position에서 position이 바뀌게 되는 객체의 영역이 벗어나면 객체의 display가 none으로 바뀜
  // cursor의 positon과 객체의 position을 맞춰주기 위하여 -1을 함
  }

  return vnTop;
};

eXria.controls.xhtml.ContextMenu.prototype.loadData = function(poDocument) {
  var voCtrl = this.ctrl;
  voCtrl.innerHTML = this.getInnerHTML(voCtrl);
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.loadComplete = function(poDocument) {
  var voCtrl = this.ctrl;
  var vnLeft = 0;
  var vnTop = 0;
  if(this.getPositionLeft(voCtrl) > 0) vnLeft = this.getPositionLeft(voCtrl);
  if(this.getPositionTop(voCtrl) > 0) vnTop = this.getPositionTop(voCtrl);
  voCtrl.style.left = vnLeft + "px";
  voCtrl.style.top = vnTop + "px";
  this.createShadow(voCtrl);
};

eXria.controls.xhtml.ContextMenu.prototype.reloadData = function(poDocument){
  this.loadData(poDocument);
  this.loadComplete(poDocument);
}
/**
 * data를 표시한다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {HTMLDiv} poCtrl 실체화 컨트롤
 * @param {eXria.controls.xhtml.MenuItem|eXria.controls.xhtml.MenuItemSet} poItems 컨텍스트 메뉴를 구성할 메뉴 객체 collection
 * @private
 */
eXria.controls.xhtml.ContextMenu.prototype.display = function(poDocument, poCtrl, poItems) {
  var vsKey = null;
  var voValue = null;
  var vsType = 0;
  var voIterator = poItems.getKeyCollection().iterator();

  while (voIterator.hasNext()) {
    vsKey = voIterator.next();
    voValue = poItems.get(vsKey);
    vsType = voValue.toString();
    if(vsType== "MenuItem") {
      var voItemCtrl = voValue.createCtrl(poDocument);
      poCtrl.childNodes[0].childNodes[0].appendChild(voItemCtrl);
    } else if(vsType == "MenuItemSet") {
      voValue.loadData(poDocument);
      voValue.display(poDocument, poCtrl.childNodes[0].childNodes[0]);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.getInnerHTML = function(poCtrl) {
  var vsKey = null;
  var voItem = null;
  var vsType = 0;
  var voIterator = this.items.getValueCollection().iterator();
  var vaStrBuf = [];
  var vsCss = this.getCSSClass(this, 1);
  //TODO get ItemgroupClass
  vaStrBuf.push("<table class='" + vsCss + "' cellSpacing=0 cellPadding=0 ");
  vaStrBuf.push("style='left:0px;top:0px'>");
  vaStrBuf.push("<tbody>");
  while (voIterator.hasNext()) {
    voItem = voIterator.next();
    vsType = voItem.toString();
    if(vsType== "MenuItem") {
      vaStrBuf.push(voItem.getInnerHTML(poCtrl))
    } else if(vsType == "MenuItemSet") {
      voItem.items.clear();
      voItem.loadData();
      vaStrBuf.push(voItem.getInnerHTML(poCtrl));
    }
  }
  vaStrBuf.push("</tbody>");
  vaStrBuf.push("</table>");

  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};
/**
 * @ignore
 */
eXria.controls.xhtml.ContextMenu.prototype.createShadow = function(poCtrl){
  if(!this.shadowEnable) return;

//  this.shadow.backgroundColor = this.getAttrValue("shadow.backgroundColor",this.shadow.backgroundColor);
//  this.shadow.borderWidth = this.getAttrValue("shadow.borderWidth",this.shadow.borderWidth);
//  this.shadow.borderStyle = this.getAttrValue("shadow.borderStyle",this.shadow.borderStyle);
//  this.shadow.borderColor = this.getAttrValue("shadow.borderColor",this.shadow.borderColor);
//  this.shadow.filter = this.getAttrValue("shadow.filter",this.shadow.filter);
//  this.shadow.opacity = this.getAttrValue("shadow.opacity",this.shadow.opacity);
  this.shadow.left = this.getAttrValue("shadow.left",this.shadow.left);
  this.shadow.top = this.getAttrValue("shadow.top",this.shadow.top);

  var voDocument = this.document;
  var vsClass = this.getCSSClass(this, 1, "Shadow");
  var voShadow = voDocument.createElement("div");
  voShadow.className = vsClass;
  var voStyle = voShadow.style;
  voStyle.position = "absolute";
//  voStyle.backgroundColor = this.shadow.backgroundColor;
//  voStyle.borderWidth = this.shadow.borderWidth;
//  voStyle.borderStyle = this.shadow.borderStyle;
//  voStyle.borderColor = this.shadow.borderColor;
//  voStyle.filter = this.shadow.filter;
//  voStyle.opacity = this.shadow.opacity;
  voStyle.zIndex = "-1";
  voStyle.left = this.shadow.left;
  voStyle.top = this.shadow.top;
  voStyle.width = poCtrl.offsetWidth + "px";
  voStyle.height = poCtrl.offsetHeight + "px";

  poCtrl.appendChild(voShadow);
};
/**
 * 클래스 명을 반환.
 * @return "ContextMenu"
 * @type String
 */
eXria.controls.xhtml.ContextMenu.prototype.toString = function(){
  return "ContextMenu";
};

/**
 * @fileoverview
 * Concreate xhtml MDIGroup, MDIButton, MDIPage
 * @author 박상찬
 */

/**
 * MDI 컨트롤 헤더의 버튼 공통 속성을 저장하기 위한 클래스.
 * @version 2.0
 * @type eXria.controls.xhtml.MDIButtons
 * @constructor
 */
eXria.controls.xhtml.MDIButtons = function() {
  /**
   * MDI 버튼의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * MDI 버튼의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * MDI 버튼의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * MDI 버튼의 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * MDI 버튼의 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * MDI 버튼의 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * MDI 버튼의 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * MDI 버튼에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * MDI 버튼에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * MDI 버튼에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * MDI 버튼에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * MDI 버튼에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * MDI 버튼간 간격(px).
   * @type Number
   */
  this.cellSpacing = null;
  /**
   * MDI 버튼의 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * MDI 버튼의 세로 길이.
   * readOnly 속성.
   * @type Number
   * @private
   */
  this.height = null;
  /**
   * MDI 버튼의 Top.
   * @type Number
   */
  this.top = null;
  /**
   * MDI 버튼의 Left.
   * readOnly 속성.
   * @type Number
   * @private
   */
  this.left = null;
  /**
   * MDI 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 선택된 MDI 버튼의 배경이미지 url.
   * @type String
   */
  this.imageFocused = null;
  /**
   * MDI 버튼 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * MDI 버튼 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * MDI 버튼의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * MDI 버튼이 선택되었을 때의 배경 색상.
   * @type String
   */
  this.focusBackgroundColor = null;
  /**
   * MDI 버튼의 텍스트 색상.
   * @type String
   */
  this.color = null;
  /**
   * MDI 버튼이 선택되었을 때의 텍스트 색상.
   * @type String
   */
  this.focusColor = null;
  /**
   * MDI 버튼에 표시될 텍스트의 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * MDI 버튼에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * MDI 버튼에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * MDI 버튼에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * MDI 버튼에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 텍스트 밑줄 적용 속성.
   * @type String
   */
  this.textDecoration = null;
  /**
   * MDI 버튼에 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * MDI 버튼에 외곽에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * MDI 컨트롤 헤더의 MDI 버튼 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  /**
   * MDI 컨트롤 헤더의 MDI 버튼 cursor값
   * @type String
   * @private
   */
  this.cursor = null;

  this.df = {};
};

/**
 * @class Concreate xhtml MDIButton
 * XHTML MDI 컨트롤 헤더에 포함되는 MDI 버튼 컨트롤.
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIButton 객체
 * @type eXria.controls.xhtml.MDIButton
 * @constructor
 * @base eXria.controls.xhtml.Button
 */
eXria.controls.xhtml.MDIButton = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  eXria.controls.xhtml.Button.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * MDIButtons 참조
   * @type eXria.controls.xhtml.MDIButtons
   * @private
   */
  this.parent = null;
  /**
   * Button의 subId 참조(MDI 컨트롤 id가 제외된 값)
   * @private
   */
  this.subId = null;
  /**
   * 링크된 페이지 아이디(MDI 컨트롤 id와 조합된 값) 참조
   * @type String
   * @private
   */
  this.pageId = null;
  /**
   * 링크된 페이지 아이디 참조(MDI 컨트롤 id가 제외된 값)
   * @type String
   * @private
   */
  this.pageSubId = null;
  /**
   * @ignore
   */
  this.position = "relative";
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Button, eXria.controls.xhtml.MDIButton);
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<button hidefocus='true' type='button' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' style=\"");
  vaTemplate.push("@cssStrbuf"); //setSpecificAttrs메소드에서  스타일 속성이 대체될  부분은 @cssStrBuf로 마크(Element 속성의 경우엔 @attStrBuf로 마크)
  vaTemplate.push("\" class='" + vsClass + "'>");
  vaTemplate.push("@innStrBuf"); //setSpecificAttrs메소드에서 innerHTML이 대체될 부분은 @innStrBuf로 마크
  vaTemplate.push("</button>");
//  vaTemplate.push("<div style=\"");
//  vaTemplate.push("@cssStrBuf");
//  vaTemplate.push("\"><table style=\"position:absolute;left:0px;top:0px;width:100%;height:100%;font-family:Arial;font-weight:bold;\">");
//  vaTemplate.push("<tr><td align=\"center\" vAlign=\"middle\">x</td></tr></table></div>");
//  var vcTab = this.parent.parent;
//    if(vcTab.type == "minimizedWindow") {
//    vaTemplate.push("<input type=\"button\" value=\"x\" HIDEFOCUS=\"true\" style=\"");
//    vaTemplate.push("@cssStrBuf");
//    vaTemplate.push("\" onclick=\"");
//    vaTemplate.push(this.getEHandler2(this.pageId));
//    vaTemplate.push("\"/>");
//  }
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\"/>");
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  ///////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  ///////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존에 이와같은 코드가 있었는데 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", "hand");
  poCtrl.style.cssText = vaCssStrBuf.join("");
  //////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  //////////////////////////////////////////////////////////////////////////////////////////

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[2] + "')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[1] + "')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(poCtrl.style["filter"]) poCtrl.style["filter"] = "";
    }
  }

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", "hand");

  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");
  vaTemplate[voIndexMap.get(1)] = this.getLabelText(this.value);

  var vnIndex = 2;
//  var vcTab = this.parent.parent;
//  if(vcTab.type == "minimizedWindow") {
//    vaCssStrBuf = [];
//    vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;border-width:0px;left:" + (this.innerWidth - 20) + "px;top:0px;");
//    vaCssStrBuf.push("border-style:none;font-family:Arial;font-weight:bold;text-align:center;outline-style:none;");
//    vfcSetCssStrBuf(vaCssStrBuf, "width", 20, "px");
//    vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
//    vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
//    vaTemplate[voIndexMap.get(vnIndex++)] = vaCssStrBuf.join("");
//  }

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(vnIndex)] = vaCssStrBuf.join("");
  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  voEvent.object = poControl;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리

  if (poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if (poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if (poControl[vsOnEvent]) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }
};
eXria.controls.xhtml.MDIButton.prototype.setSpecificEvents = function(poCtrl) {
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.atmouseover = function(poEvent) {
}
/**
* @ignore
*/
eXria.controls.xhtml.MDIButton.prototype.atmouseout = function(poEvent) {
}
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.atclick = function(poEvent) {
  var vsPageId = this.id.substring(0, this.id.indexOf("_button"));
  var vsPageNum = this.parent.getIndexById(vsPageId);
  
  var voMdiPage = this.parent.mdiPageSet.elements[vsPageNum];
  var voMdiPageCtrl = this.document.getElementById(voMdiPage.id);
  var voMdiButton = this.document.getElementById(this.id);
  var voResizeLabel = this.document.getElementById(voMdiPageCtrl.id+"_resize");
  this.parent.zIndexSeq++;
  var vnZIndex = this.parent.zIndexSeq;
  
  voMdiPageCtrl.style["display"] = "block";
  voResizeLabel.style["display"] = "block";
  voMdiButton.style["background-color"] = "cornflowerblue";
  
  vnZIndex += 200;
  voMdiPageCtrl.style["zIndex"] = vnZIndex;
  voResizeLabel.style["zIndex"] = vnZIndex+1;
  
  //zIndex 증가
  this.parent.zIndexSeq++;

  // 조영진 선임 추가 코드
//  var voTabHeader = this.parent;
//  var voTab = voTabHeader.parent;
//  var voButton = poEvent.object;
//  var vnIndex = voTab.getIndexById(voButton.pageId);
//  if(vnIndex != voTab.selectedIndex) voTabHeader.select(vnIndex);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voBtn = voCtrl.childNodes[0];
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
//    if(this.borderLeftWidth == null) this.borderLeftWidth = this.borderWidth;
//    if(this.borderRightWidth == null) this.borderRightWidth = this.borderWidth;
//    if(this.borderTopWidth == null) this.borderTopWidth = this.borderWidth;
//    if(this.borderBottomWidth == null) this.borderBottomWidth = this.borderWidth;
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;

    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth, voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth, voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth, voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth, voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  //case "borderTopHeight" :
  case "borderBottomWidth" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "value" :
    this.setValue(psAttrValue, voBtn, poDocument);
    break;
  case "backgroundImage" :
  case "imageFocused" :
    if(this.focused) this.setAttrCtrl("backgroundImage", this.imageFocused, voBtn);
    else this.setAttrCtrl("backgroundImage", this.backgroundImage, voBtn);
    break;
  case "backgroundPosition":
  case "backgroundRepeat":
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "outerClassName" :
  case "className" :
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type Unknown
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = null;
  var vsDefaultValue = eXria.controls.xhtml.Default.MDIGroup.MDIButtons[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Default 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIButton.prototype.getEHandler2 = function(psPageId) {
  var voTabHeader = this.parent;
  var voTab = voTabHeader.parent;
  var vnIndex = voTab.getIndexById(psPageId);
  var vaStrBuf = [];
  vaStrBuf.push("var voControl=page.getControl('");
  vaStrBuf.push(voTab.id);
  vaStrBuf.push("');");
  vaStrBuf.push("voControl.")
  vaStrBuf.push("removeMinimizedWindowTab(" + vnIndex + ");");
  vaStrBuf.push("var voEvent = new eXria.event.Event(event);");
  vaStrBuf.push("voEvent.stopEvent();");
  var vsRet = vaStrBuf.join("");
  vaStrBuf = null;
  return vsRet;
};

/**
 * 클래스 명을 반환.
 * @return "MDIButton"
 * @type String
 */
eXria.controls.xhtml.MDIButton.prototype.toString = function() {
  return "MDIButton";
};

/**
 * @class Concreate xhtml MDIPageButton<br>
 * XHTML MDIPageButton control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIPageButton 객체
 * @type eXria.controls.xhtml.MDIPageButton
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.MDIPageButton = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  /*
   * UIControl을 상속받는다.
   */
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).
   * @type String
   */
  this.position = "absolute";
  /**
   * 버튼에 라벨값(아이콘 url정보 포함) 저장.
   * @type String
   */
  this.value = null;
  /**
   * 컨트롤 외곽 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * 컨트롤 외곽 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * 컨트롤 외곽 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * 컨트롤 외곽 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 표시될 텍스트 가로정렬.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트에 밑줄을 넣을때.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 버튼이 눌려을 때 표시될 이미지.
   * @type String
   */
  this.imagePushed = null;
  /**
   * 버튼에 포커스가 위치했을 때 표시될 이미지.
   * @type String
   */
  this.imageFocused = null;
  /**
   * 버튼에 마우스가 위치했을 때 표시될 이미지.
   * @type String
   */
  this.imageMouseover = null;
  /**
   * 버튼의 이미지가 바뀌기전의 이미지.
   * @type String
   * @type private
   */
  this.oldImage = null;
  /**
   * 버튼에 포커스가 위치했는지 여부.
   * @type boolean
   * @private
   */
  this.focused = false;
  /**
   * MDIPages 버튼 cursor값
   * @type String
   * @private
   */
  this.cursor = null;
  /**
   * 자동줄바꿈 여부.
   * @type Boolean
   */
  this.wordWrap = null;
   /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * default로 eXria_CSS_Configure.xml에 정의된 값으로 설정(최소 default 설정 필요함)
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.MDIPageButton);
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<button hidefocus='true' type='button' id='");
  vaTemplate.push(this.id);
  vaTemplate.push("_btn' style=\"");
  vaTemplate.push("@cssStrbuf"); //setSpecificAttrs메소드에서  스타일 속성이 대체될  부분은 @cssStrBuf로 마크(Element 속성의 경우엔 @attStrBuf로 마크)
  vaTemplate.push("\" class='" + vsClass + "'>");
  vaTemplate.push("@innStrBuf"); //setSpecificAttrs메소드에서 innerHTML이 대체될 부분은 @innStrBuf로 마크
  vaTemplate.push("</button>");
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\"/>");
};

eXria.controls.xhtml.MDIPageButton.prototype.refreshTemplate = null;
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.showContextByClick = voUserAttr.showContextByClick;
    this.labelName = voUserAttr.labelName;
  }
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.width = this.getAttrValue("width", this.width);
  this.value = this.getAttrValue("value", this.value);
  this.backgroundImage = this.getAttrValue("backgroundImage", this.backgroundImage);
  this.imagePushed = this.getAttrValue("imagePushed", this.imagePushed);
  //if(this.imagePushed) this.imagePushed = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imagePushed, this.window);
  this.imageFocused = this.getAttrValue("imageFocused", this.imageFocused);
  //if(this.imageFocused) this.imageFocused = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imageFocused, this.window);
  this.imageMouseover = this.getAttrValue("imageMouseover", this.imageMouseover);
  //if(this.imageMouseover) this.imageMouseover = eXria.controls.xhtml.Util.getBackgroundImagePath(this.imageMouseover, this.window);
  this.wordWrap = this.getAttrValue("wordWrap", this.wordWrap);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  ///////////////////////////////////////////////////////////////////////////////////
  // 블럭 A
  // 이 블럭의 코드는 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  ///////////////////////////////////////////////////////////////////////////////
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaInnStrBuf = null;
  var vaTemplate = this.template;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존에 이와같은 코드가 있었는데 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", "hand");
  poCtrl.style.cssText = vaCssStrBuf.join("");
  //////////////////////////////////////////////////////////////////////////////////////////
  // 블럭 A 끝
  //////////////////////////////////////////////////////////////////////////////////////////

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[2] + "')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + vsSplit[1] + "')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(poCtrl.style["filter"]) poCtrl.style["filter"] = "";
    }
  }

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", "hand");

  vaTemplate[3] = vaCssStrBuf.join("");
  vaTemplate[5] = this.getLabelText(this.value);
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[8] = vaCssStrBuf.join("");
  poCtrl.innerHTML = vaTemplate.join("");

  vaAttStrBuf = null;
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;

  this.setSubElement(poDocument);
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.button = this.getSubCtrl("button", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.setSpecificEvents = function(poCtrl) {
  var voBtn = this.subElement.button;
  this.eventManager.addListener(voBtn, "onblur", this.mediateEvent);
  this.eventManager.addListener(voBtn, "onfocus", this.mediateEvent);
  voBtn.control = this;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.dofocus = function() {
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(this.visible != false)
    voBtn.focus();
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.atfocus = function(poEvent) {
  var voDf = this.df;
  this.focused = true;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var vsImage = voBtn.style.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imageFocused) {
    vsImage = this.imageFocused;
  }
  this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atblur = function(poEvent) {
  var voDf = this.df;
  this.focused = false;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atmousedown = function(poEvent) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(poEvent.target == voBtn) this.focused = true;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imagePushed) vsImage = this.imagePushed;
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atmouseup = function(poEvent) {
  var voDf = this.df;
  if(!this.imagePushed) return;
  var voBtn = this.subElement.button;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atmouseover = function(poEvent) {
  if(this.focused == null) return;  //조건절이 true가 될 수 없는 코드

  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(this.imageFocused && this.imageFocused == vsImage) return;
  if(this.imageMouseover) vsImage = this.imageMouseover;
//  if(poEvent.target.id == this.id) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atmouseout = function(poEvent) {
  if(this.focused == null) return;  //조건절이 true가 될 수 없는 코드

  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
//if(poEvent.target.id == this.id) this.setAttrCtrl("backgroundImage", this.oldImage, voBtn);
  var vsImage = null;
  if(this.focused && this.imageFocused) vsImage = this.imageFocused;
  else vsImage = this.backgroundImage;
  if(vsImage == null) vsImage = "";
  if(vsImage != null) this.setAttrCtrl("backgroundImage", vsImage, voBtn);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.atclick = function(poEvent) {
  //to-do button 제어
  var voMdiGroup = this.parent.parent;
  var voMdiPage = this.parent;
  
  var vnPageNum = voMdiGroup.getIndexById(voMdiPage.id);
  var voPageCtrl = voMdiGroup.mdiPageSet.elements[vnPageNum];
  var voResizeLable = this.document.getElementById(voMdiPage.id+"_resize");
  var vnPageLabelNum = voMdiGroup.getIndexLabelById(voResizeLable.id);
  var voMdiButton = this.document.getElementById(voMdiPage.id+"_button");
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  var voMdiSubpage = null;
  if(voMdiPage.pagebody.controls) {
    var vnPageBodyCtrlCnt = voMdiPage.pagebody.controls.size();
    var voCtrl = null;
    for(var i = 0; i < vnPageBodyCtrlCnt; i++){
      voCtrl = voMdiPage.pagebody.controls.elements[i];
      if(voCtrl.toString() == "SubPage") voMdiSubpage = voCtrl;
    }
  }
  
  if(this.backgroundImage.indexOf("up.jpg") > - 1){
    voMdiPage.applyAttr("visible", false);
    voResizeLable.style["display"] = "none";
    voMdiButton.style["background-color"] = "red";
  }else if(this.backgroundImage.indexOf("Enlargement.jpg") > - 1 || this.backgroundImage.indexOf("minimal.jpg") > - 1){
    
    if(this.backgroundImage.indexOf("Enlargement.jpg") > - 1){
      voMdiPage.currentCodinate(voMdiPage);
      this.applyAttr("backgroundImage", "url("+vsResourceBaseUrl+"/eXria/controls/xhtml/images/minimal.jpg)");
      voMdiPage.applyAttr("top", 1);
      voMdiPage.applyAttr("left", 1);
      voMdiPage.applyAttr("height", voMdiGroup.height - voMdiGroup.titleBarHeight);
      voMdiPage.applyAttr("width", voMdiGroup.width - 3);
      
      voMdiPage.pagebody.applyAttr("top", voMdiPage.pagecaption.height);
      voMdiPage.pagebody.applyAttr("left", 1);
      voMdiPage.pagebody.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
      voMdiPage.pagebody.applyAttr("width", voMdiGroup.width - 3);
      
      if(voMdiSubpage){
        voMdiSubpage.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
        voMdiSubpage.applyAttr("width", voMdiGroup.width - 3);
      }
    }else{
      //to-do 위치값 저장 변수 선언 mdipage 것
      this.applyAttr("backgroundImage", "url("+vsResourceBaseUrl+"/eXria/controls/xhtml/images/Enlargement.jpg)");
      voMdiPage.applyAttr("top", voMdiPage.currentTop);
      voMdiPage.applyAttr("left", voMdiPage.currentLeft);
      voMdiPage.applyAttr("height", voMdiPage.currentHeight);
      voMdiPage.applyAttr("width", voMdiPage.currentWidth);
      
      voMdiPage.pagebody.applyAttr("top", voMdiPage.pagecaption.height);
      voMdiPage.pagebody.applyAttr("left", 1);
      voMdiPage.pagebody.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
      voMdiPage.pagebody.applyAttr("width", voMdiPage.width);
      
      if(voMdiSubpage){
        voMdiSubpage.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
        voMdiSubpage.applyAttr("width", voMdiPage.width);
      }
    }
    this.mdiPageButtonMove(voPageCtrl);
    voMdiPage.mdiLabelMove();
  }else if(this.backgroundImage.indexOf("close.jpg") > - 1){
    if(page.voFncListAdd) page.voFncListAdd(voMdiPage.id);
    this.canvas.removeControl(voResizeLable.id);
    this.canvas.removeControl(voMdiButton.id);
    this.canvas.removeControl(voMdiPage.id);
    // TODO 추후 mdiGroupSet 도 제거해 줘야 함
    voMdiGroup.mdiPageSet.remove(vnPageNum);
    if(voMdiSubpage)  voMdiGroup.mdiPageSet.remove(vnPageNum);
    voMdiGroup.mdiPageResizeSet.remove(vnPageLabelNum);
    voMdiGroup.mdiButtonMove();
  }
    
  if(this.showContextByClick == null) return;
  var vcCtl = this.canvas.page.getControl(this.showContextByClick);
  vcCtl.left = this.left;
  vcCtl.top = this.top + this.height;
  if(this.showContext) {
    vcCtl.isShowing = false;
    this.showContext = null;
  } else {
    vcCtl.isShowing = true;
    this.showContext = true;
  }
  vcCtl.refresh();
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.mdiPageButtonMove = function(poPageCtrl) {
  if(!this.id) return;
  
  var poBtn1 = this.document.getElementById(poPageCtrl.id+"_button_1");
  var poBtn2 = this.document.getElementById(poPageCtrl.id+"_button_2");
  var poBtn3 = this.document.getElementById(poPageCtrl.id+"_button_3");
  
  poBtn1.style.left = parseInt(poPageCtrl.width) - (25 + 25 + 35 + 6) + "px";
  poBtn2.style.left = parseInt(poPageCtrl.width) - (25 + 35 + 4) + "px";
  poBtn3.style.left = parseInt(poPageCtrl.width) - (35 + 2) + "px";
};
  
/**
 * 텍스트 박스의 텍스트 세로정렬을 새로고침 합니다.
 * @param {HTMLDiv} poCtrl
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.setInputHeight = function(poCtrl){
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  var vsText = voBtn.value;
  if(vsText == "") voSpan.innerHTML = "&nbsp;";
  else voSpan.innerHTML = vsText;
  //var vnHeight = voSpan.offsetHeight;
  //this.setAttrCtrl("height", vnHeight, voBtn);
}
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.loadComplete = function(poDocument) {
  var voDf = this.df;
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  if(this.canvas.page.metadata.browser.opera){
    this.setInputHeight(voCtrl);
    this.setVerticalAlign(voBtn, voCtrl);
  }
};
/**
 * 수직정렬 처리.
 * @param {HTMLElement} poCtrl 수직정렬 대상 Element
 * @param {HTMLElement} poParent 수직정렬 대상 Element 의 상위 Element
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.setVerticalAlign = function(poCtrl, poParent) {
  var vnHeight = this.subElement.span.offsetHeight;
  var vnParentHeight = parseInt(poParent.style.height);
  var vnPadding = vnParentHeight - vnHeight;
  if(vnPadding < 0) vnPadding = 0;
  vnPadding = vnPadding / 2;
  if(vnParentHeight < vnHeight) vnPadding = 0;
  poCtrl.style.paddingTop = vnPadding + "px";
};
/**
 * setAttrSubCtrl
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voBtn, psAttrValue);
    break;
  case "width" :
    this.setAttrCtrl("width", this.innerWidth, voBtn);
    break;
  case "height" :
    if(this.canvas.page.metadata.browser.opera){
      this.setVerticalAlign(voBtn, poCtrl);
    }
    this.setAttrCtrl("height", this.innerHeight, voBtn);
    break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageButton.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voBtn = this.subElement.button;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  voBtn.className = this.getCSSClass(this, 1);
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.09.21 기존 voDF.disabed는 아예 동작을 안했는데 여기서는 동작이 되서 side effect 생김
  //if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;left:0px;top:0px;border-style:none;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);

  // AlphaImageLoader는 IE 6.0 이하에서 PNG의 투명처리를 위해서 사용되는 비표준 기술임으로 속성으로 빼지않고
  // backgroundImage 속성에 기술되었을 경우에 대해서만 지원한다.
  if(this.backgroundImage) {
    if(this.backgroundImage.indexOf("filter.progid:DXImageTransform.Microsoft.AlphaImageLoader") > -1) {
      var vsSplit = this.backgroundImage.split("\'");
      if(vsSplit[0] == "url(")
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" + vsSplit[2] + "\')");
      else
        vfcSetCssStrBuf(vaCssStrBuf, "filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" + vsSplit[1] + "\')");
    } else {
      vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
      if(voBtn.style["filter"]) voBtn.style["filter"] = "";
    }
  }

  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else if(this.wordWrap == true) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");

  voBtn.style.cssText = vaCssStrBuf.join("");
  if(this.canvas.page.metadata.browser.opera){
  //20091125 최현종 수정 voCtrl -> poCtrl (opera bug)
    this.setVerticalAlign(voBtn, poCtrl, "middle");
  }
  voBtn.innerHTML = this.getLabelText(this.value)
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.refreshSpecificEvents = function(poCtrl) {
  this.setSpecificEvents(poCtrl);
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    if(this.canvas.page.metadata.browser.opera){
      this.setInputHeight(voCtrl);
      this.setVerticalAlign(voBtn, voCtrl, "middle");
    }
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    voCtrl.style[psAttrName] = psAttrValue + "px";
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.setAttrCtrl(psAttrName, this.df[psAttrName] + "px", voCtrl);
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "padding" :
    if(this.paddingLeft == null) this.paddingLeft = this.padding;
    if(this.paddingRight == null) this.paddingRight = this.padding;
    if(this.paddingTop == null) this.paddingTop = this.padding;
    if(this.paddingBottom == null) this.paddingBottom = this.padding;
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voBtn);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voBtn);
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voBtn);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voBtn);
    break;
  case "paddingLeft" :
  case "paddingRight" :
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voBtn);
    break;
  case "backgroundImage" :
    psAttrValue = eXria.controls.xhtml.Util.getBackgroundImagePath(psAttrValue, this.window);
    if(voObj) voObj[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "value" :
    this.setValue(psAttrValue);
    break;
  case "backgroundColor" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
  case "fontFamily" :
  case "fontSize" :
  case "fontStyle" :
  case "fontWeight" :
  case "textAlign" :
  case "textDecoration" :
  case "backgroundPosition":
  case "backgroundRepeat":
    this.setAttrCtrl(psAttrName, psAttrValue, voBtn);
    break;
  case "outerClassName" :
  case "className" :
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * loadData
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null || this.data.isRelativeRef()) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var vsRefValue = this.data.getData();
  this.setValue(vsRefValue);
};
/**
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
};
/**
 * 버튼에 라벨(아이콘 이미지 포함)을 표시합니다.
 * @param {String} psLabel 라벨명
 */
eXria.controls.xhtml.MDIPageButton.prototype.setValue = function(psLabel) {
  var voBtnCtrl = this.subElement.button;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psLabel) {
    vbChanged = true;
  }
  this.value = psLabel;
  if(vbChanged) {
    this.data.setData(this.value);
  }

  voBtnCtrl.innerHTML = this.getLabelText(psLabel);
};
/**
 * 지정된 값을 버튼에 표시할 라벨 텍스트로 변경시켜 주는 메소드입니다.
 * @param {String} psValue 입력 텍스트
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.getLabelText = function(psValue) {
  if(psValue == null) return "";
  this.value = psValue;
//  this.df.value = psValue;

  var vaLabel = psValue.split(";");
  var vaStrBuf = [];
  var vsStr = null;
  vsStr = vaLabel[0];
  if(vsStr) {
    vsStr = vsStr.replace(/</g, "&lt;");
    vsStr = vsStr.replace(/>/g, "&gt;");
    vsStr = vsStr.replace(/\n/g, "<br/>");
    vsStr = eXria.controls.xhtml.Util.parseLang(vsStr);
    vaStrBuf.push(vsStr);
  }
  vsStr = vaLabel[1];
  if(vsStr) {
    vaStrBuf.push("<img src='");
    vaStrBuf.push(vsStr);
    vaStrBuf.push("'>");
  }

  return vaStrBuf.join("");
};
/**
 * 버튼에 표시된 라벨값을 반환합니다.
 * @return 컨트롤 value속성 값
 * @type String
 */
eXria.controls.xhtml.MDIPageButton.prototype.getValue = function() {
  return this.value;
};
/**
 * 버튼의 포커스를 해제합니다.
 */
eXria.controls.xhtml.MDIPageButton.prototype.blur = function() {
  this.ctrl.blur();
};
/**
 * 버튼에 클릭 이벤트를 발생시킵니다.
 */
eXria.controls.xhtml.MDIPageButton.prototype.click  = function() {
  this.ctrl.click();
};
/**
 * 버튼에 포커스를 발생시켜 줍니다.
 */
eXria.controls.xhtml.MDIPageButton.prototype.focus  = function() {
  this.ctrl.focus();
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @private
 */
eXria.controls.xhtml.MDIPageButton.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Button[psAttrName];
  if(vsDefaultValue === undefined) {
    return null;
  }
  return vsDefaultValue;
};
/**
 * 클래스 명을 반환합니다.
 * @return "MDIPageButton"
 * @type String
 */
eXria.controls.xhtml.MDIPageButton.prototype.toString = function() {
  return "MDIPageButton";
};

/**
 * 제목표시줄
 * @member eXria.controls.xhtml
 * @author ParkSC at 13. 4. 8 오후 1:53
 */
eXria.controls.xhtml.MDIPageCaption = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.Label.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.Label, eXria.controls.xhtml.MDIPageCaption);
//////////////////////////////////////////////////////////////////

/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageCaption.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<div class=\"" + vsClass + "\" style=\"");
  vaTemplate.push("@cssStrBuf"); //0
  vaTemplate.push("\">&nbsp;</div>");
  vaTemplate.push("<span style=\"");
  vaTemplate.push("@cssStrBuf"); //1
  vaTemplate.push("\"/>");
  
  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

/**
 * MDIPages의 공통속성을 저장하기 위한 클래스.
 * @version 1.0
 * @constructor
 */
eXria.controls.xhtml.MDIPages = function() {
  /**
   * MDIPages의 보더 색상.
   * @type String
   */
  this.borderColor = null;
  /**
   * MDIPages의 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * MDIPages의 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * MDIPages의 보더의 좌측 부분 두께.
   * @type Number
   */
  this.borderLeftWidth = null;
  /**
   * MDIPages의 보더의 우측 부분 두께.
   * @type Number
   */
  this.borderRightWidth = null;
  /**
   * MDIPages의 보더의 상단 부분 두께.
   * @type Number
   */
  this.borderTopWidth = null;
  /**
   * MDIPages의 보더의 하단 부분 두께.
   * @type Number
   */
  this.borderBottomWidth = null;
  /**
   * MDI 바디에 담긴 컨트롤이 영역을 벗어날때 스크롤 처리.
   * @type String
   */
  this.overflow = null;
  /**
   * MDI 바디에 담긴 컨트롤이 영역을 벗어날때 횡 스크롤 처리.
   * @type String
   */
  this.overflowX = null;
  /**
   * MDI 바디에 담긴 컨트롤이 영역을 벗어날때 종 스크롤 처리.
   * @type String
   */
  this.overflowY = null;
  /**
   * MDIPages의 배경 색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * MDIPages의 적용될 css 클래스 명.
   * @type String
   */
  this.className = null;
  /**
   * MDIPages의 외곽 div에 적용될 css 클래스 명.
   * @type String
   */
  this.outerClassName = null;
  /**
   * MDIPages의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
};

/**
 * @class Concreate xhtml MDIPage.<br>
 * XHTML MDIPage 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIPage 객체
 * @type eXria.controls.xhtml.MDIPage
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @base eXria.controls.MDIGroup
 */
eXria.controls.xhtml.MDIPage = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight =  pnHeight == null ? 300 : pnHeight;

  eXria.controls.MDIGroup.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * movable 속성
   * @type Boolean
   */
  this.movable = true;
  /**
   * 하위 컨트롤들의 readOnly 여부 설정
   * @type Boolean
   */
  this.readOnly = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 하위 컨트롤 id에 붙일 suffix 문자열
   * @type String
   * @private
   */
  this.idSuffix = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * MDIPage 의 최대화 기능 여부.
   * @type Boolean
   * @private
   */
  this.maximize = null;
  /**
   * MDIPage 의 최소화 기능 여부.
   * @type Boolean
   * @private
   */
  this.minimize = null;
  /**
   * MDIPage 의 복원 기능 여부.
   * @type Boolean
   * @private
   */
  this.restore = null;
  /**
   * MDIPage 의 Cursor.
   * @private
   */
  this.cursor = null;
  /*
   * MDIPage의 현재 Left위치
   * @Type Number
   */
  this.currentLeft = null;
  /*
   * MDIPage의 현재 Top위치
   * @Type Number
   */
  this.currentTop = null;
  /*
   * MDIPage의 현재 Width값
   * @Type Number
   */
  this.currentWidth = null;
  /*
   * MDIPage의 현재 Height값
   * @Type Number
   */
  this.currentHeight = null;
  /**
  * @private
  */
  this.impList = new eXria.data.Collection();
  /**
   * MDIPage Body 에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.MDIPageBody
   */
  this.pagebody = new eXria.controls.xhtml.MDIPageBody(psId+"_body", pnLeft, pnTop+20, pnWidth, pnHeight-20);
  this.pagebody.parent = this;
  /**
   * Top_Label 에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.MDIPageCaption
   */
  this.pagecaption = new eXria.controls.xhtml.MDIPageCaption(psId+"_caption", 4, 1, parseInt((pnWidth*0.8)), 18);
  this.pagecaption.parent = this;
  /**
   * MDIPage Button 에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.MDIPageButton
   */
  this.pagebutton_1 = new eXria.controls.xhtml.MDIPageButton(psId+"_button_1", pnWidth - (25 + 25 + 35 + 6), 3, 25, 15);
  this.pagebutton_1.parent = this;
  /**
   * MDIPage Button 에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.MDIPageButton
   */
  this.pagebutton_2 = new eXria.controls.xhtml.MDIPageButton(psId+"_button_2", pnWidth - (25 + 35 + 4), 3, 25, 15);
  this.pagebutton_2.parent = this;
  /**
   * MDIPage Button 에 속성을 저장하기 위한 오브젝트.
   * @type eXria.controls.xhtml.MDIPageButton
   */
  this.pagebutton_3 = new eXria.controls.xhtml.MDIPageButton(psId+"_button_3", pnWidth - (35 + 2), 3, 35, 15);
  this.pagebutton_3.parent = this;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.MDIPage);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.MDIGroup, eXria.controls.xhtml.MDIPage);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.MDIPage.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;
//if(vsType == "change")
  switch(vsType) {
  case "mousedown" :
    break;
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
//  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

/**
 * @ignore
 */
eXria.controls.xhtml.MDIPage.prototype.atmousedown = function(e) {
  if(this.document == null) return;
  var voCanvas = this.canvas;
  // 컨트롤 이동을 처리
  if(this.movable) {
    if(this.document.ondragstart !== "undefined")
    {
      this.document.ondragstart = function() { return false; };
    }
    if((this.top <= (e.clientY-this.parent.top) && (e.clientY-this.parent.top) <= this.top + this.pagecaption.height)){
      this.startMove(e);
      e.stopEvent();
    }     
  } else if(this.dragDrop) {
    if(this.document.ondragstart !== "undefined")
    {
      this.document.ondragstart = function() { return false; };
    }
    this.startDrag(e);
    e.stopEvent();
  }else {
    if(voCanvas.page.metadata.browser.opera) {
    } else {
      this.document.ondragstart = function() { this.body.dragDrop(); };
    }
  }
};

eXria.controls.xhtml.MDIPage.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  
  var voPageCaptionCtrl = poDocument.createElement("div");
  voPageCaptionCtrl["id"] = this.id+"_caption";
  voPageCaptionCtrl["accesskey"] = this.accessKey;
  if(this.canvas.page.metadata.browser.ie > 0) voPageCaptionCtrl["hideFocus"] = true;
  
  voCtrl.appendChild(voPageCaptionCtrl);
  
  this.ctrl = voCtrl;
  this.document = poDocument;
  return voCtrl;
};

eXria.controls.xhtml.MDIPage.prototype.mdiLabelMove = function() {
  var voPageCtrl = this.document.getElementById(this.id);
  var voResizeLabelCtrl = this.document.getElementById(this.id + "_resize");
  this.parent.zIndexSeq++;
  var vnZIndex = this.parent.zIndexSeq;
  
  voResizeLabelCtrl.style.top = (parseInt(voPageCtrl.style.top) + parseInt(voPageCtrl.style.height) - parseInt(voResizeLabelCtrl.style.height)) + "px";
  voResizeLabelCtrl.style.left = (parseInt(voPageCtrl.style.left) + parseInt(voPageCtrl.style.width) - parseInt(voResizeLabelCtrl.style.width)) + "px";
  
  vnZIndex += 200;
  voPageCtrl.style["zIndex"] = vnZIndex;
  voResizeLabelCtrl.style["zIndex"] = vnZIndex+1;
  
  this.parent.zIndexSeq++;
};

eXria.controls.xhtml.MDIPage.prototype.currentCodinate = function(voMdiPage){
  this.currentLeft = voMdiPage.left;
  this.currentTop = voMdiPage.top;
  this.currentHeight = voMdiPage.height;
  this.currentWidth = voMdiPage.width;
};

eXria.controls.xhtml.MDIPage.prototype.startMove = function(e) {
  if (this.disabled == true) {
    return;
  }
  var voDocument = this.document;
  var voParent = this.parent;
  if (voParent == null) voParent = this.canvas;
  var voCtrl = this.getCtrl();
  
  var voGlassPane = new eXria.controls.xhtml.GlassPane(voParent);
  this.glassPane = voGlassPane;
  voGlassPane.opacity = 10;
  voParent.ctrl.parentNode.appendChild(voGlassPane.create(voDocument));
  
  var voPane = this.paneHandler.createPane();
  var voPaneStyle = voPane.style;
  
  var voEvent = e;
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;
  
  this.clientAbsLeft = this.getClientAbsLeft();
  this.clientAbsTop = this.getClientAbsTop();
  
  var vnMouseX = voEvent.e.clientX - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY - this.clientAbsTop;
  
  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;
  
  this.backupCtrlCsr = this.getCtrl().style.cursor;
  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "default";
  this.getCtrl().style.cursor = "default";
  
  voPane.control = this;
  voPane.onmousemove = function(e) {
    this.control.onMove(e);
  };
  voPane.onmouseup = function(e) {
    this.control.stopMove(e);
    this.control.mdiLabelMove(e);
  };
  voDocument.control = this;
  voDocument.onmousemove = function(e) {
    this.control.onMove(e);
  };
  if (typeof voPane.onselectstart != "undefined") {
    voPane.onselectstart = function(e) {
      return false;
    };
  } else {
    voPane.onmousedown = function(e) {
      return false;
    };
  }
}

eXria.controls.xhtml.MDIPage.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
};

eXria.controls.xhtml.MDIPage.prototype.setSpecificAttrs = function(poCtrl, poDocument, psDiv) {
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  
  var voDf = this.df;
  this.setTemplate();
  var vaTemplate = this.template;
  var mdiSubpage = this.parent.mdisubpage;
  var vsOverFlow = null;
  var vaCssStrBuf = null;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;

  if(mdiSubpage) !!mdiSubpage.id? vsOverFlow="hidden": vsOverFlow = "auto";
//  else vsOverFlow = "auto";
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  
  // 2009.10.12 동적인 코드에서는 disabled를 제어하지 않으며 FF에서는 없는 속성이다
  //if(this.disabled) poCtrl["disabled"] = true;

  var vsBackgroundImage = "url("+vsResourceBaseUrl+"/eXria/controls/xhtml/images/groupBack.jpg)";
  var vsBackgroundRepeat = "repeat-x";
  
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "tooltip", this.tooltip);
  vfcSetCssStrBuf(vaCssStrBuf, "disabled", this.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", vsBackgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", vsBackgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", vsOverFlow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", vsOverFlow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", vsOverFlow);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  
  vaCssStrBuf = null;
//  poCtrl.outerHTML = vaTemplate.join("");
  
  /////////////////////////////////////////////////////////////////////////////////////////////////
  //Group 속성 끝//
  ////////////////////////////////////////////////////////////////////////////////////////////////
  
  var voCaptionDf = this.pagecaption;
  var poCaptionCtrl = this.document.getElementById(this.id+"_caption");
  voCaptionDf.setTemplate();
  var vaTemplate = voCaptionDf.template;
  
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 voCaptionDf라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = voCaptionDf.setCssStrBuf;
  var vfcSetAttStrBuf = voCaptionDf.setAttStrBuf;
  var voIndexMap = voCaptionDf.templateIndexMap;
  poCaptionCtrl["tabIndex"] = voCaptionDf.tabIndex;
  
  poCaptionCtrl["tooltip"] = voCaptionDf.tooltip;
  if(voCaptionDf.disabled) poCaptionCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;outline-style:none;");
  if(voCaptionDf.visible == false) vaCssStrBuf.push("display:none;");
//  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", voCaptionDf.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", voCaptionDf.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voCaptionDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", voCaptionDf.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", voCaptionDf.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", voCaptionDf.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", voCaptionDf.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", voCaptionDf.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", voCaptionDf.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", voCaptionDf.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", voCaptionDf.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", voCaptionDf.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", voCaptionDf.borderBottomWidth, "px");

  //외각DIV
  //2010.06.03
  //내부DIV 영역에 스크롤이 생성되는 경우를 막기 위해
  //visible 과 hidden 이 아닌경우에는 auto가 되게 수정
  if(!!voCaptionDf.overflow && !!(voCaptionDf.overflow === "scroll" || voCaptionDf.overflow === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "auto");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", voCaptionDf.overflow);

  if(!!voCaptionDf.overflowX && !!(voCaptionDf.overflowX === "scroll" || voCaptionDf.overflowX === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", auto);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voCaptionDf.overflowX);

  if(!!voCaptionDf.overflowY && !!(voCaptionDf.overflowY === "scroll" || voCaptionDf.overflowY === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voCaptionDf.overflowY);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voCaptionDf.overflowY);


  vfcSetCssStrBuf(vaCssStrBuf, "cursor", voCaptionDf.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voCaptionDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voCaptionDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", voCaptionDf.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", voCaptionDf.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", voCaptionDf.backgroundImage);

  poCaptionCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;position:absolute;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", voCaptionDf.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", voCaptionDf.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", voCaptionDf.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", voCaptionDf.paddingBottom, "px");
  var vnWidth = voCaptionDf.innerWidth;
  if(voCaptionDf.paddingLeft !== null) vnWidth = vnWidth - voCaptionDf.paddingLeft;
  if(voCaptionDf.paddingRight !== null) vnWidth = vnWidth - voCaptionDf.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", voCaptionDf.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", voCaptionDf.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", voCaptionDf.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", voCaptionDf.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", voCaptionDf.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", voCaptionDf.color);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", voCaptionDf.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", voCaptionDf.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  if(voCaptionDf.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else{
    vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
    //2010.06.01
    //영문자 개행 관련 word-wrap 추가
    vfcSetCssStrBuf(vaCssStrBuf, "word-wrap","break-word");
  }

  //2010.06.03
  //내부 div 스크롤 관련 버그 수정
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow", voCaptionDf.overflow);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", voCaptionDf.overflowX);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", voCaptionDf.overflowY);

  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", voCaptionDf.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", voCaptionDf.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", voCaptionDf.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", voCaptionDf.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", voCaptionDf.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", voCaptionDf.textDecoration);
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  poCaptionCtrl.innerHTML = vaTemplate.join("");
  
  voIndexMap.clear();
  vaCssStrBuf = null;
  vaTemplate = null;
  voCaptionDf.template = null;
  voCaptionDf.templateIndexMap = null;
  /////////////////////////////////////////////////////////////////////////////////////////////////
  //MDIPageCaption 속성 끝//
  ////////////////////////////////////////////////////////////////////////////////////////////////
  
};

/*
 * 제목표시줄 value
 */
eXria.controls.xhtml.MDIPage.prototype.setCaptionText = function() {
  var voCaptionDf = this.pagecaption;
  var poCaptionCtrl = this.document.getElementById(voCaptionDf.id);
  
  voCaptionDf.setText(poCaptionCtrl, this.btn.value);
};

eXria.controls.xhtml.MDIPage.prototype.maxMdiPage = function() {
  var voMdiGroup = this.parent;
  
  var vnPageNum = voMdiGroup.getIndexById(this.id);
  var voPageCtrl = voMdiGroup.mdiPageSet.elements[vnPageNum];
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  
  this.currentCodinate(this);
  this.pagebutton_2.applyAttr("backgroundImage", "url("+vsResourceBaseUrl+"/eXria/controls/xhtml/images/minimal.jpg)");
  this.applyAttr("top", 1);
  this.applyAttr("left", 1);
  this.applyAttr("height", voMdiGroup.height - voMdiGroup.titleBarHeight);
  this.applyAttr("width", voMdiGroup.width - 3);
  
  this.pagebody.applyAttr("top", this.pagecaption.height);
  this.pagebody.applyAttr("left", 1);
  this.pagebody.applyAttr("height", this.height - this.pagecaption.height);
  this.pagebody.applyAttr("width", voMdiGroup.width - 3);
  
  this.parent.mdisubpage.applyAttr("height", this.height - this.pagecaption.height);
  this.parent.mdisubpage.applyAttr("width", voMdiGroup.width - 3);
  
  this.pagebutton_2.mdiPageButtonMove(voPageCtrl);
  this.mdiLabelMove();
};

eXria.controls.xhtml.MDIPage.prototype.refreshTemplate = function(poCtrl, poDocument) {
  if(this.setTemplate) this.setTemplate(poCtrl, poDocument);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.refreshTemplate) voChild.refreshTemplate(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPage.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  this.setSpecificDefaults(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificDefaults(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPage.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificAttrs(voChild.ctrl, voChild.document);
  }
};

 eXria.controls.xhtml.MDIPage.prototype.reloadData = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
  if(voChild.reloadData) voChild.reloadData(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPage.prototype.refreshComplete = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshComplete(voChild.ctrl, voChild.document);
  }
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};

eXria.controls.xhtml.MDIPage.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPage.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTable = poCtrl.childNodes[0];

  switch(psAttrName) {
    case "disabled" :
      poCtrl.disabled = psAttrValue;
      this.applyAttrToChildren("disabled", psAttrValue);
      break;
    //case "borderWidth" :
    //  this.innerWidth = this.width - 2 * this.borderWidth;
    //  this.innerHeight = this.height - 2 * this.borderWidth;
    //  poCtrl.style.width = this.innerWidth + "px";
    //  poCtrl.style.height = this.innerHeight + "px";
    //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPage.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
//  var voCtrl = this.lookup(poDocument.id, poDocument);
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
  case "overflow" :
    this.refresh(poDocument);
    break;
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue)
    this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
    var voChild = null;
    var voIterator = this.controls.iterator();
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      if(voChild.refreshVerticalAlign) {
        voChild.refreshVerticalAlign();
      }
    }
    break;
  case "readOnly" :
    this.setReadOnly(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};

eXria.controls.xhtml.MDIPage.prototype.clear = function() {
  this.removeChildren();
  this.clearCtrl();
  this.clearControl();
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPage.prototype.loadComplete = function() {
  this.createChildren();
  this.addChild(this.pagebutton_1);
  this.addChild(this.pagebutton_2);
  this.addChild(this.pagebutton_3);
  this.addChild(this.pagebody);
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  this.pagebutton_1.applyAttr("backgroundImage", "url("+ vsResourceBaseUrl +"/eXria/controls/xhtml/images/up.jpg)");
  this.pagebutton_2.applyAttr("backgroundImage", "url("+ vsResourceBaseUrl +"/eXria/controls/xhtml/images/Enlargement.jpg)");
  this.pagebutton_3.applyAttr("backgroundImage", "url("+ vsResourceBaseUrl +"/eXria/controls/xhtml/images/close.jpg)");
  this.setCaptionText();
  //subpage 일때 max 로 창키움 현재는 막음
//  if(this.pagebody.get(this.id+"_subpage"))  this.maxMdiPage();
  if (this.parent.mdiCallFnc == "addMdiSubPage") this.parent.mdiInitLayout();
  
  if(this.readOnly != null) this.setReadOnly(this.readOnly);
};
/**
 * 컨트롤에 하위 컨트롤를 추가합니다.
 * @param {eXria.controls.xhtml.Control} poControl 추가 대상 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 */
eXria.controls.xhtml.MDIPage.prototype.addChild = function(poControl, poDocument) {
  var that = null;
  if(poControl.id.indexOf("_button_") > -1 || poControl.id.indexOf("_body") > -1) that = this;
  else that = this.pagebody;
  
  var voCanvas = that.canvas;
  if(poDocument == null) poDocument = that.document;
  var voCanvas = that.canvas;
  poControl.parent = that;
  poControl.canvas = voCanvas;
  poControl.window = that.window;
  poControl.document = that.document;
  that.addItem(poControl);
  if(voCanvas) voCanvas.registerControl(poControl);
  var voCtrl = that.getCtrl(poDocument);
  if((that.visible || that.visible == null) && voCtrl) {
    voCtrl.appendChild(poControl.create(poDocument));
    poControl.load(poDocument);
  // TODO 추후 수정
    var name = poControl.toString();
    if(name == "Rectangle" || name == "Roundrect" || name == "Ellipse" ) {poControl.getCtrl(poDocument).blur();};
  }
};
/**
 * 하위 컨트롤을 제거 시킵니다.
 * @param {String} psId 제거대상 컨트롤 id
 */
eXria.controls.xhtml.MDIPage.prototype.removeChild = function(psId) {
  var vnIndex = this.getIndex(psId);
  var voControl = this.controls.remove(vnIndex);
  voControl.clear();
};
/**
 * 하위 컨트롤 id에 매칭되는 컨트롤 식별 인덱스 번호를 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 하위 컨트롤 식별 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.MDIPage.prototype.getIndex = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vnIndex = -1;
  while(voIterator.hasNext()) {
    vnIndex++;
    voControl = voIterator.next();
    if (voControl.id == psId) break;
  }
  return vnIndex;
};
/**
 * 지정된 id에 해당하는 하위 컨트롤을 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 지정된 id에 해당하는 하위 컨트롤 객체
 * @type eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.MDIPage.prototype.get = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    if (voControl.id == psId) { return voControl; }
  }
  return null;
};
/**
 * 포함된 하위 컨트롤의 실체화 객체를 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {String} psIdSuffix 실체화된 컨트롤 id에 따라붙을 문자열
 * @private
 */
eXria.controls.xhtml.MDIPage.prototype.createChildren = function(poDocument, psIdSuffix) {
  if(poDocument == null) poDocument = this.document;
  if(psIdSuffix == null && this.idSuffix) psIdSuffix = this.idSuffix;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    vsId = voControl.id;
    if(psIdSuffix != null) voControl.id += psIdSuffix;
    if(voControl.canvas == null) {
      voControl.canvas = this.canvas;
      voControl.window = this.window;
      voControl.document = this.document;
      this.canvas.registerControl(voControl);
    }
    if(voControl.toString() != "Timer") {
      this.appendChild(voControl.create(poDocument), poDocument);
      //voControl.refresh(poDocument);
      voControl.load(this.document);
    }
    voControl.id = vsId;
  }
};
/**
 * 하위 컨트롤에 일괄적으로 속성을 적용합니다.
 * @param {String} psAttrValue 지정된 속성값
 * @param {String} psAttrName 속성명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.MDIPage.prototype.applyAttrToChildren = function(psAttrName, psAttrValue, poDocument) {
  if(this.getCtrl(poDocument) == null) return;

  var voIterator = this.controls.iterator();
  var voControl = null;
  var voCtrl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    voCtrl = voControl.getCtrl(poDocument);
    if(voCtrl) voControl.applyAttr(psAttrName, psAttrValue, poDocument);
  }
};
/**
 * 모든 하위 컨트롤을 제거 시킵니다.
 */
eXria.controls.xhtml.MDIPage.prototype.removeChildren = function() {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
//debugger;
    this.canvas.unregisterControl(voControl.id);
    if(voControl.toString() == "SubPage") {
//      var voWindow = voControl.ctrl.contentWindow;
//      if(voWindow) {
//        voWindow.close();
//      }
        voControl.setSrc("javascript:false");
    }
    voControl.clear();
  }
  this.controls.clear();
};

eXria.controls.xhtml.MDIPage.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.MDIGroup.mdipages.mdipage[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 하위 컨트롤의 readOnly속성을 설정
 * @param {String} pbEnable readOnly속성을 활성화할지 여부
 */
eXria.controls.xhtml.MDIPage.prototype.setReadOnly = function(pbEnable) {
  var voIterator = this.controls.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.readOnly !== undefined) voChild.applyAttr("readOnly", pbEnable);
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "MDIPage"
 * @type String
 */
eXria.controls.xhtml.MDIPage.prototype.toString = function() {
  return "MDIPage";
};

/**
 * @class Concreate xhtml MDIPageBody.<br>
 * XHTML MDIPageBody 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIPageBody 객체
 * @type eXria.controls.xhtml.MDIPageBody
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @base eXria.controls.MDIGroup
 */
eXria.controls.xhtml.MDIPageBody = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight =  pnHeight == null ? 300 : pnHeight;

  eXria.controls.MDIGroup.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight); // UIControl을 상속받는다.
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * movable 속성
   * @type Boolean
   */
  this.movable = null;
  /**
   * 하위 컨트롤들의 readOnly 여부 설정
   * @type Boolean
   */
  this.readOnly = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 하위 컨트롤 id에 붙일 suffix 문자열
   * @type String
   * @private
   */
  this.idSuffix = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  
  this.cursor = null;
  /**
  * @private
  */
  this.impList = new eXria.data.Collection();
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.MDIPageBody);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.MDIGroup, eXria.controls.xhtml.MDIPageBody);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.MDIPageBody.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;
//if(vsType == "change")
  switch(vsType) {
  case "mousedown" :
    break;
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

eXria.controls.xhtml.MDIPageBody.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  
  this.ctrl = voCtrl;
  this.document = poDocument;
  return voCtrl;
};

eXria.controls.xhtml.MDIPageBody.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
};

eXria.controls.xhtml.MDIPageBody.prototype.setSpecificAttrs = function(poCtrl, poDocument, psDiv) {
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;

  var voDf = this.df;
  this.setTemplate();
  var vaTemplate = this.template;
  var vaCssStrBuf = null;
  var voParent = this.parent;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  
  // 2009.10.12 동적인 코드에서는 disabled를 제어하지 않으며 FF에서는 없는 속성이다
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "tooltip", this.tooltip);
  vfcSetCssStrBuf(vaCssStrBuf, "disabled", this.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", (this.parent.top + 20), "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", 0, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");
  
  vaCssStrBuf = null;
//  poCtrl.outerHTML = vaTemplate.join("");
  
  /////////////////////////////////////////////////////////////////////////////////////////////////
  //MDIPageBody 속성 끝//
  ////////////////////////////////////////////////////////////////////////////////////////////////
};

eXria.controls.xhtml.MDIPageBody.prototype.refreshTemplate = function(poCtrl, poDocument) {
  if(this.setTemplate) this.setTemplate(poCtrl, poDocument);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.refreshTemplate) voChild.refreshTemplate(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPageBody.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  this.setSpecificDefaults(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificDefaults(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPageBody.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificAttrs(voChild.ctrl, voChild.document);
  }
};

 eXria.controls.xhtml.MDIPageBody.prototype.reloadData = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
  if(voChild.reloadData) voChild.reloadData(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIPageBody.prototype.refreshComplete = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshComplete(voChild.ctrl, voChild.document);
  }
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};

eXria.controls.xhtml.MDIPageBody.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageBody.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTable = poCtrl.childNodes[0];

  switch(psAttrName) {
    case "disabled" :
      poCtrl.disabled = psAttrValue;
      this.applyAttrToChildren("disabled", psAttrValue);
      break;
    //case "borderWidth" :
    //  this.innerWidth = this.width - 2 * this.borderWidth;
    //  this.innerHeight = this.height - 2 * this.borderWidth;
    //  poCtrl.style.width = this.innerWidth + "px";
    //  poCtrl.style.height = this.innerHeight + "px";
    //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageBody.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
//  var voCtrl = this.lookup(poDocument.id, poDocument);
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
  case "overflow" :
    this.refresh(poDocument);
    break;
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue)
    this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
    var voChild = null;
    var voIterator = this.controls.iterator();
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      if(voChild.refreshVerticalAlign) {
        voChild.refreshVerticalAlign();
      }
    }
    break;
  case "readOnly" :
    this.setReadOnly(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};

eXria.controls.xhtml.MDIPageBody.prototype.clear = function() {
  this.removeChildren();
  this.clearCtrl();
  this.clearControl();
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageBody.prototype.loadComplete = function() {
  this.createChildren();
  if(this.readOnly != null) this.setReadOnly(this.readOnly);
};
/**
 * 컨트롤에 하위 컨트롤를 추가합니다.
 * @param {eXria.controls.xhtml.Control} poControl 추가 대상 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 */
eXria.controls.xhtml.MDIPageBody.prototype.addChild = function(poControl, poDocument) {
  if(poDocument == null) poDocument = this.document;
  var voCanvas = this.canvas;
  poControl.parent = this;
  poControl.canvas = voCanvas;
  poControl.window = this.window;
  poControl.document = this.document;
  this.addItem(poControl);
  if(voCanvas) voCanvas.registerControl(poControl);
  var voCtrl = this.getCtrl(poDocument);
  if((this.visible || this.visible == null) && voCtrl) {
    voCtrl.appendChild(poControl.create(poDocument));
    poControl.load(poDocument);
  // TODO 추후 수정
    var name = poControl.toString();
    if(name == "Rectangle" || name == "Roundrect" || name == "Ellipse" ) {poControl.getCtrl(poDocument).blur();};
  }
};
/**
 * 하위 컨트롤을 제거 시킵니다.
 * @param {String} psId 제거대상 컨트롤 id
 */
eXria.controls.xhtml.MDIPageBody.prototype.removeChild = function(psId) {
  var vnIndex = this.getIndex(psId);
  var voControl = this.controls.remove(vnIndex);
  voControl.clear();
};
/**
 * 하위 컨트롤 id에 매칭되는 컨트롤 식별 인덱스 번호를 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 하위 컨트롤 식별 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.MDIPageBody.prototype.getIndex = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vnIndex = -1;
  while(voIterator.hasNext()) {
    vnIndex++;
    voControl = voIterator.next();
    if (voControl.id == psId) break;
  }
  return vnIndex;
};
/**
 * 지정된 id에 해당하는 하위 컨트롤을 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 지정된 id에 해당하는 하위 컨트롤 객체
 * @type eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.MDIPageBody.prototype.get = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    if (voControl.id == psId) { return voControl; }
  }
  return null;
};
/**
 * 포함된 하위 컨트롤의 실체화 객체를 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {String} psIdSuffix 실체화된 컨트롤 id에 따라붙을 문자열
 * @private
 */
eXria.controls.xhtml.MDIPageBody.prototype.createChildren = function(poDocument, psIdSuffix) {
  if(poDocument == null) poDocument = this.document;
  if(psIdSuffix == null && this.idSuffix) psIdSuffix = this.idSuffix;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    vsId = voControl.id;
    if(psIdSuffix != null) voControl.id += psIdSuffix;
    if(voControl.canvas == null) {
      voControl.canvas = this.canvas;
      voControl.window = this.window;
      voControl.document = this.document;
      this.canvas.registerControl(voControl);
    }
    if(voControl.toString() != "Timer") {
      this.appendChild(voControl.create(poDocument), poDocument);
      //voControl.refresh(poDocument);
      voControl.load(this.document);
    }
    voControl.id = vsId;
  }
};
/**
 * 하위 컨트롤에 일괄적으로 속성을 적용합니다.
 * @param {String} psAttrValue 지정된 속성값
 * @param {String} psAttrName 속성명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.MDIPageBody.prototype.applyAttrToChildren = function(psAttrName, psAttrValue, poDocument) {
  if(this.getCtrl(poDocument) == null) return;

  var voIterator = this.controls.iterator();
  var voControl = null;
  var voCtrl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    voCtrl = voControl.getCtrl(poDocument);
    if(voCtrl) voControl.applyAttr(psAttrName, psAttrValue, poDocument);
  }
};
/**
 * 모든 하위 컨트롤을 제거 시킵니다.
 */
eXria.controls.xhtml.MDIPageBody.prototype.removeChildren = function() {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    this.canvas.unregisterControl(voControl.id);
    if(voControl.toString() == "SubPage") {
//      var voWindow = voControl.ctrl.contentWindow;
//      if(voWindow) {
//        voWindow.close();
//      }
//        voControl.setSrc("javascript:false");
    }
    voControl.clear();
  }
  this.controls.clear();
};

eXria.controls.xhtml.MDIPageBody.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.MDIGroup.mdipages.mdipage[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 하위 컨트롤의 readOnly속성을 설정
 * @param {String} pbEnable readOnly속성을 활성화할지 여부
 */
eXria.controls.xhtml.MDIPageBody.prototype.setReadOnly = function(pbEnable) {
  var voIterator = this.controls.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.readOnly !== undefined) voChild.applyAttr("readOnly", pbEnable);
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "MDIPageBody"
 * @type String
 */
eXria.controls.xhtml.MDIPageBody.prototype.toString = function() {
  return "MDIPageBody";
};

/**
 * @class MDIPage의 사이즈를 조절하기 위한 컨트롤 클래스입니다. <br />
 * XHTML MDIPageResize Contorl.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIPageResize 객체
 * @type eXria.controls.xhtml.MDIPageResize
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */

eXria.controls.xhtml.MDIPageResize = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 30 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 텍스트에 줄을 넣을때.
   * "underline" | "overline" | "line-through" | "blink"
   * @type String
   */
  this.textDecoration = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 컨트롤에 표시될 텍스트 폰트두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 컨트롤에 설정된 값.
   * @type String
   */
  this.value  = null;
  /**
   * movable
   * @type Boolean
   */
  this.movable = true;
  /**
   * 텍스트 가로 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 텍스트 세로 정렬 방식.
   * @type String
   */
  this.verticalAlign = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflow = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowX = null;
  /**
   * 라벨 컨텐츠 오버플로우 타입.
   * @type String
   */
  this.overflowY = null;
  /**
   * 자동줄바꿈 여부.
   * @type Boolean
   */
  this.wordWrap = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @ignore
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @ignore
   */
  this.innerHeight = this.height;
  /**
   * 컨트롤의 텍스트 패딩
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤의 상단 패딩
   * @type Number
   * @private
   */
  this.paddingTop = null;
  /**
   * 컨트롤의 우측 패딩
   * @type Number
   * @private
   */
  this.paddingRight = null;
  /**
   * 컨트롤의 하단 패딩
   * @type Number
   * @private
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 좌측 패딩
   * @type Number
   * @private
   */
  this.paddingLeft = null;
  /**
   * 컨트롤이 디스플레이 되는 document객체 지정
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  /**
   * 버튼의 배경이미지 url.
   * @type String
   */
  this.backgroundImage = null;
  /**
   * 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   */
  this.backgroundRepeat = null;
  /**
   * 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   */
  this.backgroundPosition = null;

  /**
  * @private
  */
  this.divOffsetHeight = null;
  /**
  * @private
  */
  this.subElement = {};
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.MDIPageResize);
//////////////////////////////////////////////////////////////////
// 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  voCtrl["accesskey"] = this.accessKey;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  
  this.document = poDocument;
  this.ctrl = voCtrl;

  return voCtrl;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.setTemplate = function(poCtrl, poDocument) {
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<div class=\"" + vsClass + "\" style=\"");
  vaTemplate.push("@cssStrBuf"); //0
  vaTemplate.push("\">&nbsp;</div>");

  this.templateIndexMap = eXria.controls.xhtml.Util.getTemplateIndexMap(vaTemplate);
};

eXria.controls.xhtml.MDIPageResize.prototype.startMove = function(e) {
  if (this.disabled == true) {
    return;
  }
  var voDocument = this.document;
  var voParent = this.parent;
  if (voParent == null) voParent = this.canvas;
  var voCtrl = this.getCtrl();
  
  var voGlassPane = new eXria.controls.xhtml.GlassPane(voParent);
  this.glassPane = voGlassPane;
  voGlassPane.opacity = 10;
  voParent.ctrl.parentNode.appendChild(voGlassPane.create(voDocument));
  
  var voPane = this.paneHandler.createPane();
  var voPaneStyle = voPane.style;
  
  var voEvent = e;
  var voTarget = voEvent.target;
  this.mode = voTarget.style.cursor;
  
  this.clientAbsLeft = this.getClientAbsLeft();
  this.clientAbsTop = this.getClientAbsTop();
  
  var vnMouseX = voEvent.e.clientX - this.clientAbsLeft;
  var vnMouseY = voEvent.e.clientY - this.clientAbsTop;
  
  var vnPaneLeft = parseInt(voPaneStyle.left);
  var vnPaneTop = parseInt(voPaneStyle.top);
  this.leftOffset = vnPaneLeft - vnMouseX;
  this.topOffset = vnPaneTop - vnMouseY;
  
  this.backupCtrlCsr = this.getCtrl().style.cursor;
  voPaneStyle.display = "block";
  voDocument.body.style.cursor = "se-resize";
  this.getCtrl().style.cursor = "se-resize";
  
  voPane.control = this;
  voPane.onmousemove = function(e) {
    this.control.onMove(e);
  };
  voPane.onmouseup = function(e) {
    this.control.stopMove(e);
    this.control.mdiMove(e);
  };
  voDocument.control = this;
  voDocument.onmousemove = function(e) {
    this.control.onMove(e);
  };
  if (typeof voPane.onselectstart != "undefined") {
    voPane.onselectstart = function(e) {
      return false;
    };
  } else {
    voPane.onmousedown = function(e) {
      return false;
    };
  }
}

eXria.controls.xhtml.MDIPageResize.prototype.mdiMove = function(poEvent) {
  var vsPageId = this.id.substr(0, this.id.indexOf("_resize"));
  var vnPageNum = this.parent.getIndexById(vsPageId);
  var voMdiPage = this.parent.mdiPageSet.elements[vnPageNum];
  var voPageCtrl = this.document.getElementById(vsPageId);
  var voResizeLabelCtrl = this.document.getElementById(this.id);
  this.parent.zIndexSeq++;
  var vnZIndex = this.parent.zIndexSeq;
  var voMdiSubpage = null;
  if(voMdiPage.pagebody.controls) {
    var vnPageBodyCtrlCnt = voMdiPage.pagebody.controls.size();
    var voCtrl = null;
    for(var i = 0; i < vnPageBodyCtrlCnt; i++){
      voCtrl = voMdiPage.pagebody.controls.elements[i];
      if(voCtrl.toString() == "SubPage") voMdiSubpage = voCtrl;
    }
  }
  
  if(parseInt(voResizeLabelCtrl.style.top) + parseInt(voResizeLabelCtrl.style.height) < parseInt(voPageCtrl.style.top)
    || parseInt(voResizeLabelCtrl.style.left) + parseInt(voResizeLabelCtrl.style.width) < parseInt(voPageCtrl.style.left)
    || parseInt(voResizeLabelCtrl.style.left) + parseInt(voResizeLabelCtrl.style.width) > voPageCtrl.parentNode.offsetWidth){
    //group 컨트롤의 범위를 넘어갔을때
    voMdiPage.applyAttr("height", parseInt(voPageCtrl.style.height) / 2 + 1);
    voMdiPage.applyAttr("width", parseInt(voPageCtrl.style.width) / 2 + 2);
    
    voMdiPage.pagebody.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
    voMdiPage.pagebody.applyAttr("width", voMdiPage.width);

    this.applyAttr("top", parseInt(voPageCtrl.style.top) + parseInt(voPageCtrl.style.height) - parseInt(voResizeLabelCtrl.style.height));
    this.applyAttr("left", parseInt(voPageCtrl.style.left) + parseInt(voPageCtrl.style.width) - parseInt(voResizeLabelCtrl.style.width));
  }else{
    voMdiPage.applyAttr("height", parseInt(voResizeLabelCtrl.style.top) + parseInt(voResizeLabelCtrl.style.height) - parseInt(voPageCtrl.style.top) + 2);
    voMdiPage.applyAttr("width", parseInt(voResizeLabelCtrl.style.left) + parseInt(voResizeLabelCtrl.style.width) - parseInt(voPageCtrl.style.left) + 2);
    
    voMdiPage.pagebody.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
    voMdiPage.pagebody.applyAttr("width", voMdiPage.width);
    
    if(voMdiSubpage){
      voMdiSubpage.applyAttr("height", voMdiPage.height - voMdiPage.pagecaption.height);
      voMdiSubpage.applyAttr("width", voMdiPage.width);
    }
  }
  voMdiPage.pagebutton_2.mdiPageButtonMove(voMdiPage);
  
  vnZIndex += 200;
  voPageCtrl.style["zIndex"] = vnZIndex;
  voResizeLabelCtrl.style["zIndex"] = vnZIndex+1;
  
  this.parent.zIndexSeq++;
};

/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.refreshTemplate = null;
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    this.innerHTML = voUserAttr.innerHTML;
    if(voUserAttr.useHtmlTag != null &&  voUserAttr.useHtmlTag === true){
      this.value = "";
      this.innerHTML = this.data.getData();
    }
    this.funcNec = voUserAttr.funcNec;
    this.labelName = voUserAttr.labelName;
    this.type = voUserAttr.type;
  }
  if(this.type == "SPLITTER") {
    if(this.height > this.width) this.type = "HSPLITTER";
    else this.type = "VSPLITTER";
    this.ltCtls = voUserAttr.ltCtls ? voUserAttr.ltCtls : [];
    this.rbCtls = voUserAttr.rbCtls ? voUserAttr.rbCtls : [];
  }
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.verticalAlign = this.getAttrValue("verticalAlign", this.verticalAlign);
  this.value = this.getAttrValue("value", this.value);
  this.imagePushed = this.getAttrValue("imagePushed", this.imagePushed);
  this.imageFocused = this.getAttrValue("imageFocused", this.imageFocused);
  this.imageMouseover = this.getAttrValue("imageMouseover", this.imageMouseover);
  this.wordWrap = this.getAttrValue("wordWrap", this.wordWrap);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  // 반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  // 단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;
  var voIndexMap = this.templateIndexMap;
  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;
  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;outline-style:none;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
//  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");

  //외각DIV
  //2010.06.03
  //내부DIV 영역에 스크롤이 생성되는 경우를 막기 위해
  //visible 과 hidden 이 아닌경우에는 auto가 되게 수정
  if(!!this.overflow && !!(this.overflow === "scroll" || this.overflow === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "auto");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);

  if(!!this.overflowX && !!(this.overflowX === "scroll" || this.overflowX === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", auto);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);

  if(!!this.overflowY && !!(this.overflowY === "scroll" || this.overflowY === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  this.backgroundImage = "url("+vsResourceBaseUrl+"/eXria/controls/xhtml/images/resizeJ.jpg)";

  vfcSetCssStrBuf(vaCssStrBuf, "cursor", "se-resize");
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "#f0f0f0");
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;position:absolute;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else{
    vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
    //2010.06.01
    //영문자 개행 관련 word-wrap 추가
    vfcSetCssStrBuf(vaCssStrBuf, "word-wrap","break-word");
  }

  //2010.06.03
  //내부 div 스크롤 관련 버그 수정
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  vaTemplate[voIndexMap.get(0)] = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vaTemplate[voIndexMap.get(1)] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");
  
  voIndexMap.clear();
  vaCssStrBuf = null;
  vaTemplate = null;
  this.template = null;
  this.templateIndexMap = null;

  this.setSubElement(poDocument);
};
/**
 * @ignroe
 */
eXria.controls.xhtml.MDIPageResize.prototype.setSpecificEvents = function(poCtrl) {
  if(this.type != "HSPLITTER" && this.type != "VSPLITTER") return;
  this.movable = true;
  this.onMove = function(e) {
    var voCtrl = this.getCtrl();
    var voParentNode = voCtrl.parentNode;
    var voPaneCtrl = this.paneHandler.getCtrl();
    if(voCtrl == null || voPaneCtrl == null) {
        return;
    }

    var voStyle = voPaneCtrl.style;

    var voEvent = new eXria.event.Event(e, this.window);
    var voTarget = voEvent.target;
    if(voTarget == voPaneCtrl || voTarget == voPaneCtrl.parentNode) {
    } else {
      return;
    }
    var vnMouseX = voEvent.e.clientX; // - this.clientAbsLeft;
    var vnMouseY = voEvent.e.clientY; // - this.clientAbsTop;

    var vnNewLeft = vnMouseX + this.leftOffset;
    var vnNewTop = vnMouseY + this.topOffset;

    if(voParentNode.style.left == null || voParentNode.style.left == "") voParentNode.style.left = 0;
    if(voParentNode.style.top == null || voParentNode.style.top == "") voParentNode.style.top = 0;
    if(this.type == "HSPLITTER") voStyle.left = vnNewLeft + "px";
    else voStyle.top = vnNewTop + "px";
  };

  this.stopMove = function(e) {
    if (this.disabled == true) { return; }

    var voDocument = this.document;
    var voCtrl = this.getCtrl();
    var voPane = this.paneHandler.getCtrl();
    var voPaneStyle = voPane.style;

    var voParent = this.parent;
    if(voParent == null) voParent = this.canvas;
    var vnOldPos = null;
    if(this.type == "HSPLITTER") {
      vnOldPos = this.left;
      this.left = parseInt(voPaneStyle.left);
      if(this.left < 0) this.left = 0;
      else if(this.left + this.width > voParent.width) this.left = voParent.width - this.width;
      this.resizeHorz(this.left - vnOldPos);
    } else {
      vnOldPos = this.top;
      this.top = parseInt(voPaneStyle.top);
      if(this.top < 0) this.top = 0;
      else if(this.top + this.height > voParent.height) this.top = voParent.height - this.height;
      this.resizeVert(this.top - vnOldPos);
    }
    this.refresh();
    this.paneHandler.removePane();
    this.glassPane.removeCtrl();
    // Check
    voDocument.body.style.cursor = 'auto';
    voCtrl.style.cursor = this.backupCtrlCsr;

    voPane.onmousemove = null;
    voPane.onmouseup = null;
    voDocument.onmousemove = null;
    voDocument.onmouseup = null;
    if (typeof voPane.onselectstart != "undefined") {
      voPane.onselectstart = null;
    } else {
      voPane.onmousedown = null;
    }

    this.mode = null;
    this.leftOffset = -1;
    this.topOffset = -1;
    this.rightOffset = -1;
    this.bottomOffset = -1;
  };
};
/**
 * setSubElement
 * @param {HTMLElement} poCtrl 실체화 컨트롤
 * @private
 */
eXria.controls.xhtml.MDIPageResize.prototype.setSubElement = function(poDocument) {
  var voCtrl = this.ctrl;
  var voSubElement = this.subElement;
  voSubElement.div = this.getSubCtrl("div", voCtrl, poDocument);
  voSubElement.span = this.getSubCtrl("span", voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var voDivCtrl = this.subElement.div;
  var voSpanCtrl = this.subElement.span;
  var vaCssStrBuf = null;
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  if(this.disabled) poCtrl["disabled"] = true;

  if(this.className) voDivCtrl.className = this.getCSSClass(this, 1);

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");

  //외각DIV
  //2010.06.03
  //내부DIV 영역에 스크롤이 생성되는 경우를 막기 위해
  //visible 과 hidden 이 아닌경우에는 auto가 되게 수정
  if(!!this.overflow && !!(this.overflow === "scroll" || this.overflow === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", "auto");
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);

  if(!!this.overflowX && !!(this.overflowX === "scroll" || this.overflowX === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", auto);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);

  if(!!this.overflowY && !!(this.overflowY === "scroll" || this.overflowY === "auto"))
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  else
    vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;position:absolute;left:0px;top:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
//  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  var vnWidth = this.innerWidth;
  if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
  if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  //vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");

  if(this.wordWrap == false) vfcSetCssStrBuf(vaCssStrBuf, "white-space", "nowrap");
  else{
    vfcSetCssStrBuf(vaCssStrBuf, "white-space", "normal");
    //2010.06.01
    //영문자 개행 관련 word-wrap 추가
    vfcSetCssStrBuf(vaCssStrBuf, "word-wrap","break-word");
  }

  //2010.06.03
  //내부 div 스크롤 관련 버그 수정
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  //vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);

  voDivCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = [];
  vaCssStrBuf.push("visibility:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  voSpanCtrl.style.cssText = vaCssStrBuf.join("");
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;

  switch(psAttrName) {
  case "width" :
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    if(vnWidth < 0) vnWidth = 0;
    this.setAttrCtrl("width", vnWidth, voDiv);
    //var vsLabel = this.getWordWrapped(this.value, voSpan);
    var vsLabel = this.value;
    this.setText(voDiv, vsLabel);
    this.setVerticalAlign(voDiv, poCtrl, this.verticalAlign);
    break;
  case "height" :
    this.setVerticalAlign(voDiv, poCtrl, this.verticalAlign);
    break;
  }
};
/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MDIPageResize.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;
  var vaAttrName = psAttrName.split(".");
  var voDf = this.df;
  this.setAttr(psAttrName, psAttrValue);
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
//  if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    voCtrl.style[psAttrName] = psAttrValue + "px";
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "padding" :
    this.paddingTop = this.padding;
    this.paddingRight = this.padding;
    this.paddingBottom = this.padding;
    this.paddingLeft = this.padding;
    this.setAttrCtrl("paddingTop", this.paddingTop + "px", voDiv);
    this.setAttrCtrl("paddingRight", this.paddingRight + "px", voDiv);
    this.setAttrCtrl("paddingBottom", this.paddingBottom + "px", voDiv);
    this.setAttrCtrl("paddingLeft", this.paddingLeft + "px", voDiv);
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    this.setAttrCtrl("Width", vnWidth, voDiv);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "paddingTop" :
  case "paddingBottom" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
    this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
    break;
  case "paddingLeft" :
  case "paddingRight" :
    this.setAttrCtrl(psAttrName, psAttrValue + "px", voDiv);
    var vnWidth = this.innerWidth;
    if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
    if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
    this.setAttrCtrl("Width", vnWidth, voDiv);
    break;
  break;
  case "value" :
    this.setValue(psAttrValue);
    break;
  case "outerClassName" :
  case "className" :
    this.refresh(poDocument);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};
/**
 * 데이타 로딩완료 후에 처리작업을 수행합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MDIPageResize.prototype.loadComplete = function(poDocument) {
  if(this.value == null) this.value = "";
  if(this.value == "" && this.innerHTML) {
    this.subElement.div.innerHTML = this.innerHTML;
    this.setVerticalAlign(this.subElement.div, this.ctrl, this.verticalAlign);
  } else {
    this.setValue(this.value);
  }
};
/**
 * loadData.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.MDIPageResize.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;

  if(!!this.innerHTML) this.value = "";
  else this.value = this.data.getData();

//  this.value = this.data.getData();
//  this.df.value = this.value;
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
  this.loadComplete(poDocument);
};
/**
 * 컨트롤에 값을 설정합니다.
 * @param {String} psLabel 컨트롤에 설정할 라벨 값
 */
eXria.controls.xhtml.MDIPageResize.prototype.setValue = function(psLabel) {
  var voCtrl = this.ctrl;
  var voDiv = this.subElement.div;
  var voSpan = this.subElement.span;
  var voDf = this.df;
  var vbChanged = false;
  if(this.onchangeInitValue !== undefined && this.onchangeInitValue != psLabel) {
    vbChanged = true;
  }
  this.onchangeInitValue = psLabel;
  this.value = psLabel;
//  this.df.value = psLabel;
  if(vbChanged) this.data.setData(this.value);

  //var vsLabel = this.getWordWrapped(psLabel, voSpan);
  var vsLabel = "" + psLabel;
  if(this.funcNec) {
    this.funcNec(this, voDiv, vsLabel);
  } else {
    this.setText(voDiv, vsLabel);
  }
  this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
  var vnWidth = voCtrl.offsetWidth - this.borderLeftWidth - this.borderRightWidth;;
  var vnPaddingLeft = parseInt(this.getStyleCurrentValue(voDiv, "padding-left", "paddingLeft"), 10);
  var vnPaddingRight = parseInt(this.getStyleCurrentValue(voDiv, "padding-right", "paddingRight"), 10);
  if(vnPaddingLeft > 0 || vnPaddingRight > 0) {
  if(vnWidth > 0)
      this.setAttrCtrl("width", vnWidth - (vnPaddingRight+vnPaddingLeft), this.subElement.div);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.getWordWrapped = function(psLabel, poSpan) {
  var voDf = this.df;
  psLabel = eXria.controls.xhtml.Util.parseLang(psLabel);
  var vsLabel = "";
  if(psLabel != null) {
    if(this.wordWrap == false) {
      //var vnStrLen = Math.round(vsLabel.length * this.fontSize / 0.75); //pt -> px : pt / 0.75
      //voSpan.innerHTML = psLabel;
      //this.setAttrCtrl("width", voSpan.offsetWidth, voDiv);
      vsLabel = psLabel;
    } else {
      var voIdxCollection = new eXria.data.ArrayCollection();
      var vnSt = 0;
      for(var i = 1; i < psLabel.length; i++) {
        poSpan.innerHTML = psLabel.substring(vnSt, i);
        var vnWidth = this.innerWidth;
        if(this.paddingLeft !== null) vnWidth = vnWidth - this.paddingLeft;
        if(this.paddingRight !== null) vnWidth = vnWidth - this.paddingRight;
        if(poSpan.offsetWidth > vnWidth) {
          vnSt = i - 1;
          voIdxCollection.add(vnSt);
        } else if(psLabel.substring(vnSt, i).indexOf("\n") != -1) {
          vnSt = i - 1;
          psLabel = psLabel.substring(0, vnSt) + psLabel.substring(vnSt + 1);
          voIdxCollection.add(vnSt)
          i--;
        }
      }
      var voIterator = voIdxCollection.iterator();
      vnSt = 0;
      var vnIdx = 0;
      while(voIterator.hasNext()) {
        vnIdx = voIterator.next();
        vsLabel += psLabel.substring(vnSt, vnIdx) + "\n";
        vnSt = vnIdx;
      }
      vsLabel += psLabel.substring(vnSt);
    }
  }
  return vsLabel;
};
/**
 * 컨트롤에 할당된 값을 반환합니다.
 * @return 컨트롤에 할당된 값
 * @type String
 */
eXria.controls.xhtml.MDIPageResize.prototype.getValue = function() {
  return this.value;
};
/**
 * 컨트롤 텍스트 수직정렬을 새로고침 합니다.
 */
eXria.controls.xhtml.MDIPageResize.prototype.refreshVerticalAlign = function() {
  var voCtrl = this.ctrl;
  if(voCtrl == null) return;
  var voDf = this.df;
  var voDiv = this.subElement.div;
  this.setVerticalAlign(voDiv, voCtrl, this.verticalAlign);
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.MDIPageResize.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vsDefaultValue = eXria.controls.xhtml.Default.Label[psAttrName];
  if(vsDefaultValue === undefined) {
    return null;
  }
  if((psAttrName == "backgroundImage")
  && vsDefaultValue != null) {
    if(vsDefaultValue.indexOf("http://") != -1) {
      vsDefaultValue = "url(" + this.canvas.page.metadata.resourceBaseUrl + vsDefaultValue + ")";
    } else {
      vsDefaultValue = "url(" + vsDefaultValue + ")";
    }
  }
  return vsDefaultValue;
};
/** MDIPageResize 컨트롤의 Vertical Align을 설정한다
 * @private
 */
// IE6의 예외 처리문제로 추가 되었으며 UIControl에서 if..else문대신 재정의 형태로 함
eXria.controls.xhtml.MDIPageResize.prototype.setVerticalAlign = function(poCtrl, poParent, psVAlign) {
  if(poCtrl.offsetHeight !== 0)
    this.divOffsetHeight = poCtrl.offsetHeight;

  if(!this.divOffsetHeight)
  this.divOffsetHeight = 0;

  var vnHeight = this.divOffsetHeight;

  if(this.canvas.page.metadata.browser.ie == 6) {
    var voFont = this.getStyleCurrentValue(poCtrl, "font-size", "fontSize");
    vnHeight = parseInt(voFont);
    vnHeight = vnHeight * 1.333;
    // IE6에서  특정 높이보다 작아지면 높이를 제대로 못가져오는 문제로 font-size로 설정하게 했으나
    // 멀티라인처럼 높이가 커진경우에는 원래 경우대로 하게끔 한다.
    if(this.divOffsetHeight > vnHeight) vnHeight = this.divOffsetHeight;
  }
  if(psVAlign == null) psVAlign = "middle";
  var vnParentHeight = poParent.style.height;
  if(vnParentHeight == "") vnParentHeight = "0";
  vnParentHeight = parseInt(vnParentHeight);
  var vnPadding = vnParentHeight - vnHeight;

  //2010.06.01
  //아래 로직이 있으면 스크롤이 중첩되서 생성되고
  //VerticalAlign 이 middle로 강제로 고정되는 경우가발생 그래서 주석 처리
  //if(vnPadding < 0) vnPadding = 0;

  switch(psVAlign) {
  case "top" :
    poCtrl.style.top = "0px";
    poCtrl.style.bottom = "";
    break;
  case "bottom" :
    poCtrl.style.top = ""; //(vnParentHeight - vnPadding)
    poCtrl.style.bottom = "0px";
    break;
  case "middle" :
    var vnPadding = vnPadding / 2;

    //2010.06.01
    //아래 로직이 있으면 스크롤이 중첩되서 생성되고
    //VerticalAlign 이 middle로 강제로 고정되는 경우가발생 그래서 주석 처리
    //if(vnParentHeight < vnHeight) vnPadding = 0;

    poCtrl.style.top = vnPadding + "px";
    poCtrl.style.bottom = "";
    break;
  }
};
/**
 * MDIPageResize의 div에 포커스를 사용
 * @private
 */
eXria.controls.xhtml.MDIPageResize.prototype.dofocus = function() {
  this.ctrl.focus();
};
/**
 * 좌우 splitter에 의한 관련 컨트롤들의 위치를 재설정 해주는 메소드
 * @param {Number} pnOffset splitter의 위치 이동 편차
 */
eXria.controls.xhtml.MDIPageResize.prototype.resizeHorz = function(pnOffset) {
  if(pnOffset == 0) return;
  var voPage = this.canvas.page;
  var vaLeftCtls = this.ltCtls;
  var vaRightCtls = this.rbCtls;
  var vnSize = 0;
  var vcCtl = null;
  var vnWidth = null;
  vnSize = vaLeftCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaLeftCtls[i]);
    if(vcCtl.rWidth === undefined) vcCtl.rWidth = vcCtl.width;
    vnWidth = vcCtl.rWidth + pnOffset;
    vcCtl.rWidth = vnWidth;
    if(vnWidth < 0) vnWidth = 0;
    vcCtl.applyAttr("width", vnWidth);
  }
  vnSize = vaRightCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaRightCtls[i]);
    vcCtl.left = vcCtl.left + pnOffset;
    if(vcCtl.rWidth === undefined) vcCtl.rWidth = vcCtl.width;
    vnWidth = vcCtl.rWidth - pnOffset;
    vcCtl.rWidth = vnWidth;
    if(vnWidth < 0) vnWidth = 0;
    vcCtl.width = vnWidth;
    vcCtl.refresh(null, null, true);
  }
};
/**
 * 상하 splitter에 의한 관련 컨트롤들의 위치를 재설정 해주는 메소드
 * @param {Number} pnOffset splitter의 위치 이동 편차
 */
eXria.controls.xhtml.MDIPageResize.prototype.resizeVert = function(pnOffset) {
  if(pnOffset == 0) return;
  var voPage = this.canvas.page;
  var vaUpperCtls = this.ltCtls;
  var vaLowerCtls = this.rbCtls;
  var vnSize = 0;
  var vcCtl = null;
  vnSize = vaUpperCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaUpperCtls[i]);
    vcCtl.applyAttr("height", vcCtl.height + pnOffset);
  }
  vnSize = vaLowerCtls.length;
  for(var i = 0; i < vnSize; i++) {
    vcCtl = voPage.getControl(vaLowerCtls[i]);
    vcCtl.top = vcCtl.top + pnOffset;
    vcCtl.height = vcCtl.height - pnOffset;
    vcCtl.refresh(null, null, true);
  }
};
/**
 * @
 */
eXria.controls.xhtml.MDIPageResize.prototype.atdblclick = function(poEvent) {
  if(this.type != "HSPLITTER" && this.type != "VSPLITTER") return;
  if(this.type == "HSPLITTER") {
    if(this.left != 0) {
      this.orgLeft = this.left;
      this.left = 0;
      this.refresh();
      this.resizeHorz(-this.orgLeft);
    } else {
      this.left = this.orgLeft;
      this.refresh();
      this.resizeHorz(this.left);
    }
  } else {
    if(this.top != 0) {
      this.orgTop = this.top;
      this.top = 0;
      this.refresh();
      this.resizeVert(-this.orgTop);
    } else {
      this.top = this.orgTop;
      this.refresh();
      this.resizeVert(this.top);
    }
  }
};
/**
 * 클래스 명을 반환합니다.
 * @return "MDIPageResize"
 * @type String
 */
eXria.controls.xhtml.MDIPageResize.prototype.toString = function() {
  return "MDIPageResize";
};

/**
 * @fileoverview
 * Concreate xhtml MDIGroup(XHTML MDIGroup 컨트롤)
 * @author 박상찬
 */
/**
 * @class Concreate xhtml MDIGroup.<br>
 * XHTML MDIGroup 컨트롤.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.MDIGroup 객체
 * @type eXria.controls.xhtml.MDIGroup
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 * @base eXria.controls.MDIGroup
 */
eXria.controls.xhtml.MDIGroup = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop =  pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 400 : pnWidth;
  pnHeight =  pnHeight == null ? 300 : pnHeight;

  eXria.controls.MDIGroup.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  //////////////////////////////////////////////////////////////////
  // 속성
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 스크롤 처리.
   * @type String
   */
  this.overflow = null;
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 횡 스크롤 처리.
   * @type String
   */
  this.overflowX = null;
  /**
   * 그룹에 담긴 컨트롤이 영역을 벗어날때 종 스크롤 처리.
   * @type String
   */
  this.overflowY = null;
  /**
   * 하위 컨트롤들의 readOnly 여부 설정
   * @type Boolean
   */
  this.readOnly = null;
  /**
   * 컨트롤이 디스플레이 되는 document
   * @type HTMLDocument
   * @private
   */
  this.document = null;
  /**
   * 하위 컨트롤 id에 붙일 suffix 문자열
   * @type String
   * @private
   */
  this.idSuffix = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * MDIButton 영역의 세로 길이.
   * @type Number
   */
  this.titleBarHeight = null;
  /**
   * MDIButton 의 위치 지정.
   * "top" | "bottom"
   * @type String
   */
  this.minimizePos = null;
  
  this.cursor = null;
  /**
  * @private
  */
  this.impList = new eXria.data.Collection();
  /**
   * MDIGroup(MDIGroup의 컨텐츠 패널 영역)을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   */
  this.mdiGroupSet = new eXria.data.ArrayCollection();
  /**
   * MDIPage(MDIPage의 컨텐츠 패널 영역)을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   */
  this.mdiPageSet = new eXria.data.ArrayCollection();
  /**
   * MDIPageResize(MDIPageResize의 컨텐츠 패널 영역)을 저장하기 위한 eXria.data.ArrayCollection.
   * @type eXria.data.ArrayCollection
   */
  this.mdiPageResizeSet = new eXria.data.ArrayCollection();
  /**
   * MDI 아이디 생성에 이용되는 순차적인 번호.
   * @type Number
   * @private
   */
  this.mdiSeqNum = 0;
  /**
   * ZIndex 생성에 이용되는 순차적인 번호.
   * @type Number
   * @private
   */
  this.zIndexSeq = 0;
  /**
   * @type Number
   * @ignore
   */
  this.mdiPageZindex = null;
  /**
   * MDIButtons 들의 공통속성을 관리하는 오브젝트
   * @type eXria.controls.xhtml.MDIButtons
   */
  this.mdibuttons = new eXria.controls.xhtml.MDIButtons();
  /**
   * MDIButton 객체.<br>
   * 개별 Button 을 관리하는 오브젝트.
   * readOnly
   * @type eXria.controls.xhtml.MDIButton
   */
  //addMdiPage method 에서 세부속성 정의 해야함
  this.mdibutton = null;
  /**
   * MDIPages 들의 공통속성을 관리하는 오브젝트
   * @type eXria.controls.xhtml.MDIPages
   */
  this.mdipages = new eXria.controls.xhtml.MDIPages();
  /**
   * MDIPage 객체.<br>
   * 개별 Page 을 관리하는 오브젝트.
   * readOnly
   * @type eXria.controls.xhtml.MDIPage
   */
  this.mdipage = null;
  
  this.mdisubpage = null;
  /**
   * resize 객체.<br>
   * readOnly
   * @type eXria.controls.xhtml.MDIPageResize
   */
   this.mdipageresize = null;
   /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
   this.innerWidth = this.width;
   /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
   this.innerHeight = this.height;
   /**
    * layout 의 matrix 속성
    * @member eXria.controls.xhtml.MDIGroup
    * @type String
    * @author ParkSC at 13. 6. 24 오후 6:29
    */
   this.mdiLayout = null;
   /**
    * layout 의 matrix 속성의 행 값
    * @member eXria.controls.xhtml.MDIGroup
    * @type Number
    * @author ParkSC at 13. 6. 24 오후 6:29
    */
   this.rows = null;
   /**
    * layout 의 matrix 속성의 열 값
    * @member eXria.controls.xhtml.MDIGroup
    * @type Number
    * @author ParkSC at 13. 6. 24 오후 6:29
    */
   this.cols = null;
   
   this.mdiCallFnc = null;
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.MDIGroup);
eXria.controls.xhtml.Util.createInheritance(eXria.controls.MDIGroup, eXria.controls.xhtml.MDIGroup);
//////////////////////////////////////////////////////////////////
// 메소드

eXria.controls.xhtml.MDIGroup.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  if(voEvent.target && voEvent.target.id == "GridEx") return;
  voEvent.object = poControl;
  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;
//if(vsType == "change")
  switch(vsType) {
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

eXria.controls.xhtml.MDIGroup.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;

  this.ctrl = voCtrl;
  this.document = poDocument;
  return voCtrl;
};

eXria.controls.xhtml.MDIGroup.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voDf = this.df;

  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
};

eXria.controls.xhtml.MDIGroup.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var vsClass = this.getCSSClass(this, 1);
  poCtrl.className = poCtrl.className + " " + vsClass;

  var voDf = this.df;
  var vaCssStrBuf = null;
  //반복해서 호출되는 메소드는 다음과 같이 지역변수를 함수를 할당하여 사용.
  //단, 함수 내부에 this라는 키워드가 들어가는 메소드는 지역변수에 할당할 수 없음)
  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;
  // 2009.10.12 동적인 코드에서는 disabled를 제어하지 않으며 FF에서는 없는 속성이다
  //if(this.disabled) poCtrl["disabled"] = true;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  vfcSetCssStrBuf(vaCssStrBuf, "tooltip", this.tooltip);
  vfcSetCssStrBuf(vaCssStrBuf, "disabled", this.disabled);
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", this.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "background-repeat", this.backgroundRepeat);
  vfcSetCssStrBuf(vaCssStrBuf, "background-position", this.backgroundPosition);
  vfcSetCssStrBuf(vaCssStrBuf, "background-image", this.backgroundImage);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", this.overflow);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-x", this.overflowX);
  vfcSetCssStrBuf(vaCssStrBuf, "overflow-y", this.overflowY);
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaCssStrBuf = null;
};

eXria.controls.xhtml.MDIGroup.prototype.refreshTemplate = function(poCtrl, poDocument) {
  if(this.setTemplate) this.setTemplate(poCtrl, poDocument);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.refreshTemplate) voChild.refreshTemplate(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIGroup.prototype.refreshSpecificDefaults = function(poCtrl, poDocument) {
  this.setSpecificDefaults(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificDefaults(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIGroup.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {
  this.setSpecificAttrs(poCtrl);
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshSpecificAttrs(voChild.ctrl, voChild.document);
  }
};

 eXria.controls.xhtml.MDIGroup.prototype.reloadData = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
  if(voChild.reloadData) voChild.reloadData(voChild.ctrl, voChild.document);
  }
};

eXria.controls.xhtml.MDIGroup.prototype.refreshComplete = function(poCtrl, poDocument) {
  var voChild = null;
  var voIterator = this.controls.iterator();
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    voChild.refreshComplete(voChild.ctrl, voChild.document);
  }
  if(this.loadCanvasConfig) this.loadCanvasConfig(poDocument);
  this.setDisable(poCtrl, this.disabled);
  this.hideFocusLine(poCtrl, true);
};

eXria.controls.xhtml.MDIGroup.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIGroup.prototype.setAttrSubCtrl = function(psAttrName, psAttrValue, poCtrl) {
  if(poCtrl.id != this.id) return;

  var voTable = poCtrl.childNodes[0];

  switch(psAttrName) {
    case "disabled" :
      poCtrl.disabled = psAttrValue;
      this.applyAttrToChildren("disabled", psAttrValue);
      break;
    //case "borderWidth" :
    //  this.innerWidth = this.width - 2 * this.borderWidth;
    //  this.innerHeight = this.height - 2 * this.borderWidth;
    //  poCtrl.style.width = this.innerWidth + "px";
    //  poCtrl.style.height = this.innerHeight + "px";
    //  break;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIGroup.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.getCtrl(poDocument);
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }
  //if(voObj.df) voObj.df[vaAttrName[vaAttrName.length - 1]] = psAttrValue;
  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "left" :
  case "top" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    break;
  case "height" :
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderWidth" :
    this.borderLeftWidth = this.borderWidth;
    this.borderRightWidth = this.borderWidth;
    this.borderTopWidth = this.borderWidth;
    this.borderBottomWidth = this.borderWidth;
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height -  this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("borderLeftWidth", this.borderLeftWidth + "px", voCtrl);
    this.setAttrCtrl("borderRightWidth", this.borderRightWidth + "px", voCtrl);
    this.setAttrCtrl("borderTopWidth", this.borderTopWidth + "px", voCtrl);
    this.setAttrCtrl("borderBottomWidth", this.borderBottomWidth + "px", voCtrl);
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    break;
  case "borderLeftWidth" :
  case "borderRightWidth" :
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.setAttrCtrl("width", this.innerWidth, voCtrl);
    this.setAttrCtrl(psAttrName, this[psAttrName] + "px", voCtrl);
    break;
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;
    this.setAttrCtrl("height", this.innerHeight, voCtrl);
    this.setAttrCtrl(psAttrName, voDf[psAttrName] + "px", voCtrl);
    break;
  case "className" :
  case "outerClassName" :
  case "overflow" :
    this.refresh(poDocument);
    break;
  case "visible" :
    this.setAttrCtrl(psAttrName, psAttrValue)
    this.setAttrCtrl("zIndex", this.zIndex, voCtrl);
    var voChild = null;
    var voIterator = this.controls.iterator();
    while(voIterator.hasNext()) {
      voChild = voIterator.next();
      if(voChild.refreshVerticalAlign) {
        voChild.refreshVerticalAlign();
      }
    }
    break;
  case "readOnly" :
    this.setReadOnly(psAttrValue);
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  }
};

eXria.controls.xhtml.MDIGroup.prototype.clear = function() {
  this.removeChildren();
  this.clearCtrl();
  this.clearControl();
};
/**
 * @ignore
 */
eXria.controls.xhtml.MDIGroup.prototype.loadComplete = function() {
  this.createChildren();
  if(this.readOnly != null) this.setReadOnly(this.readOnly);
  this.mdiInitLayout();
};
/**
 * 컨트롤에 하위 컨트롤를 추가합니다.
 * @param {eXria.controls.xhtml.Control} poControl 추가 대상 컨트롤
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document(생략가능)
 */
eXria.controls.xhtml.MDIGroup.prototype.addChild = function(poControl, poDocument) {
  if(poDocument == null) poDocument = this.document;
  var voCanvas = this.canvas;
  poControl.parent = this;
  poControl.canvas = voCanvas;
  poControl.window = this.window;
  poControl.document = this.document;
  this.addItem(poControl);
  if(voCanvas) voCanvas.registerControl(poControl);
  var voCtrl = this.getCtrl(poDocument);
  if((this.visible || this.visible == null) && voCtrl) {
    voCtrl.appendChild(poControl.create(poDocument));
    poControl.load(poDocument);
  // TODO 추후 수정
    var name = poControl.toString();
    if(name == "Rectangle" || name == "Roundrect" || name == "Ellipse" ) {poControl.getCtrl(poDocument).blur();};
  }
};
/**
 * 하위 컨트롤을 제거 시킵니다.
 * @param {String} psId 제거대상 컨트롤 id
 */
eXria.controls.xhtml.MDIGroup.prototype.removeChild = function(psId) {
  var vnIndex = this.getIndex(psId);
  var voControl = this.controls.remove(vnIndex);
  voControl.clear();
};
/**
 * 하위 컨트롤 id에 매칭되는 컨트롤 식별 인덱스 번호를 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 하위 컨트롤 식별 인덱스 번호
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.getIndex = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vnIndex = -1;
  while(voIterator.hasNext()) {
    vnIndex++;
    voControl = voIterator.next();
    if (voControl.id == psId) break;
  }
  return vnIndex;
};
/**
 * 지정된 id에 해당하는 하위 컨트롤을 반환합니다.
 * @param {String} psId 하위 컨트롤 id
 * @return 지정된 id에 해당하는 하위 컨트롤 객체
 * @type eXria.controls.xhtml.Control
 */
eXria.controls.xhtml.MDIGroup.prototype.get = function(psId) {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    if (voControl.id == psId) { return voControl; }
  }
  return null;
};
/**
 * 포함된 하위 컨트롤의 실체화 객체를 생성합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @param {String} psIdSuffix 실체화된 컨트롤 id에 따라붙을 문자열
 * @private
 */
eXria.controls.xhtml.MDIGroup.prototype.createChildren = function(poDocument, psIdSuffix) {
  if(poDocument == null) poDocument = this.document;
  if(psIdSuffix == null && this.idSuffix) psIdSuffix = this.idSuffix;
  var voIterator = this.controls.iterator();
  var voControl = null;
  var vsId = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    vsId = voControl.id;
    if(psIdSuffix != null) voControl.id += psIdSuffix;
    if(voControl.canvas == null) {
      voControl.canvas = this.canvas;
      voControl.window = this.window;
      voControl.document = this.document;
      this.canvas.registerControl(voControl);
    }
    if(voControl.toString() != "Timer") {
      this.appendChild(voControl.create(poDocument), poDocument);
      //voControl.refresh(poDocument);
      voControl.load(this.document);
    }
    voControl.id = vsId;
  }
};
/**
 * 하위 컨트롤에 일괄적으로 속성을 적용합니다.
 * @param {String} psAttrValue 지정된 속성값
 * @param {String} psAttrName 속성명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.MDIGroup.prototype.applyAttrToChildren = function(psAttrName, psAttrValue, poDocument) {
  if(this.getCtrl(poDocument) == null) return;

  var voIterator = this.controls.iterator();
  var voControl = null;
  var voCtrl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    voCtrl = voControl.getCtrl(poDocument);
    if(voCtrl) voControl.applyAttr(psAttrName, psAttrValue, poDocument);
  }
};
/**
 * 모든 하위 컨트롤을 제거 시킵니다.
 */
eXria.controls.xhtml.MDIGroup.prototype.removeChildren = function() {
  var voIterator = this.controls.iterator();
  var voControl = null;
  while(voIterator.hasNext()) {
    voControl = voIterator.next();
    this.canvas.unregisterControl(voControl.id);
    if(voControl.toString() == "SubPage") {
//      var voWindow = voControl.ctrl.contentWindow;
//      if(voWindow) {
//        voWindow.close();
//      }
        voControl.setSrc("javascript:false");
    }
    voControl.clear();
  }
  this.controls.clear();
};

eXria.controls.xhtml.MDIGroup.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.MDIGroup[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};
/**
 * 하위 컨트롤의 readOnly속성을 설정
 * @param {String} pbEnable readOnly속성을 활성화할지 여부
 */
eXria.controls.xhtml.MDIGroup.prototype.setReadOnly = function(pbEnable) {
  var voIterator = this.controls.iterator();
  var voChild = null;
  while(voIterator.hasNext()) {
    voChild = voIterator.next();
    if(voChild.readOnly !== undefined) voChild.applyAttr("readOnly", pbEnable);
  }
};
/**
 * MDIButton 및 그에 따른 MDIPage 추가 메소드.
 * @param {String} psPageName MDI Page 라벨
 * @param {String} psPageId MDI 페이지 아이디
 * @param {Boolean} pbVisible Visible 여부
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 추가된 MDIPage 의 인덱스
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.addMdiPage = function(psPageName, psPageId, pbVisible, pnLeft, pnTop, pnWidth, pnHeight) {
  var voCtrl = this.getCtrl();
  var voDf = this.df;
  var voPageDf = this.mdipages;
  var voMdiPage = null;
  var voMdiButton = null;
  var vsButtonId = null;
  var vsPageId = null;
  var vsResizeLableId = null;
  var vnHeight = this.height;
  var vnButtonLeft = 0;
  var vnButtonTop = 0;
  var vnBtnWidth = null;
  var vnBtnHeight = null;
  this.mdiCallFnc = "addMdiPage";
  this.titleBarHeight = this.getAttrValue("titleBarHeight", this.titleBarHeight);
  this.minimizePos = this.getAttrValue("minimizePos", this.minimizePos);
  
  if(this.titleBarHeight == null) this.titleBarHeight = 25;
  if(this.minimizePos == null) this.minimizePos = "bottom";
  
  if(psPageId == null) vsPageId = this.id + "_group";
  else vsPageId = psPageId;
  
  vsButtonId = vsPageId + "_button";
  vsResizeLableId = vsPageId+"_resize";
  
  if(pnLeft == null) {
    pnLeft = 0;
    pnTop = this.titleBarHeight;
    if(this.minimizePos == "bottom") pnTop = 0;
    pnWidth = parseInt(this.innerWidth * 0.5);
    pnHeight = parseInt((this.innerHeight - this.titleBarHeight) * 0.5);
  }
  
  this.mdipageresize = new eXria.controls.xhtml.MDIPageResize(vsResizeLableId, (pnLeft + pnWidth - 17), (pnTop + pnHeight - 16), 17, 16);
  this.mdipageresize.parent = this;
  
  this.mdiGroupSet.add(this.mdipageresize);
  this.mdiPageResizeSet.add(this.mdipageresize);
  
  this.mdipage = new eXria.controls.xhtml.MDIPage(vsPageId, pnLeft, pnTop, pnWidth, pnHeight);
  this.mdipage.parent = this;
  
  voMdiPage = this.mdipage;
  voMdiPage.subId = psPageId;
  
  voMdiPage.maximize = voMdiPage.getAttrValue("maximize", voMdiPage.maximize);
  voMdiPage.minimize = voMdiPage.getAttrValue("minimize", voMdiPage.minimize);
  voMdiPage.restore = voMdiPage.getAttrValue("restore", voMdiPage.restore);
  
  if(pbVisible) voMdiPage.visible = pbVisible;
  voMdiPage.zIndex = this.mdiSeqNum;
  this.mdiPageZindex = this.mdiSeqNum;
  this.mdiGroupSet.add(this.mdipage);
  this.mdiPageSet.add(voMdiPage);
  
  if(voCtrl) {
   voMdiPage.canvas = this.canvas;
   voMdiPage.window = this.window;
   voMdiPage.document = this.document;
   voMdiPage.backgroundColor = this.mdipages.backgroundColor;
   voMdiPage.className = voPageDf.className;
   voMdiPage.outerClassName = voPageDf.outerClassName;
   voMdiPage.borderStyle = voPageDf.borderStyle;
   voMdiPage.borderColor = voPageDf.borderColor;
   voMdiPage.borderWidth = voPageDf.borderWidth;
   voMdiPage.borderLeftWidth = voPageDf.borderLeftWidth;
   voMdiPage.borderRightWidth = voPageDf.borderRightWidth;
   voMdiPage.borderTopWidth = voPageDf.borderTopWidth;
   voMdiPage.borderBottomWidth = voPageDf.borderWidth;
   voMdiPage.overflow = voPageDf.overflow;
   voMdiPage.overflowX = voPageDf.overflowX;
   voMdiPage.overflowY = voPageDf.overflowY;
   voMdiPage.visible = true;
   voMdiPage.zIndex = this.mdiSeqNum;
  }
  
  voMdiPage.zIndex = this.mdiSeqNum;
  this.mdipageresize.zIndex = this.mdiSeqNum+1;
  this.addChild(this.mdipage);
  this.addChild(this.mdipageresize);
  
  if(this.mdibuttons.width == null) vnBtnWidth = 100;
  else vnBtnWidth = this.mdibuttons.width;
  if(this.mdibuttons.height == null)  vnBtnHeight = 20;
  else vnBtnHeight = this.mdibuttons.height;
  
  if(this.mdiSeqNum == 0) {
    vnButtonLeft = 2;
  }else{
    vnButtonLeft = this.mdibuttons.left + vnBtnWidth + 4;
  }
  vnButtonTop = parseInt((vnHeight - 20 * (this.mdiSeqNum+1.1)));
  
  this.mdibuttons.top = vnButtonTop;
  this.mdibuttons.left = vnButtonLeft;
  this.mdibuttons.width = vnBtnWidth;
  this.mdibuttons.height = vnBtnHeight;

  this.mdibutton = new eXria.controls.xhtml.MDIButton(vsButtonId, vnButtonLeft, vnButtonTop, vnBtnWidth, vnBtnHeight);
  this.mdibutton.parent = this;
  voMdiButton = this.mdibutton;
  voMdiButton.subId = vsButtonId;
  voMdiButton.value = psPageName;
  voMdiButton.pageId = vsPageId;
  voMdiButton.pageSubId = psPageId;
  voMdiPage.btn = voMdiButton;
  if(pbVisible != null) voMdiButton.visible = pbVisible;
  this.addMdiButton(voMdiButton);
  this.mdiGroupSet.add(this.mdibutton);
  this.mdiSeqNum++;

  var vnIndex = this.mdiPageSet.size() - 1;
//  if(vnIndex == this.selectedIndex) this.selectTab(vnIndex);

  return this.mdiPageSet.size() - 1;
};

/**
 * MDIButton 및 그에 따른 MDIPage 추가 메소드.
 * @param {String} psPageName MDI Page 라벨
 * @param {String} psPageId MDI 페이지 아이디
 * @param {Boolean} pbVisible Visible 여부
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @param {String} 페이지 Src
 * @return 추가된 MDIPage 의 인덱스
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.addMdiSubPage = function(psPageName, psPageId, pbVisible, pnLeft, pnTop, pnWidth, pnHeight, psSrc) {
  var voCtrl = this.getCtrl();
  var voDf = this.df;
  var voPageDf = this.mdipages;
  var voMdiPage = null;
  var voMdiSubpage = null;
  var voMdiButton = null;
  var vsButtonId = null;
  var vsPageId = null;
  var vsResizeLableId = null;
  var vnHeight = this.height;
  var vnButtonLeft = 0;
  var vnButtonTop = 0;
  var vnBtnWidth = null;
  var vnBtnHeight = null;
  var vsSrc = psSrc;
  if(!vsSrc) vsSrc = "";
  var vnLeft = pnLeft;
  var vnTop = pnTop;
  if(!vnLeft) vnLeft = 0;
  if(!vnTop) vnTop = 0;
  this.titleBarHeight = this.getAttrValue("titleBarHeight", this.titleBarHeight);
  this.minimizePos = this.getAttrValue("minimizePos", this.minimizePos);
  this.mdiCallFnc = "addMdiSubPage";
  
  if(this.titleBarHeight == null) this.titleBarHeight = 25;
  if(this.minimizePos == null) this.minimizePos = "bottom";
    
  if(psPageName == null) psPageName = this.id + "_name";
  if(psPageId == null) vsPageId = this.id + "page"+""+this.mdiSeqNum;
  else vsPageId = psPageId;
  
  vsButtonId = vsPageId + "_button";
  vsResizeLableId = vsPageId+"_resize";
  if(!vnLeft) {
    vnLeft = 0;
    if(this.minimizePos == "bottom") vnTop = 0;
    else vnTop = this.titleBarHeight;
    if(!pnWidth) pnWidth = parseInt(this.innerWidth * 0.5);
    if(!pnHeight) pnHeight = parseInt((this.innerHeight - this.titleBarHeight) * 0.5);
  }
  
  this.mdipageresize = new eXria.controls.xhtml.MDIPageResize(vsResizeLableId, (vnLeft + pnWidth - 17), (vnTop + pnHeight - 16), 17, 16);
  this.mdipageresize.parent = this;
  this.mdipageresize.zIndex = this.mdiSeqNum;
  
  this.mdiGroupSet.add(this.mdipageresize);
  this.mdiPageResizeSet.add(this.mdipageresize);
  this.mdipage = new eXria.controls.xhtml.MDIPage(vsPageId, vnLeft, vnTop, pnWidth, pnHeight);
  this.mdipage.parent = this;
  
  voMdiPage = this.mdipage;
  voMdiPage.subId = psPageId;
  
  voMdiPage.maximize = voMdiPage.getAttrValue("maximize", voMdiPage.maximize);
  voMdiPage.minimize = voMdiPage.getAttrValue("minimize", voMdiPage.minimize);
  voMdiPage.restore = voMdiPage.getAttrValue("restore", voMdiPage.restore);

  if(pbVisible) voMdiPage.visible = pbVisible;
  voMdiPage.zIndex = this.mdiSeqNum;
  this.mdiPageZindex = this.mdiSeqNum;
  this.mdiGroupSet.add(this.mdipage);
  this.mdiPageSet.add(voMdiPage);
  
  if(voCtrl) {
   voMdiPage.canvas = this.canvas;
   voMdiPage.window = this.window;
   voMdiPage.document = this.document;
   voMdiPage.backgroundColor = this.mdipages.backgroundColor;
   voMdiPage.className = voPageDf.className;
   voMdiPage.outerClassName = voPageDf.outerClassName;
   voMdiPage.borderStyle = voPageDf.borderStyle;
   voMdiPage.borderColor = voPageDf.borderColor;
   voMdiPage.borderWidth = voPageDf.borderWidth;
   voMdiPage.borderLeftWidth = voPageDf.borderLeftWidth;
   voMdiPage.borderRightWidth = voPageDf.borderRightWidth;
   voMdiPage.borderTopWidth = voPageDf.borderTopWidth;
   voMdiPage.borderBottomWidth = voPageDf.borderWidth;
   voMdiPage.overflow = voPageDf.overflow;
   voMdiPage.overflowX = voPageDf.overflowX;
   voMdiPage.overflowY = voPageDf.overflowY;
   voMdiPage.visible = true;
   voMdiPage.zIndex = this.mdiSeqNum;
  }
  
  if(this.mdibuttons.width == null) vnBtnWidth = 100;
  else vnBtnWidth = this.mdibuttons.width;
  if(this.mdibuttons.height == null)  vnBtnHeight = 20;
  else vnBtnHeight = this.mdibuttons.height;
  
  if(this.mdiSeqNum == 0) {
    vnButtonLeft = 2;
  }else{
    vnButtonLeft = this.mdibuttons.left + vnBtnWidth + 4;
  }
  vnButtonTop = parseInt((vnHeight - 20 * (this.mdiSeqNum+1.1)));
  
  this.mdibuttons.top = vnButtonTop;
  this.mdibuttons.left = vnButtonLeft;
  this.mdibuttons.width = vnBtnWidth;
  this.mdibuttons.height = vnBtnHeight;
 
  this.mdibutton = new eXria.controls.xhtml.MDIButton(vsButtonId, vnButtonLeft, vnButtonTop, vnBtnWidth, vnBtnHeight);
  this.mdibutton.parent = this;
  voMdiButton = this.mdibutton;
  voMdiButton.subId = vsButtonId;
  voMdiButton.value = psPageName;
  voMdiButton.pageId = vsPageId;
  voMdiButton.pageSubId = psPageId;
  voMdiPage.btn = voMdiButton;
  if(pbVisible != null) voMdiButton.visible = pbVisible;
  this.addMdiButton(voMdiButton);
  this.mdiGroupSet.add(this.mdibutton);
  
  this.mdiSeqNum++;

  var vnIndex = this.mdiPageSet.size() - 1;
//  if(vnIndex == this.selectedIndex) this.selectTab(vnIndex);
  this.mdisubpage = new eXria.controls.xhtml.SubPage(vsPageId+"_subpage", 0, 0, pnWidth, pnHeight);
  voMdiSubpage = this.mdisubpage;
  var vsResourceBaseUrl = (this.canvas.page.metadata.resourceBaseUrl == "/") ? "" : this.canvas.page.metadata.resourceBaseUrl;
  if(psSrc.indexOf("http://") > -1) voMdiSubpage.src = psSrc;
  else voMdiSubpage.src = vsResourceBaseUrl + psSrc;
  voMdiSubpage.zIndex = this.mdiSeqNum + 1;
  this.mdiGroupSet.add(voMdiSubpage);
  this.mdiPageSet.add(voMdiSubpage);
  voMdiPage.pagebody.addChild(voMdiSubpage);
  
  this.mdipageresize.zIndex = this.mdiSeqNum+1;
  
  this.addChild(this.mdipageresize);
  this.addChild(this.mdipage);
  
  return this.mdiPageSet.size() - 1;
};

/**
 * MdiButton 을 추가
 * @param {eXria.controls.xhtml.MDIGroup.prototype} poMdiButton MDI 버튼
 * @private
 */
eXria.controls.xhtml.MDIGroup.prototype.addMdiButton = function(poMdiButton) {
  var voCtrl = this.getCtrl();
  var voBtnDf = this.mdibuttons;
  if(this.visible == false) {
    this.visible = true;
  }
  poMdiButton.parent = this;
//  this.addItem(poMdiButton);

  if(voBtnDf) {
  //mdibuttons 속성을 mdibutton 에 전달
    poMdiButton.canvas = this.canvas;
    poMdiButton.window = this.window;
    poMdiButton.document = this.document;
    poMdiButton.className = voBtnDf.className;
    poMdiButton.outerClassName = voBtnDf.outerClassName;
    poMdiButton.backgroundColor = voBtnDf.backgroundColor;
    poMdiButton.backgroundImage = voBtnDf.backgroundImage;
    poMdiButton.imageFocused = voBtnDf.imageFocused;
    poMdiButton.backgroundPosition = voBtnDf.backgroundPosition;
    poMdiButton.backgroundRepeat = voBtnDf.backgroundRepeat;
    poMdiButton.color = voBtnDf.color;
    poMdiButton.fontFamily = voBtnDf.fontFamily;
    poMdiButton.fontSize = voBtnDf.fontSize;
    poMdiButton.fontWeight = voBtnDf.fontWeight;
    poMdiButton.fontStyle = voBtnDf.fontStyle;
    poMdiButton.textDecoration = voBtnDf.textDecoration;
    poMdiButton.borderColor = voBtnDf.borderColor;
    poMdiButton.borderStyle = voBtnDf.borderStyle;
    poMdiButton.borderWidth = voBtnDf.borderWidth;
    poMdiButton.borderLeftWidth = voBtnDf.borderLeftWidth;
    poMdiButton.borderRightWidth = voBtnDf.borderRightWidth;
    poMdiButton.borderTopWidth = voBtnDf.borderTopWidth;
    poMdiButton.borderBottomWidth = voBtnDf.borderBottomWidth;
    poMdiButton.padding = voBtnDf.padding;
    poMdiButton.paddingLeft = voBtnDf.paddingLeft;
    poMdiButton.paddingRight = voBtnDf.paddingRight;
    poMdiButton.paddingTop = voBtnDf.paddingTop;
    poMdiButton.paddingBottom = voBtnDf.paddingBottom;
    poMdiButton.position = "relative";
    poMdiButton.cursor = voBtnDf.cursor;
  
    if(poMdiButton.visible != false) {
//      this.checkScroll();
//      poMdiButton.load();
      this.addChild(this.mdibutton);
    }
  }
};

/**
 * 지정된 인덱스에 해당하는 MDI 페이지 반환.
 * @param {Number} pnIndex 인덱스
 * @return 지정된 인덱스에 해당하는 MDI 페이지
 * @type eXria.controls.xhtml.MDIGroup
 */
eXria.controls.xhtml.MDIGroup.prototype.getPage = function(pnIndex) {
  var voPage = null;
  try {
    voPage = this.mdiPageSet.get(pnIndex);
  } catch(err) {}
  return voPage;
};
/**
 * 지정된 페이지 ID에 해당하는 MDI 페이지 반환.
 * @param {String} psPageSubId MDI 페이지 id
 * @return 지정된 페이지 ID에 해당하는 MDI 페이지
 * @type eXria.controls.xhtml.MDIGroup
 */
eXria.controls.xhtml.MDIGroup.prototype.getPageById = function(psPageId) {
  var vnIndex = this.getIndexById(psPageId);
  var voPage = null;
  
  if(vnIndex == -1) voPage = null;
  else voPage = this.mdiPageSet.get(vnIndex);
    
  return voPage;
};

/**
 * 지정된 pageId에 해당하는 인덱스 반환.
 * @param {String} psPageId 지정된 페이지 아이디.
 * @return pageId에 해당하는 인덱스
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.getIndexById = function(psPageId) {
  var vnIndex = -1;
  var voIterator = this.mdiPageSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == psPageId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};

eXria.controls.xhtml.MDIGroup.prototype.getPageLabelById = function(psPageId) {
  var vnIndex = this.getIndexLabelById(psPageId);

  var voPage = null;
  
  if(vnIndex == -1) voPage = null;
  else voPage = this.mdiPageResizeSet.get(vnIndex);
  
  return voPage;
};

/**
 * 지정된 pageId에 해당하는 인덱스 반환.
 * @param {String} psPageId 지정된 페이지 아이디.
 * @return pageId에 해당하는 인덱스
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.getIndexLabelById = function(psPageId) {
  var vnIndex = -1;
  var voIterator = this.mdiPageResizeSet.iterator();
  var voPage = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voPage = voIterator.next();
    cnt++;
    if(voPage.id == psPageId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};

/**
 * 지정된 컨트롤의 ID로 컨트롤객체 반환.
 * @param {String} psControlId
 * @return 지정된 컨트롤 ID에 해당하는 컨트롤 객체
 * @type eXria.controls.xhtml.MDIGroup
 */
eXria.controls.xhtml.MDIGroup.prototype.getControlById = function(psControlId) {
  var vnIndex = this.getControlIndexById(psControlId);

  var voCtrl = null;
  
  if(vnIndex == -1) voCtrl = null;
  else voCtrl = this.mdiGroupSet.get(vnIndex);
  
  return voCtrl;
};

/**
 * 지정된 ControlId 에 해당하는 인덱스 반환.
 * @param {String} psControlId 지정된 컨트롤 아이디.
 * @return psControlId에 해당하는 인덱스
 * @type Number
 */
eXria.controls.xhtml.MDIGroup.prototype.getControlIndexById = function(psControlId) {
  var vnIndex = -1;
  var voIterator = this.mdiGroupSet.iterator();
  var voCtrl = null;
  var cnt = -1;
  while(voIterator.hasNext()) {
    voCtrl = voIterator.next();
    cnt++;
    if(voCtrl.id == psControlId) {
      vnIndex = cnt;
      break;
    }
  }
  return vnIndex;
};

/**
 * MDI 버튼의 위치이동
 * @type eXria.controls.xhtml.MDIGroup
 * @private
 */
eXria.controls.xhtml.MDIGroup.prototype.mdiButtonMove = function() {
  var voIterator = this.mdiGroupSet.iterator();
  var vnCnt = 0;
  var vnButtonTop = 0;
  var vnButtonLeft = 0;
  
  while(voIterator.hasNext()){
    var voCtrl = voIterator.next();
    if(voCtrl.toString() == "MDIButton" && !!voCtrl.id){
      if(vnCnt == 0) {
        vnButtonLeft = 2;
        this.mdiSeqNum = 0;
        if(this.minimizePos == "top") vnButtonTop = 0;
        else vnButtonTop = parseInt((this.height - 20 * (vnCnt + 1.1)));
      }else{
        vnButtonLeft = this.mdibuttons.left + this.mdibuttons.width + 4;
        if(this.minimizePos == "top") vnButtonTop = parseInt((-20 * (vnCnt + 1.1)));
        else vnButtonTop = parseInt((this.height - 20 * (vnCnt + 1.1)));
      }
      this.mdibuttons.top = vnButtonTop;
      this.mdibuttons.left = vnButtonLeft;
      
      voCtrl.applyAttr("top", vnButtonTop);
      voCtrl.applyAttr("left", vnButtonLeft);
      voCtrl.applyAttr("tooltip", voCtrl.value);

      vnCnt++;
    }
  }
  if(vnCnt == 0)  this.mdiSeqNum = 0;
};

/**
 * mdipage 들의 초기 layout 배치
 * @type eXria.controls.xhtml.MDIGroup
 * @private
 */
eXria.controls.xhtml.MDIGroup.prototype.mdiInitLayout = function() {
  var voMdiPage = null;
  var vnTop = 0;
  var vnLeft = 0;
  var vaTop = new Array();
  var vaLeft = new Array();
  var mdiPageCnt = 0;
  this.mdiLayout = this.getAttrValue("mdiLayout", this.mdiLayout);
  this.rows = this.getAttrValue("rows", this.rows);
  this.cols = this.getAttrValue("cols", this.cols);
  
  var vnMainHeight = this.height;
  var vnMainWidth = this.width;
  var vnHeight = 0;
  var vnWidth = 0;
  var voIterator = this.mdiPageSet.iterator();
  var voResizeIterator = this.mdiPageResizeSet.iterator();
  
  if(this.minimizePos == "top") vnTop = this.titleBarHeight;
  
  while(voIterator.hasNext()){
    voMdiPage = voIterator.next();
    if(voMdiPage.toString() == "MDIPage"){
      mdiPageCnt++;
    }
  }
  if(this.mdiLayout == "matrix"){
    if(mdiPageCnt > (this.rows * this.cols)){
      alert("matrix의 행, 열의 정의가 잘못되었습니다.");
      return;
    }else{
      mdiPageCnt = 0;
      vnHeight = parseInt((vnMainHeight - (this.titleBarHeight + 4)) / this.rows);
      vnWidth = parseInt((vnMainWidth - 2) / this.cols);
      for(var i = 1; i <= this.rows; i++){
        for(var j = 1; j <= this.cols; j++){
          vaTop.push(vnTop);
          vaLeft.push(vnLeft);
          vnLeft = vnLeft + vnWidth;
        }
        vnTop = vnTop + vnHeight;
        vnLeft = 0;
      }
      voIterator = this.mdiPageSet.iterator();
      while(voIterator.hasNext()){
        voMdiPage = voIterator.next();
        if(voMdiPage.toString() == "MDIPage"){
          voMdiPage.applyAttr("top", vaTop[mdiPageCnt]);
          voMdiPage.applyAttr("left", vaLeft[mdiPageCnt]);
          voMdiPage.applyAttr("height", vnHeight);
          voMdiPage.applyAttr("width", vnWidth);
        
          voMdiPage.mdiLabelMove();
          mdiPageCnt++;  
        }
      }
      while(voResizeIterator.hasNext()){
        voMdiPageResize = voResizeIterator.next();
        voMdiPageResize.mdiMove();
      }
    }
  }else{
    voIterator = this.mdiPageSet.iterator();
    while(voIterator.hasNext()){
      voMdiPage = voIterator.next();
      voMdiPage.applyAttr("top", vnTop);
      voMdiPage.applyAttr("left", vnLeft);
      vnTop = vnTop + 70;
      vnLeft = vnLeft + 70;
      voMdiPage.mdiLabelMove();
    }
  }
  this.mdiButtonMove();
};

/**
 * 클래스 명을 반환합니다.
 * @return "MDIGroup"
 * @type String
 */
eXria.controls.xhtml.MDIGroup.prototype.toString = function() {
  return "MDIGroup";
};
/**
 * @fileoverview
 * canvas를 통해 컨트롤을 생성 시 사용되는 컨트롤 타입 값을 정의한 오브젝트
 * @author 조동일
 * @version 2.0
 */

/**
 * eXria.controls.xhtml.ControlTypeProvider Object
 */
eXria.controls.xhtml.ControlTypeProvider = {
  /**
   * 컨트롤 타입 별 컨트롤 full class name 반환
   * @param {String} psType 컨트롤 타입<br>
   * slidetab : 슬라이드탭 컨트롤<br>
   * button : 버튼 컨트롤<br>
   * combo : 콤보박스 컨트롤<br>
   * listbox : 리스트박스 컨트롤<br>
   * label : 레이블 컨트롤<br>
   * calendar : 달력 컨트롤<br>
   * input : 입력 컨트롤<br>
   * object : 플래시 등 ActiveX 로딩용 오브젝트 컨트롤<br>
   * output : 결과출력용 ouput 컨트롤<br>
   * secret : 비밀번호 등 암호입력 컨트롤<br>
   * progress : 진행바 표시 컨트롤<br>
   * textarea : 줄바꿈이 가능한 입력 컨트롤<br>
   * dateinput : 날짜입력 컨트롤<br>
   * treeview : 트리뷰 컨트롤<br>
   * image : 이미지 컨트롤<br>
   * tab : 탭 컨트롤<br>
   * editmask : 입력마스크 컨트롤<br>
   * group : 여러 컨트롤을 하위관계로 포함시키는 그룹 컨트롤<br>
   * mdigroup : 여러 창으로 작업할 수 있는 컨트롤<br>
   * time : 시간 컨트롤<br>
   * check : 체크박스 컨트롤<br>
   * radio : 라디오 버튼 컨트롤<br>
   * freeform : 프리폼(그룹 컨트롤에 데이타 연동기능 제공) 컨트롤<br>
   * line : 선 도형 컨트롤<br>
   * rectangle : 사각형 도형 컨트롤<br>
   * roundrect : 둥근모서리 사각형 도형 컨트롤<br>
   * ellipse : 타원 도형 컨트롤<br>
   * import : 다른 페이지 화면을 현재 화면에 하나에 윈도우로 결합하여 보여주기 위한 컨트롤<br>
   * subpage : 다른 페이지 화면을 현재 화면에 결합하여(두개의 윈도우로 존재) 보여주기 위한 컨트롤<br>
   * htmlsnippet : 매쉬업 컨텐츠를 로딩하기 위한 컨트롤<br>
   * gridex : 그리드 컨트롤<br>
   * contextmenu : 우측 팝업 메뉴 컨트롤<br>
   * fileselector : 파일 선택 컨트롤<br>
   * htmleditor : html 편집기 컨트롤<br>
   * @return 컨트롤 생성 시 이용될 컨트롤의 full class name
   * @type Class
   */
  get : function(psType) {
    switch(psType) {
      case "slidetab" :
      return eXria.controls.xhtml.SlideTab;
      case "button" :
      return eXria.controls.xhtml.Button;
      case "combo" :
      return eXria.controls.xhtml.ComboBox;
      case "listbox" :
      return eXria.controls.xhtml.ListBox;
      case "label" :
      return eXria.controls.xhtml.Label;
      case "calendar" :
      return eXria.controls.xhtml.Calendar;
      case "input" :
      return eXria.controls.xhtml.InputBox;
      case "object" :
      return eXria.controls.xhtml.Object;
      case "output" :
      return eXria.controls.xhtml.Output;
      case "secret" :
      return eXria.controls.xhtml.SecretBox;
      case "progress":
      return eXria.controls.xhtml.Progress;
      case "textarea":
      return eXria.controls.xhtml.TextArea;
      case "dateinput" :
      return eXria.controls.xhtml.DateInput;
      case "treeview" :
      return eXria.controls.xhtml.TreeView;
      case "image" :
      return eXria.controls.xhtml.Image;
      case "tab" :
      return eXria.controls.xhtml.Tab;
      case "editmask" :
      return eXria.controls.xhtml.EditMask;
      case "group" :
      return eXria.controls.xhtml.Group;
      case "mdigroup" :
      return eXria.controls.xhtml.MDIGroup;
      case "tablelayout" :
      return eXria.controls.xhtml.TableLayout;
      case "time" :
      return eXria.controls.xhtml.Timer;
      case "check" :
      return eXria.controls.xhtml.CheckBox;
      case "radio" :
      return eXria.controls.xhtml.RadioButton;
      case "freeform" :
      return eXria.controls.xhtml.FreeForm;
      case "line" :
      return eXria.controls.xhtml.Line;
      case "rectangle" :
      return eXria.controls.xhtml.Rectangle;
      case "roundrect" :
      return eXria.controls.xhtml.Roundrect;
      case "ellipse" :
      return eXria.controls.xhtml.Ellipse;
      case "import" :
      return eXria.controls.xhtml.Import;
      case "subpage" :
      return eXria.controls.xhtml.SubPage;
      case "htmlsnippet" :
      return eXria.controls.xhtml.HtmlSnippet;
//      case "grid" :
//      return eXria.controls.xhtml.Grid;
      case "gridex" :
      return eXria.controls.xhtml.GridEx;
      case "contextmenu" :
      return eXria.controls.xhtml.ContextMenu;
      case "fileselector" :
      return eXria.controls.xhtml.FileSelector;
      case "htmleditor" :
      return eXria.controls.xhtml.HtmlEditor;
    }
  }
};



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of import Const6.js
var BOpera9 = navigator.appName.search("Opera")>=0;
var BOpera8 = BOpera9 ? 0 : navigator.userAgent.search("Opera")>=0;
var BOperaVer = parseFloat(navigator.appVersion);
var BSafariMac = navigator.userAgent.search("Safari")>=0;
var BSafariWin = BSafariMac && navigator.userAgent.search("Windows")>=0;
var BSafari = navigator.userAgent.search("KHTML")>=0;
var BSafariVer = BSafari?parseFloat(navigator.userAgent.match(/(?:KHTML\D*|VERSION\D*)(\d[\d\.]+)/i)[1]):0;
var BKonqueror = BSafari && !BSafariMac && !BSafariWin;
var BChrome = BSafari && navigator.userAgent.search("Chrome")>=0;
var BMozilla = navigator.appName.search("Netscape")>=0 && !BOpera8 && !BSafari;
var BStrict = document.compatMode=="CSS1Compat";
var BIEA = navigator.appName.search("Microsoft")>=0 && !BOpera8;

var BIE = BIEA && !BStrict;
var BIEStrict = BIEA && !BIE;

var BIE5 = BIE && navigator.appVersion.search("MSIE 5")>=0;
var BIEA6 = BIEA && navigator.appVersion.search("MSIE 6")>=0 || BIE5;

var BIEA8 = BIEA && document.documentMode==8;
var BIE8Strict = BIEA8 && BIEStrict;
if(BIEA6) try { document.execCommand("BackgroundImageCache", false, true); } catch(e) { }

var BNN = navigator.userAgent.search("Netscape")>=0;
var BFF1 = BMozilla && navigator.userAgent.search("Firefox/1.")>=0;
var BFF15 = BMozilla && navigator.userAgent.search("Firefox/1.5")>=0;
var BFF3 = BMozilla && navigator.userAgent.search("Firefox/3.")>=0;
var BFF35 = BMozilla && navigator.userAgent.search("Firefox/3.5")>=0;

if(BIE5) undefined=null;
//-----------------------------------------------------------------------------------------------------------
var CScrollWidth = 0, CScrollHeight = 0;
var CCursorPointer = BIE5 ? "cursor:hand;" : "cursor:pointer;";
//-----------------------------------------------------------------------------------------------------------
try { if(BIEA6) document.execCommand("BackgroundImageCache", false, true); } catch(e) {}
//////////////////////////////////////////////////////////////////////////////////////////
//end of import Const6.js


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of import Format6.js
var PFormat = {

EmptyNumber : null,
EmptyDate : "",

ValueSeparator : ";",
RangeSeparator : "~",
ValueSeparatorHtml : " <b style='color:red;'>;</b> ",
RangeSeparatorHtml : " <b style='color:red;'>~</b> ",

LongDayNames : "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
ShortDayNames : "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
Day2CharNames : "Su,Mo,Tu,We,Th,Fr,Sa".split(","),
Day1CharNames : "S,M,T,W,T,F,S".split(","),
LongMonthNames : "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
LongMonthNames2 : "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
ShortMonthNames : "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
DayNumbers : "1st,2nd,3rd,4th,5th,6th,7th,8th,9th,10th,11th,12th,13th,14th,15th,16th,17th,18th,19th,20th,21st,22nd,23rd,24th,25th,26th,27th,28th,29th,30th,31st".split(","),
Quarters : "I,II,III,IV".split(","),
Halves : "I,II".split(","),
DateSeparator : "/",
InputDateSeparators : "/.-",
TimeSeparator : ":",
InputTimeSeparators : ":",
AMDesignator : "AM",
PMDesignator : "PM",
FirstWeekDay : 0,
NaD : "NaN",
GMT : 0,
Hirji : 0,

DecimalSeparator : ".",
InputDecimalSeparators : ".,",
GroupSeparator : ",",
InputGroupSeparators : ",",
Percent : "%",
NaN : "NaN",

d : "M/d/yyyy",
D : "d. MMMM yyyy",
t : "H:mm",
T : "H:mm:ss",
f : "d. MMMM yyyy H:mm",
F : "d. MMMM yyyy H:mm:ss",
g : "M/d/yyyy H:mm",
G : "M/d/yyyy H:mm:ss",
m : "d. MMMM",
M : "d. MMMM",
s : "yyyy-MM-ddTHH:mm:ss",
u : "yyyy-MM-dd HH:mm:ssZ",

U : "d. MMMM yyyy HH:mm:ss",
r : "ddd MMM d HH:mm:ss UTCzzzzz yyyy",
R : "ddd MMM d HH:mm:ss UTCzzzzz yyyy",
y : "MMMMMMM yyyy",
Y : "MMMMMMM yyyy",

ng : "0.######",
nf : "0.00",
nc : "$###########0.00",
np : "0.00%",
nr : "0.0000",
ne : "0.000000 E+000"
}

PFormat.CNumberMinMax = ["",/\D*0$/,/\D*0{1,2}$/,/\D*0{1,3}$/,/\D*0{1,4}$/,/\D*0{1,5}$/,/\D*0{1,6}$/,/\D*0{1,7}$/,/\D*0{1,8}$/,/\D*0{1,9}$/,/\D*0{1,10}$/,/\D*0{1,11}$/,/\D*0{1,12}$/,/\D*0{1,13}$/,/\D*0{1,14}$/,/\D*0{1,15}$/,/\D*0{1,16}$/,/\D*0{1,17}$/,/\D*0{1,18}$/,/\D*0{1,19}$/,/\D*0{1,20}$/];
PFormat.CEmptyString = ["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000"];
PFormat.CNumberSep = ["",/.{1,1}$/,/.{2,2}$/,/.{3,3}$/,/.{4,4}$/,/.{5,5}$/,/.{6,6}$/,/.{7,7}$/,/.{8,8}$/,/.{9,9}$/,/.{10,10}$/,/.{11,11}$/,/.{12,12}$/,/.{13,13}$/,/.{14,14}$/,/.{15,15}$/,/.{16,16}$/,/.{17,17}$/,/.{18,18}$/,/.{19,19}$/,/.{20,20}$/];

PFormat.CDateFormatEng = /\D*(\d{1,4})?\s*([\-\/\.])?\s*(\d{1,2})?\s*([\-\/\.])?\s*(\d{1,4})?[^\d\:\.]*(\d{1,2})?\s*[\:\.]?\s*(\d{1,2})?\s*[\:\.]?\s*(\d{1,2})?\s*([apAP]\.?[Mm]?\.?)?\D*/;
PFormat.CActualYear = (new Date()).getUTCFullYear();
PFormat.CActualMonth = (new Date()).getUTCMonth();
PFormat.CActualDay = (new Date()).getUTCDate();

PFormat.CDateFormat = /\W*(\d{1,4})?([a-zA-Z]+)?\s*([\-\/\.\,])?\s*(\d{1,4})?([a-zA-Z]+)?\s*([\-\/\.\,])?\s*(\d{1,4})?([a-zA-Z]+)?[^\d\:\.aApP]*(\d{1,2})?\s*([\:\.])?\s*(\d{1,2})?\s*([\:\.])?\s*(\d{1,2})?\s*([apAP]\.?[Mm]?\.?)?\W*/;

PFormat.CSearchEscape1 = /[\&\<]/;
PFormat.CSearchEscape2 = /[\&\<\n]/;
PFormat.CSearchEscape3 = /[\&\<\"\']/;
PFormat.CReplaceWhite = new RegExp(BIE5?"^ | $|  ":"^ | $| (?= )","g");
PFormat.CReplaceCR = /\n/g;
PFormat.CReplaceAmp = /\&/g;
PFormat.CReplaceLt = /\</g;
PFormat.CReplaceApos = /\'/g;
PFormat.CReplaceQuot = /\"/g;

PFormat.Parsed = {};

var TFormat = function(){ };
TFormat.prototype = PFormat;
Formats = new TFormat();

//---------------------------------------------------------------------------------------------------------------------------
PFormat.NumberToString = function(num,ff,range){

if(!ff) {
if(num-0 || num===0) return num+"";
return isFinite(num) ? "" : this.NaN;
}
var f = this.Parsed[ff];
if(!f){ f = this.ParseNumberFormat(ff); if(!f) return "Bad format"; }
if(!(num-0)) {
if(num=="0") return f.Zero;
return isFinite(num) ? f.Empty : f.NaN;
}
var neg = 0, exp="";
if(num<0){
num = -num;
neg = 1;
}
if(f.Exp){
var e = f.Exp;
if(num<=e.Min || num>=e.Max){
   exp = Math.floor(Math.log(num)*Math.LOG10E);
   if(e.Sub) exp-=e.Sub;
   num /= Math.pow(10,exp);
   var eneg = 0;
   if(exp<0){ eneg = 1; exp = -exp; }
   exp+="";
   if(e.Dig){
      var len = e.Dig-exp.length;
      if(len==1) exp = "0"+exp;
      else if(len==2) exp = "00"+exp;
      }
   if(eneg) exp = e.NegPrefix+exp+e.NegPostfix;
   else exp = e.Prefix+exp+e.Postfix;
   }
}
num = Math.round(num*f.Div);
if(num<1e21) num+="";
else {
var s = "";
while(num>=1e21){ s+="000"; num/=1000; }
num += s;
}
if(f.Dig){
var len = f.Max+f.Dig-num.length;
if(len>0) num = (len==1 ? "0" : this.CEmptyString[len]) + num;
}
if(f.Group){
var len = num.length - f.Max;
if(len>3){
   if(len<7) num = num.slice(0,len-3) + f.Group + num.slice(len-3);
   else if(len<10) num = num.slice(0,len-6) + f.Group + num.slice(len-6,len-3) + f.Group + num.slice(len-3);
   else {
      var s = num.slice(len-3,len+f.Max); len-=3;
      while(len>3){ s = num.slice(len-3,len) + f.Group + s; len -= 3; }
      num = (len ? num.slice(0,len)+f.Group : "")+s;
      }
   }
}
if(f.Max){
if(BIE5){
   var cnt = num.length-f.Max, d = num.slice(cnt);
   if(f.Max!=f.Min) d = d.replace(this.CNumberMinMax[f.Max-f.Min],"");
   if(d) num = num.slice(0,cnt) + f.Sep + d;
   else num = num.slice(0,cnt);
   }
else {
   num = num.replace(this.CNumberSep[f.Max],f.Sep+"$&");
   if(f.Max!=f.Min) num = num.replace(this.CNumberMinMax[f.Max-f.Min],"");
   }
}
if(neg) return f.NegPrefix + num + exp + f.NegPostfix;
return f.Prefix + num + exp + f.Postfix;
}
//---------------------------------------------------------------------------------------------------------------------------
PFormat.ParseNumberFormat = function(f,neg){
if(!f) return null;
if(f.length==1){
switch(f){
   case 'g' : f = this.ng; break;
   case 'f' : f = this.nf; break;
   case 'c' : f = this.nc; break;
   case 'p' : f = this.np; break;
   case 'r' : f = this.nr; break;
   case 'e' : f = this.ne; break;
   }
}

var F = {Dig:0,Min:0,Max:0,Div:1,Sep:"",Group:"",Prefix:"",Postfix:""};

var g = 0, pp = "", t = 0;
for(var i=0;i<f.length;i++){
var c = f.charAt(i);
if(c=='0' || c=='#'){
   if(g){ F.Group = this.GroupSeparator; g = 0; }
   if(t==0){ t=1; F.Prefix = pp; pp = ""; }
   if(t==2){ t=3; F.Sep = pp; pp = ""; }
   }
if(c=='"' || c=="'"){
   for(i++;i<f.length && f.charAt(i)!=c;i++) pp += f.charAt(i);
   }
else if(c=='\\'){
   i++;
   pp += f.charAt(i);
   }
else if(c=='0'){
   if(t==1) F.Dig++;
   if(t==3){ F.Min++;F.Max++; }
   if(t==5) F.Exp.Dig++;
   }
else if(c=='#'){
   if(t==3){ F.Max++; }
   if(t==5) F.Exp.Dig++;
   }
else if(c=='.'){
   if(t==0){ t=1; F.Prefix = pp; pp = ""; }
   if(t<2) t = 2;
   pp += this.DecimalSeparator;
   if(g) { F.Div/=Math.pow(1000,g); g = 0; }
   }
else if(c==','){
   if(t<2) g++;
   }
else if(c=='%'){
   pp += this.Percent;
   F.Div*=100;
   }
else if(c==';'){
   var ff = f.slice(i+1);
   if(!ff) F.Zero = "";
   else {
      var N = this.ParseNumberFormat(ff,1);
      if(N){
         if(neg){
            F.Zero = N.Prefix + this.CEmptyString[N.Dig] + N.Sep + this.CEmptyString[N.Min] + N.Postfix;
            }
         else {
            F.NegPrefix = N.Prefix; F.NegPostfix = N.Postfix; F.Zero = N.Zero;
            }
         }
      }
   break;
   }
else if((c=='e' || c=='E') && pp==0){
   var e = new Object();
   F.Exp = e;
   e.Dig = 0;
   e.Min = 1; e.Max = 1;
   e.Sub = F.Dig-1; if(e.Sub<0) e.Sub = 0;
   c = pp + c; pp = "";
   e.Prefix = c; e.NegPrefix = c+"-";
   e.Postfix = ""; e.NegPostfix = "";
   var sig = f.charAt(i+1);
   if(sig=='-') i++;
   else if(sig=='+'){ e.Prefix+='+'; i++; }
   t = 5;
   }
else pp += c;
}
F.Postfix = pp;
F.Div *= Math.pow(10,F.Max);
if(F.NegPrefix==null) F.NegPrefix = F.Prefix+"-";
if(F.NegPostfix==null) F.NegPostfix = F.Postfix;
if(F.Zero==null){
if(F.Exp) F.Zero = F.Prefix + this.CEmptyString[F.Dig] + (F.Dig||F.Min?F.Sep:"0") + this.CEmptyString[F.Min] + F.Exp.Prefix + this.CEmptyString[F.Exp.Dig] + F.Exp.Postfix + F.Postfix;
else F.Zero = F.Prefix + this.CEmptyString[F.Dig] + (F.Dig||F.Min?F.Sep:"0") + this.CEmptyString[F.Min] + F.Postfix;
}
F.NaN = this.NaN;
this.Parsed[f] = F;
F.Empty = this.EmptyNumber==null?this.NumberToString(0,f):this.EmptyNumber;
return F;
}
//-----------------------------------------------------------------------------------------------------------
//Converts number to string, ignores format. Its possible to read hexadecimal numbers with 'x' preffix.
PFormat.StringToNumber = function(str,f,range){
if(!str) return this.EmptyNumber!=null ? "" : 0;
if(str==this.EmptyNumber) return "";
if(str-0+""==str) return str-0;

if(!str.replace) return parseFloat(str);
var gs = this.InputGroupSeparators; if(gs) gs = "\\"+gs.split('').join('\\');
str = str.replace(new RegExp("[\\s"+gs+"]","g"),"").replace(new RegExp("[\\"+this.InputDecimalSeparators.split('').join('\\')+"]","g"),".");
if(str.search(/[xe]/i)>=0){
if(str.charAt(0).toLowerCase()=="x") str="0"+str;
try { return eval(str); }
catch(e){ return 0; }
}
return parseFloat(str);
}
PFormat.DateToStringEng = function(num,pnGmt){
if(num==null||num==="") return "";
if(typeof(num)!="object") num = new Date(num-0+""==num?num-0:num);
if(!isFinite(num)) return this.NaD;
var vnGmt = this.GMT;
if(pnGmt != null) vnGmt = pnGmt;
if(vnGmt-0) {
var d = num.getUTCDate(), M = num.getUTCMonth()+1, y = num.getUTCFullYear();
var h = num.getUTCHours(), m = num.getUTCMinutes(), s = num.getUTCSeconds();
}
else {
var d = num.getDate(), M = num.getMonth()+1, y = num.getFullYear();
var h = num.getHours(), m = num.getMinutes(), s = num.getSeconds();
}
var S = "";
if(d!=1 || M!=1 || y!=1970) S = (M<10?"0":"")+M+"/"+(d<10?"0":"")+d+"/"+y;
if(h||m||s) S += (S?" ":"")+(h<10?"0":"")+h+":"+(m<10?"0":"")+m+(s?":"+(s<10?"0":"")+s:"");
return S;
}
//---------------------------------------------------------------------------------------------------------------------------
PFormat.DateToString = function(num,ff,range,pnGmt){

if(!ff) return this.DateToStringEng(num,pnGmt);
var f = this.Parsed[ff];
if(!f){
f = this.ParseDateFormat(ff,pnGmt);
if(!f) return "Bad format";
this.Parsed[ff] = f;
}
if(num==null || num==="") return f[3];
if(typeof(num)!="object") num = new Date(num-0+""==num?num-0:num);
if(!isFinite(num)) return f[4];
var len = f.length, s = f[10], n;

if(f[2]=="0") for(var i=11;i<len;i+=2){
switch(f[i]){
   case 1: s += num.getUTCDate(); break;
   case 2: n = num.getUTCDate(); s += n<10?"0"+n:n; break;
   case 3: s += f[6][num.getUTCDay()]; break;
   case 6: s += f[7][num.getUTCDate()-1]; break;
   case 7:
      var ddd = new Date(num.getUTCFullYear(),0,1);
      s += Math.ceil((((num - ddd) / 86400000) + ddd.getUTCDay())/7);
      break;
   case 11: s += num.getUTCMonth()+1; break;
   case 12: n = num.getUTCMonth()+1; s += n<10?"0"+n:n; break;
   case 13: s += f[5][num.getUTCMonth()]; break;
   case 15: s += f[5][Math.floor(num.getUTCMonth()/3)]; break;
   case 16: s += f[5][Math.floor(num.getUTCMonth()/6)]; break;
   case 21: s += num.getUTCFullYear()%100; break;
   case 22: n = num.getUTCFullYear()%100; s += n<10?"0"+n:n; break;
   case 24: s += num.getUTCFullYear(); break;
   case 41 : s += num.getUTCHours()%12; break;
   case 42 : n = num.getUTCHours()%12; s += n<10?"0"+n:n; break;
   case 51 : s += num.getUTCHours(); break;
   case 52 : n = num.getUTCHours(); s += n<10?"0"+n:n; break;
   case 61 : s += num.getUTCMinutes(); break;
   case 62 : n = num.getUTCMinutes(); s += n<10?"0"+n:n; break;
   case 71 : s += num.getUTCSeconds(); break;
   case 72 : n = num.getUTCSeconds(); s += n<10?"0"+n:n; break;
   case 81 : s += num.getUTCHours()<12?f[8]:f[9]; break;
   default:
      n = -num.getTimezoneOffset();
       if(n<0){ s+="-"; n=-n; } else s+="+";
       s += (n<600&&f[i]==92||f[i]==94||f[i]==95 ? "0":"") + Math.round(n/60);
       if(f[i]>=93){ n = n%60; s += (f[i]==95?"":":") + (n<10?"0":"") + n; }
      break;
   }
s+=f[i+1];
}

else if(!f[2]) for(var i=11;i<len;i+=2){
switch(f[i]){
   case 1: s += num.getDate(); break;
   case 2: n = num.getDate(); s += n<10?"0"+n:n; break;
   case 3: s += f[6][num.getDay()]; break;
   case 6: s += f[7][num.getDate()-1]; break;
   case 7:
      var ddd = new Date(num.getFullYear(),0,1);
      s += Math.ceil((((num - ddd) / 86400000) + ddd.getDay())/7);
      break;
   case 11: s += num.getMonth()+1; break;
   case 12: n = num.getMonth()+1; s += n<10?"0"+n:n; break;
   case 13: s += f[5][num.getMonth()]; break;
   case 15: s += f[5][Math.floor(num.getMonth()/3)]; break;
   case 16: s += f[5][Math.floor(num.getMonth()/6)]; break;
   case 21: s += num.getFullYear()%100; break;
   case 22: n = num.getFullYear()%100; s += n<10?"0"+n:n; break;
   case 24: s += num.getFullYear(); break;
   case 41 : s += num.getHours()%12; break;
   case 42 : n = num.getHours()%12; s += n<10?"0"+n:n; break;
   case 51 : s += num.getHours(); break;
   case 52 : n = num.getHours(); s += n<10?"0"+n:n; break;
   case 61 : s += num.getMinutes(); break;
   case 62 : n = num.getMinutes(); s += n<10?"0"+n:n; break;
   case 71 : s += num.getSeconds(); break;
   case 72 : n = num.getSeconds(); s += n<10?"0"+n:n; break;
   case 81 : s += num.getHours()<12?f[8]:f[9]; break;
   default:
      n = -num.getTimezoneOffset();
       if(n<0){ s+="-"; n=-n; } else s+="+";
       s += (n<600&&f[i]==92||f[i]==94||f[i]==95 ? "0":"") + Math.round(n/60);
       if(f[i]>=93){ n = n%60; s += (f[i]==95?"":":") + (n<10?"0":"") + n; }
      break;
   }
s+=f[i+1];
}
return s;
}

PFormat.ParseDateFormat = function(f,pnGmt){
if(!f) return null;
var vnGmt = this.GMT;
if(pnGmt != null) vnGmt = pnGmt;
var F = [null,null,vnGmt-0?0:null,this.EmptyDate?this.EmptyDate:"",this.NaD];
if(f.length==1){
if(f=='U') F[2] = 0;
if(f=='R' || f=='r') F[2] = null;
if(this[f]) f = this[f];
}

var p = 10, out = "";
for(var i=0;i<f.length;i++){
switch(f.charAt(i)){
   case '%' : break;
   case '/' : out+=this.DateSeparator; break;
   case ':' : out+=this.TimeSeparator; break;
   case 'd' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='d'){ F[p++]=1; break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=2; break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=3; F[6] = this.ShortDayNames; break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=3; F[6] = this.LongDayNames;  break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=3; F[6] = this.Day1CharNames;  break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=6; F[7] = this.DayNumbers; break; }
      i++; if(f.charAt(i+1)!='d'){ F[p++]=7; break; }
      F[p++] = ""; break;
   case 'M' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='M'){ F[p++] = 11; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 12; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 13; F[5] = this.ShortMonthNames; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 13; F[5] = this.LongMonthNames; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 15; F[5] = this.Quarters; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 16; F[5] = this.Halves; break; }
      i++; if(f.charAt(i+1)!='M'){ F[p++] = 13; F[5] = this.LongMonthNames2; break; }
      F[p++] = ""; break;
   case 'y' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='y'){ F[p++] = 21; break; }
      i++; if(f.charAt(i+1)!='y'){ F[p++] = 22; break; }
      i++; if(f.charAt(i+1)!='y'){ F[p++] = "";  break; }
      i++; if(f.charAt(i+1)!='y'){ F[p++] = 24; break; }
      F[p++] = ""; break;
   case 'h' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='h'){ F[p++] = 41; break; }
      i++; if(f.charAt(i+1)!='h'){ F[p++] = 42; break; }
      F[p++] = ""; break;
   case 'H' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='H'){ F[p++] = 51; break; }
      i++; if(f.charAt(i+1)!='H'){ F[p++] = 52; break; }
      F[p++] = ""; break;
   case 'm' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='m'){ F[p++] = 61; break; }
      i++; if(f.charAt(i+1)!='m'){ F[p++] = 62; break; }
      F[p++] = ""; break;
   case 's' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='s'){ F[p++] = 71; break; }
      i++; if(f.charAt(i+1)!='s'){ F[p++] = 72; break; }
      F[p++] = ""; break;

   case 't' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='t'){ F[p++] = 81; F[8] = this.AMDesignator.charAt(0); F[9] = this.PMDesignator.charAt(0); break; }
      i++; if(f.charAt(i+1)!='t'){ F[p++] = 81; F[8] = this.AMDesignator; F[9] = this.PMDesignator; break; }
      F[p++] = ""; break;
   case 'z' :
      F[p++] = out; out="";
      if(f.charAt(i+1)!='z'){ F[p++]=91; break; }
      i++; if(f.charAt(i+1)!='z'){ F[p++]=92; break; }
      i++; if(f.charAt(i+1)!='z'){ F[p++]=93; break; }
      i++; if(f.charAt(i+1)!='z'){ F[p++]=94; break; }
      i++; if(f.charAt(i+1)!='z'){ F[p++]=95; break; }
      break;
   case '\\' : i++; out+=f.charAt(i); break;
   case '"' :
   case "'" :
      var pos = f.indexOf(f.charAt(i),i+1);
      if(pos==-1) break;
      out+=f.substring(i+1,pos); i=pos;
      break;
   default : out+=f.charAt(i);
   }
}
F[p] = out;
return F;
}
//---------------------------------------------------------------------------------------------------------------------------
//Converts string to date (number of milliseconds), possible formats: yyyy-mm-dd, mm-dd, mm/dd/yyyy, mm/dd, dd.mm.yyyy, dd.mm nebo hh:mm, hh:mm:ss

PFormat.StringToDateEng = function(str,pnGmt){
if(!str) return this.EmptyDate!=null ? "" : 0;
if(str==this.EmptyDate) return "";
var M = (str+"").match(this.CDateFormatEng);
if(!M) return 0;
var c = M[2], d, h = M[6], m = M[7], s = M[8];
if(!h) h = 0; if(!m) m = 0; if(!s) s = 0;

if(M[9]){
var a = M[9].charAt(0);
if(!c) h = M[1];
if(h<12) { if(a=='p' || a=='P') h = h-0+12; }
else if(h==12) { if(a=='a' || a=='A') h = 0; }
if(!c) M[1] = h;
}
var vnGmt = this.GMT;
if(pnGmt != null) vnGmt = pnGmt;
if(vnGmt-0) {

if(!c) {
   if(M[7]) return Date.UTC(1970,0,1,M[1],m,s);
   if(!M[1]&&M[0]-0+""!=M[0]) return NaN;
   return Date.UTC(this.CActualYear,this.CActualMonth,M[1]?M[1]:this.CActualDay);
   }

if(M[4]){
   if(c=='/') return Date.UTC(M[5]<70?M[5]-0+2000:M[5],M[1]-1,M[3],h,m,s);
   if(c=='-') return Date.UTC(M[1]<70?M[5]-0+2000:M[1],M[3]-1,M[5],h,m,s);
   if(c=='.') return Date.UTC(M[5]<70?M[5]-0+2000:M[5],M[3]-1,M[1],h,m,s);
   return 0;
   }

if(c=='/') return Date.UTC(this.CActualYear,M[1]-1,M[3]?M[3]:1,h,m,s);
if(c=='-') return Date.UTC(this.CActualYear,M[1]-1,M[3]?M[3]:1,h,m,s);
if(c=='.') return Date.UTC(this.CActualYear,M[3]?M[3]-1:CActualMonth,M[1],h,m,s);
return 0;
}

if(!c){
if(M[7]) return (new Date(1970,0,1,M[1],m,s)).getTime();
if(!M[1]&&M[0]-0+""!=M[0]) return NaN;
return (new Date(this.CActualYear,this.CActualMonth,M[1]?M[1]:this.CActualDay)).getTime();
}

if(M[4]){
if(c=='/') return (new Date(M[5]<70?M[5]-0+2000:M[5],M[1]-1,M[3],h,m,s)).getTime();
if(c=='-') return (new Date(M[1]<70?M[5]-0+2000:M[1],M[3]-1,M[5],h,m,s)).getTime();
if(c=='.') return (new Date(M[5]<70?M[5]-0+2000:M[5],M[3]-1,M[1],h,m,s)).getTime();
return 0;
}

if(c=='/') return (new Date(this.CActualYear,M[1]-1,M[3]?M[3]:1,h,m,s)).getTime();
if(c=='-') return (new Date(this.CActualYear,M[1]-1,M[3]?M[3]:1,h,m,s)).getTime();
if(c=='.') return (new Date(this.CActualYear,M[3]?M[3]-1:CActualMonth,M[1],h,m,s)).getTime();
return 0;
}
//---------------------------------------------------------------------------------------------------------------------------
PFormat.StringToDate = function(str,f,range,pnGmt){
if(!str) return this.EmptyDate!=null ? "" : 0;
if(str==this.EmptyDate) return "";

if(!f) return this.StringToDateEng(str,pnGmt);

var gmt = this.GMT-0;
if(pnGmt != null) gmt = pnGmt;

function GetIndex(str,A){
if(!A) return null;
str = str.toLowerCase();
for(var i=0;i<A.length;i++) if(A[i].toLowerCase()==str) return i+1;
return null;
}

function GetMonthIndex(str){
var m = GetIndex(str,this.LongMonthNames); if(m) return m;
m = GetIndex(str,this.LongMonthNames2); if(m) return m;
m = GetIndex(str,this.ShortMonthNames); if(m) return m;
return null;
}

if(f.length==1){
f = this[f];
if(!f) this.DateToStringEng(str,pnGmt);
}
f = f.replace(/\'[^\']*\'|\"[^\"]*\"|\\\S/g,"");

if(str-0 && str.length>=3){
var ok = 0, len = str.length;
var h=0,n=0,s=0;
//if(f.indexOf('M')<0){
if(/(h{1,2}|m{1,2}|s{1,2})/.test(f)){
   if(len==6){ h = str.slice(0,2)-0; n = str.slice(2,4)-0; s = str.slice(4,6)-0; ok = 1; }
   else if(len==5){ h = str.slice(0,1)-0; n = str.slice(1,3)-0; s = str.slice(3,5)-0; ok = 1; }
   else if(len==4){
      if(f.search(/h/i)>=0){ h = str.slice(0,2)-0; n = str.slice(2,4)-0; ok = 1; }
      else { n = str.slice(0,2)-0; s = str.slice(2,4)-0; ok = 1; }
      }
   else if(len==3){
      if(f.search(/h/i)>=0){ h = str.slice(0,1)-0; n = str.slice(1,3)-0; ok = 1; }
      else { n = str.slice(0,1)-0; s = str.slice(1,3)-0; ok = 1; }
      }
   if(ok) return gmt ? Date.UTC(1970,0,1,h,n,s) : (new Date(1970,0,1,h,n,s)).getTime();
   }
else {
   var date = new Date();
   if(gmt) { var d = date.getUTCDate(), m = date.getUTCMonth(), y = date.getUTCFullYear(); }
   else { var d = date.getDate(), m = date.getMonth()+1, y = date.getFullYear(); }
   if(len==3){
      if(f.search(/M.*d/)>=0){ m = str.slice(0,1)-0; d = str.slice(1,3)-0; ok = 1; }
      else if(f.search(/d.*M/)>=0){ d = str.slice(0,1)-0; m = str.slice(1,3)-0; ok = 1; }
      }
   else if(len==4){
      if(f.search(/M.*d/)>=0){ m = str.slice(0,2)-0; d = str.slice(2,4)-0; ok = 1; }
      else if(f.search(/d.*M/)>=0){ d = str.slice(0,2)-0; m = str.slice(2,4)-0; ok = 1; }
      else if(f.search(/y.*M/)>=0){ y = str.slice(0,2)-0; m = str.slice(2,4)-0; y+=y<70?2000:1900; ok = 1; }
      else if(f.search(/M.*y/)>=0){ m = str.slice(0,2)-0; y = str.slice(2,4)-0; y+=y<70?2000:1900; ok = 1; }
      }
   else if(len==6){
      if(f.search(/M.*d.*y/)>=0){ m = str.slice(0,2)-0; d = str.slice(2,4)-0; y = str.slice(4,6)-0; y+=y<70?2000:1900; ok = 1; }
      else if(f.search(/d.*M.*y/)>=0){ d = str.slice(0,2)-0; m = str.slice(2,4)-0; y = str.slice(4,6)-0; y+=y<70?2000:1900; ok = 1; }
      else if(f.search(/y.*M.*d/)>=0){ y = str.slice(0,2)-0; m = str.slice(2,4)-0; d = str.slice(4,6)-0; y+=y<70?2000:1900; ok = 1; }
      else if(f.search(/y.*d.*M/)>=0){ y = str.slice(0,2)-0; d = str.slice(2,4)-0; m = str.slice(4,6)-0; y+=y<70?2000:1900; ok = 1; }
      else if(f.search(/yyyy.*M/)>=0){ y = str.slice(0,4)-0; m = str.slice(4,6)-0; ok = 1; }
      else if(f.search(/M.*yyyy/)>=0){ m = str.slice(0,2)-0; y = str.slice(2,6)-0; ok = 1; }
      }
   else if(len==8){
      if(f.search(/M.*d.*y/)>=0){ m = str.slice(0,2)-0; d = str.slice(2,4)-0; y = str.slice(4,8)-0; ok = 1; }
      else if(f.search(/d.*M.*y/)>=0){ d = str.slice(0,2)-0; m = str.slice(2,4)-0; y = str.slice(4,8)-0; ok = 1; }
      else if(f.search(/y.*M.*d/)>=0){ y = str.slice(0,4)-0; m = str.slice(4,6)-0; d = str.slice(6,8)-0; ok = 1; }
      else if(f.search(/y.*d.*M/)>=0){ y = str.slice(0,4)-0; d = str.slice(4,6)-0; m = str.slice(6,8)-0; ok = 1; }
      }
   if(ok) return gmt ? Date.UTC(y,m-1,d) : (new Date(y,m-1,d)).getTime();
   }
}

var M = str.match(this.CDateFormat);

if(!M) return 0;
var d,m,y,h = M[9], n = M[11], s = M[13], t = 0;
if(!M[3]&&!M[4]&&!M[5] && M[10]) t = f.search(/[dMy]/)<0 ? 1 : 2;
else if(M[3]=='.' && !h && !n){
if(f.search(/[dMy]/)<0) t = 1;
else if(this.TimeSeparator=='.') t = 2;
if(t){ n = M[4]; s = M[7]; }
}
else if(M[1] && !M[2] && !h && f.search(/[dMy]/)<0) t = 1;

if(t) h = M[1];
else if(!h && M[10]){
if(M[7]){ h = M[7]; M[7] = null; }
}
if(!h) h = 0; if(!n) n = 0; if(!s) s = 0;

if(M[14] || !M[3]&&M[2]&&M[2].search(/^[ap]m?$/i)==0){
var a = (M[14]?M[14]:M[2]).charAt(0);
if(!M[14]) { t = 1; h = M[1]-0; }
if(h<12) { if(a=='p' || a=='P') h = h-0+12; }
else if(h==12) { if(a=='a' || a=='A') h = 0; }
}

if(t==2) {
var date = new Date();
if(gmt) date.setUTCHours(h,n,s,0);
else date.setHours(h,n,s,0);
return date.getTime();
}
else if(t==1) return gmt ? Date.UTC(1970,0,1,h,n,s) : (new Date(1970,0,1,h,n,s)).getTime();

if(!M[1] && M[2]){
m = GetMonthIndex(M[2]); if(!m) return 0
d = M[4];
y = M[7];
}
else if(!M[4] && M[5]){
m = GetMonthIndex(M[5]); if(!m) return 0
d = M[1];
y = M[7];
}
else if(!M[7] && M[8]){
m = GetMonthIndex(M[8]); if(!m) return 0
d = M[4];
y = M[1];
}
else if(M[1]>31){
d = M[7]; m = M[4];
if(f.search(/y{1,4}\W*d{1,2}/)>=0){ d = M[4]; m = M[7]; }
if(!d) d = 1;
if(!m) m = 1;
y = M[1];
}
else if(M[4]>31){
d = M[7]; if(!d) d = 1;
m = M[1];
if(f.search(/d{1,2}\W*y{1,4}/)>=0){ m = d; d = M[1]; }
y = M[4];
}
else if(!M[1]){
d = this.CActualDay;
}
else {

if(f.search(/d{1,2}\W*M{1,5}/)>=0){
   if(f.search(/y{1,4}\W*d{1,2}/)>=0){
      d = M[4]; if(!d) d = 1;
      m = M[7]; if(!m) m = 1;
      y = M[1];
      if(m>12 && y<=31) { d = M[1]; m = M[4]; y = M[7]; }
      }
   else {
      d = M[1]; m = M[4]; y = M[7];
      }
   }
else if(f.search(/y{1,4}\W*M{1,5}/)>=0){
   if(f.search(/d{1,2}\W*y{1,4}/)>=0){
      d = M[1];
      m = M[7];
      y = M[4];
      }
   else {
      d = M[7]; if(!d) d = 1;
      m = M[4]; if(!m) m = 1;
      y = M[1];
      if(d>31 && y<=31) { d = M[1]; m = M[4]; y = M[7]; }
      }
   }
else if(f.search(/M{1,5}\W*y{1,4}/)>=0){
   d = M[7]; if(!d) d = 1;
   m = M[1];
   y = M[4];
   }
else {
   d = M[4]; if(!d) d = 1;
   m = M[1];
   y = M[7];
   }
}
if(!y){ y = m||d ? this.CActualYear : 1970; }
else if(y<100){ if(y<70) y=y-0+2000; else y=y-0+1900; }
if(!m) m = d ? this.CActualMonth+1 : 1;
m--;
if(!d) d = 1;
return gmt ? Date.UTC(y,m,d,h,n,s) : (new Date(y,m,d,h,n,s)).getTime();

}

//-----------------------------------------------------------------------------------------------------------
//Converts value to show it in HTML
PFormat.Escape = function(val){
if(val==null) return "";
if(typeof(val)!="string") return val+"";
if(val.search(this.CSearchEscape3)<0) return val;
if(val.indexOf("&")>=0) val = val.replace(PFormat.CReplaceAmp,"&amp;");
if(val.indexOf("<")>=0) val = val.replace(PFormat.CReplaceLt,"&lt;");
if(val.indexOf('"')>=0) val = val.replace(PFormat.CReplaceQuot,"&quot;");
if(val.indexOf("'")>=0) val = val.replace(PFormat.CReplaceApos,"&#x27;");
return val;
}
//-----------------------------------------------------------------------------------------------------------
//Formats HTML string of types "Text" and "Lines"
PFormat.FormatString = function(Value,format, esc){
if(Value==null) Value="";
else Value+="";
if(!format){
if(!esc) return Value;
if(Value.search(this.CSearchEscape2)>=0) {
   if(Value.indexOf("&")>=0) Value = Value.replace(this.CReplaceAmp,"&amp;");
   if(Value.indexOf("<")>=0) Value = Value.replace(this.CReplaceLt,"&lt;");
   if(Value.indexOf("\n")>=0) Value = Value.replace(this.CReplaceCR,"<br>");
   }
if(Value.indexOf(" ")>=0) Value = Value.replace(this.CReplaceWhite,CNBSP);
return Value;
}
format+="";
var f = format.split(format.charAt(0));
if(f[4]){
try { Value = Value.replace(new RegExp(f[4],f[5]),f[6]); }
catch(e){ alert ((e.message?e.message:e)+"\n\nin value: "+Value+"\nwith format: "+format+"\nregex: /"+f[4]+"/"+f[5]+" => "+f[6]); }
}
switch(f[1]-0){
case 1 : Value = Value.toLowerCase(); break;
case 2 : Value = Value.toUpperCase(); break;
case 3 : Value = Value.toLocaleLowerCase(); break;
case 4 : Value = Value.toLocaleUpperCase(); break;
}
return (f[2] ? (esc>1 ? this.Escape(f[2]) : f[2]) : "") + (esc ? this.Escape(Value).replace(this.CReplaceWhite,CNBSP).replace(this.CReplaceCR,"<br/>") : Value) + (f[3] ? (esc>1 ? this.Escape(f[3]) : f[3]) : "");
}
//-----------------------------------------------------------------------------------------------------------
//Converts value to show it in HTML

//-----------------------------------------------------------------------------------------------------------
PFormat.StringToValue = function(val,type,format,range){
if(type=="Int" || type=="Float") val = this.StringToNumber(val,format,range);
else if(type=="Date") val = this.StringToDate(val,format,range);
return val;
}
//-----------------------------------------------------------------------------------------------------------
PFormat.ValueToString = function(val,type,format,range){
if(type=="Int" || type=="Float") {
if(val==="" && this.EmptyNumber) return "";
val = this.NumberToString(val,format,range);
}
else if(type=="Date") {
if(val==="" && this.EmptyDate) return "";
val = this.DateToString(val,format,range);
}
else if(val==null) val = "";
else val+="";
return val;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of import Format6.js

var TGP = {};
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of import Value6.js
TGP.GetString = function(psValue, psType, psFormat, pnGmt){
var type = psType, Value = psValue;
switch(type){
case "string" :
  return PFormat.FormatString(Value, psFormat);
case "number":
  return PFormat.NumberToString(Value, psFormat);
case "date":
  return  PFormat.DateToString(Value, psFormat, null, pnGmt);
default:
  return Value;
}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of import Value6.js

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of import Grid/Edit6.js
TGP.GetValueInput = function(Value, psType, psFormat, pnGmt){
var format = psFormat, type = psType;
switch(type){
case "number":
   if(Value==="" && PFormat.EmptyNumber!=null) return "";
   Value = PFormat.StringToNumber(Value,format);
   return Value;
case "date":
   if(Value==="" && PFormat.EmptyDate!=null) return "";
   if(Value==PFormat.NaN) return '/';
   return PFormat.StringToDate(Value,format,null,pnGmt);
   return '/';
case "string":
   if(!format) return Value;
   var f = format.split(format.charAt(0));
   if(f[2]!="" && Value.slice(0,f[2].length)==f[2]) Value = Value.slice(f[2].length);
   if(f[3]!="" && Value.slice(Value.length-f[3].length,Value.length)==f[3]) Value = Value.slice(0,Value.length-f[3].length);
   return Value;
default:
   return Value;
}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of import Grid/Edit6.js

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of import Lib/Edit6.js
function TestKey(ev,tag,func,data){
var okey = ev.keyCode; if(!okey || BMozilla) okey = ev.charCode; if(!okey) return;
var nkey = func(okey,tag.value,data), dom2 = !!ev.preventDefault;
if(typeof(nkey)=="string") nkey = nkey.charCodeAt(0);
if(nkey && nkey!=okey){
  if(!dom2) ev.keyCode = nkey;
  else {
     try {
        var s = tag.selectionStart, e = tag.selectionEnd; if(e==null) e = s;
        tag.value = tag.value.slice(0,s)+String.fromCharCode(nkey)+tag.value.slice(e);
        tag.selectionStart = s+1; tag.selectionEnd = s+1;
        }
     catch(e) { }
     nkey = 0;
     }
  }
if(!nkey){
  if(dom2) ev.preventDefault();
  else ev.returnValue = false;
  }
if(tag.control.onkeypress)  {
  tag.control.onkeypress(new eXria.event.Event(ev, tag.control.window));
}
return nkey;
}
// -----------------------------------------------------------------------------------------------------------
// Tests pressed key if can be added into integer number, include hexadecimal numbers
function TestKeyInt(key,val,add){
if(key>=97 && key<=122) key-=32;
if(add) for(var i=0;i<add.length;i++) if(key==add.charCodeAt(i)) return key;

if(key==88) return 120;

if(key==45) return  key;
if(key>=65 && key<=70) return val.indexOf('x')>=0 ? key : 0;
if(key>=48 && key<=57 || key==8 || BSafari&&(key==37 || key==39)) return key;
return 0;
}

// -----------------------------------------------------------------------------------------------------------
// Tests pressed key if can be added into floating point number
function TestKeyFloat(key,val,add){
if(key>=97 && key<=122) key-=32;
if(add) for(var i=0;i<add.length;i++) if(key==add.charCodeAt(i)) return key;
if(key==45) return key;
for(var i=0;i<Formats.InputDecimalSeparators.length;i++) if(key==Formats.InputDecimalSeparators.charCodeAt(i)){

  return Formats.DecimalSeparator.charCodeAt(0);
  }
for(var i=0;i<Formats.InputGroupSeparators.length;i++) if(key==Formats.InputGroupSeparators.charCodeAt(i)) {

  return Formats.GroupSeparator.charCodeAt(0);
  }
if(key==69) return val.indexOf('e')>=0 ? 0 : 101;
if(key>=48 && key<=57 || key==8 || key==37 || key==39) return key;
return 0;
}
// -----------------------------------------------------------------------------------------------------------
// Tests pressed key if can be added into date/time value
function TestKeyDate(key,val,add){
if(key>=97 && key<=122) key-=32;
if(add) for(var i=0;i<add.length;i++) if(key==add.charCodeAt(i)) return key;
for(var i=0;i<Formats.InputDateSeparators.length;i++) if(key==Formats.InputDateSeparators.charCodeAt(i)) return Formats.DateSeparator.charCodeAt(0);
for(var i=0;i<Formats.InputTimeSeparators.length;i++) if(key==Formats.InputTimeSeparators.charCodeAt(i)) return Formats.TimeSeparator.charCodeAt(0);
if(key==32 || key==44) return 32;
if(key>=48 && key<=57 || key==8 || key==37 || key==39) return key;
return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of import Lib/Edit6.js


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of eXria.controls.xhtml.DateInput.js override
eXria.controls.xhtml.DateInput.prototype.getDate = eXria.controls.xhtml.EditMask.prototype.getDate;
eXria.controls.xhtml.DateInput.prototype.getDateString = eXria.controls.xhtml.EditMask.prototype.getDateString;
eXria.controls.xhtml.Output.prototype.getDate = eXria.controls.xhtml.DateInput.prototype.getDate;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of eXria.controls.xhtml.DateInput.js override

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//start of eXria.controls.xhtml.Output.js override

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//end of eXria.controls.xhtml.Output.js override

/**
 * @fileoverview
 * Concreate xhtml GridEx
 * @작성자 : 김경태
 * @version 2.0
 */

/**
 * @class GridEx의 toolbar 설정 속성을 저장하기 위한 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx_toolbar 객체
 * @type eXria.controls.xhtml.GridEx_toolbar
 * @constructor
 * @ignore
 */
eXria.controls.xhtml.GridEx_toolbar = function() {
  /**
   * 그리드에 toolbar를 표시할 지 여부
   * @type Boolean
   */
  this.visible = true;
  /**
   * 표시될 툴바 버튼 목록을 정의한 문자열
   * @type String
   * @private
   */
  this.cells = "Save,Reload,Repaint,Print,Export,Add,AddChild,ExpandAll,CollapseAll,Columns,Cfg";
};

/**
 * @class GridEx의 panel 설정 속성을 저장하기 위한 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx_panel 객체
 * @type eXria.controls.xhtml.GridEx_panel
 * @constructor
 */
eXria.controls.xhtml.GridEx_panel = function() {
  /**
   * @private
   */
  this.copy = null;
  /**
   * @private
   */
  this.move = null;
  /**
   * @private
   */
  this.select = null;
  /**
   * @private
   */
  this.del = null;
};

/**
 * @class GridEx에 이벤트 핸들러에 전달되는 이벤트 구조 정의 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx_event 객체
 * @type eXria.controls.xhtml.GridEx_event
 * @constructor
 */
eXria.controls.xhtml.GridEx_event = function() {
  /**
   * GridEx 객체
   * @type eXria.controls.xhtml.GridEx
   */
  this.object = null;
  /**
   * event 타입을 구분하기 위한 속성
   * @type Number
   */
  this.type = null;
  /**
   * 칼럼 id
   * @type Strnig
   */
  this.colId = null;
  /**
   * 이전 칼럼의 id
   * @type Strnig
   */
  this.beforeColId = null;
  /**
   * 그리드에서 이벤트가 발생된 row의 실체화 객체 참조 변수
   * @type HTMLElement
   */
  this.row = null;
  /**
   * 그리드에서 이벤트가 발생된 row의 이전 row 실체화 객체 참조 변수
   * @type HTMLElement
   */
  this.beforeRow = null;
  /**
   * 페이지에서의 위치
   * @type Number
   */
  this.pagePos = null;
  /**
   * 이벤트 발생 x 좌표 값
   * @type Number
   */
  this.x = null;
  /**
   * 이벤트 발생 y 좌표 값
   * @type Number
   */
  this.y = null;
  /**
   * 입력된 키
   * @type Number
   */
  this.key = null;
  /**
   * 데이터 값
   * @type Object
   */
  this.value = null;
  /**
   * 브라우저 이벤트
   * @type HTMLEvent
   */
  this.e = null;

  /**
   * scroll 관련 이벤트
   */
  this.scroll = {
    newLeft : null,
    newTop : null,
    oldLeft : null,
    oldTop : null
  };
};
/**
 * @class 테이블형태의 2차원 데이터를 표시하며 확장된 기능들을 제공하는 컨트롤
 * @version 1.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.GridEx 객체
 * @type eXria.controls.xhtml.GridEx
 * @constructor
 * @base eXria.controls.UIControl
 */
eXria.controls.xhtml.GridEx = function(psId, pnLeft, pnTop, pnWidth, pnHeight) {
  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * GridEx의 설정 클래스
   * @private
   */
  this.cfg = new eXria.controls.xhtml.GridEx.Cfg();
  /**
   * Data 연동 객체(노드셋 연동).
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset(this);
  /**
   * dataset과 연동하기 위한 dataset id
   * @type String
   */
  this.datasetId = null;
  /**
   * 그리도 연동 데이타 셋 참조 변수
   * @type eXria.data.plugin.DataSetCmd
   */
  this.dataset = null;
  /**
   * 그리드 헤더.
   * 그리드의 헤더정보를 관리하기 위한 오브젝트.
   * @type eXria.controls.xhtml.GridEx.Header
   */
  this.header = null;
  /**
   * 그리드 바디.
   * 그리드 바디에 표시될 컨텐츠를 관리하기 위한 오브젝트
   * @type eXria.controls.xhtml.GridEx.Body
   */
  this.body = null;
  /**
   * 그리드 footer.
   * 그리드 footer에 표시될 컨텐츠를 관리하기 위한 오브젝트
   * @type eXria.controls.xhtml.GridEx.Footer
   */
  this.footer = null;
  /**
   * tree 그리드 객체 참조 변수
   * @type Object
   * @private
   */
  this.grid = null;
  /**
   * 포커스 된 row 객체 참조 변수
   */
  this.focusRow = null;
  /**
   * 포커스된 column 객체 참조 변수
   */
  this.focusCol = null;
  /**
   * 상위 컨트롤과의 위치 관계(absolute | relative | static).
   * @type String
   * @ignore
   */
  this.position = "absolute";
  /**
   * 배경이미지 url.
   * @type String
   * @private
   */
  this.backgroundImage = null;
  /**
   * 이미지 반복 표현 방식 지정.<br>
   * "repeat" | "repeat-x" | "repeat-y" | "no-repeat"
   * @type String
   * @private
   */
  this.backgroundRepeat = null;
  /**
   * 이미지 위치 방식 지정.<br>
   * 가로 : "left" | "center" | "right" | x% | xpos  세로 : "top" | "center" | "bottom" | y% | ypos
   * @type String
   * @private
   */
  this.backgroundPosition = null;
  /**
   * default 설정 정보를 정의한는 XML 파일경로
   * @type String
   */
  this.defaultFileName = null;
  /**
   * 출력되는 문자열을 정의한 XML 파일경로
   * @type String
   */
  this.textFileName = null;
  /**
   * DataSet과 TreeGrid 간의 데이타 동기화를 위한 Sorting 정보
   * @type Array Object
   * @private
   */
  this.sortList = new Array();

  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * GridEx에 디폴트로 설정될 style관련 속성을 저장하기 위한 오브젝트
   * @private
   */
  this.styles = {};
  this.styles.style = "Modern";
  this.styles.prefix = "GM";
  this.styles.file = "GridModern.css";
  /**
   * GridEx 툴바 설정 속성을 저장하기 위한 오브젝트
   * @type eXria.controls.xhtml.GridEx_toolbar
   * @private
   */
  this.toolbar = new eXria.controls.xhtml.GridEx_toolbar();
  /**
   * GridEx panel 설정 속성을 저장하기 위한 오브젝트
   * @type eXria.controls.xhtml.GridEx_panel
   */
  this.panel = new eXria.controls.xhtml.GridEx_panel();
  /**
   * GridEx에 이벤트 핸들러에 전달되는 이벤트 객체 참조
   * @type eXria.controls.xhtml.GridEx_event
   */
  this.event = new eXria.controls.xhtml.GridEx_event();
  /**
   * row 타입을 구분하기 위한 상수 값 접근 오브젝트
   * @type Object
   */
  this.RowType = {
    HeadRow : "HeadRow",
    BodyRow : "BodyRow",
    FootRow : "FootRow"
  };
  /*
   * GridEx의 Rendering 상태
   * @private
   */
  this.rendering = false;

  /**
   * 최초 로딩시 바인딩된 데이타 초기화 여부
   * @type Object
   */
  this.hideInitRow = null;

  /**
   * GridEx Page(Fast) 사용시 전체 선택 관련 Flag
   * @private
   */
  this.pageSelectAllChecked = false;

  /**
   * @ignore
   */
  this.init = true;
  /**
   * @ignore
   */
  this.CopiedRow = [];

  this.cursor = null;

  /**
   * GridEx의 locale정보
   * @private
   */
  this.locale = null;

  this.selectedIndexes = null;

  /**
   * page Fast모드에서 렌더링할 총 갯수
   * @private
   */
  this.pageCountWithFastMode = -1;
  /**
   * right button 저장 목록
   * @private
   */
  this.rgtBtnList = new eXria.data.ArrayCollection();
  /**
   * enum column 저장 목록
   * @private
   */
  this.enumColList = new eXria.data.ArrayCollection();
  /**
   * head column id를 통해 head column 객체를 참조하기 위한 맵
   * @private
   */
  this.headColMap = new eXria.data.ArrayMap();
  /**
   * head column id를 통해 body column 객체를 참조하기 위한 맵
   * @private
   */
  this.bodyColHMap = new eXria.data.ArrayMap();
  /**
   * body column id를 통해 body column 객체를 참조하기 위한 맵
   * @private
   */
  this.bodyColMap = new eXria.data.ArrayMap();
  /**
   * function column id를 통해 function column 객체를 참조하기 위한 맵
   * @private
   */
  this.functionColMap = new eXria.data.ArrayMap();
  /**
   * foot column id를 통해 footer column 객체를 참조하기 위한 맵
   * @private
   */
  this.footColMap = new eXria.data.ArrayMap();
  /*
   * 숨겨진 column 명세를 기록하기 위한 Map;
   * @type eXra.data.ArrayMap;
   */
  this.hideColMap = new eXria.data.ArrayMap();
  
  this.isRendered = false;
};
eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.GridEx);

/**
 * @class GridEx의 Configration 지정 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx.Cfg 객체
 * @type eXria.controls.xhtml.GridEx.Cfg
 * @constructor
 */
eXria.controls.xhtml.GridEx.Cfg = function() {
  /**
   * Tree 형태로 펼쳐질때 기준이 되는 칼럼 ID
   * @type String
   */
  this.maincol = null;
  /**
   * Panel의 숨김 여부
   * @type Boolean
   */
  this.hidePanel = true;
  /**
   * GridEx의 전체 넓이의 고정 여부
   * @type Boolean
   * @ignore
   */
  this.constWidth = true;
  /**
   * GridEx의 전체 높이의 고정 여부
   * @type Boolean
   * @ignore
   */
  this.constHeight = true;
  /**
   * row들이 서로 다른 높이를 가질 수 있도록 자동 계산될지의 여부
   * 이 높이는 로우의 가장 높은 높이를 가진 cell에 의해서 자동적으로 계산된다.
   * 멀티라인 textarea(cell type Lines)를 사용하거나 various HTML code를 가진 셀들을 포함시키기를 원한다면 VarHeight 값을 1로 설정한다
   * 페이징을 사용하는 경우에는 Variable한 row의 높이는 권장되지 않는다 (Child paging is mostly ok)
   * VarHeight를 1로 설정하게 되면 grid의 렌더링 속도를 저하시킬 수 있고 로우들에 사용되는 grid 이미지들이 꽉 차게 표시되지 않을 수 있다.
   * VarHeight='0' 으로 위에 정의되어 있어야 Defalut Row의 height 속성이 적용된다. 단 Row가 2줄로 지정이된 행을 만나면 그 이후부터 Defalut Row의 height는 적용이 안됨
   * 위에서 MaxHeight='1' MinHeight='1' 높이의 최대값과 최소값 설정을 통해 높이를 지정하도록 한다.
   * @type Boolean
   * @ignore
   */
  this.varHeight = false;
  /**
   * row의 평균 높이 (VarHeight가 1일때만 적용됨)
   * 이 값은 페이지 높이와 몇몇 다른 설정들을 사전에 계산하기 위해 사용된다.
   * @type Boolean
   * @ignore
   */
  this.rowHeight = 18;
  /////////////////////////////////////////////////////////////////
  // Grid 특성
  /**
   * How values of grid can be edited, 0: never, 1: yes, according to other settings, 2: preview (read only) mode
   * @type Number
   */
  this.editing = null;
  /**
   * multiSelect 여부
   * @type Boolean
   */
  this.multiSelect = null;
  /**
   * 다른 row 클릭 시 Selecting 유지 여부
   * @type Boolean
   */
  this.keepSelecting = null;
  /**
   * If selecting individual cells or cells ranges is permitted.
   * @type Boolean
   * @ignore
   */
  this.selectingCells = null;
  /**
   * If text selection by mouse is permitted. For text selection must be also set dragging = 0 or column canDrag = 0
   * @type Boolean
   * @ignore
   */
  this.selectingText = null;

  /**
   * 그리드에 메시지를 표시할 지 여부
   * @type Boolean
   * @private
   */
  this.suppressMessage = null;  // 그리드에 메시지를 표시하지 않는다.

  /**
   * If selecting individual cells or cells ranges is permitted.
   * @type Boolean
   * @ignore
   */
  this.pasting = null;
  /**
   * Rows can be filtered
   * @type Boolean
   * @ignore
   */
  this.filtering = true;
  /**
   * Rows can be moved by mouse (grid can be a source grid for drag / drop)
   * @type Boolean
   * @ignore
   */
  this.dragging = true;

  /**
   * Row의 grouping 가능 여부
   * @type Boolean
   */
  this.grouping = true;
  /**
   * 그룹된 칼럼이 표시되는 칼럼
   * @type String
   */
  this.groupMain = null;
  /**
   * 그룹되어지는 칼럼들
   * @type String
   */
  this.groupCols = null;
  /**
   * Grouping일 경우 전부 ExpandAll 하는 옵션
   * @type Boolean
   */
  this.expandAll = false;

  /**
   * Row의 sorting 가능 여부(false일 경우 헤더의 sorting 아이콘이 표시되지 않으며 sorting이 동작하지 않음)
   * @type Boolean
   */
  this.sorting = true;
  /**
   * 사용자에 의한 sorting 가능 여부(false일 경우 헤더의 sorting 아이콘은 제대로 표시되지만 sorting이 동작하지 않음)
   * @type Boolean
   */
  this.sorted = null;
  /**
   * sort되는 column들의 id
   * @type String
   */
  this.sortCols = null;
  /**
   * sort되는 column들의 올림/내림차순 지정
   * @type String
   */
  this.sortTypes = null;

  /**
   * pageing 사용 여부
   * @type Boolean
   */
  this.paging = null; // none || auto || fast
  /**
   * 하나의 페이지를 이루는 Row 갯수
   * @type Number
   */
  this.pageLength = null;
  /**
   * 현재 페이지 위치 정보
   * @type Number
   * @private
   */
  this.pagePos = 0;
  /**
   * page모드시 paging할때 전체 선택에 대한 상태유지를 하기위한 옵션
   * @type Boolean
   */
  this.pageSelectAll = true;

  /**
   * ID 칼럼으로 지정된 ID(HeadColumn ID)
   * @type String
   */
  this.idColumn = null;
  /**
   * Gantt Chart에서 ID 칼럼으로 지정된 ID(HeadColumn ID)로 idColumn과 중복되서 적용이 안되며 우선순위가 더 높음
   * @type String
   * @ignore
   */
  this.ganttIdColumn = null;
  /**
   * Row ID를 generate할 때 주어진 순서에 따라 허용되는 문자열
   * @type String
   * @ignore
   */
  this.idChars = '0123456789';
  /**
   * Row ID를 number로 generate할지 여부
   * @type Boolean
   * @ignore
   */
  this.numberID = '1';
  /**
   * ID칼럼 앞 부분에 insert 되는 문자열
   * @type String
   */
  this.idPrefix = "";
  /**
   * ID칼럼 뒷 부분에 insert 되는 문자열
   * @type String
   */
  this.idPostfix = "";
};

eXria.controls.xhtml.GridEx.prototype.create = function(poDocument, poDiv) {
  if(poDocument == null) poDocument = this.document;
  var voCtrl = null;

  if(this.createCtrl) { voCtrl = this.createCtrl(poDocument); };                                      // 1. Main Ctrl 생성
  if(this.createSubCtrl && voCtrl) { this.createSubCtrl(voCtrl, poDocument); };                       // 2. Composite Child Ctrl 생성

  if(this.setMainCtrlStyles && voCtrl) { this.setMainCtrlStyles(voCtrl, poDocument); };               // 3. Main Style 적용
  if(this.setSubCtrlStyles && voCtrl) { this.setSubCtrlStyles(voCtrl, poDocument); };                 // 4. Composite Child Style 적용

  if(this.setFormDefaults && voCtrl) { this.setFormDefaults(voCtrl, poDocument); };
  if(this.setUIGeneralDefaults && voCtrl) { this.setUIGeneralDefaults(voCtrl, poDocument); };         // 5. 공통 초기값 설정
  if(this.setSpecificDefaults && voCtrl) { this.setSpecificDefaults(voCtrl, poDocument); };           // 6. 개별 초기값 설정

  if(this.setSpecificAttrs && voCtrl) { this.setSpecificAttrs(voCtrl, poDocument); }                  // 9. 개별 Attrs 적용

  if(!this.printMode) {
    if(this.setGeneralEvents && voCtrl) { this.setGeneralEvents(voCtrl); }                            // 10. 공통 Events 적용
    if(this.setUIGeneralEvents && voCtrl) { this.setUIGeneralEvents(voCtrl); }                        // 11. UI 공통 Events 적용
    if(this.setSpecificEvents && voCtrl) { this.setSpecificEvents(voCtrl); }                          // 12. 개별 Events 적용
  }

  return voCtrl;
};

eXria.controls.xhtml.GridEx.prototype.createCtrl = function(poDocument) {
  var voCtrl = poDocument.createElement("div");
  voCtrl.style.position = "absolute";
  voCtrl["id"] = this.id;

  this.template = [];           // grid 생성 과정에서 사용되는 임시데이타 보관소
  this.templateLayout = null;   // grid 레이아웃 정보를 보관하는 임시 보관소
  this.templateData = null;     // grid 데이터 정보를 보관하는  임시 보관소

  this.ctrl = voCtrl;

  return voCtrl;
};

eXria.controls.xhtml.GridEx.prototype.createSubCtrl = function(poCtrl, poDocument) {
  var vaTemplate = this.template;
  var vsCfg = "";
  var vsToolbar = "";

  vaTemplate["Start"] = "<Grid>";
  vaTemplate["End"] = "</Grid>";

  /////////////////////////////////////////////////////////////////
  // Cfg 구성
  var voCfg = this.cfg;
  vsCfg = "<Cfg id='" + this.id + "' StandardFilter='2'  PasteFocused='3' PrintCols='0' BorderCursors='1' ";
  vsCfg = vsCfg + "Code='GTGDONJGPDMUXB' ";
//  vsCfg = vsCfg + "CSS='/guide/eXria/config/gridex/Modern/Grid.css' ";
  // Grid capabilities
//  if(voCfg.editing != null) vsCfg = vsCfg + " Editing='" + voCfg.editing + "'";
  if(voCfg.sorting != null) vsCfg = vsCfg + " Sorting=" + this.getXmlValue(voCfg.sorting);
//  if(voCfg.filtering != null) vsCfg = vsCfg + " Filtering=" + this.getXmlValue(voCfg.filtering);
  if(voCfg.grouping != null) vsCfg = vsCfg + " Grouping=" + this.getXmlValue(voCfg.grouping);
//  if(voCfg.dragging != null) vsCfg = vsCfg + " Dragging=" + this.getXmlValue(voCfg.dragging);
//  if(voCfg.dragging != null) vsCfg = vsCfg + " Dragging='1'";
//  if(voCfg.dropping != null) vsCfg = vsCfg + " Dropping=" + this.getXmlValue(voCfg.dropping);
  if(voCfg.pasting != null) vsCfg = vsCfg + " Pasting=" + this.getXmlValue(voCfg.pasting);
//  if(voCfg.colResizing != null) vsCfg = vsCfg + " ColResizing=" + this.getXmlValue(voCfg.colResizing);
//  if(voCfg.colMoving != null) vsCfg = vsCfg + " ColMoving=" + this.getXmlValue(voCfg.colMoving);
//  if(voCfg.resizingMain != null) vsCfg = vsCfg + " ResizingMain=" + this.getXmlValue(voCfg.resizingMain);
//  if(voCfg.resizingMainLap != null) vsCfg = vsCfg + " ResizingMainLap=" + this.getXmlValue(voCfg.resizingMainLap);
  if(voCfg.selectingCells != null) vsCfg = vsCfg + " SelectingCells=" + this.getXmlValue(voCfg.selectingCells);
  if(voCfg.selectingText != null) vsCfg = vsCfg + " SelectingText=" + this.getXmlValue(voCfg.selectingText);

  vsCfg = vsCfg + " HidePanel=" + this.getXmlValue(voCfg.hidePanel);
//  vsCfg = vsCfg + " VarHeight=" + this.getXmlValue(voCfg.varHeight);
  vsCfg = vsCfg + " RowHeight='" + voCfg.rowHeight + "'";
//  vsCfg = vsCfg + " MaxHeight='0'";// + this.height + "'";
//  vsCfg = vsCfg + " MaxWidth='0'";// + this.width + "'";
  vsCfg = vsCfg + " ConstHeight=" + this.getXmlValue(voCfg.constHeight);

  if(voCfg.groupMain) vsCfg = vsCfg + " GroupMain='" + (voCfg.groupMain == this.cfg.idColumn ? "id" : voCfg.groupMain) + "'";
  if(voCfg.groupCols) vsCfg = vsCfg + " GroupCols='" + (voCfg.groupCols == this.cfg.idColumn ? "id" : voCfg.groupCols) + "'";
  if(voCfg.sorted != null || this.sortUser) {
    if(this.sortUser) vsCfg = vsCfg + " Sorted=" + this.getXmlValue(1);
    else vsCfg = vsCfg + " Sorted=" + this.getXmlValue(voCfg.sorted);
  }
  if(voCfg.sortCols != null || this.sortColsUser) {
    var voMap = new eXria.data.ArrayMap();
    var vaSortCols = voCfg.sortCols;
    if(!!vaSortCols) vaSortCols = vaSortCols.split(",");
    else vaSortCols = [];
    var vaSortTypes = voCfg.sortTypes;
    if(!!vaSortTypes) vaSortTypes = vaSortTypes.split(",");
    vaSortTypes = [];
    var vnSize = vaSortCols.length;
    for(var i = 0; i < vnSize; i++) {
      voMap.put(vaSortCols[i], vaSortTypes[i]);
    }
    if(this.sortColsUser) {
      vaSortCols = this.sortColsUser;
      vaSortTypes = this.sortTyepsUser;
      if(vaSortTypes == null) vaSortTypes = [];
      vnSize = vaSortCols.length;
      for(var i = 0; i < vnSize; i++) {
        voMap.put(vaSortCols[i], vaSortTypes[i]);
      }
      var voCollection = voMap.getKeyCollection();
      vsCfg = vsCfg + " SortCols='" + voCollection.elements.join(",") + "'";
      voCollection = voMap.getValueCollection();
      vsCfg = vsCfg + " SortTypes='" + voCollection.elements.join(",") + "'";
    }
  }

  if(voCfg.suppressMessage != null) {
    if(voCfg.suppressMessage) vsCfg = vsCfg + " SuppressMessage='3'";
    else vsCfg = vsCfg + " SuppressMessage='0'";
   } else {
    var voSuppressMessage = this.getAttrValue("cfg.suppressMessage",this.cfg.suppressMessage);
    if(voSuppressMessage) vsCfg = vsCfg + " SuppressMessage='3'";
    else vsCfg = vsCfg + " SuppressMessage='0'";
  }

  vsCfg = vsCfg + " SuppressCfg='3'";
  vsCfg = vsCfg + " EnumKeys='1'";

  //yhkim 2009.05.18 Paging Data
  this.cfg.paging = this.getAttrValue("cfg.paging",voCfg.paging);
  this.cfg.pageLength = this.getAttrValue("cfg.pageLength", voCfg.pageLength);

  if (this.cfg.paging == "fast") {
    vsCfg = vsCfg + " Paging='3' ";
    vsCfg = vsCfg + " PageLength='" + voCfg.pageLength + "'";
    vsCfg = vsCfg + " Allpages='1' ";
    vsCfg = vsCfg + " NoPager='1' ";
  }else if(this.cfg.paging == "auto"){
    vsCfg = vsCfg + " Paging='2' ";
    vsCfg = vsCfg + " PageLength='" + voCfg.pageLength + "'";
    vsCfg = vsCfg + " Allpages='1' ";
    vsCfg = vsCfg + " NoPager='1' ";
  }

  //yhkim 2009.06.25  row이동 방지
  vsCfg = vsCfg + " Dragging='0'";

  // ID 칼럼 구성
  if(voCfg.idChars) vsCfg = vsCfg + " IdChars='" + voCfg.idChars + "'";
  if(voCfg.numberID) vsCfg = vsCfg + " NumberId='" + voCfg.numberID + "'";
  if(voCfg.idPrefix) vsCfg = vsCfg + " IdPrefix='" + voCfg.idPrefix + "'";
  if(voCfg.idPostfix) vsCfg = vsCfg + " IdPostfix='" + voCfg.idPostfix + "'";

  vsCfg = vsCfg + "/>";

  vaTemplate["Cfg"] = vsCfg;
  vsCfg = null;

  /////////////////////////////////////////////////////////////////
  // Toolbar 구성
  vsToolbar = "<Toolbar";
  vsToolbar = vsToolbar + " Visible='0'"; // 임시 1.0 릴리즈에서 제공 안됨
//  if(this.toolbar.visible) vsToolbar = vsToolbar + " Visible=" + this.getXmlValue(this.toolbar.visible);
//  if(this.toolbar.cells) vsToolbar = vsToolbar + " Save='0'";
  if(this.toolbar.cells) vsToolbar = vsToolbar + " cells=" + this.getXmlValue(this.toolbar.cells);
  vsToolbar = vsToolbar + "/>";

  vaTemplate["Toolbar"] = vsToolbar;

  /////////////////////////////////////////////////////////////////
  // Panel 구성 2009.08.04
  var voPanel = "";
  if(this.panel) {
    voPanel = this.panel;
    var vsPanel = "<Panel";
    if(voPanel.select != null)  vsPanel = vsPanel + " Select="+ this.getXmlValue(voPanel.select);
    if(voPanel.del != null)     vsPanel = vsPanel + " Delete="+ this.getXmlValue(voPanel.del);
  //if(voPanel.copy != null)    vsPanel = vsPanel + " Copy="  + this.getXmlValue(voPanel.copy);
    vsPanel = vsPanel + "/>";
    vaTemplate["Panel"] = vsPanel;
  }

  vaTemplate = null;
};

eXria.controls.xhtml.GridEx.prototype.setMainCtrlStyles = function(poCtrl, poDocument) {
  poCtrl.className = this.getCSSClass(this, 2);
};

eXria.controls.xhtml.GridEx.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voCssStyle = this.canvas.getCssStyle(this.outerClassName, poDocument);
  var voCfg = this.cfg;
  var voDf = this.df;
  voDf.position = this.makeSpecificAttrValue(poCtrl, voCssStyle, "position");
  voDf.borderColor = this.makeSpecificAttrValue(poCtrl, voCssStyle, "borderColor");
  voDf.borderStyle = this.makeSpecificAttrValue(poCtrl, voCssStyle, "borderStyle");

  voCssStyle = this.canvas.getCssStyle(this.className, poDocument);
  voDf.color = this.makeSpecificAttrValue(poCtrl, voCssStyle, "color");
  voDf.fontFamily = this.makeSpecificAttrValue(poCtrl, voCssStyle, "fontFamily");
  voDf.fontSize = this.makeSpecificAttrValue(poCtrl, voCssStyle, "fontSize");
  voDf.fontStyle = this.makeSpecificAttrValue(poCtrl, voCssStyle, "fontStyle");
  voDf.fontWeight = this.makeSpecificAttrValue(poCtrl, voCssStyle, "fontWeight");
  voDf.textAlign = this.makeSpecificAttrValue(poCtrl, voCssStyle, "textAlign");
  voDf.textDecoration = this.makeSpecificAttrValue(poCtrl, voCssStyle, "textDecoration");
  voDf.padding = this.makeSpecificAttrValue(poCtrl, voCssStyle, "padding");
  voDf.paddingLeft = this.makeSpecificAttrValue(poCtrl, voCssStyle, "paddingLeft");
  voDf.paddingRight = this.makeSpecificAttrValue(poCtrl, voCssStyle, "paddingRight");
  voDf.paddingTop = this.makeSpecificAttrValue(poCtrl, voCssStyle, "paddingTop");
  voDf.paddingBottom = this.makeSpecificAttrValue(poCtrl, voCssStyle, "paddingBottom");
  voDf.cursor = this.makeSpecificAttrValue(poCtrl, voCssStyle, "cursor");
  voDf.backgroundColor = this.makeSpecificAttrValue(poCtrl, voCssStyle, "backgroundColor");
  voDf.backgroundRepeat = this.makeSpecificAttrValue(poCtrl, voCssStyle, "backgroundRepeat");
  voDf.backgroundPosition = this.makeSpecificAttrValue(poCtrl, voCssStyle, "backgroundPosition");
  voDf.backgroundImage = this.makeSpecificAttrValue(poCtrl, voCssStyle, "backgroundImage", "backgroundImage", this.className);
  if(voDf.backgroundImage != null) voDf.backgroundImage = voDf.backgroundImage.replace(/\'/gi, "");

  if(voDf.fontSize != null) voDf.fontSize = parseInt(voDf.fontSize);
  if(voDf.padding != null) voDf.padding = parseInt(voDf.padding);
  else voDf.padding = 0;
  if(voDf.paddingLeft != null) voDf.paddingLeft = parseInt(voDf.paddingLeft);
  else voDf.paddingLeft = voDf.padding;
  if(voDf.paddingRight != null) voDf.paddingRight = parseInt(voDf.paddingRight);
  else voDf.paddingRight = voDf.padding;
  if(voDf.paddingTop != null) voDf.paddingTop = parseInt(voDf.paddingTop);
  else voDf.paddingTop = voDf.padding;
  if(voDf.paddingBottom != null) voDf.paddingBottom = parseInt(voDf.paddingBottom);
  else voDf.paddingBottom = voDf.padding;
  voDf.value = this.getAttrValue("value",this.value);
  voDf.imagePushed = this.getAttrValue("imagePushed",this.imagePushed);
  voDf.imageFocused = this.getAttrValue("imageFocused",this.imageFocused);
  voDf.imageMouseover = this.getAttrValue("imageMouseover",this.imageMouseover);
  this.defaultFileName = this.getAttrValue("defaultFileName", this.defaultFileName);
  this.textFileName = this.getAttrValue("textFileName", this.textFileName);

  this.hideInitRow = this.getAttrValue("hideInitRow",this.hideInitRow);
  voCfg.multiSelect = this.getAttrValue("cfg.multiSelect",voCfg.multiSelect);
  voCfg.keepSelecting = this.getAttrValue("cfg.keepSelecting",voCfg.keepSelecting);
  this.oddRowBg = this.getAttrValue("oddRowBg", this.oddRowBg);
  this.evenRowBg = this.getAttrValue("evenRowBg", this.evenRowBg);
  if(this.userAttr == "") this.userAttr = null;
  this.userAttr = this.getAttrValue("userAttr", this.userAttr);

  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
    else this.labelName = this.userAttr;
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
    if(voUserAttr.ganttFlagObj) this.ganttFlagObj = voUserAttr.ganttFlagObj;
    this.labelName = voUserAttr.labelName;
    this.colResizeDiff = voUserAttr.colResizeDiff;
    this.funcRowCanEdit = voUserAttr.funcRowCanEdit;
    if(voUserAttr.sorting != null) voCfg.sorting = voUserAttr.sorting;
    if(!!voUserAttr.colTypeDefine) this.colTypeDefine = voUserAttr.colTypeDefine;
    if(!!voUserAttr.rowMaxHeight) this.rowMaxHeight = voUserAttr.rowMaxHeight;
    if(!!voUserAttr.showTooltip) this.showTooltip = voUserAttr.showTooltip;
    if(!!voUserAttr.hRowSpans) this.hRowSpans = voUserAttr.hRowSpans;
    if(!!voUserAttr.mergeRowCols) this.mergeRowCols = voUserAttr.mergeRowCols;
    if(!!voUserAttr.columnCursor) this.columnCursor = voUserAttr.columnCursor;
    if(!!voUserAttr.childRows) {
      this.childRows = voUserAttr.childRows;
     this.template["Cfg"] = this.template["Cfg"].replace(/ Grouping\=\"[01]*\"/g, " Grouping=\"0\"");
    }
    if(!!voUserAttr.oddRowBg) this.oddRowBg = voUserAttr.oddRowBg;
    if(!!voUserAttr.evenRowBg) this.evenRowBg = voUserAttr.evenRowBg;
    if(voUserAttr.allPages != null) {
      this.allPages = voUserAttr.allPages;
      this.template["Cfg"] = this.template["Cfg"].replace(/ AllPages\=\"[01]*\"/g, " AllPages=\"" + this.allPages + "\"");
    }
  }
  if(this.colResizeDiff == null) this.colResizeDiff = true;
  if(this.funcRowCanEdit == null) this.funcRowCanEdit = true;
  if(this.cacheResource == null) this.cacheResource = this.canvas.page.cacheGridExResource;
  
  var voGrids = this.window.Grids;
  if(voGrids) {
    //Click and Key Event 추가
    if(voGrids.OnClick == null) {
      voGrids.OnClick = function(poTGP, poRow, psCol, pnX, pnY, poEvent) {
        return poTGP.GridEx.control.enGridexClick(poTGP, poRow, psCol, pnX, pnY, poEvent);
      };
    }
    if(voGrids.OnDblClick == null) {
      voGrids.OnDblClick = function(poTGP, poRow, psCol, pnX, pnY, poEvent) {
        return poTGP.GridEx.control.enGridexDblClick(poTGP, poRow, psCol, pnX, pnY, poEvent);
      };
    }
    if(voGrids.OnClickSide == null) {
      voGrids.OnClickSide = function(poTGP, poRow, psCol) {
        return poTGP.GridEx.control.enGridexButtonClick(poTGP, poRow, psCol);
      };
    }
    if(voGrids.OnFocus == null) {
      voGrids.OnFocus = function(poTGP, poRow, psCol, poBeforeRow, psBeforeCol, pnfocusPagePos) {
        return poTGP.GridEx.control.enGridexFocus(poTGP, poRow, psCol, poBeforeRow, psBeforeCol, pnfocusPagePos);
      };
    }
    if(voGrids.OnKeyDown == null) {
      voGrids.OnKeyDown = function(poTGP, pcKey, poEvent, pnKeyCodes, psPrefix) {
        return poTGP.GridEx.control.enGridexKeyDown(poTGP, pcKey, poEvent, pnKeyCodes, psPrefix);
      };
    };
    if(voGrids.OnRightClick == null) {
      voGrids.OnRightClick = function(poTGP, poRow, psCol, pnX, pnY, poEvent) {
        return poTGP.GridEx.control.enGridexRightClick(poTGP, poRow, psCol, pnX, pnY, poEvent);
      };
    };
    if(voGrids.OnSelect == null) {
      voGrids.OnSelect = function(poTGP, poRow, pnType) {
        return poTGP.GridEx.control.enGridexSelect(poTGP, poRow, pnType);
      };
    };
    //End
  
    //Status Event 추가
    if(voGrids.OnAfterValueChanged == null) {
      voGrids.OnAfterValueChanged = function(poTGP, poRow, psCol, poVal) {
        return poTGP.GridEx.control.enGridexAfterValueChanged(poTGP, poRow, psCol, null);
      };
    };
    if(voGrids.OnChange == null) {
      voGrids.OnChange = function(poTGP, poRow, psCol, poEvent) {
        var psNewValue = window.Get(poRow, psCol);
        var psBeforeValue = window.Get(poRow, psCol + "Orig");
        return poTGP.GridEx.control.enGridexCellEditChanged(psNewValue, psBeforeValue, poRow, poEvent);
      };
    };
    if(voGrids.OnScroll == null) {
      voGrids.OnScroll = function(poTGP, pnNewScollLeft, pnNewScrollTop, pnOldScollLeft, pnOldScrollTop, pnNewScollLeft0, pnOldScollLeft0, pnNewScollLeft2, pnOldScollLeft2) {
        return poTGP.GridEx.control.enGridexScroll(poTGP, pnNewScollLeft, pnNewScrollTop, pnOldScollLeft, pnOldScrollTop);
      };
    };
    if(voGrids.OnValueChanged == null) {
      voGrids.OnValueChanged = function(poTGP, poRow, psCol, poNewValue) {
        return poTGP.GridEx.control.enGridexValueChanged(poTGP, poRow, psCol, poNewValue);
      };
    };
    if(voGrids.OnRowDelete == null) {
      voGrids.OnRowDelete = function(poTGP, poRow, pnType) {
        return poTGP.GridEx.control.enGridExDelRow(poTGP, poRow);
      };
    };
    if(voGrids.OnPrint == null) {
      voGrids.OnPrint = function(poTGP, poWindow, psVal) {
        return poTGP.GridEx.control.enGridexPrint(poTGP, poWindow);
      };
    };
    if(voGrids.OnPrintFinish == null) {
      voGrids.OnPrintFinish = function(poTGP, poWindow ) {
        return poTGP.GridEx.control.enGridexPrintFinish(poTGP, poWindow);
      };
    };
    //End

    if(voGrids.OnClickSideDate == null) {
      voGrids.OnClickSideDate = function(poTGP, poRow, psCol, poEvent) {
        return poTGP.GridEx.control.enGridexClickSideDate(poRow, psCol, poEvent);
      };
    }
    if(voGrids.OnStartEdit == null) {
      voGrids.OnStartEdit = function(poTGP, poRow, psCol) {
        return poTGP.GridEx.control.enGridexStartEdit(poRow, psCol);
      };
    }
    if(voGrids.OnEndEdit == null) {
      voGrids.OnEndEdit = function(poTGP, poRow, psCol, pbSave, psVal) {
        return poTGP.GridEx.control.enGridexEndEdit(poRow, psCol, pbSave, psVal);
      };
    }
    if(voGrids.OnGanttChanged == null) {
      this.window.Grids.OnGanttChanged = function(poTGP, poRow, psCol, psKind, psVal1, psVal2) {
        return poTGP.GridEx.control.enGridexGanttChanged(poRow, psCol, psKind, psVal1, psVal2);
      };
    }
  //  if(voGrids.OnStartDrag == null) {
  //    voGrids.OnStartDrag = function(poTGP, poRow, psCol, pbMultiRow) {
  //      return poTGP.GridEx.control.enGridexStartDrag(poRow, psCol, pbMultiRow);
  //    }
  //  }
  //  if(voGrids.OnEndDrag == null) {
  //    voGrids.OnEndDrag = function(poSrcTGP, poSrcRow, poTrgTGP, poTrgRow, pnType, nX, nY)  {
  //      var vcSrcGrx = null;
  //      if(poSrcTGP) vcSrcGrx = poSrcTGP.GridEx.control;
  //      return poTrgTGP.GridEx.control.enGridexEndDrag(vcSrcGrx, poSrcRow, poTrgRow, pnType, nX, nY);
  //    }
  //  }
    if(voGrids.OnRenderStart == null) {
      voGrids.OnRenderStart  = function(poTGP) {
        return poTGP.GridEx.control.enGridexRenderStart();
      };
    }
    if(voGrids.OnRenderFinish == null) {
      voGrids.OnRenderFinish  = function(poTGP) {
        return poTGP.GridEx.control.enGridexRenderFinish();
      };
    }
    if(voGrids.OnDownloadPage == null) {
      voGrids.OnDownloadPage = function(poTGP, poRow, poFunc) {
        return poTGP.GridEx.control.enGridexDownloadPage(poRow, poFunc);
      };
    }
    if(voGrids.OnCustomAjax  == null) {
      voGrids.OnCustomAjax = function(poTGP, poSource, poData, poFunc) {
        if(poSource.Name != "Page") return;
        return poTGP.GridEx.control.enGridexCustomAjax(poSource, poData, poFunc);
      };
    }
    if(voGrids.OnRenderPageFinish == null) {
      voGrids.OnRenderPageFinish = function(poTGP, poRow) {
        return poTGP.GridEx.control.enGridexRenderPageFinish(poRow);
      };
    }
    if(voGrids.OnSort == null) {
      voGrids.OnSort = function(poTGP, psCol, psSort) {
        return poTGP.GridEx.control.enGridexSort(psCol, psSort);
      };
    }
    if(voGrids.OnSortFinish == null) {
      voGrids.OnSortFinish = function(poTGP) {
        return poTGP.GridEx.control.enGridexSortFinish();
      };
    }
    if(voGrids.OnClickOutside == null) {
      voGrids.OnClickOutside = function() {
        return true;
      };
    }
    if(voGrids.OnPasteRow == null) {
        voGrids.OnPasteRow = function(poTGP, poRow, paCols, paValues, pbAdded) {
          return poTGP.GridEx.control.enGridexPasteRow(poRow, paCols, paValues, pbAdded);
        };
      }
      if(voGrids.OnPasteRowFinish == null) {
        voGrids.OnPasteRowFinish = function(poTGP, poRow, paCols, paValues, pbAdded) {
        poTGP.GridEx.control.enGridexPasteRowFinish(poRow, paCols, paValues, pbAdded);
        };
      }
    }
    if(voGrids.OnSelectAll == null) {
      voGrids.OnSelectAll = function(poTGP) {
        poTGP.GridEx.control.enGridexSelectAll();
      };
    }
};

eXria.controls.xhtml.GridEx.prototype.setSpecificAttrs = function(poCtrl, poDocument) {

  // 데이터셋 참조
  if(this.datasetId) this.dataset = this.canvas.page.model.getDataSet(this.datasetId);

  /////////////////////////////////////////////////////////////////
  // 최외곽의 Div element를 보더로 갖는 컨트롤에 동일하게 적용함
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaTemplate = this.template;
  this.headColMap.clear();
  this.bodyColMap.clear();
  this.bodyColHMap.clear();
  this.functionColMap.clear();
  this.footColMap.clear();
  this.rgtBtnList.clear();
  this.enumColList.clear();

  var vfcSetCssStrBuf = this.setCssStrBuf;

  poCtrl["tabIndex"] = voDf.tabIndex;
  poCtrl["tooltip"] = voDf.tooltip;
  if(voDf.disabled) poCtrl["disabled"] = true;
  poCtrl["accessKey"] = voDf.accessKey;

  vaCssStrBuf = [];
  vaCssStrBuf.push("margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "position", voDf.position);
  vfcSetCssStrBuf(vaCssStrBuf, "color", voDf.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", voDf.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", voDf.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", voDf.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", voDf.cursor);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", "12px");        // 버튼 타입내의 폰트의 상하 align이 깨지는 현상 방지

  poCtrl.style.cssText = vaCssStrBuf.join("");

  /////////////////////////////////////////////////////////////////
  // Def 구성
  var voRow = this.body.cols["center"].rows[0];

  var voCols = new Array();
  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  var vsDef = "<Def>";
  var vsDefC = "<D Name='C' CanMove='2'/>";

  // HighGarden Modify Start
  var vsDefR = "";
  var vsDefF = "<D Name='Fixed' ";
  var vsDefBodyRow = "<D Name='R' Calculated='1' ";

  if(voBody.height != null) vsDefF = vsDefF + "Height='" + voBody.height + "' ";
  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      if(voCols[i].rows.length > 1) { new Error("GridEx' body.cols have one row"); return; }
      for(j=0; voCols[i].rows.length>j; j++) {
        var voRow = voCols[i].rows[j];
        var voColumn = null;
        for(k=0; voRow.columns.length>k; k++) {
          voColumn = voRow.columns[k];

          if(voColumn.type != null) {
            if(voColumn.colId == this.cfg.idColumn) {
              voColumn.colId = 'id';
              voColumn.canEdit = 0;
            }
            vsDefF = vsDefF + voColumn.colId + "Type='Text' "; //Fixed Row Def

            if(voColumn.type == "Image") vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Type='Img'";
            else if(voColumn.type == "Radio" || voColumn.type == "CheckBox") vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Type='Radio'";
            else if(voColumn.type == "Lines") vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Type='Lines'";
            else if(!!this.colTypeDefine && !!this.colTypeDefine[voColumn.colId]){
              //사용자 정의 속성에 colTypeDefine 가 있으면 해당 컬럼을 Lines로 바꿔
              //주기 위해서 추가. 현재 eXria 의 그리드에서 Lines를 지원 안해서
              //이화여대 요청을 반영하기 위해서 추가
              if(this.colTypeDefine[voColumn.colId] === 'Lines') vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Type='" + this.colTypeDefine[voColumn.colId] + "'";
            }
            else vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Type='" + voColumn.type + "'";

            if(voColumn.type == "Enum") {
              this.enumColList.add(voColumn);
              var voItemGData = voColumn.itemgroup.data;
              voItemGData.control = this;
              if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
                voColumn.itemgroup.addToItemset();
              }
              var vsValues = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
              var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
              vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Enum='" + vsLabels + "'" + " " + voColumn.colId + "EnumKeys='" + vsValues + "'";
            }
            if(voColumn.type == "Select") {
              var voItemGData = voColumn.itemgroup.data;
              voItemGData.control = this;
              if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
                voColumn.itemgroup.addToItemset();
              }
              voValue = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
              var vsDefaults = " " + voColumn.colId + "Defaults='" + voValue + "'";
              vsDefBodyRow = vsDefBodyRow + vsDefaults;
            }
            // HighGarden Add Start
            if(voColumn.type == "Radio" || voColumn.type == "CheckBox") {
              vsDefF = vsDefF + voColumn.colId + "Enum='|' "; //Fixed Row Def
              if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);

              var voItemGData = voColumn.itemgroup.data;
              voItemGData.control = this;
              if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
                voColumn.itemgroup.addToItemset();
              }
              var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
              vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Enum='" + vsLabels + "'";
              if(voColumn.type == "CheckBox") vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Range='1'";
              vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Wrap='0'";
            }
            if(voColumn.type == "Date") {
              if(voColumn.dateType == null) {
                if(voColumn.mask && /ss/.test(voColumn.mask)) {
                  voColumn.dateType = "DateTime";
                  voColumn.maxLength = 14;
                } else {
                  voColumn.dateType = "Date";
                  voColumn.maxLength = 8;
                }
              }
              if(voColumn.format === null) voColumn.format = "yyyy-MM-dd";
              if(!voColumn.calendarEnable) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Button='None'";
            }
            // HighGarden Add End
          }
          //Highgarden Start 090407
          if(voColumn.format != null || voColumn.mask != null) {
            vsDefF = vsDefF + voColumn.colId + "Format='' " + voColumn.colId + "ResultMask='' "; //Fixed Row Def
            if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);
            var vsFormat = voColumn.format;
            if(vsFormat && vsFormat.indexOf("TG:") == 0) {
              voColumn.regFormat = vsFormat.replace(/^TG:/, "");
            }
            var vsMask = voColumn.mask;
            if(vsMask && vsMask.indexOf("TG:") == 0) {
              voColumn.regMask = vsMask.replace(/^TG:/, "");
            }
            vsDefBodyRow = vsDefBodyRow + voColumn.formatMask.createFormatAndMask(voColumn);
          }
          //Highgarden End 090407
          if(voColumn.textAlign != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Align='" + voColumn.textAlign + "' ";
          //userAttr 를 통한 각 셀마다 커서 정의 가능 13.7.23 박상찬
          if(!!this.columnCursor && !!this.columnCursor[voColumn.colId]){
            vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Cursor='"+ this.columnCursor[voColumn.colId] +"' ";
          }
          if(voColumn.enums != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Enum='" + voColumn.enums + "' ";
          if(voColumn.enumType != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "EnumType='" + voColumn.enumType + "' ";
          if(voColumn.canEdit != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "CanEdit='" + voColumn.canEdit + "' ";
          if(voColumn.mask != null && (voColumn.maxLength == null && voColumn.type == "Text")) voColumn.maxLength = voColumn.mask.length;
          else if(voColumn.mask != null && (voColumn.maxLength != null && (voColumn.type == "Int" || voColumn.type == "Float")))  voColumn.maxLength = voColumn.maxLength;
          else if(voColumn.mask == null && voColumn.type == "Date") voColumn.maxLength = 8;
          if(voColumn.maxLength != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Size='" + voColumn.maxLength + "' ";
          if(voColumn.maxByteLength != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "ByteSize='" + voColumn.maxByteLength + "' ";
          if(voColumn.formula != null){
            voColumn.formula = voColumn.formula.split("\"").join("'");
            vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Formula=\"" + voColumn.formula + "\" ";
          }
          if(voColumn.rightButton != null) {
            this.rgtBtnList.add(voColumn);
            voRButton = voColumn.rightButton;

            if(voRButton.type == "Defaults") {
              if(vsRButton != "Enum" && vsRButton != "Select" && vsRButton != "Radio" && vsRButton != "List") {
                var voItemGData = voColumn.itemgroup.data;
                voItemGData.control = this;
                if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
                  voColumn.itemgroup.addToItemset();
                }
                voValue = voColumn.itemgroup.getItemValuesToString('|');
                vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Defaults='" + voValue + "'";
              }
            }
          }

          // 조영진 추가코드
          if(voColumn.backgroundColor != null) vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Color='" + this.getRGBValue(voColumn.backgroundColor) + "' ";
          if(voColumn.className != null){
            vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "ClassInner='" + voColumn.className + "' ";
            vsDefF = vsDefF + " " + voColumn.colId + "ClassInner='' ";
          }
          if(voColumn.outerClassName != null){
            vsDefBodyRow = vsDefBodyRow + " " + voColumn.colId + "Class='" + voColumn.outerClassName + "' ";
            vsDefF = vsDefF + " " + voColumn.colId + "Class='' ";
          }
          // HighGarden Modify End
        }
      }
    }
  }
  vsDefF = vsDefF + "/>"; // Fixed Row Def
  vsDefBodyRow = vsDefBodyRow + "/>";

  vsDef = vsDef + vsDefC + vsDefR + vsDefF + vsDefBodyRow;
  var vsDefG = "<D Name='Group' Calculated='1' ";
  var vaDefGCalcCol = new Array();
  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      if(voCols[i].rows.length > 1) { new Error("GridEx' body.cols have one row"); return; }
      for(var j=0, jl=voCols[i].rows.length; jl>j; j++) {
        var voRow = voCols[i].rows[j];
        var voColumn = null;
        for(var k=0, kl=voRow.columns.length; kl>k; k++) {
          voColumn = voRow.columns[k];
          if(voColumn.groupFormula) {
            voColumn.groupFormula = voColumn.groupFormula.split("\"").join("'");
            vaDefGCalcCol.push(voColumn.colId);
            vsDefG = vsDefG + voColumn.colId + "Formula=\"" + voColumn.groupFormula + "\" ";
          }
          if(voColumn.groupFormat) vsDefG = vsDefG + voColumn.colId + "Format='" + voColumn.groupFormat + "' ";
        }
      }
    }
  }
  var vsDefGCalc = "CalcOrder='";
  vsDefGCalc = vsDefGCalc + vaDefGCalcCol.join(",");
  vsDefGCalc = vsDefGCalc + "' ";

  vsDefG = vsDefG + vsDefGCalc + "/>";
  vsDef = vsDef + vsDefG + "</Def>"; // + "<Colors Default='255,255,255'/>";
  vaTemplate["Def"] = vsDef;

  /////////////////////////////////////////////////////////////////
  // LeftCols, Cols, RightCols 구성
  var voCols = new Array();
  var voBody = this.body;

  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];
  var vsCols = "";
  var voHideColMap = this.hideColMap;
  for(var i = 0; i < 3; i++) {
    if(voCols[i]) {
      if(i == 0) vsCols = vsCols + "<LeftCols>";
      if(i == 1) vsCols = vsCols + "<Cols>";
      if(i ==2 ) vsCols = vsCols + "<RightCols>";
      if(voCols[i].rows.length > 1) { new Error("GridEx' body.cols have one row"); return; }

      for(j=0; voCols[i].rows.length>j; j++) {
        var voRow = voCols[i].rows[j];
        var vsRow = "";
        for(k=0; voRow.columns.length>k; k++) {
          var voColumn = voRow.columns[k];

          vsColumn = "<C Spanned='1' Name='" + voColumn.colId + "' " + "Width='" + voColumn.width + "'";
          if(voHideColMap.get(voColumn.colId) != null) vsColumn += " Visible='0'";
          if(voColumn.type != null) {
            if(!!this.colTypeDefine && !!this.colTypeDefine[voColumn.colId]){
              if(this.colTypeDefine[voColumn.colId] === 'Lines') vsColumn = vsColumn + " AcceptEnters='1' Type='" + this.colTypeDefine[voColumn.colId] + "'";
            }else if(voColumn.type === "Lines"){
              vsColumn = vsColumn + " AcceptEnters='1' Type='Lines'";
            }else{
              vsColumn = vsColumn + " Type='" + voColumn.type + "'";
              if(voColumn.type != "Bool") vsColumn = vsColumn + " EmptyValue='' CanEmpty='1'";
              if(voColumn.type == "Radio" || voColumn.type == "CheckBox"){
                if(voColumn.labelPos != null && "left" === voColumn.labelPos) vsColumn = vsColumn + " RadioRight='1'";
              }
            }
          }
//        if(voColumn.textAlign != null) vsColumn = vsColumn + " TextAlign='" + voColumn.textAlign + "' "; // treeGrid 6.0에서는 cell 속성으로  변경됨
          if(voColumn.visible != null) vsColumn = vsColumn + " Visible=" + this.getXmlValue(voColumn.visible);
          if(voColumn.canSort != null) vsColumn = vsColumn + " CanSort=" + this.getXmlValue(voColumn.canSort);
          if(voColumn.canFocus != null) vsColumn = vsColumn + " CanFocus=" + this.getXmlValue(voColumn.canFocus);
          if(voColumn.canEdit != null) vsColumn = vsColumn + " CanEdit=" + this.getXmlValue(voColumn.canEdit)+ " ";
          if(voColumn.rightButton != null) {
            if(voColumn.rightButton.width  == null) voColumn.rightButton.width = 10;
            vsColumn = vsColumn + " WidthPad=\'" + voColumn.rightButton.width + "\'";
          }
          if(voColumn.className != null) vsColumn = vsColumn + " " + voColumn.colId + "ClassInner='" + voColumn.className + "' ";
          if(voColumn.outerClassName != null) vsColumn = vsColumn + " " + voColumn.colId + "Class='" + voColumn.outerClassName + "' ";

          if(voColumn.type == "Gantt") {
            vsColumn = vsColumn + " MinWidth='" + voColumn.width + "'";
            if(voColumn.ganttStart != null) vsColumn = vsColumn + " GanttStart='" + voColumn.ganttStart + "'";
            if(voColumn.ganttEnd != null) vsColumn = vsColumn + " GanttEnd='" + voColumn.ganttEnd + "'";
            if(voColumn.ganttComplete != null) vsColumn = vsColumn + " GanttComplete='" + voColumn.ganttComplete + "'";
            if(voColumn.ganttTooltipText != null) vsColumn = vsColumn + " GanttText='" + voColumn.ganttTooltipText + "'";
            if(voColumn.ganttDependencies != null) vsColumn = vsColumn + " GanttDescendants='" + voColumn.ganttDependencies + "'";
            if(voColumn.ganttDependencyTypes != null) vsColumn = vsColumn + " GanttDescendants='" + voColumn.ganttDependencyTypes + "'";
            if(voColumn.ganttUnits != null) vsColumn = vsColumn + " GanttUnits='" + voColumn.ganttUnits + "'";
            if(voColumn.ganttTrimUnits != null) vsColumn = vsColumn + " GanttChartRound='" + voColumn.ganttTrimUnits + "'";
            if(voColumn.ganttEditMain || voColumn.ganttEditDependency || voColumn.ganttEditResources || voColumn.ganttStart) {
              var vsEdit = "";
              if(voColumn.ganttEditMain) vsEdit = "Main";
              if(vsEdit != "") { if(voColumn.ganttEditDependency) vsEdit = vsEdit + "," + "Dependency";
              } else { if(voColumn.ganttEditDependency) vsEdit = "Dependency"; }
              if(vsEdit != "") { if(voColumn.ganttEditResources) vsEdit = vsEdit + "," + "Resources";
              } else { if(voColumn.ganttEditResources) vsEdit = "Resources";}
              vsColumn = vsColumn + " GanttEdit='" + vsEdit + "'";
//              vsColumn = vsColumn + " GanttEdit='All'";
            }
            var voObj = this.ganttFlagObj;
            if(voObj) {
              if(voObj.flagTag) {
                voObj.data = new eXria.controls.DataRefNodeset(this);
                var voData = voObj.data;
                voData.setNodesetRef(voObj.instanceId, voObj.nodeset);
                var voCollectionNode = voData.getNodesetData2();
                if (voCollectionNode && voCollectionNode.getLength() > 0) {
                  var vnLoop = voCollectionNode.getLength();
                  var voItem = null;
                  var voValueNode = null;
                  var vaFlag = [];
                  var vaText = [];
                  var vaIcons = [];
                  var vsFlag = null;
                  var vsText = null;
                  for ( var l = 0; l < vnLoop; l++) {
                    voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(l));
                    vsFlag = String(voMapNode.get(voObj.flagTag));
                    if(vsFlag == null || vsFlag == "") break;
                    vsTemp = parseInt(vsFlag.substring(4,6));
                    vsTemp += "/" + parseInt(vsFlag.substring(6));
                    vsTemp += "/" + vsFlag.substring(0,4)
                    if(voObj.textTag) {
                      vsText = voMapNode.get(voObj.textTag);
                    } else {
                      vsText = vsTemp;
                    }
                    vaFlag.push(vsTemp);
                    vaText.push(vsText);
                    vaIcons.push(voObj.icon)
                  }
                  voColumn.ganttFlags = vaFlag.join(";");
                  vsColumn = vsColumn + " GanttMark='" + voColumn.ganttFlags + "'";
                  voColumn.ganttFlagTexts = vaText.join(";");
                  voColumn.ganttFlagIcons = vaIcons.join(";");
                }
              }
              if(voObj.todayIcon) {
                var voDate = new Date();
                vsDate = (voDate.getMonth() + 1) + "/" + voDate.getDate() + "/" + voDate.getFullYear();
                vsColumn = vsColumn + " GanttFlags='" + vsDate + "'";
                vsColumn = vsColumn + " GanttFlagTexts='today'";
                vsColumn = vsColumn + " GanttFlagIcons='"+ voObj.todayIcon + "'";
              }
            }

            if(voColumn.ganttBackground != null) vsColumn = vsColumn + " GanttBackground='" + voColumn.ganttBackground + "'";
            if(voColumn.ganttBackgroundRepeat != null) vsColumn = vsColumn + " GanttBackgroundRepeat='" + voColumn.ganttBackgroundRepeat + "'";
            if(voColumn.ganttResources != null) vsColumn = vsColumn + " GanttResources='" + voColumn.ganttResources + "'";
            if(voColumn.ganttUnitWidth != null) vsColumn = vsColumn + " GanttWidth='" + voColumn.ganttUnitWidth + "'";
            if(voColumn.ganttClass != null) vsColumn = vsColumn + " GanttClass='" + voColumn.ganttClass + "'";

            var voHeadCols = null;
            if(i == 0) voHeadCols = this.header.cols["left"];
            if(i == 1) voHeadCols = this.header.cols["center"];
            if(i == 2) voHeadCols = this.header.cols["right"];
            var voHeadColumn = voHeadCols.rows[j].columns[k];

            if(voHeadColumn.ganttHeader1 != null) vsColumn = vsColumn + " GanttHeader1='" + voHeadColumn.ganttHeader1 + "'";
            if(voHeadColumn.ganttHeader2 != null) vsColumn = vsColumn + " GanttHeader2='" + voHeadColumn.ganttHeader2 + "'";
            if(voHeadColumn.ganttHeader3 != null) vsColumn = vsColumn + " GanttHeader3='" + voHeadColumn.ganttHeader3 + "'";
            if(voHeadColumn.ganttHeader4 != null) vsColumn = vsColumn + " GanttHeader4='" + voHeadColumn.ganttHeader4 + "'";
            if(voHeadColumn.ganttHeader5 != null) vsColumn = vsColumn + " GanttHeader5='" + voHeadColumn.ganttHeader5 + "'";
            if(voHeadColumn.ganttFormat1 != null) vsColumn = vsColumn + " GanttFormat1='" + voHeadColumn.ganttFormat1 + "'";
            if(voHeadColumn.ganttFormat2 != null) vsColumn = vsColumn + " GanttFormat2='" + voHeadColumn.ganttFormat2 + "'";
            if(voHeadColumn.ganttFormat3 != null) vsColumn = vsColumn + " GanttFormat3='" + voHeadColumn.ganttFormat3 + "'";
            if(voHeadColumn.ganttFormat4 != null) vsColumn = vsColumn + " GanttFormat4='" + voHeadColumn.ganttFormat4 + "'";
            if(voHeadColumn.ganttFormat5 != null) vsColumn = vsColumn + " GanttFormat5='" + voHeadColumn.ganttFormat5 + "'";
          }

          vsColumn = vsColumn + "/>";
          var vsRow = vsRow + vsColumn;
        }
        vsCols = vsCols + vsRow;
      }
      if(i==0) vsCols = vsCols + "</LeftCols>";
      if(i==1) vsCols = vsCols + "</Cols>";
      if(i==2) vsCols = vsCols + "</RightCols>";
    }
  }
  vaTemplate["Cols"] = vsCols;

  // yhkim 2009.05.25 헤더포맷 수정
  vaTemplate["Header"] = this.getHeaderFormat();
  var vnSorting = this.cfg.sorting;
  if(vnSorting) vnSorting = 1;
  else vnSorting = 0;
  vaTemplate["Cfg"] = vaTemplate["Cfg"].replace(/ Sorting\=\"[01]*\"/g, " Sorting=\"" + vnSorting + "\"");

  vaTemplate = null;

  this.makeLayout();
};
/**
 * 헤더 구조를 정의하는 문자열을 얻어오는 메소드
 * @type String
 * @return 헤더 구조를 정의하는 문자열
 */
eXria.controls.xhtml.GridEx.prototype.getHeaderFormat = function(){
  // header.cols로 부터 Header 구성
  var voCols = new Array();
  voCols[0] = this.header.cols["left"];
  voCols[1] = this.header.cols["center"];
  voCols[2] = this.header.cols["right"];

  var vsTitle, vsColumnText = "";
  var vaHeader = [];
  var vaMainCols = [[], [], []];
  // yhkim 2009.05.19 head 컬럼
  var voColumn = null;

  for ( var i = 0; i < 3; i++) {
    if (voCols[i] && !!voCols[i].rows[0].columns.length){
      for ( var j = 0; voCols[i].rows.length > j; j++) {
        var voRow = voCols[i].rows[j];

        for ( var k = 0; voRow.columns.length > k; k++){
          voColumn = voRow.columns[k];
          if(voColumn == null) continue;
          if(voColumn.id == this.cfg.idColumn) {
            voColumn.id = "id";  // id 칼럼에 대한 처리
            break;
          }
        }
      }
      break;
    }
  }

  if (this.header.mainRow == null)  this.header.mainRow = 0;
  for ( var i = 0; i < 3; i++) {
    if (voCols[i]) {
      for ( var j = 0; voCols[i].rows.length > j; j++) {
        if(this.header.mainRow != j) continue;
        var voRow = voCols[i].rows[j];

        for ( var k = 0; voRow.columns.length > k; k++) {
          voColumn = voRow.columns[k];
          if(voColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn) continue;
          vaMainCols[i][k] = voColumn.id;
        }
      }
    }
  }

  for ( var i = 0; i < 3; i++) {
    if (voCols[i]) {
      for ( var j = 0; voCols[i].rows.length > j; j++) {
        var voRow = voCols[i].rows[j];
        var vsRow = "";
        if(vaHeader[j] == null) {
          vaHeader[j] = "";
         }

        var vnColIdx = 0;
        var vnColSpan = null;
        var vnRowSpan = null;
        var voRowSpans = null;
        var vsCol = null;
        if(this.hRowSpans) voRowSpans = this.hRowSpans[j];
        for ( var k = 0; voRow.columns.length > k; k++) {
          var vsAlign = "";
          vsColumnText = "";
          voColumn = voRow.columns[k];
          vsCol = vaMainCols[i][vnColIdx];

          if(voColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn) {
            vnColIdx += voColumn.colspan;
            continue;
          }
          if (voColumn.instanceId && voColumn.ref) {
            var voNode = null, voNodeValue = "";
            voColumn.data.instanceId = voColumn.instanceId;
            voColumn.data.instancePath = voColumn.ref;
            voNode = voColumn.data.getNodeData();
            if (voNode) {
              voNodeValue = voNode.getValue();
              voColumn.value = voNodeValue;
            } else {
              voColumn.value = "";
            }
          }
          vsColumnText = voColumn.value;
          if(vsColumnText == null) vsColumnText = "";
          vsTitle = vsCol + "='" + vsColumnText + "'";
          if(this.header.mainRow != j && vsColumnText == "") vsTitle += " " + vsCol + "Visible=\"-1\"";
          else if(this.header.mainRow != j) vsTitle += " " + vsCol + "Button=\"\"";

          vsRow = vsRow + vsTitle;
          if (voColumn.textAlign == "left")
            vsAlign = " " + vsCol + "Align='0'";
          if (voColumn.textAlign == "center")
            vsAlign = " " + vsCol + "Align='1'";
          if (voColumn.textAlign == "right")
            vsAlign = " " + vsCol + "Align='2'";

          vsRow = vsRow + vsAlign;
          if(voColumn.className != null) vsRow = vsRow + " " + vsCol + "Class=\"" + voColumn.className + "\"";
          if(voColumn.hoverClassName != null) vsRow = vsRow + " " + vsCol + "ClassOuterHover=\"" + voColumn.hoverClassName + "\"";
          vnColspan = voColumn.colspan;
          if(vnColspan == null) vnColspan = 1;
          if(vnColspan != 1) {
            vsRow = vsRow + " " + vsCol + "Span=" + this.getXmlValue(vnColspan);
          }
          if(voRowSpans) {
            vnRowSpan = voRowSpans[vsCol == "id" ? this.cfg.idColumn : vsCol];
            if(vnRowSpan == null) vnRowSpan = 1;
            if(vnRowSpan != 1) {
              vsRow = vsRow + " " + vsCol + "RowSpan=" + this.getXmlValue(vnRowSpan);
            }
          }
          vnColIdx += vnColspan;
        }
        vaHeader[j] += vsRow;
      }
    }
  }

  var vnSize = vaHeader.length;
  vsHeader = "<Head>";
  for(var i = 0; i < vnSize; i++) {
    if(vaHeader[i] == "") continue;
    vaHeader[i] = "<Header Spanned=\"1\" " + vaHeader[i];
    if(i == this.header.mainRow) {
      var vbSelect = this.panel.select;
      var vbDel = this.panel.del;
      if(this.cfg.hidePanel == false) {
        if(vbSelect == null) vbSelect = true;
        if(vbDel == null) vbDel = true;
      } else {
        if(vbSelect == null) vbSelect = false;
        if(vbDel == null) vbDel = false;
      }
      if(vbSelect) vaHeader[i] += " CanSelect=\"1\"";
      if(vbDel) vaHeader[i] += " CanDelete=\"1\"";
    }
    if(this.header.visible != null) vaHeader[i] += " Visible=" + this.getXmlValue(this.header.visible);
    vaHeader[i] += "/>";
    vsHeader += vaHeader[i];
  }
  vsHeader += "<Header id=\"Header\" Visible=\"0\"/>";
  vsHeader += "</Head>"
  return vsHeader;
};
/**
 * TreeGrid의 Format, Mask 관련 속성의 문자열 반환
 * @param {Object} psFormat Format
 * @return String
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.createFormatAndMask = function(poColumn){
  var vsFormat = poColumn.format;
  var vsMask = poColumn.mask;
  var vsType = poColumn.type;
  var vaRegExp = {"x": "A-Za-z", "#": "0-9", "*": "A-Za-z0-9" };
  var vsEditFormat = "", vsEditMask = "", vsResultMask = "", vsRet = "";

  if(!vsFormat && vsMask) vsFormat = vsMask;
  if(!vsFormat && vsType=="Date") vsFormat = "yyyy-MM-dd";
  if(!vsMask && vsType=="Date") vsMask = "yyyyMMdd";
  switch(vsType){
    case "Int" :
    case "Float" :
//      if(vsMask.lastIndexOf(".")){ vsMask = vsMask.replace(vsMask.charAt(vsMask.lastIndexOf(".")-1), "0"); }
      if(vsMask){
        vsEditMask = "^[0-9]*\\.*[0-9]*$";
        vsResultMask = "^[0-9]*\\.*[0-9]*$";
      }
      break;
    case "Text" :
    case "Lines" :
      if(vsMask){
        var vsNoFormat = vsFormat.replace(/[^\#\x\*]/g, "");
        vsEditMask = "^";

        //문자가 일치하는 마지막 index를 리턴
        var getLastIndex = function(pnIndex){
          if(pnIndex > vsNoFormat.length) return vsNoFormat.length;
          if(vsNoFormat.charAt(pnIndex) == vsNoFormat.charAt(pnIndex + 1)) pnIndex = getLastIndex(pnIndex + 1);
          return pnIndex;
        }

        //editmask 생성
        var getEditMask = function(pnIndex){
          if(!pnIndex) pnIndex = 0;
          var vnStartIdx = pnIndex;
          var vnLastIdx = getLastIndex(pnIndex);
          var vnCnt = vnLastIdx + 1 - vnStartIdx;

          vsEditMask = vsEditMask + "[" + vaRegExp[vsNoFormat.charAt(pnIndex)] + "]{" + 0 + "," + vnCnt + "}";
          if(vsNoFormat.charAt(vnLastIdx + 1)) vsEditMask = getEditMask(vnLastIdx + 1);
          return vsEditMask;
        }

        //resultmask 생성
        var getResultMask = function(pnIndex){
          if(!pnIndex) pnIndex = 0;
          var vnStartIdx = pnIndex;
          var vnLastIdx = getLastIndex(pnIndex);
          var vnCnt = vnLastIdx + 1 - vnStartIdx;

          vsResultMask = vsResultMask + "[" + vaRegExp[vsNoFormat.charAt(pnIndex)] + "]{" + vnCnt + "}";
          if(vsNoFormat.charAt(vnLastIdx + 1)) vsResultMask = getResultMask(vnLastIdx + 1);
          return vsResultMask;
        }

        vsEditMask = getEditMask() + "$";
        vsResultMask = getResultMask() + "$";
      }
      break;
    case "Date" :
      vsFormat = vsFormat.split("Y").join("y");
      vsFormat = vsFormat.split("D").join("d");
      vsFormat = vsFormat.split("h").join("H");

//      if(vsMask){
//        vsMask = vsMask.split("Y").join("y");
//        vsMask = vsMask.split("D").join("d");
//        vsMask = vsMask.split("h").join("H");
//        var vsNoFormat = vsMask.replace(/[^ymdhs]/gi, "");
//        vsEditMask = "^";
//        vsEditMask = vsEditMask + "[0-9]{0," + vsNoFormat.length + "}$";
//        vsResultMask = vsResultMask + "[0-9]{" + vsNoFormat.length + "}$";
//      }
      break;
    case "Radio" :
    case "CheckBox" :
      var pnFormat = 1;
      if(poColumn.displayMode){
        if(poColumn.displayMode == "horizontal") pnFormat -= 1;
        else if(poColumn.displayMode == "vertical") pnFormat += 1;
      }
      if(poColumn.labelPos == "left") pnFormat += 4;
      if(poColumn.type == "CheckBox") pnFormat = pnFormat + 8 + 16 + 32;

      vsFormat = "|" + pnFormat + "|||||";
      return vsFormat;
      break;
  }
  var vsRet = "";
  if(vsFormat) vsRet = vsRet + " Format='" + vsFormat + "'";
  if(vsMask) vsRet = vsRet + " EditFormat='" + vsMask + "'";
  return  vsRet;
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.runEvent = function(e, poControl) {
  if(this.disabled) return;
  var voEvent = new eXria.event.Event(e, this.window);
  voEvent.object = poControl;

  //FF에서 voEvent.target 이 undefined 로 넘어옴
  if(!!voEvent.target)
  voEvent.target.id = "GridEx";

  var voCanvas = this.canvas;
  var vsType = voEvent.type;
  if(vsType == "mousedown" || vsType == "mouseup") return;
  var vsAtEvent = "at" + vsType;        // 컨트롤별 이벤트 처리
  var vsCoEvent = "co" + vsType;        // 공통 이벤트 처리
  var vsOnEvent = "on" + vsType;        // 사용자 지정 이벤트 처리
  var vsEventCallback = vsType + "EventCallback";
  var vsFinalEvent = "final" + vsType;  // 최종 이벤트 처리
  var vbSkip = false;

  switch(vsType) {
  case "mouseover" :
    if(voCanvas.mouseoverObj == poControl) {
      vbSkip = true;
    } else {
      voCanvas.mouseoverObj = poControl;
      this.mouseoutFired = false;
    }
    break;
  case "mouseout" :
    var vnX = this.borderLeftWidth;
    var vnY = this.borderTopWidth;
    if(voCanvas.page.metadata.browser.ie) {
      vnX = voEvent.e.offsetX;
      vnY = voEvent.e.offsetY;
      var voElement = voEvent.target;
      while(voElement.offsetParent) {
        vnX += voElement.offsetLeft;
        vnY += voElement.offsetTop;
        voElement = voElement.offsetParent ;
      };
    } else {
      vnX = voEvent.e.pageX;
      vnY = voEvent.e.pageY;
    }
    if(this.isContain(this.ctrl, vnX, vnY) || this.mouseoutFired) {
      vbSkip = true;
    } else {
      this.mouseoutFired = true;
    }
    break;
  case "keyup" :
    if(voEvent.keyCode == 229 && voCanvas.page.metadata.browser.gecko) {
      vbSkip = true;
    }
    break;
  }

  if(poControl[vsAtEvent]) { poControl[vsAtEvent](voEvent); }
  if(poControl[vsCoEvent]) { poControl[vsCoEvent](voEvent); }
  if(poControl[vsOnEvent] && vbSkip == false) {
    if(this.debug) {
      poControl[vsOnEvent](voEvent);
    } else {
      try {
        poControl[vsOnEvent](voEvent);
      } catch(err) {
        alert(vsOnEvent + "_" + poControl.id + " 사용자 정의 스크립트 오류\n\nname : " + err.name + "\nmessage : " + err.message);
      }
    }
  }
  if(poControl[vsEventCallback]) { poControl[vsEventCallback](voEvent); }
  if(poControl[vsFinalEvent]) { poControl[vsFinalEvent](voEvent); }

  switch(vsType) {
  case "keydown" :
  case "keyup" :
  case "mousemove" :
    break;
  case "contextmenu" :
    voEvent.stopEvent();
    break;
  default :
    voEvent.stopPropagation();
    break;
  }
};

eXria.controls.xhtml.GridEx.prototype.setSpecificEvents = function(poCtrl) {
  var base = this;

  this.enGridexColResize = function(poGrid, psCol) {
    var voCols = new Array();
    var voBodyCols = new Array();
    var voHeader = this.header;
    var voBody = this.body;

    voCols[0] = voHeader.cols["left"];
    voCols[1] = voHeader.cols["center"];
    voCols[2] = voHeader.cols["right"];
    voBodyCols[0] = voBody.cols["left"];
    voBodyCols[1] = voBody.cols["center"];
    voBodyCols[2] = voBody.cols["right"];

    var nColLen = 0;
    for(var i=0; i<3; i++) {
      if(voCols[i]) {
        voRow = voCols[i].rows[0];
      if(voRow && voRow.columns) {
        for(var j=0; j<voRow.columns.length; j++) {
            voColumn = voRow.columns[j];
        // 비교는 헤더컬럼과 비교해도 값은 바디 컬럼에 설정해야한다
        if(voColumn.id === psCol) {
          voBodyCols[i].rows[0].columns[j].width =  this.grid.Cols[psCol].Width;
        }
        }
      }
      }
    }
  }
  // 내부 그리드 컨트롤의 OnClick 발생 시 호출되는 이벤트  (pbIgnored는 항상 false 임)
  /**
   * @ignore
   */
  this.enGridexClick = function(poGrid, poRow, psCol, pnX, pnY, poEvent) {
    // yhkim 2009.08.19 (pageSelectAll) 리턴값 지정
    var ret = false;
    if(poGrid) {
      base.selectedIndexes = base.getSelectedIndexes();
      if(base.selectedIndexes) {
        base.clearDataSetRowKeyValue("selected__RowIndex");
        base.setDataSetRowKeyValue("selected__RowIndex", "U");
      }
      base.focusRow = base.grid.FRow;
      base.focusCol = base.grid.FCol;
      if(base.grid.FRow && base.grid.FCol) {
        base.clearDataSetRowKeyValue("focus__RowIndex");
        if(base.focusCol == null) base.focusCol = psCol;
        base.setDataSetRowKeyValue("focus__RowIndex", base.focusCol);
      }
      base.focusPagePos  = base.grid.FPagePos;
        // yjcho 2009.09.21 헤더를 선택하여 sort 수행 시 디폴트 row 선택이 일어나지 않도록 조치
  //      if(poRow && poRow.id == "Header") {
  //        var voBodyCol = null;
  //        if(psCol) voBodyCol = this.getBodyColumn(null, psCol);
  //        if(voBodyCol && voBodyCol.canSort != false) {
  //          this.grid.FRow = null;
  //          this.grid.FCol = null;
  //        }
  //      }
      vaSelRows = poGrid.GetSelRows();
      var vnSize = 0;
      if(vaSelRows) vnSize = vaSelRows.length;
      if (psCol != "Panel") {                    // Panel이 아닐경우
        if (base.cfg.multiSelect == false) {
          for(var i=0; i < vnSize; i++){
            poGrid.SelectRow(vaSelRows[i]);
          }
          if(poEvent.shiftKey) {
            poGrid.SelectRow(poRow);
            ret = true;
          }
        } else {
          if(psCol && (base.cfg.keepSelecting != true)) {
            if (!poEvent.ctrlKey){
              for(var i=0; i < vnSize; i++){
                poGrid.SelectRow(vaSelRows[i]);
              }
            }
            if (poRow.Kind != "Header") base.clearDataSetRowKeyValue("selected__RowIndex");
          }
        }

      } else {                                                // Panel일 경우
        if (poRow.Kind != "Header") {                         // Panel 헤더가 아닐경우
          if (base.cfg.multiSelect == false) {
            for(var i=0; i < vaSelRows.length; i++){
              poGrid.SelectRow(vaSelRows[i]);
            }
          }
        } else {                                               // Panel 해더일 경우
          if (base.cfg.multiSelect == false) {
            for(var i=0; i < vnSize; i++){
              poGrid.SelectRow(vaSelRows[i]);
            }
            ret = true;
          } else {
            if(base.cfg.pageSelectAll == true && base.cfg.paging == "fast") {
              if(base.pageSelectAllChecked == true) base.pageSelectAllChecked = false;
              else base.pageSelectAllChecked = true;
              base.enGridexSelectAll();
              base.setPageSelection();
              ret = true;
            }
          }
        }

      }

      base.resetEvent();
      var voEvent = base.event;
      voEvent.object = base;
      voEvent.row = poRow;
      voEvent.colId = psCol;
      voEvent.x = pnX;
      voEvent.y = pnY;
      voEvent.e = poEvent;
    }

    if(base.onGridexClick && poRow && psCol) ret = base.onGridexClick(voEvent);
    if(poRow && psCol) {
      base.runEvent(poEvent, base);   // 기본 이벤트를 전파함
    }

    return ret;
  };
  /**
   * @ignore
   */
  this.enGridexMouseDown = function(poEvent) {
    base.runEvent(poEvent, base);   // 기본 이벤트를 전파함
  };
  /**
   * @ignore
   */
  this.enGridexMouseMove = function(poEvent) {
    base.runEvent(poEvent, base);   // 기본 이벤트를 전파함
  };
  /**
   * @ignore
   */
  this.enGridexMouseUp = function(poGrid, poRow, psCol, pnX, pnY, poEvent) {
    //컨텍스트 메뉴를 refresh(display 표시) 하는 순간 firefox에서는 이벤트 발생이 끊기고 focus가 작동안함
    //따라서 UIControl의 finalmouseup을 호출하지 않도록 처리
    if(base["on" + poEvent.type]) base["on" + poEvent.type](poEvent);
  };
  /**
   * @ignore
   */
  this.enGridexMouseOut = function(poEvent) {
    base.runEvent(poEvent, base);   // 기본 이벤트를 전파함
  };
  // 내부 그리드 컨트롤의 OnDblClick 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexDblClick = function(poGrid, poRow, psCol, pnX, pnY, poEvent) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.x = pnX;
    voEvent.y = pnY;
    voEvent.e = poEvent;
    if(this.onGridexDblClick) return this.onGridexDblClick(voEvent);
    this.runEvent(poEvent, this);   // 기본 이벤트를 전파함
  };
  /**
   * @ignore
   */
  this.enGridexRightClick = function(poGrid, poRow, psCol, pnX, pnY, poEvent) {
    base.showContextMenu(poEvent.clientX, poEvent.clientY);
    base.event.object = base;
    base.event.type = null;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = psCol;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = pnX;
    base.event.y = pnY;
    base.event.key = null;
    base.event.value = null;
    base.event.e = poEvent;
    if(base.onGridexRightClick) return base.onGridexRightClick(base.event);
    base.runEvent(poEvent, base);   // 기본 이벤트를 전파함
    base.grid.Focus(base.focusRow, base.focusCol, base.focusPagePos);
  };
  /**
   * @ignore
   */
  this.enGridexKeyDown = function(poGrid, pcKey, poEvent, pnKeyCodes, psPrefix) {
    base.event.object = base;
    base.event.type = null;
    base.event.row = null;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColid = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = pcKey;
    base.event.value = null;
    base.event.e = poEvent;
    if(base.onGridexKeyDown) base.onGridexKeyDown(base.event);
  };
  // 내부 그리드 컨트롤의 OnFocus 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexFocus = function(poGrid, poRow, psCol, poBeforeRow, psBeforeCol, pnfocusPagePos ) {
    base.focusRow = poRow;
    base.focusCol = psCol;
    base.focusPagePos = pnfocusPagePos ;

    base.event.object = base;
    base.event.type = null;
    base.event.row = poRow;
    base.event.beforeRow = poBeforeRow;
    base.event.colId = psCol;
    base.event.beforeColId = psBeforeCol;
    base.event.pagePos = pnfocusPagePos ;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(this.onGridexFocus && !this.noFocusEvent) this.onGridexFocus(this.event);
    if(this.GridexFocusEventCallback && !this.noFocusEvent) this.GridexFocusEventCallback(this.event);
    if(poRow != poBeforeRow) {
      if(this.onGridexFocusRowChange && !this.noFocusEvent) this.onGridexFocusRowChange(this.event);
      if(this.GridexFocusRowChangeEventCallback && !this.noFocusEvent) this.GridexFocusRowChangeEventCallback(this.event);
    }
  };
  // 내부 그리드 컨트롤의 OnSelect 발생 시 호출되는 이벤트 (pnType = 0이면 select, 1이면 unselect, 2이면 change)
  /**
   * @ignore
   */
  this.enGridexSelect = function(poGrid, poRow, pnType) {
    var voRow = base.grid.FRow;

    // yhkim 2009.05.11 multiSelect 관련
    /*
    if(voRow) {
      base.grid.Focus(null, null);
      base.grid.SelectRow(voRow);
    }
    */

    base.event.object = base;
    base.event.type = pnType;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexSelect) base.onGridexSelect(base.event);
  };
  /**
   * @ignore
   */
  this.enGridExDelRow = function(G, poRow){
    base.event.object = base;
    base.event.type = null;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexDelRow) base.onGridexDelRow(base.event);
  };

  //Studio 추가 필요
  /**
   * @ignore
   */
  this.enGridexMarkDelRow = function(poGrid, poRow, pnType) {
    base.event.object = base;
    base.event.type = pnType;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    // 2009.07.15 yhkim markdel관련 dataset 상태 바꾸기
    base.SetMarkDelStatus(poRow, true);
    if(base.onGridexMarkDelRow) base.onGridexMarkDelRow(base.event);
  };

  this.enGridexUnMarkDelRow = function(poGrid, poRow) {
    base.event.object = base;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColid = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    // 2009.07.15 yhkim markdel관련 dataset 상태 바꾸기
    base.SetMarkDelStatus(poRow, false);
    if(base.onGridexUnMarkDelRow) base.onGridexUnMarkDelRow(base.event);
  };

  // 2009.06.16 yhkim
  /**
   * @ignore
   */
  this.enGridexAddRow = function(G, poRow) {
    base.event.object = base;
    base.event.type = null;
    base.event.row = poRow;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexAddRow) base.onGridexAddRow(base.event);
  };

  // 2009.06.16 yhkim
  /**
   * @ignore
   */
  this.enGridexPrint = function(G, poWindow) {
    base.event.object = base;
    base.event.type = null;
    base.event.row = null;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexPrint) base.onGridexPrint(base.event);
  };

  // 2009.06.16 yhkim
  /**
   * @ignore
   */
  this.enGridexPrintFinish = function(G, poWindow) {
    base.event.object = base;
    base.event.type = null;
    base.event.row = null;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexPrintFinish) base.onGridexPrintFinish(base.event);
  };

//내부 그리드 컨트롤의 OnRenderFinish 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexRenderStart = function() {
    if(base.cfg.paging === "fast") this.pageCountWithFastMode = 0;
    base.event.object = base;
    base.event.type = null;
    base.event.row = null;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos  = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    if(base.onGridexRenderStart) base.onGridexRenderStart(base.event);
  };
  
  /**
   * @ignore
   */
  this.enGridexLoaded = function(poGrid) {
    base.event.object = base;
    base.event.type = null;
    base.event.row = null;
    base.event.beforeRow = null;
    base.event.colId = null;
    base.event.beforeColId = null;
    base.event.pagePos = null;
    base.event.x = null;
    base.event.y = null;
    base.event.key = null;
    base.event.value = null;
    base.event.e = null;
    //if(base.onGridexLoaded) base.onGridexLoaded(base);
    if (base.onGridexLoaded) base.onGridexLoaded(base.event);
  };
  
  // 내부 그리드 컨트롤의 OnRenderFinish 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexRenderFinish  = function(poGrid) {
    function voFunc() {
      base.grid.OnCanRowAdd = function(){}; // onGridExPasteRow 이후 TreeGird의 로직 수행 방지 (이 이벤트 등록시 Row Add 수행안함)

      base.rendering = false;
      base.setDisable(base.getCtrl(), base.disabled);
      base.resetEvent();
      var voEvent = base.event;
      voEvent.object = base;
      if(base.onGridexRenderFinish) base.onGridexRenderFinish(voEvent);
      if(base.getDataRowCnt() == 0) base.enGridexRenderComplete(voEvent);
    };
    var voPage = base.canvas.page;
    if(voPage.isUnload) return;
    if(voPage.isRendered) voFunc();
    else voPage.eventQueue.push(voFunc);
  };

  // variable row 형태도 RenderFinish인경우 >> SetFocusRowIndex 호출이 가능해짐
  /**
   * @ignore
   */
  this.enGridexRenderPageFinish  = function(poRow) {
    if(this.canvas.page.isUnload) return;
    if(poRow["State"] != "4") return;
    var voGrid = this.grid;
    this.resizeTreeImg(); // 트리 이미지의 리사이징
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    if(this.onGridexRenderPageFinish) this.onGridexRenderPageFinish(voEvent);
    this.enGridexRenderComplete(voEvent);
//    if(this.onGridexRenderCompleteAll || this.GridexRenderCompleteAllEventCallback) {
    var vnRowTop = voGrid.GetRowTop(poRow);
    var vnRowHeight = voGrid.GetRowHeight(poRow);
    var vnScrollTop = voGrid.GetScrollTop();
    var vnBodyHeight = voGrid.GetBodyHeight();
    if(vnRowTop - vnScrollTop + vnRowHeight >= vnBodyHeight) {
      this.isRendered = true;
      if(this.onGridexRenderCompleteAll) this.onGridexRenderCompleteAll(voEvent);
      if(this.GridexRenderCompleteAllEventCallback) this.GridexRenderCompleteAllEventCallback(voEvent);
    }
//    }
    
    
  };

  /** 렌더링이 최종 완료시
   * @ignore
   */
  this.enGridexRenderComplete = function(voEvent) {
    var voFunc = function() {
      base.onGridexRenderComplete(voEvent);
    };
    var voPage = base.canvas.page;
    if(this.cfg.paging === "fast") {
      if(this.pageCountWithFastMode > -1) this.pageCountWithFastMode--;
      if(this.pageCountWithFastMode === 0) {
        if (base.onGridexRenderComplete) {
          if(voPage.isRendered) voFunc();
          else voPage.eventQueue.push(voFunc);
          this.runWithDataSetColumnType("focus__RowIndex");
          this.runWithDataSetColumnType("selected__RowIndex");
        }
      }
    } else {
        if (base.onGridexRenderComplete) {
          if(voPage.isRendered) voFunc();
          else voPage.eventQueue.push(voFunc);
        }
        this.runWithDataSetColumnType("focus__RowIndex");
        this.runWithDataSetColumnType("selected__RowIndex");
    }

    if(this.cfg.pageSelectAll == true && this.cfg.paging == "fast" && this.pageSelectAllChecked == true) {
      this.enGridexSelectAll();
      this.setPageSelection();
    }
    if(this.cfg.expandAll == true) this.grid.ExpandAll();
  };

  // 내부 그리드 컨트롤의 OnValueChanged 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexValueChanged = function(poGrid, poRow, psCol, poNewValue) {
    var vsType = this.getType(poRow, psCol);
    var vsRowType = this.getRowType(poRow);

    if(vsRowType == this.RowType.BodyRow)
      voColumn = this.getBodyColumn(null, psCol);
    else if(vsRowType == this.RowType.HeadRow)
      voColumn = this.getFunctionColumn(poRow, null , psCol);
    else if(vsRowType == this.RowType.FootRow)
      voColumn = this.getFootColumn(poRow, null , psCol);

    if(vsType == "Text" && voColumn.mask) {
      poNewValue = this.getOrgValueFromMask(String(poNewValue), voColumn.mask);
    }

    if(!voColumn.mask && !!voColumn.inputMode){
      poNewValue = eXria.controls.xhtml.Util.getValueFromInputMode(String(poNewValue), voColumn.inputMode);
    }

    if(voColumn.regMask) {
      var vsType = null;
      switch(voColumn.type) {
      case "Text" :
        vsType = "string";
        break;
      case "Int" :
      case "Float" :
        vsType = "number";
        break;
      case "Date" :
        vsType = "date";
        break;
      }
      poNewValue = TGP.GetString(poNewValue, vsType, voColumn.regMask, 1);
      poNewValue = TGP.GetValueInput(poNewValue, vsType, voColumn.regMask, 1);
    }

    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.value = poNewValue;
    if(this.onGridexValueChanged) this.onGridexValueChanged(voEvent);
    return voEvent.value;
  };

  // 내부 그리드 컨트롤의  OnAfterValueChanged 발생 시 호출되는 이벤트
  /**
   * @ignore  (pbSimple이 true일 경우에는 DataSet의 status를 변경하지 않고 단지 value만을 변경함)
   */
  this.enGridexAfterValueChanged = function(poGrid, poRow, psCol, pbSimple) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    
    // DataSet과의 데이타 동기화
    var voDataSet, voColumn, vsDatasetCol,voValue = null;
    var vnChildIdx = poRow["ChildIdx"];
    var vnRowSpan = poRow[psCol + "RowSpan"];
    if(vnRowSpan != null) vnRowSpan = eval(vnRowSpan);
    else vnRowSpan = 1;
    if(base.datasetId != null) {
      if(base.dataset) voDataSet = base.dataset;
      else voDataSet = base.canvas.page.model.getDataSet(base.datasetId);
      if(base.dataset) {
        voColumn = base.getBodyColumn(null, psCol);
        if(voColumn) {
          vsDatasetCol = voColumn.datasetCol;
          if(vnChildIdx != null) vsDatasetCol = this.childRows[vnChildIdx][psCol];
          if(vsDatasetCol == null) {
            vsDatasetCol = voColumn.ref;
            if(vsDatasetCol != null) {
              var vaPath = vsDatasetCol.split("/");
              vsDatasetCol = vaPath[vaPath.length - 1];
            }
          }
          if(vsDatasetCol) {
            var vnRowIndex = base.getIndexOfRow(poRow);
            voValue = base.grid.GetValue(poRow, psCol);
            voValue = this.convertValueExria(poRow, psCol, voValue);
            if(voValue === null) voValue = "";
            if(voColumn.type == "Int" && voValue != "") {
              if(voValue >= 0) voValue = Math.round(voValue);
              else voValue = -1 * Math.round(-1 * voValue);
            }
            var vbResult;
            if(vnRowIndex != null) {
              for(var i = 0; i < vnRowSpan; i++) {
                 vbResult = true;
                 if(pbSimple) {
                   vbResult = base.dataset.simpleSet(vnRowIndex + 1 + i, vsDatasetCol, voValue);
                 } else {
                   vbResult = base.dataset.set(vnRowIndex + 1 + i, vsDatasetCol, voValue);
                 }
                 if(!vbResult) alert("data sync error");
               }
            }
          }
        }
      }
    } else if (!!base.data.nodesetInstanceId && !!base.data.nodesetInstancePath) {
      if (base.getRowType(poRow) == base.RowType.BodyRow) {
        voColumn = base.getBodyColumn(null, psCol);
        var vnInstIdx = poRow ["InstIdx"];
        if(vnChildIdx != null) vnInstIdx = poRow.parentNode["InstIdx"];
        if (vnInstIdx == null) vnInstIdx = poRow.getAttribute("InstIdx");
        vnInstIdx = parseInt(vnInstIdx);
        var voMapNode = base.data.getNodesetData2(vnInstIdx);
        var voRowNode = null;
        
        if (!pbSimple) {
          voRowNode = voMapNode.node;
          var vsStatus = voRowNode.getUserAttribute("status");
          if (vsStatus == null) vsStatus = "";
          if (vsStatus.indexOf("U") == -1) voRowNode.setUserAttribute("status", vsStatus + "U");
        }

        var vsRef = voColumn.ref;
        if(vnChildIdx != null) vsRef = this.childRows[vnChildIdx][psCol];
        if (!!vsRef) {
          var vnRowIndex = base.getIndexOfRow(poRow);
          voValue = base.grid.GetValue(poRow, psCol);
          voValue = this.convertValueExria(poRow, psCol, voValue);
          if (voValue === null) voValue = "";
          if (voColumn.type == "Int" && voValue != "") {
            if (voValue >= 0) voValue = Math.round(voValue);
            else voValue = - 1 * Math.round(- 1 * voValue);
          }
          vsRef = vsRef.split("/");
          vsRef = vsRef [vsRef.length - 1];
          voMapNode.put(vsRef, voValue);
          for(var i = 1; i < vnRowSpan; i++) {
            voMapNode = base.data.getNodesetData2(vnInstIdx + i);
          }
        }
        //수정
        if(poRow["Changed"] == "1") {
          if(poRow["Added"] == "1") voRowNode.setUserAttribute("status", "IU");
          if(poRow["Deleted"] == "1") voRowNode.setUserAttribute("status", "D");
        } else {
          if(poRow["Deleted"] == "1") voRowNode.setUserAttribute("status", "D");
          else  {
            vsStatus = poRow["InstStatus"];
            if(vsStatus == null) vsStatus = "";
            if(vsStatus.indexOf("U") != -1) poRow["Changed"] = "1";
            voRowNode.setUserAttribute("status", vsStatus);
          }
        }
      }
    }

    //컬럼별 showTooltip 기능이 동작 되야 할때
    var vbShowTooltip = !!this.showTooltip,
        vaShowTooltip = this.showTooltip,
        vsDsColId,
        vsColId;

    if(vbShowTooltip){
      for(var z=0, vnRowCnt = vaShowTooltip.length; z < vnRowCnt; z++){
        vsDsColId = vaShowTooltip[z]['dsColId'];
        vsColId = vaShowTooltip[z]['colId'];
        if(psCol === vsColId){
          poRow[vsColId+'Tip'] = voValue.simpleReplace('\n','<br/>');
        }
      }
    };

    if(this.onGridexAfterValueChanged) this.onGridexAfterValueChanged(this.event);
    if(this.GridexAfterValueChangedEventCallback) this.GridexAfterValueChangedEventCallback(this.event);
  };

  // 내부 그리드 컨트롤의  OnButtonClick 발생 시 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexButtonClick = function(poGrid, poRow, psCol) {
    var voCol = null;
    if(poRow) {
      if(poRow.Fixed) {
        if(poRow.Fixed == "Head")
          voCol = this.getFunctionColumn(poRow, null , psCol);
        else if(poRow.Fixed == "Foot")
          voCol = this.getFootColumn(poRow, null , psCol);
      }
      else {
        voCol = this.getBodyColumn(null, psCol);
      }
    }
    if(voCol) {
      if(voCol.rightButton.enableMode == "auto" || voCol.rightButton.enableMode === null) {
        var vbEdit = Get(poRow, psCol + "CanEdit");
        if(vbEdit === 0 || vbEdit === false)
          return;
      }
      else if(voCol.rightButton.enableMode == "disabled")
        return;
      // enabled는 해줄게 없다
    }
    
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    if(this.onGridexButtonClick) this.onGridexButtonClick(voEvent);
  };
  // GridEx에 Paste시 발생하는 이벤트
  /**
   * @ignore
   */
  this.enGridexPasteRow = function(poRow, paCols, paValues, pbAdded){
    var vbRet = false;
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = paCols;
    voEvent.pastedtext = paValues;
    if(this.onGridexPasteRow) vbRet = this.onGridexPasteRow(voEvent);
    return vbRet;
  };
  /**
   * @ignore
   */
  this.enGridexPasteRowFinish = function(poRow, paCols, paValues, pbAdded){
    // DataSet과의 데이타 동기화
    var voDataSet, vsCol, voColumn, vsDatasetCol, vnRowPan, voValue = null;
    var vnChildIdx = poRow["ChildIdx"];
    var vnSize = paValues.length;
    if(this.datasetId != null) {
      if(this.dataset) voDataSet = this.dataset;
      else voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
      if(this.dataset) {
        for(var i = 0; i < vnSize; i++) {
          vsCol = paCols[i];
          vnRowSpan = poRow[vsCol + "RowSpan"];
          if(vnRowSpan != null) vnRowSpan = eval(vnRowSpan);
          else vnRowSpan = 1;
          voColumn = base.getBodyColumn(null, vsCol);
          if(voColumn) {
            vsDatasetCol = voColumn.datasetCol;
            if(vnChildIdx != null) vsDatasetCol = this.childRows[vnChildIdx][vsCol];
            if(vsDatasetCol == null) {
              vsDatasetCol = voColumn.ref;
              if(vsDatasetCol != null) {
                var vaPath = vsDatasetCol.split("/");
                vsDatasetCol = vaPath[vaPath.length - 1];
              }
            }
            if(vsDatasetCol) {
              var vnRowIndex = this.getIndexOfRow(poRow);
              voValue = this.grid.GetValue(poRow, vsCol);
              voValue = this.convertValueExria(poRow, vsCol, voValue);
              if(voValue === null) voValue = "";
              if(voColumn.type == "Int" && voValue != "") {
                if(voValue >= 0) voValue = Math.round(voValue);
                else voValue = -1 * Math.round(-1 * voValue);
              }
              var vbResult;
              if(vnRowIndex != null) {
                for(var j = 0; j < vnRowSpan; j++) {
                   vbResult = true;
                   vbResult = this.dataset.set(vnRowIndex + 1 + j, vsDatasetCol, voValue);
                   if(!vbResult) alert("data sync error");
                 }
              }
            }
          }
        }
      }
    } else if (!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
      if (this.getRowType(poRow) == this.RowType.BodyRow) {
        for(var i = 0; i < vnSize; i++) {
          vsCol = paCols[i];
          vnRowSpan = poRow[vsCol + "RowSpan"];
          if(vnRowSpan != null) vnRowSpan = eval(vnRowSpan);
          else vnRowSpan = 1;
          voColumn = this.getBodyColumn(null, vsCol);
          var vnInstIdx = poRow ["InstIdx"];
          if(vnChildIdx != null) vnInstIdx = poRow.parentNode["InstIdx"];
          if (vnInstIdx == null) vnInstIdx = poRow.getAttribute("InstIdx");
          vnInstIdx = parseInt(vnInstIdx);
          var voMapNode = this.data.getNodesetData2(vnInstIdx);
          var voRowNode = voMapNode.node;
          var vsStatus = voRowNode.getUserAttribute("status");
          if (vsStatus == null) vsStatus = "";
          if (vsStatus.indexOf("U") == -1) voRowNode.setUserAttribute("status", vsStatus + "U");
  
          var vsRef = voColumn.ref;
          if(vnChildIdx != null) vsRef = this.childRows[vnChildIdx][vsCol];
          if (!!vsRef) {
            var vnRowIndex = this.getIndexOfRow(poRow);
            voValue = this.grid.GetValue(poRow, vsCol);
            voValue = this.convertValueExria(poRow, vsCol, voValue);
            if (voValue === null) voValue = "";
            if (voColumn.type == "Int" && voValue != "") {
              if (voValue >= 0) voValue = Math.round(voValue);
              else voValue = - 1 * Math.round(- 1 * voValue);
            }
            vsRef = vsRef.split("/");
            vsRef = vsRef [vsRef.length - 1];
            voMapNode.put(vsRef, voValue);
            for(var j = 1; j < vnRowSpan; j++) {
              voMapNode = base.data.getNodesetData2(vnInstIdx + j);
            }
          }
          if(poRow["Changed"] == "1") {
            if(poRow["Added"] == "1") voRowNode.setUserAttribute("status", "IU");
            if(poRow["Deleted"] == "1") voRowNode.setUserAttribute("status", "D");
          } else {
            if(poRow["Deleted"] == "1") voRowNode.setUserAttribute("status", "D");
            else  voRowNode.setUserAttribute("status", "");
          }
        }
      }
    }
  };

  // 사용자에 Action에 의해 sort 될때 발생하는 이벤트
  /**
   * @ignore (-1을 리턴하면 디폴트로 설정된 sorting 관련 동작을 모두 중지시키고, 1을 리턴하면 sorting 만 중지시키고 sort icon에 대한 디폴트 변경 동작은 허용된다.)
   */
  this.enGridexSort = function(psCol, psSort) {
    var voGrid = this.grid;
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.colId = psCol;
    var vnResult = 0;

    if(this.onGridexSort) {
      vnResult = base.onGridexSort(voEvent);
    }
    if(!vnResult) {
      var voDst = this.dataset;
      if(voDst) {
        var vnPaging = this.grid.Paging;
        if(vnPaging == 3) return;
        var vaSortCol = psSort.split(",");
        var vsCol = null;
        var vbSortAsc = null;
        var vaSortType = [];
        for(var i = 0; i < vaSortCol.length; i++) {
          vsCol = vaSortCol[i];
          vbSortAsc = true;
          if(vsCol.indexOf("-") == 0) {
            vsCol = vsCol.substring(1);
            vaSortType.push(1);
            vaSortCol[i] = vsCol;
          } else {
            vaSortType.push(0);
          }
        }
        this.grid.Paging = 3;
        this.sort(1, vaSortCol, vaSortType);
        this.grid.Paging = vnPaging;
        vnResult = 1;
      }
    }
    return vnResult;
  };
  /**
   * @ignore
   */
  this.enGridexSortFinish = function() {
    if(this.oddRowBg || this.evenRowBg) {
      var voXB = this.grid.XB;
      var voFuncSetColor, vsBg, vnIdx;
      var voBase = this;
      voFuncSetColor = function(poNode){
        if(poNode.childNodes.length > 0 && poNode["InstIdx"] == null && poNode["ChildIdx"] == null){
          vnIdx = -1;
          for(var r=poNode.firstChild;r;r=r.nextSibling){
            voFuncSetColor(r);
          }
        } else {
          if(poNode && poNode.nodeName && poNode.nodeName == "I" && poNode["InstIdx"] != null) vnIdx++;
          if(vnIdx % 2 == 1) vsBg = voBase.evenRowBg;
          else vsBg = voBase.oddRowBg;
          poNode["Color"] = vsBg;
          for(var rr=poNode.firstChild;rr;rr=rr.nextSibling){
            voFuncSetColor(rr);
          }
        }
      };
      if(voXB != undefined) voFuncSetColor(voXB);
      this.grid.RenderBody();
    }
  };
  /**
   * @ignore
   */
  this.enGridexScroll = function(poGrid, pnNewScollLeft, pnNewScrollTop, pnOldScollLeft, pnOldScrollTop) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.scroll.newLeft = pnNewScollLeft;
    voEvent.scroll.newTop = pnNewScrollTop;
    voEvent.scroll.oldLeft = pnOldScollLeft;
    voEvent.scroll.oldTop = pnOldScrollTop;
    if(this.onGridexScroll) return this.onGridexScroll(voEvent);
  };
  /**
   * @ignore
   */
  this.enGridexClickSideDate = function(poRow, psCol, poEvent) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.e = poEvent;
    if(this.onGridexClickSideDate) return this.onGridexClickSideDate(voEvent);
  };
  /**
   * @ignore
   */
  this.enGridexStartEdit = function(poRow, psCol, poEvent) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.e = poEvent;
    this.isEditing = true;
    var vbRet = false;
    if(this.onGridexStartEdit) vbRet = this.onGridexStartEdit(voEvent);
    if(vbRet == null) vbRet = false;
    return vbRet;
  };
  // cell에 editing이 종료되거나 Enum 리스트가 닫힐때 호출되는 이벤트
  /**
   * @ignore
   */
  this.enGridexEndEdit = function(poRow, psCol, pbSave, psValue) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.type = pbSave;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.value = psValue;
    if(this.grid.isEntered) voEvent.isEntered = true;

    this.isEditing = false;
    if (this.onGridexEndEdit) this.onGridexEndEdit(voEvent);
    voEvent.isEntered = null;
    this.grid.isEntered = null;
  };
  /**
   * @ignore
   */
  this.enGridexGanttChanged = function(poRow, psCol, psKind, psVal1, psVal2) {
    var voBodyColumn = base.getBodyColumn(null, psCol);
    var vsGanttCol = null;
    switch(psKind) {
    case "Main" :
      if(psVal1 != null) {
        vsGanttCol = voBodyColumn.ganttStart;
        base.enGridexAfterValueChanged(base, poRow, vsGanttCol);
      }
      if(psVal2 != null) {
        vsGanttCol = voBodyColumn.ganttEnd;
        base.enGridexAfterValueChanged(base, poRow, vsGanttCol);
      }
      break;
    case "Dependency" :
      if(psVal1 != null) {
        vsGanttCol = voBodyColumn.ganttDependencies;
        base.enGridexAfterValueChanged(base, poRow, vsGanttCol);
      }
      if(psVal2 != null) {
        vsGanttCol = voBodyColumn.ganttDependencyTypes;
        base.enGridexAfterValueChanged(base, poRow, vsGanttCol);
      }
      break;
    case "UpdateDependency" :
      vsGanttCol = psVal1;
      base.enGridexAfterValueChanged(base, poRow, vsGanttCol);
      break;
    }
  };

  this.enGridexPostRender = function() {};

  this.enGridexScrollUpdate = function() {
    if(this.onGridexScrollUpdate || this.onGridexRenderCompleteAll) {
      this.resetEvent();
      var voEvent = this.event;
      voEvent.object = this;
      voEvent.row = this.grid.GetPage(this.cfg.pagePos);
      voEvent.pagePos = this.cfg.pagePos;
      
      if(voEvent.row == null || voEvent.row["State"] != "4") return;
      var voGrid = this.grid;
      var voPage = voEvent.row;
      var vnHeight = voGrid.GetRowHeight(voPage);
      if(this.onGridexScrollUpdate) this.onGridexScrollUpdate(voEvent);
      if(this.onGridexRenderCompleteAll) this.onGridexRenderCompleteAll(voEvent);
      if(this.cfg.ganttIdColumn) {
        this.grid.RefreshGanttDependencies(1);
        setTimeout(function() { base.moveToToday(); }, 100);
      }
    }
  };

  this.enGridexStartDrag = function(poRow, psCol, pbMultiRow) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.row = poRow;
    voEvent.colId = psCol;
    voEvent.isMulti = pbMultiRow;
    if(this.onGridexStartDrag) return this.onGridexStartDrag(voEvent);
  };

  this.enGridexEndDrag = function(pcSrcGrx, poSrcRow, poTrgRow, pnType, nX, nY) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.beforeObject = pcSrcGrx;
    voEvent.dropType = pnType;
    voEvent.row = poTrgRow;
    voEvent.beforeRow = poSrcRow;
    voEvent.x = nX;
    voEvent.y = nY;
    
    if(this == pcSrcGrx) {
      // TODO :
    }
    var vnType = null;
    if(this.onGridexEndDrag) vnType = this.onGridexEndDrag(voEvent);
    if(vnType == null) vnType = pnType;
    return pnType;
  };

  this.enGridexCellEditChanged = function(psNewValue, psBeforeValue, poRow, poEvent) {
    this.resetEvent();
    var voEvent = this.event;
    voEvent.object = this;
    voEvent.value = psNewValue;
    voEvent.row = poRow;
    voEvent.e = poEvent;
    
    if(this.onGridexCellEditChanged) this.onGridexCellEditChanged(voEvent);
  };

  this.enGridexDownloadPage = function(poRow, poFunc) {
      this.cfg.pagePos = poRow.Pos;
  };

  this.enGridexCustomAjax = function(poSource, psData, poFunc) {
    var vsData = this.getPagingData(this.cfg.pagePos);
    if(!vsData) poFunc(-1, "Error");
    else poFunc(0, vsData);
    return true;
  };
  
  this.enGridexSelectAll = function() {
    var voGrid = this.grid;
    var vaFixedRows = voGrid.GetFixedRows();
    var vnSize = vaFixedRows.length;
    var vbCheck = false;
    var vcCtrl = null;
    if(this.cfg.pageSelectAll == true && this.cfg.paging == "fast") {
      if(this.pageSelectAllChecked) vbCheck = true;
    } else {
      if(voGrid.GetSelRows().length == 0) vbCheck = true;
    }
    for(var i = 0; i < vnSize; i++){
      var vsSection = vaFixedRows[i].Fixed;
      if(vsSection == "Head") {
        vcCtrl = voGrid.GetCell(vaFixedRows[i], "Panel");
        if(vbCheck) vcCtrl = vcCtrl.childNodes[0].style.backgroundPosition = "-150px 0px";
        else vcCtrl = vcCtrl.childNodes[0].style.backgroundPosition = "-100px 0px";
      }
    }
    
  };
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.resizeTreeImg = function(){
  if(this.cfg.grouping === false || !this.cfg.groupMain || !this.cfg.groupCols) return;
  var vaCenter = document.getElementsByTagName("center");
  for(var i=0, il=vaCenter.length; i<il; i++){
    if(vaCenter[i].parentNode){
      var voParent = vaCenter[i].parentNode;
      if(voParent.className){
        var vsClass = voParent.className;
        var vsClassTree = vsClass.substring(vsClass.length-8, vsClass.length);
        if(vsClassTree == "TreeIcon"){
          var vnHeight = voParent.parentNode.parentNode.parentNode.parentNode.parentNode.offsetHeight - 2;
          if(vnHeight < 0) vnHeight = 0;
          if(this.canvas.page.metadata.browser.ie > 0 && vaCenter[i].firstChild) vaCenter[i].firstChild.style.height = vnHeight + "px";
          else vaCenter[i].style.height = vnHeight + "px";
        }
      }
    }
  }
};
/**
 * 2009.05.19 yjcho - Tab키에 의한 focus이동을 위해 추가
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.dofocus = function(poEvent) {
  if(poEvent && poEvent.type == "keydown") {
    poEvent.stopEvent();
    var base = this;
    this.temp = function() {
      var voGrid = base.grid;
      var voFRow = voGrid.FRow;
      var voFCol = voGrid.FCol;
      if(voFRow) {
        voGrid.Focus(voFRow, voFCol);
      } else {
        if(poEvent && poEvent.shiftKey) {
          voGrid.ActionGoLast();
        } else {
          voGrid.ActionGoFirst();
        }
      }
    }
    this.canvas.delayedKeydown.add(this.temp);
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.doblur = function(){
  this.grid.EndEdit(this.grid.FRow,this.grid.FCol,true);
  // yhkim 2009.07.16 탭이동간 차일드  Window들 닫기
  this.grid.CloseDialog();
  // yhkim 2009. 05.07
  if(this.window.Grids) this.window.Grids.Focused = null;
};
/**
 * 그리드 layout data 구성하기 위해 호출되는 메소드
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.makeLayout = function(){
  /////////////////////////////////////////////////////////////////
  // layout data 구성
  var vsLayOutData = "";
  vsLayOutData = this.template["Start"] + this.template["Cfg"];

  vsLayOutData = vsLayOutData + this.template["Def"];
  vsLayOutData = vsLayOutData + this.template["Cols"];
  vsLayOutData = vsLayOutData + this.template["Header"];
//vsLayOutData = vsLayOutData + "<Body><B/></Body>";
  // yhkim 2009.08.29 Data영역에서 <B/>를 설정한다
  vsLayOutData = vsLayOutData + "<Body></Body>";

  vsLayOutData = vsLayOutData + this.template["Toolbar"] + "\n";

  // 2009.08.04 Panel Layout
  vsLayOutData = vsLayOutData + this.template["Panel"];

  vsLayOutData = vsLayOutData + this.template["End"];
  this.templateLayout = vsLayOutData;
  vsLayOutData = null;
};

eXria.controls.xhtml.GridEx.prototype.loadData = function(poDocument) {
  if(this.datasetId == null) {
    this.loadDataFromInstance(poDocument);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  } else {
    this.loadDataFromDataSet(poDocument);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  }
};
// yhkim 2009. 05.25
/**
 * loadFunctionColumnDataFromInstance
 * @param {HTMLDocument} poDocument 윈도우 document 객체
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.loadFunctionColumnDataFromInstance = function(poDocument) {
  this.template["FunctionColumn"] = "";
  this.template["FunctionColumn"] = this.makeFunctionRowDataFromInstance();
};
//yhkim 2009. 05.25
/**
 * makeFunctionRowDataFromInstance
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.makeFunctionRowDataFromInstance = function(){
  var voCols = new Array();
  var voColumn = null;
  voCols[0] = this.header.cols["left"];
  voCols[1] = this.header.cols["center"];
  voCols[2] = this.header.cols["right"];

  var vsFunctionColumns = "";
  var vnFunctionHeaderCnt = 0;
  var vnHeaderCnt = 0;
  var voTmpCols;

  for ( var i = 0; i < 3; i++) {
    if (voCols[i] && !!voCols[i].rows[0].columns.length){
      for ( var j = 0; voCols[i].rows.length > j; j++) {
        var voRow = voCols[i].rows[j];
        if(voRow.columns == null) continue;
        var vnColumns = voRow.columns.length;
        for(var k = 0; k < vnColumns; k++) {
          voColumn = voRow.columns[k];
          if(voColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn){
            vnFunctionHeaderCnt++;
          }
          else if(voColumn instanceof eXria.controls.xhtml.GridEx.HeadColumn){
            vnHeaderCnt++;
          }
          break; //row 수 판단을 위한 코드이므로 한 컬럼만을 체크
        }
      }
      voTmpCols = voCols[i];
      break; // row 수 판단을 위한 코드이므로 한 Cols만을 체크
    }
  }
  if(vnFunctionHeaderCnt > 0) {
    var vsTitle, vsColumnText = "";
    vsFunctionColumns = "<Head Height='" + this.header.height + "'>";
    var vsRow = "";
    var voCfg = this.cfg;

    for(var cnt = 0; cnt < vnHeaderCnt + vnFunctionHeaderCnt; cnt++){
      vsRow = "<I Calculated='1' Spanned='1' ";
      if(this.funcRowCanEdit == false) {
        vsRow += "CanEdit='0' CanFocus='0' "
      }else{
        if(voCfg.editing != null) vsRow = vsRow + " CanEdit='" + voCfg.editing + "'";
      }

      var voFirstCol = null;
      //if(voCols[0]) voFirstCol = voCols[0].rows[cnt].columns[0];
      //else if(voCols[1]) voFirstCol = voCols[1].rows[cnt].columns[0];
      voFirstCol = voTmpCols.rows[cnt].columns[0];
      vsRow = vsRow + this.makeHeaderRowColorData(voFirstCol.id);

      for ( var i = 0; i < 3; i++) {  // left,center,right가 순서대로 가야 한다.
        if (voCols[i]) {
          var voRow = voCols[i].rows[cnt];  // cnt갯수에 따라 결정되어야 한다.
          var voColumn = null;
          if(voRow.columns == null) continue;
          for ( var k = 0; voRow.columns.length > k; k++) {
            voColumn = voRow.columns[k];

            if(this.cfg.idColumn != null && voColumn.colId == this.cfg.idColumn) { // id 칼럼에 대한 처리
              if(!!voColumn.value){
                vsColumn = " id='" + voColumn.value + "'";
              }else{
//                vsColumn = " id='" + "H" + (cnt+1-vnHeaderCnt) + "'";
                vsColumn = " id='&#x90;'";
              }
            } else {
              if(voColumn instanceof eXria.controls.xhtml.GridEx.HeadColumn){
                vsRow = "";
                continue;
              }

              vsColumn = "";
              vsColumnText = "";

              // itemgroup
              if(voColumn.itemgroup.data){
                var voItemGData = voColumn.itemgroup.data;
                voItemGData.control = this;
                if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
                  voColumn.itemgroup.addToItemset();
                }
              }

              // value
              var voInstance = null;
              var vsValue = "";
              if(voColumn.instanceId){
                voInstance = this.canvas.page.getInstance(voColumn.instanceId);
              }
              if(voInstance && voColumn.ref) {
                //voValue = voInstance.getValueNode(voColumn.ref).getValue();
                //voColumn.value = voValue;
                voColumn.data = new eXria.controls.DataRefNodeset(this);
                    voColumn.data.setRef(voColumn.instanceId, voColumn.ref);
                    vsValue = voColumn.data.getData();  // 리스트값이 필요
              }
              // 기본  text/caption/값
              if (voColumn.type == "Radio" || voColumn.type == "CheckBox"){
                vsValue = this.convertValueTGrid(voColumn, vsValue);
                vsColumn = vsColumn + " " + voColumn.colId + "='" + vsValue + "'";
              }else if(voColumn.type == "Button"){
                if(vsValue.length == 0)
                  vsValue = voColumn.value;
                vsColumn = " " + voColumn.colId + "Caption='" + vsValue + "'";
              }else if(voColumn.type == "Date"){
                vsColumn = vsColumn + " " + voColumn.colId + "='" + vsValue + "'";
              }else if(voColumn.type == "Bool" || voColumn.type == "Int" || voColumn.type == "Float"){
                if(vsValue.length == 0)
                  vsValue = voColumn.value;
                      try {
                        vsValue = eval(vsValue);
                        //vsValue = this.getXml(vsValue,2);
                        vsColumn = vsColumn + " " + voColumn.colId + "='" + vsValue + "'";
                      } catch(err) {
                        throw new Error("Column miss type error");
                      }
              }else if(voColumn.type == "Image"){// 텍스트가 필요없다
              }else {
                if(voColumn.value == null)
                  voColumn.value = "";
                if(vsValue.length == 0){
                    vsValue = voColumn.value;
                }
                vsValue = this.getXmlValue(vsValue);
                vsColumn = vsColumn + " " + voColumn.colId + "=" + vsValue + "";
              }
            }

            // type
            if (voColumn.type == "Image"){
              var voHrefValue, voWidthValue, voHeightValue, voLeftValue, voTopValue, voTargetValue;
              vsColumn = vsColumn + " " + voColumn.colId + "Type='Img'";

              var vsRef = voColumn.imageItem.href;
              if (voInstance && vsRef)
                voHrefValue = voInstance.getValueNode(vsRef).getValue();
              else
                voHrefValue = "";

              vsRef = voColumn.imageItem.target;
              if (voInstance && vsRef)
                voTargetValue = voInstance.getValueNode(vsRef).getValue();
              else
                voTargetValue = "";

              vsRef = voColumn.imageItem.width;
              if (voColumn.instanceId && vsRef)
                voWidthValue = voInstance.getValueNode(vsRef).getValue();
              else
                voWidthValue = "";

              vsRef = voColumn.imageItem.height;
              if (voInstance && vsRef)
                voHeightValue = voInstance.getValueNode(vsRef).getValue();
              else
                voHeightValue = "";

              vsRef = voColumn.imageItem.left;
              if (voInstance && vsRef)
                voLeftValue = voInstance.getValueNode(vsRef).getValue();
              else
                voLeftValue = "";

              vsRef = voColumn.imageItem.top;
              if (voInstance && vsRef)
                voTopValue = voInstance.getValueNode(vsRef).getValue();
              else
                voTopValue = "";

              if (vsValue != null) {
                vsColumn = vsColumn + " " + voColumn.colId
                    + "=" + "\"|" + voHrefValue + "|"
                    + voWidthValue + "|"
                    + voHeightValue + "|" + voLeftValue
                    + "|" + voTopValue + "|"
                    + voTargetValue + "\"";
              }

            }
            else if (voColumn.type == "Radio" || voColumn.type == "CheckBox"){
              vsColumn = vsColumn + " " + voColumn.colId +"Type='Radio'";
              var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
              vsLabels =  " " + voColumn.colId + "Enum='" + vsLabels + "'";
              if(voColumn.type == "CheckBox") vsLabels = " " + voColumn.colId + "Range='1'";
              vsColumn = vsColumn + " " + voColumn.colId + "Wrap='0'";
            }
            else
              vsColumn = vsColumn + " " + voColumn.colId +"Type='" + voColumn.type + "'";

            // 리스트 형태들 추가속성들
            if (voColumn.type == "Enum") {
              var vsValues = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
              var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
              vsColumn = vsColumn + " " + voColumn.colId + "Enum='" + vsLabels + "'"
                + voColumn.colId + "EnumKeys='" + vsValues + "'";
              if(voColumn.enumType) vsColumn = vsColumn + " " + voColumn.colId + "EnumType='" + voColumn.enumType + "'";
            }
            else if (voColumn.type == "Select") {
              voValue = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
              var vsDefaults = " " + voColumn.colId + "Defaults='" + voValue + "'";
              vsColumn = vsColumn + vsDefaults;
            }
            else if (voColumn.type == "Button"){
              for(var vsAttr in voColumn.buttonItem){
                      var vsRef = voColumn.buttonItem[vsAttr];
                      if(vsRef == null) continue;
                      var voValueNode = voInstance.getValueNode(vsRef);
                      if(voValueNode == null) continue;
                      var vsAttrValue = voValueNode.getValue();
                      if(vsAttrValue) vsAttrValue = this.getXml(vsAttrValue, 2);

                      if(vsAttrValue != ""){
                        if(vsAttr == "width") vsColumn = vsColumn + " " + voColumn.colId + "Width=" + vsAttrValue;
                        else if(vsAttr == "height") vsColumn = vsColumn + " " + voColumn.colId + "Height=" + vsAttrValue;
                        else if(vsAttr == "icon") vsColumn = vsColumn + " " + voColumn.colId + "Icon=" + vsAttrValue;
                        else if(vsAttr == "iconChecked") vsColumn = vsColumn + " " + voColumn.colId + "IconChecked=" + vsAttrValue;
                        else if(vsAttr == "tooltip") vsColumn = vsColumn + " " + voColumn.colId + "ToolTip=" + vsAttrValue;
                        else if(vsAttr == "tooltipChecked") vsColumn = vsColumn + " " + voColumn.colId + "ToolTipChecked=" + vsAttrValue;
                      }
                    }
            }
            else if (voColumn.type == "Date") {
            if (!voColumn.calendarEnable)
              vsColumn = vsColumn + " " + voColumn.colId +"Button='None'";
            }

            // Mask
            if(voColumn.format != null || voColumn.mask != null) {
              if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);
              vsColumn = vsColumn + voColumn.formatMask.createFormatAndMask(voColumn);
            }

            // rightbutton
            if(voColumn.rightButton != null) {
              if(voColumn.rightButton.instanceId){
                voInstance = this.canvas.page.getInstance(voColumn.rightButton.instanceId);
                  var vsRButtonRef = voColumn.rightButton.ref;
                  if(vsRButtonRef != null){
                      var voNode = voInstance.getValueNode(vsRButtonRef);
                      if(voNode)
                        voRButtonValue = voNode.getValue();
                  }
                  else
                    voRButtonValue = voColumn.rightButton.value;

                  if(voRButtonValue != null) {
                      vsColumn = vsColumn + " " + voColumn.colId + "Button='" + voRButtonValue + "'";
                  } else {
                      voRButtonValue = voColumn.rightButton.value;
                      if(voRButtonValue)
                        vsColumn = vsColumn + " " + voColumn.colId + "Button='" + voRButtonValue + "'";
                  }
              }
              var voRButton = voColumn.rightButton;
              if(voRButton.type == "Defaults") {
                if(vsRButton != "Enum" && vsRButton != "Select" && vsRButton != "Radio" && vsRButton != "List") {
                  voValue = voColumn.itemgroup.getItemValuesToString('|');
                  vsColumn = vsColumn + " " + voColumn.colId + "Defaults='" + voValue + "'";
                }
              }
              if(voRButton.type == "Normal") {
                vsColumn = vsColumn + " " + voColumn.colId + "Button=\"Button\"";
                if(voRButton.width == null) voRButton.width = 10;
                vsColumn = vsColumn + " " + voColumn.colId + "WidthPad=\"" + voRButton.width + "\"";
              }
              if(voRButton.type == "Image") {
                vsColumn = vsColumn + " " + voColumn.colId + "Button=\"Img\"";
                if(voRButton.width == null) voRButton.width = 10;
                vsColumn = vsColumn + " " + voColumn.colId + "WidthPad=\"" + voRButton.width + "\"";
              }
            }

            // align
            if (voColumn.textAlign == "left")
              vsColumn = vsColumn + " " + voColumn.colId + "Align='0'";
            else if (voColumn.textAlign == "center")
              vsColumn = vsColumn + " " + voColumn.colId + "Align='1'";
            else if (voColumn.textAlign == "right")
              vsColumn = vsColumn + " " + voColumn.colId + "Align='2'";

            if (voColumn.colspan != null)
              vsColumn = vsColumn + " " +voColumn.colId + "Span='" + voColumn.colspan + "'";

            if (voColumn.canEdit != null)
              vsColumn = vsColumn + " " +voColumn.colId + "CanEdit='" + voColumn.canEdit + "'";

            if(voColumn.mask != null && (voColumn.maxLength == null && voColumn.type == "Text")) voColumn.maxLength = voColumn.mask.length;

            if (voColumn.maxLength != null)
              vsColumn = vsColumn + " " +voColumn.colId + "Size='" + voColumn.maxLength + "'";

            if (voColumn.canFocus != null){
              var vbFocus = eval(voColumn.canFocus);
              if(vbFocus == true)
                vsColumn = vsColumn + " " +voColumn.colId + "CanFocus='1'";
              else
                vsColumn = vsColumn + " " +voColumn.colId + "CanFocus='0'";
              //else
                //vsColumn = vsColumn + " " +voColumn.colId + "CanFocus=" + this.getXml(voColumn.canFocus, 1);
            }

//            if (voColumn.canDrag != null) vsColumn = vsColumn + " " + voColumn.colId + "CanDrag=" + this.getXml(voColumn.canDrag, 1);
//            vsColumn = vsColumn + " " + voColumn.colId + "CanDrag='1' ";
            if(voColumn.formula != null){
              voColumn.formula = voColumn.formula.split("\"").join("'");
              vsColumn = vsColumn + " " + voColumn.colId + "Formula=\"" + voColumn.formula + "\"";
            }
//            if(voColumn.backgroundColor != null) vsColumn = vsColumn + " " + voColumn.colId + "Background='" + this.getRGBValue(voColumn.backgroundColor) + "' ";
            /*
            if(voColumn.color != null) {
              vsColumn = vsColumn + " " + voColumn.colId + "ClassInner=\"" + this.id + voColumn.colId + this.styles.prefix + "Text\" ";
            }
            */
            if(voColumn.className != null) {
              var vsColId = voColumn.colId;
              if(vsColId == this.cfg.idColumn) { // id 칼럼에 대한 처리
//                if(!!voColumn.value){
//                  vsColId = voColumn.value;
//                }else{
//                  vsColId = "H" + (cnt+1-vnHeaderCnt);
//                }
                vsColId = "";
                vsColumn = vsColumn + " " + vsColId + "SkipReadOnly='1'";
                var vsCssStyle = "CssStyle='";
                var vsColor = voColumn.color;
                if(vsColor == null) vsColor = this.getStyleCurrentValue(voColumn, "color", "color");
                if(vsColor) vsCssStyle += "color:" + vsColor + ";";
                var vsFontFamily = this.getStyleCurrentValue(voColumn, "font-family", "fontFamily");
                if(vsFontFamily) vsCssStyle += "font-family:" + vsFontFamily + ";";
                var vsFontSize = this.getStyleCurrentValue(voColumn, "font-size", "fontSize");
                if(vsFontSize) vsCssStyle += "font-size:" + vsFontSize + ";";
                var vsFontStyle = this.getStyleCurrentValue(voColumn, "font-style", "fontStyle");
                if(vsFontStyle) vsCssStyle += "font-style:" + vsFontStyle + ";";
                var vsFontWeight = this.getStyleCurrentValue(voColumn, "font-weight", "fontWeight");
                if(vsFontWeight) vsCssStyle += "font-weight:" + vsFontWeight + ";";
                if(vsCssStyle != "CssStyle='") {
                  vsCssStyle += "'";
                  vsColumn = vsColumn + " " + vsColId + vsCssStyle;
                }
              }
              vsColumn = vsColumn + " " + vsColId + "ClassInner='" + voColumn.className + "' ";
              if(voColumn.outerClassName == null) vsColumn = vsColumn + " " + vsColId + "Class='" + voColumn.className + "' ";
              var vsBackgroundColor = voColumn.backgroundColor;
              if(vsBackgroundColor == null) vsBackgroundColor = this.getStyleCurrentValue(voColumn, "background-color", "backgroundColor");
              if(vsBackgroundColor) vsColumn = vsColumn + " " + vsColId + "Background='" + this.getRGBValue(vsBackgroundColor) + "' ";

            }
            if(voColumn.outerClassName != null) vsColumn = vsColumn + " " + vsColId + "Class='" + voColumn.outerClassName + "' ";

            vsRow = vsRow + vsColumn;
          }   // for ( var k = 0; voRow.columns.length > k; k++)
        }     // end if (voCols[i])
      }       // end for ( var i = 0; i < 3; i++)
      if(vsRow != "")
        vsRow = vsRow + "/>";
      vsFunctionColumns = vsFunctionColumns + vsRow;
    }         // end for(var cnt = 0; cnt < vnHeaderCnt + vnFunctionHeaderCnt; cnt++)
    vsFunctionColumns = vsFunctionColumns + "</Head>";
  }           // end if(vnFunctionHeaderCnt > 0) {
  return vsFunctionColumns;
};
/**
 * loadFooterDataFromInstance
 * @param {HTMLDocument} poDocument 윈도우 document 객체
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.loadFooterDataFromInstance = function(poDocument) {
  if(this.footer == null){
    this.template["Footer"] = "";
    return;
  }
  var vsTemplate = "";
  vsTemplate = vsTemplate + "<Foot>";
  var vsRow = "";
  var vsColumn = "";

  if(this.footer.rows){
    var vaRows = this.footer.rows;
    for(var i=0; i<vaRows.length; i++){ // rows
      if(vaRows[i] instanceof eXria.controls.xhtml.GridEx.FootRow){ // FootRow 추가
        vsRow = this.makeFootRowDataFromInstance(vaRows[i], i);
      }
      vsTemplate = vsTemplate + vsRow;
      if(vaRows.length >= i) vsTemplate = vsTemplate;
    }
  }
  vsTemplate = vsTemplate + "</Foot>";
  this.template["Footer"] = vsTemplate;
};
/**
 * makeFootRowDataFromInstance
 * @param {eXria.controls.xhtml.GridEx.FootRow} footer row
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.makeFootRowDataFromInstance = function(poRow, pnRowIndex){
  if(poRow == null) return "";
  var vsRow = "<I Calculated='1'";
  var voCfg = this.cfg;
  if(voCfg.editing != null) vsRow = vsRow + " CanEdit='" + voCfg.editing + "'";
  var vsColumn = "";
  var voValue = null;
  var vaCols = poRow.cols;

  var voFirstCol = null;
  if(vaCols["left"]) voFirstCol = vaCols["left"].columns[0];
  else if(vaCols["center"]) voFirstCol = vaCols["center"].columns[0];
  vsRow = vsRow + this.makeFooterRowColorData(voFirstCol.id);

  for(var vsCols in vaCols){ // cols
    var voCols = vaCols[vsCols];
    if(voCols.columns == null) continue;
    for(var j=0; j<voCols.columns.length; j++){ // columns
      var voColumn = voCols.columns[j];
      if(voColumn.colId == this.cfg.idColumn) { // id 칼럼에 대한 처리
        if(!!voColumn.value){
          vsColumn = " id='" + voColumn.value + "'";
        }else{
          vsColumn = " id='" + "F" + (pnRowIndex+1) + "'";
        }
      } else {
        var vsRef = voColumn.ref;
        var vsValue = null;

        if(vsRef != null && voColumn.type != "Radio" && voColumn.type != "CheckBox"){
          voColumn.data = new eXria.controls.DataRefNode(this);
          voColumn.data.setRef(voColumn.instanceId, vsRef)
          vsValue = voColumn.data.getData();
        }else if(voColumn.type == "Radio" || voColumn.type == "CheckBox"){
          voColumn.data = new eXria.controls.DataRefNodeset(this);
          voColumn.data.setRef(voColumn.instanceId, vsRef);
          vsValue = voColumn.data.getData();
        }

        var voInstance = null;
        if(voColumn.instanceId) voInstance = this.canvas.page.getInstance(voColumn.instanceId);

        var getXmlVal = this.getXml;
        function getRefValue(psRef){
          var retValue = "";
          if(psRef) {
            retValue = voInstance.getValueNode(psRef).getValue();
            if(!retValue) retValue = "";
          }
          return retValue;
        }

        var voItemGData = voColumn.itemgroup.data;
        voItemGData.control = this;
        if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
          voColumn.itemgroup.addToItemset();
        }
        if(voColumn.value){
          vsColumn = " " + voColumn.colId + "=" + this.getXml(voColumn.value, 2);
        } else if(vsValue != null) {
          switch(voColumn.type) {
            case "Enum" :
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "=" + vsValue;
              break;
            case "Number" :
            case "Bool" :
            case "Int" :
            case "Float" :
              vsValue = eval(vsValue);
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "=" + vsValue;
              break;
            case "CheckBox" :
            case "Radio" :
              vsValue = this.convertValueTGrid(voColumn, vsValue);
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "=" + vsValue;
              break;
            case "Select" :
              if(voColumn.selectionDataType == "Numeric") vsValue = eval(vsValue);
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "=" + vsValue;
              break;
            case "Text" :
            case "Date" :
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "=" + vsValue;
              break;
            case "Button" :
              vsValue = this.getXml(vsValue,2);
              vsColumn = " " + voColumn.colId + "Caption=" + vsValue;

              for(var vsAttr in voColumn.buttonItem){
                var vsRef = voColumn.buttonItem[vsAttr];
                var vsAttrValue = getRefValue(vsRef);
                if(vsAttrValue) vsAttrValue = this.getXml(vsAttrValue, 2);

                if(vsAttrValue != ""){
                  if(vsAttr == "width") vsColumn = vsColumn + " " + voColumn.colId + "Width=" + vsAttrValue;
                  else if(vsAttr == "height") vsColumn = vsColumn + " " + voColumn.colId + "Height=" + vsAttrValue;
                  else if(vsAttr == "icon") vsColumn = vsColumn + " " + voColumn.colId + "Icon=" + vsAttrValue;
                  else if(vsAttr == "iconChecked") vsColumn = vsColumn + " " + voColumn.colId + "IconChecked=" + vsAttrValue;
                  else if(vsAttr == "tooltip") vsColumn = vsColumn + " " + voColumn.colId + "ToolTip=" + vsAttrValue;
                  else if(vsAttr == "tooltipChecked") vsColumn = vsColumn + " " + voColumn.colId + "ToolTipChecked=" + vsAttrValue;
                }
              }
              break;
            case "Image" :
              var vaImageItem = new Array(5);

              for(var vsAttr in voColumn.imageItem){
                var vsRef = voColumn.imageItem[vsAttr];
                var vsAttrValue = getRefValue(vsRef);
                var vnIndex = null;
                if(vsAttr == "href") vnIndex = 0;
                else if(vsAttr == "width") vnIndex = 1;
                else if(vsAttr == "height") vnIndex = 2;
                else if(vsAttr == "left") vnIndex = 3;
                else if(vsAttr == "top") vnIndex = 4;
                else if(vsAttr == "target") vnIndex = 5;

                if(vnIndex != null) vaImageItem[vnIndex] = vsAttrValue;
              }
              var vsImage = "|" + vaImageItem.join("|");
              if(vsValue != null) {
                vsColumn = vsColumn + " " + voColumn.colId + "=" + "\"" + vsImage + "\"";
              }
              break;
          }
          vbEmptyRow = false;
          vsValue = null;
        } else {
          vsColumn = " " + voColumn.colId + "=\"\"";
          if(voColumn.type == "Enum") vsColumn = vsColumn + " " + voColumn.colId + "IconAlign='Right'";
        }

        if(voColumn.rightButton) {
          vsRButtonRef = voColumn.rightButton.ref;
          if(vsRButtonRef != null) {
            if(voInstance == null) voInstance = this.canvas.page.getInstance(voColumn.rightButton.instanceId);
            voRButtonValue = getRefValue(vsRButtonRef);
            if(voRButtonValue != null) {
              vsColumn = vsColumn + " " + voColumn.colId + "Button='" + voRButtonValue + "'";
            }
          } else {
            voRButtonValue = voColumn.rightButton.value;
            if(voRButtonValue) vsColumn = vsColumn + " " + voColumn.colId + "Button='" + voRButtonValue + "'";
          }
        }
      }
      if(voColumn.format != null || voColumn.mask != null) {
        if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);
        var vsFormat = voColumn.format;
        if(vsFormat && vsFormat.indexOf("TG:") == 0) {
          voColumn.regFormat = vsFormat.replace(/^TG:/, "");
        }
        var vsMask = voColumn.mask;
        if(vsMask && vsMask.indexOf("TG:") == 0) {
          voColumn.regMask = vsMask.replace(/^TG:/, "");
        }
        vsColumn = vsColumn + voColumn.formatMask.createFormatAndMask(voColumn);
      }
      vsColumn = vsColumn + this.makeFootColumnAttr(voColumn); // 속성구성
      vsRow = vsRow + vsColumn;
      if(voColumn.colspan != null) {
        if(vsRow.indexOf("Spanned='1' ") == -1) vsRow += "Spanned='1' ";
      }
    }
  }
  vsRow = vsRow + " />";

  return vsRow;
};
/**
 * column의 속성정보들을 구성하여 반환
 * @param {eXria.controls.xhtml.GridEx.FootColumn} poColumn footer column
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.makeFootColumnAttr = function(poColumn){
  var voColumn = poColumn;
  var vsColAttr = "";
  if(voColumn.type != null) {
    if(voColumn.type == "Image") vsColAttr = vsColAttr + " " + voColumn.colId + "Type='Img'";
    else if(voColumn.type == "Radio" || voColumn.type == "CheckBox") vsColAttr = vsColAttr + " " + voColumn.colId + "Type='Radio'";
    else vsColAttr = vsColAttr + " " + voColumn.colId + "Type='" + voColumn.type + "'";
    if(voColumn.type == "Enum") {
      var voItemGData = voColumn.itemgroup.data;
      voItemGData.control = this;
      if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
        voColumn.itemgroup.addToItemset();
      }
      var vsValues = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
      var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
      vsColAttr = vsColAttr + " " + voColumn.colId + "Enum='" + vsLabels + "'" + " " + voColumn.colId + "EnumKeys='" + vsValues + "'";

      if(voColumn.enumType != null)
        vsColAttr = vsColAttr + " " + voColumn.colId + "EnumType='" + voColumn.enumType + "'";
    }
    if(voColumn.type == "Select") {
      var voItemGData = voColumn.itemgroup.data;
      voItemGData.control = this;
      if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
        voColumn.itemgroup.addToItemset();
      }
      voValue = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
      var vsDefaults = " " + voColumn.colId + "Defaults='" + voValue + "'";
      vsColAttr = vsColAttr + vsDefaults;
    }
    // HighGarden Add Start
    if(voColumn.type == "Radio" || voColumn.type == "CheckBox") {
      if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);

      var voItemGData = voColumn.itemgroup.data;
      voItemGData.control = this;
      if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
        voColumn.itemgroup.addToItemset();
      }
      var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);
      var vsFormat = voColumn.formatMask.createFormatAndMask(voColumn);
      vsLabels = vsFormat + vsLabels;
      vsColAttr = vsColAttr + " " + voColumn.colId + "Format='" + vsLabels + "'";
    }
    if(voColumn.type == "Date") {
      if(!voColumn.calendarEnable) vsColAttr = vsColAttr + " " + voColumn.colId + "Button='None'";
    }
    // HighGarden Add End
  }
  //Highgarden Start 090407
  if(voColumn.format != null || voColumn.mask != null) {
    if(voColumn.formatMask == null) voColumn.formatMask = new eXria.controls.xhtml.GridEx.FormatMask(voColumn, this);
    vsColAttr = vsColAttr + voColumn.formatMask.createFormatAndMask(voColumn);
  }
  //Highgarden End 090407
  if(voColumn.enums != null)vsColAttr = vsColAttr + " " + voColumn.colId + "Enum='" + voColumn.enums + "'";
  if(voColumn.canEdit != null) vsColAttr = vsColAttr + " " + voColumn.colId + "CanEdit='" + voColumn.canEdit + "'";
  if(voColumn.canSort != null)vsColAttr = vsColAttr + " " + voColumn.colId + "CanSort='" + voColumn.canSort + "'";
  if(voColumn.mask != null && (voColumn.maxLength == null && voColumn.type == "Text")) voColumn.maxLength = voColumn.mask.length;
  if(voColumn.maxLength != null)vsColAttr = vsColAttr + " " + voColumn.colId + "Size='" + voColumn.maxLength + "'";
  if(voColumn.formula != null){
    voColumn.formula = voColumn.formula.split("\"").join("'");
    vsColAttr = vsColAttr + " " + voColumn.colId + "Formula=\"" + voColumn.formula + "\"";
  }
  if(voColumn.rightButton != null) {
    voRButton = voColumn.rightButton;

    if(voRButton.type == "Defaults") {
      if(vsRButton != "Enum" && vsRButton != "Select" && vsRButton != "Radio" && vsRButton != "List") {
        var voItemGData = voColumn.itemgroup.data;
        voItemGData.control = this;
        if(voItemGData.nodesetInstanceId && voItemGData.nodesetInstancePath) {
          voColumn.itemgroup.addToItemset();
        }
        voValue = voColumn.itemgroup.getItemValuesToString('|');
        vsColAttr = vsColAttr + " " + voColumn.colId + "Defaults='" + voValue + "'";
      }
    }
    if(voRButton.type == "Normal") {
      vsColAttr = vsColAttr + " " + voColumn.colId + "Button=\"Button\"";
      if(voRButton.width == null) voRButton.width = 10;
      vsColAttr = vsColAttr + " " + voColumn.colId + "WidthPad=\"" + voRButton.width + "\"";
    }
    if(voRButton.type == "Image") {
      vsColAttr = vsColAttr + " " + voColumn.colId + "Button=\"Img\"";
      if(voRButton.width == null) voRButton.width = 10;
      vsColAttr = vsColAttr + " " + voColumn.colId + "WidthPad=\"" + voRButton.width + "\"";
    }
  }
  if(voColumn.backgroundColor != null) vsColAttr = vsColAttr + voColumn.colId + "Color='" + this.getRGBValue(voColumn.backgroundColor) + "' ";
  /*
  if(voColumn.color != null) {
//      vsDefR = vsDefR + " " + voColumn.colId + "ClassOuter=\"" + this.id + voColumn.colId + this.styles.prefix + "Cell\" " + voColumn.colId + "ClassInner=\"" + this.id + voColumn.colId + this.styles.prefix + "Text\" ";
    vsColAttr = vsColAttr + " " + voColumn.colId + "ClassInner=\"" + this.id + voColumn.colId + this.styles.prefix + "Text\" ";
  }
  */
  // 조영진 추가코드
  if(voColumn.className != null) {
    vsColAttr = vsColAttr + " " + voColumn.colId + "ClassInner='" + voColumn.className + "' ";
    if(voColumn.outerClassName == null) vsColAttr = vsColAttr + " " + voColumn.colId + "Class='" + voColumn.className + "' ";
  }
  if(voColumn.outerClassName != null) vsColAttr = vsColAttr + " " + voColumn.colId + "Class='" + voColumn.outerClassName + "' ";
  if (voColumn.textAlign == "left")
    vsColAttr = vsColAttr + " " + voColumn.colId + "Align='0'";
  else if (voColumn.textAlign == "center")
    vsColAttr = vsColAttr + " " + voColumn.colId + "Align='1'";
  else if (voColumn.textAlign == "right")
    vsColAttr = vsColAttr + " " + voColumn.colId + "Align='2'";
  if(voColumn.colspan != null) vsColAttr = vsColAttr + " " + voColumn.colId + "Span='" + voColumn.colspan + "' ";
  return vsColAttr;
};
/**
 * load data from instance
 * @param {HTMLDocument} poDocument 윈도우 document
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.loadDataFromInstance = function(poDocument) {
  if(this.hideInitRow === true && this.init === true){
    var vsInsId = this.data.nodesetInstanceId;
    var vsInsRef = this.data.nodesetInstancePath;
    if(vsInsId) {
      var voInstance = this.canvas.page.getInstance(vsInsId);
      if(voInstance) {
        var voInst =  voInstance.selectNodes(vsInsRef);
        var vnLoop = 0;
        if(voInst == null) {
          vnLoop = 0;
        } else {
          vnLoop = voInst.getLength();
        }
        for(var i=0; i<vnLoop; i++) {
          voInstance.removeNode(voInst.item(0));
        }
      }
    }

    this.init = false;
  }

  var voCollectionNode = null;
  var vnLoop = null;
  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    voCollectionNode = this.data.getNodesetStr();
    if(voCollectionNode) {
      voCollectionNode = eval(voCollectionNode);
      vnLoop = voCollectionNode.length;
    } else {
      vnLoop = 0;
    }
  } else {
    voCollectionNode = this.data.getNodesetData();
    if(!voCollectionNode) vnLoop = 0;
    else vnLoop = voCollectionNode.size();
  }
  this.lastId = vnLoop;
  // yhkim 2009.05.18 Paging Data
  if (this.cfg.paging == "fast") {
    // yhkim 2009.08.29 page + 1 를 해줘야 전체가 보임
    var vnPageCnt = parseInt(vnLoop / this.cfg.pageLength);
    if(vnLoop > 0 && vnPageCnt == 0) vnPageCnt = 1;
    var vsTemp = "<Body>";
    for ( var i = 0; i < vnPageCnt; i++)
      vsTemp = vsTemp + "<B/>";
    vsTemp = vsTemp + "</Body>";
    this.template["Body"] = vsTemp;
    return;
  } else {
    vsBody = "<Body><B>";
    vsBody = vsBody + this.makeRowData(voCollectionNode, 0, vnLoop);
    vsBody = vsBody + "</B></Body>";
    this.template["Body"] = vsBody;
  }
};
/**
 * load data from dataset
 * @param {HTMLDocument} poDocument 윈도우 document
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.loadDataFromDataSet = function(poDocument, pbKeepStatus) {
  var vnLoop = 0, voDataSet = null;
  if (this.dataset){
    voDataSet = this.dataset;
  }else {
    voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
  }
  if (voDataSet && !pbKeepStatus) {
    voDataSet.rebuild(false);
  }

  if(this.hideInitRow === true && this.init === true){
    var vbSync = voDataSet.isDataSync();
    if(!vbSync) voDataSet.setDataSync(true);
    voDataSet.reset(true);
    voDataSet.setDataSync(vbSync);

    this.init = false;
  }

  if(voDataSet) vnLoop = voDataSet.getRowCnt();
  this.lastId = vnLoop;

  // Grouping과 Sourting 처리
  var vaSortItem, vsColRef = null;
  var i, j, k = 0;
  var vaSortCols, vaSortTypes = null;
  if(this.cfg.grouping && this.cfg.groupCols) {
  this.cfg.groupCols = this.cfg.groupCols.replace(/\s+/g, ""); // eXria.util.StringUtil.trim 얘는 한글자만 적용됨
  var vaGroupCols = this.cfg.groupCols.split(",");
    for(i=0;i<vaGroupCols.length;i++) {
      vaColRefAndTextFlag = this.getColRefAndTextFlag(vaGroupCols[i]);
      vaSortItem = new Array();
      vaSortItem[0] = vaColRefAndTextFlag[0];
      vaSortItem[1] = vaColRefAndTextFlag[1];
      vaSortItem[2] = true;  // GroupMain 칼럼은 디폴트로 올림차순으로 동작
      this.sortList[i] = vaSortItem;
    }
  }
    if(this.cfg.sorting) {
      if(this.sortUser) {
        vaSortCols = this.sortColsUser;
        vaSortTypes = this.sortTyepsUser;
      } else if (this.cfg.sortCols && this.cfg.sortTypes) {
        vaSortCols = this.cfg.sortCols.split(",");
        vaSortTypes = this.cfg.sortTypes.split(",");
      }
      if(vaSortCols) {
        for(j=0;j<vaSortCols.length;j++) {
          if(vaSortCols[j] == this.cfg.groupMain) {   // GroupMain 칼럼에 대한 Sorting 지정
            vaColRefAndTextFlag = this.getColRefAndTextFlag(vaSortCols[j]);
            if(vaColRefAndTextFlag) { // 해당 칼럼에 데이타가 하나도 없을 경우의 오류발생 제거
              if((vaSortTypes[j]&1) == 0) {
                vaSortItem = new Array();
                vaSortItem[0] = vaColRefAndTextFlag[0];
                vaSortItem[1] = vaColRefAndTextFlag[1];
                vaSortItem[2] = true;
                this.sortList[0] = vaSortItem;
              } else {
                vaSortItem = new Array();
                vaSortItem[0] = vaColRefAndTextFlag[0];
                vaSortItem[1] = vaColRefAndTextFlag[1];
                vaSortItem[2] = false;
                this.sortList[0] = vaSortItem;
              }
            }
          } else {         // GroupMain 이외의 칼럼에 대한 Sorting 지정
            vaColRefAndTextFlag = this.getColRefAndTextFlag(vaSortCols[j]);
            if(vaColRefAndTextFlag) { // 해당 칼럼에 데이타가 하나도 없을 경우의 오류발생 제거
              if((vaSortTypes[j]&1) == 0) {
                vaSortItem = new Array();
                vaSortItem[0] = vaColRefAndTextFlag[0];
                vaSortItem[1] = vaColRefAndTextFlag[1];
                vaSortItem[2] = true;
                this.sortList[j] = vaSortItem;
              } else {
                vaSortItem = new Array();
                vaSortItem[0] = vaColRefAndTextFlag[0];
                vaSortItem[1] = vaColRefAndTextFlag[1];
                vaSortItem[2] = false;
                this.sortList[j] = vaSortItem;
              }
            }
          }
        }
      }
    }
    voDataSet.clearSortItem();
    for(k=0; k<this.sortList.length; k++) {
      voDataSet.setSortItem(this.sortList[k][0], this.sortList[k][1], this.sortList[k][2]);
    }
    try {
      voDataSet.sort();
    } catch(err) {}
//    this.sortUser = false;
//    this.sortColsUser = null;
//    this.sortTyepsUser = null;


  // yhkim 2009.05.18 Paging Data
  if (this.cfg.paging == "fast") {
    // yhkim 2009.08.29 page + 1 를 해줘야 전체가 보임
    var vnPageCnt = parseInt(vnLoop / this.cfg.pageLength, 10) + 1;
    var vsTemp = "<Body>";
    for ( var i = 0; i < vnPageCnt; i++)
      vsTemp = vsTemp + "<B/>";
    vsTemp = vsTemp + "</Body>";
    this.template["Body"] = vsTemp;
    return;
  } else {
    vsBody = "<Body><B>";
    // yhkim 2009.05.18 공통함수 분리 ( 1 > dataset은 1부터 시작)
    vsBody = vsBody + this.makeRowData(voDataSet, 1, vnLoop);
    vsBody = vsBody + "</B></Body>";
    this.template["Body"] = vsBody;
  }
};
/**
 * Row의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow|eXria.controls.xhtml.GridEx.FootRow} poRow row object
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveRowColor = function(poRow, psColor){
  var vsRowType = this.getRowType(poRow);
  switch(vsRowType){
    case this.RowType.HeadRow :
      return this.saveHeadRowColor(poRow, psColor)
      break;
    case this.RowType.BodyRow :
      return this.saveBodyRowColor(poRow, psColor);
      break;
    case this.RowType.FootRow :
      return this.saveFootRowColor(poRow, psColor);
      break;
  }
};
/**
 * HeadRow의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow} poRow row object
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveHeadRowColor = function(poRow, psColor){
  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();
  var vnIdx = this.getIndexOfHeadRow(poRow);
  var sections = this.grid.GetSections();
  var nSec = sections[0];
  var colID = this.grid.GetFirstCol(nSec);
  var voColumn = this.getFunctionColumn(poRow, null, colID);

  var voRowData = null;
  if(this.colorData.getHeaderRowData(voColumn.id)){
    voRowData = this.colorData.getHeaderRowData(voColumn.id);
    voRowData.rowColor = psColor;
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.columnId = voColumn.id;
    voRowData.rowColor = psColor;
    this.colorData.headColorData.push(voRowData);
  }
};
/**
 * FootRow의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.FootRow} poRow row object
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveFootRowColor = function(poRow, psColor){
  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();
  var sections = this.grid.GetSections();
  var nSec = sections[0];
  var colID = this.grid.GetFirstCol(nSec);
  var voColumn = this.getFootColumn(poRow, null, colID);

  var voRowData = null;
  if(this.colorData.getFooterRowData(voColumn.id)){
    voRowData = this.colorData.getFooterRowData(voColumn.id);
    voRowData.rowColor = psColor;
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.columnId = voColumn.id;
    voRowData.rowColor = psColor;
    this.colorData.footColorData.push(voRowData);
  }
};
/**
 * BodyRow의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow} poRow row object
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveBodyRowColor = function(poRow, psColor){
  if(this.dataset == null) return;
  var vsPK = this.dataset.getPrimaryKeys("");
  if(!vsPK || vsPK == "") return;

  if(typeof(poRow) == "Number"){
    if(this.getRowType(poRow) == this.RowType.BodyRow) poRow = this.getRowIndex();
    else return;
  }

  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();

  var vaPK = vsPK.split(",");

  var vaPrimaryKeys = this.colorData.primaryKeys;

  for(var i=0; i<vaPK.length; i++){
    if(vaPK[i] != "") vaPrimaryKeys[i] = vaPK[i].split(":")[0];
  }

  var voRowData = null;

  var vnRowIdx = this.getIndexOfRow(poRow);

  var vmPrimaryKeys = new eXria.data.ArrayMap();

  for(var i=0, il=vaPrimaryKeys.length; i<il; i++){
    var vsKeyValue = this.dataset.get(vnRowIdx+1, vaPrimaryKeys[i]);
    if(vsKeyValue == "") return;
    vmPrimaryKeys.put(vaPrimaryKeys[i], vsKeyValue);
  }

  if(this.getRowColorData(vmPrimaryKeys) != null){
    voRowData = this.getRowColorData(vmPrimaryKeys);
    voRowData.rowColor = psColor;
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.primaryKeyValues = vmPrimaryKeys;
    voRowData.rowColor = psColor;
    this.colorData.bodyColorData.push(voRowData);
  }
};
/**
 * Cell의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow|eXria.controls.xhtml.GridEx.FootRow} poRow row object
 * @param {String} psCol column id
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveCellColor = function(poRow, psCol, psColor){
  var vsRowType = this.getRowType(poRow);
  switch(vsRowType){
    case this.RowType.HeadRow :
      return this.saveHeadCellColor(poRow, psCol, psColor)
      break;
    case this.RowType.BodyRow :
      return this.saveBodyCellColor(poRow, psCol, psColor);
      break;
    case this.RowType.FootRow :
      return this.saveFootCellColor(poRow, psCol, psColor);
      break;
  }
};
/**
 * HeadCell의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow} poRow row object
 * @param {String} psCol column id
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveHeadCellColor = function(poRow, psCol, psColor){
  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();
  var vnIdx = this.getIndexOfHeadRow(poRow);
  var sections = this.grid.GetSections();
  var nSec = sections[0];
  var colID = this.grid.GetFirstCol(nSec);
  var voColumn = this.getFunctionColumn(poRow, null, colID);

  var voRowData = null;
  if(this.colorData.getHeaderRowData(voColumn.id)){
    voRowData = this.colorData.getHeaderRowData(voColumn.id);
    voRowData.columnsColor.put(psCol, psColor);
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.columnId = voColumn.id;
    voRowData.columnsColor.put(psCol, psColor);
    this.colorData.headColorData.push(voRowData);
  }
};
/**
 * BodyCell의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.ColsRow} poRow row object
 * @param {String} psCol column id
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveBodyCellColor = function(poRow, psCol, psColor){
  if(this.dataset == null) return;
  var vsPK = this.dataset.getPrimaryKeys("");
  if(!vsPK || vsPK == "") return;

  if(typeof(poRow) == "Number"){
    if(this.getRowType(poRow) == this.RowType.BodyRow) poRow = this.getRowIndex();
    else return;
  }

  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();

  var vaPK = vsPK.split(",");

  var vaPrimaryKeys = this.colorData.primaryKeys;

  for(var i=0; i<vaPK.length; i++){
    if(vaPK[i] != "") vaPrimaryKeys[i] = vaPK[i].split(":")[0];
  }

  var voRowData = null;

  var vnRowIdx = this.getIndexOfRow(poRow);

  var vmPrimaryKeys = new eXria.data.ArrayMap();

  for(var i=0, il=vaPrimaryKeys.length; i<il; i++){
    var vsKeyValue = this.dataset.get(vnRowIdx+1, vaPrimaryKeys[i]);
    if(vsKeyValue == "") return;
    vmPrimaryKeys.put(vaPrimaryKeys[i], vsKeyValue);
  }

  if(this.getRowColorData(vmPrimaryKeys) != null){
    voRowData = this.getRowColorData(vmPrimaryKeys);
    voRowData.columnsColor.put(psCol, psColor);
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.primaryKeyValues = vmPrimaryKeys;
    voRowData.columnsColor.put(psCol, psColor);
    this.colorData.bodyColorData.push(voRowData);
  }
};
/**
 * FootCell의 색상 변경정보를 저장한다.
 * @param {eXria.controls.xhtml.GridEx.FootRow} poRow row object
 * @param {String} psCol column id
 * @param {String} psColor 색상값
 */
eXria.controls.xhtml.GridEx.prototype.saveFootCellColor = function(poRow, psCol, psColor){
  if(!this.colorData) this.colorData = new eXria.controls.xhtml.GridEx.ColorData();
  var sections = this.grid.GetSections();
  var nSec = sections[0];
  var colID = this.grid.GetFirstCol(nSec);
  var voColumn = this.getFootColumn(poRow, null, colID);

  var voRowData = null;
  if(this.colorData.getFooterRowData(voColumn.id)){
    voRowData = this.colorData.getFooterRowData(voColumn.id);
    voRowData.columnsColor.put(psCol, psColor);
  }else{
    voRowData = new eXria.controls.xhtml.GridEx.ColorData.RowData();
    voRowData.columnId = voColumn.id;
    voRowData.columnsColor.put(psCol, psColor);
    this.colorData.footColorData.push(voRowData);
  }
};
/**
 * Row의 Color정보를 획득한다.
 * @param {eXria.data.ArrayMap} pmPrimaryKeys primary key map
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getRowColorData = function(pmPrimaryKeys){
  if(!this.colorData) return null;
  var vaDataRows = this.colorData.bodyColorData;
  var retData = null;
  var vaKeys = this.colorData.primaryKeys;
  for(var i=0, il=vaDataRows.length; i<il; i++){
    var vbData = true;
    var vaKeyValues = vaDataRows[i].primaryKeyValues;

    for(j=0, jl=vaKeys.length; j<jl;j++){
      if(vaKeyValues.get(vaKeys[j]) != pmPrimaryKeys.get(vaKeys[j])) vbData = false;
    }
    if(vbData) retData = vaDataRows[i];
  }
  return retData;
};
/**
 * Row의 색상정보들을 설정하여 문자열로 반환한다.
 * @param {Number} pnIndex row index
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.makeRowColorData = function(pnIndex){
  var vsColor = "";
  if(!this.colorData) return null;
  var vaColId = this.colorData.primaryKeys;
  var vmPrimaryKeyValues = new eXria.data.ArrayMap();
  var voDataset = this.canvas.page.model.getDataSet(this.datasetId);
  for(var i=0, il=vaColId.length; i<il;i++){
    var vsValue = voDataset.get(pnIndex, vaColId[i]);
    vmPrimaryKeyValues.put(vaColId[i], vsValue);
  }
  var voRowColorData = this.getRowColorData(vmPrimaryKeyValues);
  if(voRowColorData == null) return null;

  if(voRowColorData.rowColor) vsColor = vsColor + " Color='" + this.getRGBValue(voRowColorData.rowColor) + "'";
  var vaColumnColor = voRowColorData.columnsColor.getEntries();
  for(var vsCol in vaColumnColor){
    if(vaColumnColor[vsCol]) vsColor = vsColor + " " + vsCol + "Color='" + this.getRGBValue(vaColumnColor[vsCol]) + "'";
  }
  return vsColor;
};
/**
 * HeadRow의 색상정보들을 설정하여 문자열로 반환한다.
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.makeHeaderRowColorData = function(psColId){
  var vsColor = "";
  if(!this.colorData) return vsColor;
  var voRowColorData = this.colorData.getHeaderRowData(psColId);
  if(voRowColorData == null) return vsColor;

  if(voRowColorData.rowColor) vsColor = vsColor + " Color='" + this.getRGBValue(voRowColorData.rowColor) + "'";
  var vaColumnColor = voRowColorData.columnsColor.getEntries();
  for(var vsCol in vaColumnColor){
    if(vaColumnColor[vsCol]) vsColor = vsColor + " " + vsCol + "Color='" + this.getRGBValue(vaColumnColor[vsCol]) + "'";
  }
  return vsColor;
};
/**
 * FootRow의 색상정보들을 설정하여 문자열로 반환한다.
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.makeFooterRowColorData = function(psColId){
  var vsColor = "";
  if(!this.colorData) return vsColor;
  var voRowColorData = this.colorData.getFooterRowData(psColId);
  if(voRowColorData == null) return vsColor;

  if(voRowColorData.rowColor) vsColor = vsColor + " Color='" + this.getRGBValue(voRowColorData.rowColor) + "'";
  var vaColumnColor = voRowColorData.columnsColor.getEntries();
  for(var vsCol in vaColumnColor){
    if(vaColumnColor[vsCol]) vsColor = vsColor + " " + vsCol + "Color='" + this.getRGBValue(vaColumnColor[vsCol]) + "'";
  }
  return vsColor;
};
/**
 * makeData
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.makeData = function(){
  // data 구성
  var vsDataData = "";
  vsDataData = this.template["Start"];
//  if(pbReloadData){
//    vsDataData = vsDataData + this.template["Cfg"] + this.template["Header"];
//  }
//  vsDataData = vsDataData + this.template["Def"]
//yhkim 2009.05.19 head 컬럼
  vsDataData = vsDataData + this.template["FunctionColumn"];;
  vsDataData = vsDataData + this.template["Body"];
  vsDataData = vsDataData + this.template["Footer"];
  vsDataData = vsDataData + this.template["End"];

  this.templateData = vsDataData;
  vsDataData = null;
};
/**
 * 모든 로딩이 완료된 이후의 최종 처리
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.loadComplete = function(poDocument) {

    this.setStyleCurrentBorderValue(this);
    this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
    if(this.innerWidth < 0) this.innerWidth = 0;
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    if(this.innerHeight < 0) this.innerHeight = 0;

    this.ctrl.style["width"] = this.innerWidth + "px";
    this.ctrl.style["height"] = this.innerHeight + "px";

    var D = new this.window.TDataIO();
    D.Defaults.Url = this.defaultFileName;
    D.Text.Url = this.textFileName;
    D.Cache = this.cacheResource;
    D.Layout.Data = this.templateLayout;
    D.Data.Data = this.templateData;
    D.Page.Url = "getData";
    D.Page.Format = "Internal";
    D.Page.Data = "TGData";
    D.Debug = "";
//  newWin=window.open('','','toolbar=no,scrollbars=no,width=300,height=150,left=300,top=200');
//  newWin.document.open('text/html','replace');
//  newWin.document.write(D.Layout.Data);
//  newWin.document.close();

//    alert(D.Layout.Data);
//    alert(this.templateData);
    this.rendering = true;
    this.grid = this.window.TreeGrid(D, this.id, this.id, null, null);
    this.grid.GridEx = {};
    this.grid.GridEx.control = this;
};
/**
 * 데이타 영역(body)을 새로고침
 * @param {HTMLDocument} poCtrl 실체화 객체 (생략가능)
 * @param {HTMLDocument} poDocument 윈도우 document 객체 (생략가능)
 * @param {Boolean} pbKeepStatus 데이타셋 바인딩시 rebuild 여부
 * @param {Boolean} pbReRender 데이타 영역에 대한 rerendering 여부
 */
eXria.controls.xhtml.GridEx.prototype.refreshData = function(poCtrl, poDocument, pbKeepStatus, pbReRender) {
//  if(this.cfg.idColumn != null) {
//    this.refresh(poDocument, pbKeepStatus, null, true);
//    return;
//  }
  if(!this.isRendered) {
    var base = this;
    this.window.setTimeout(function(){base.refreshData();}, 100);
    return;
  }
  this.isRendered = false;
  this.grid.Focus(null, null);
  this.grid.LastId = "";
  this.templateData = null;
  if(this.datasetId == null) {
    if(page.metadata.useJsonInstance) this.data.setNodesetRef(this.data.nodesetInstanceId, this.data.nodesetInstancePath);
    this.loadDataFromInstance(this.document);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  } else {
    this.dataset = this.canvas.page.model.getDataSet(this.datasetId);
    this.loadDataFromDataSet(this.document, pbKeepStatus);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  }

  this.checkRender(pbReRender);
};
/*
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.resize = function() {
  if(this.isResize === false) {
    this.refreshPos();
    return;
  }
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;

  this.ctrl.style["left"] = this.left + "px";
  this.ctrl.style["top"] = this.top + "px";
  this.ctrl.style["width"] = this.innerWidth + "px";
  this.ctrl.style["height"] = this.innerHeight + "px";
};
/*
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.checkRender = function(pbReRender){
//  if(this.rendering == true){
//    var voGrid = this;
//    this.window.setTimeout(function(){voGrid.checkRender();}, 100);
//  }else{
    this.refreshDataComplete(this.document, pbReRender);
//  }
};
/**
 * 데이타 새로고침에 대한 최종 처리
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.refreshDataComplete = function(poDocument, pbReRender) {
  if(this.grid) {
//    alert(this.templateData);
    this.Initialize();
    this.focusRow = null;
    this.focusCol = null;
    if(this.templateData) this.grid.Data.Data.Data = this.templateData;
    if(pbReRender == null) pbReRender = true;
    this.grid.ReloadBody(null, pbReRender);
  } else {
    alert("GridEx create error. please refresh page.");
  }
};

eXria.controls.xhtml.GridEx.prototype.removeSpecificDefaults = function(poCtrl, poDocument) {
  this.df = {};
};

eXria.controls.xhtml.GridEx.prototype.refreshSpecificAttrs = function(poCtrl, poDocument, pbKeepSort, pbHideCol) {
  this.templateLayout = null;
  this.templateData = null;
  if(pbKeepSort == false) {
    this.sortUser = false;
    this.sortColsUser = null;
    this.sortTyepsUser = null;
    this.sortList.length = 0;
  }
  if(!pbHideCol) {
    this.hideColMap.clear();
  }
  this.createSubCtrl(poCtrl, poDocument);

  var vnCurInnerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth === vnCurInnerWidth) {    // 사용자 width의 값 변경이 없는경우
    if(poCtrl && poCtrl.style && poCtrl.style["width"])
    vnCurInnerWidth = poCtrl.style["width"].replace("px", "");
  }
  if(vnCurInnerWidth !== this.innerWidth) {
    if(this.colResizeDiff) this.setColumnDiffWidth(this.innerWidth, vnCurInnerWidth);  // this.innerWidth는 Old값
    this.innerWidth = vnCurInnerWidth;
  }

  var vnCurInnerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight === vnCurInnerHeight) {  // 사용자  height의 값 변경이 없는경우
    if(poCtrl && poCtrl.style && poCtrl.style["height"])
    vnCurInnerHeight = poCtrl.style["height"].replace("px", "");
  }
  if(vnCurInnerHeight !== this.innerHeight) this.innerHeight = vnCurInnerHeight;

  this.setSpecificAttrs(poCtrl, poDocument);
};

eXria.controls.xhtml.GridEx.prototype.reloadData = function(poCtrl, poDocument, pbKeepStatus) {
  if(this.datasetId == null) {
    this.loadDataFromInstance(poDocument);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  } else {
    this.loadDataFromDataSet(poDocument, pbKeepStatus);
    this.loadFunctionColumnDataFromInstance();
    this.loadFooterDataFromInstance();
    this.makeData();
  }
};
/**
 * 새로고침에 대한 최종 처리
 */
eXria.controls.xhtml.GridEx.prototype.refreshComplete = function(poCtrl, poDocument) {
  if(this.grid) this.grid.Clear(1);
  if(this.grid) this.grid.Dispose(); // 기존 그리드 삭제
  if(this.grid) this.grid.DelIdentity();
  this.grid = null;
  this.focusRow = null;
  this.focusCol = null;

  var D = new this.window.TDataIO();
  D.Defaults.Url = this.defaultFileName;
  D.Text.Url = this.textFileName;
  D.Cache = this.cacheResource;
  D.Layout.Data = this.templateLayout;
  D.Data.Data = this.templateData;
  D.Page.Url = "getData";  // Paging fast시 Page.Url에 임의의 값이 설정되어 있어야 함.
  D.Page.Format = "Internal";
  D.Page.Data = "TGData";
  D.Debug = "";
//  alert("Layout\n" + this.templateLayout);
//  alert("Data\n" + this.templateData);
  this.rendering = true;
  var tag = this.ctrl;
  var id = this.id;
  this.grid = this.window.TreeGrid(D, tag, id, null, null, this);
  this.grid.GridEx = {};
  this.grid.GridEx.control = this;
};

eXria.controls.xhtml.GridEx.prototype.refresh = function(poDocument, pbKeepStatus, pbKeepSort, pbHideCol) {
  if(!this.isRendered) {
    var base = this;
    this.window.setTimeout(function(){base.refresh();}, 100);
    return;
  }
  this.isRendered = false;
  if(poDocument == null) poDocument = this.document;

  if(this.removeUIGeneralDefaults) { this.removeUIGeneralDefaults(this.ctrl, poDocument); };           // 공통 초기값으로 지정된 속성값을 제거
  if(this.removeSpecificDefaults) { this.removeSpecificDefaults(this.ctrl, poDocument); };             // 개별 초기값으로 지정된 속성값을 제거

  if(this.refreshTemplate) { this.refreshTemplate(this.ctrl, poDocument); };
  if(this.refreshMainStyles) { this.refreshMainStyles(this.ctrl, poDocument); };                       // Main Style 새로고침
  if(this.refreshSubStyles) { this.refreshSubStyles(this.ctrl, poDocument); };                         // Composite Child Style 새로고침

  if(this.refreshUIGeneralDefaults) { this.refreshUIGeneralDefaults(this.ctrl, poDocument); };         // 공통 초기값으로 새로고침
  if(this.refreshSpecificDefaults) { this.refreshSpecificDefaults(this.ctrl, poDocument); };           // 개별 초기값으로 새로고침

  if(this.refreshSpecificAttrs) { this.refreshSpecificAttrs(this.ctrl, poDocument, pbKeepSort, pbHideCol); };                 // 개별 속성으로 새로고침

  if(this.refreshSpecificEvents) { this.refreshSpecificEvents(this.ctrl); };                           // 개별 Events로 새로고침

  if(this.reloadData) { this.reloadData(this.ctrl, poDocument, pbKeepStatus); };                       // Data 새로고침
  if(this.refreshComplete) {this.refreshComplete(this.ctrl, poDocument); };                            // 새로고침 최종 처리
};
/**
 * treegrid body reload 메소드
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.reloadBody = function() {
  if(this.grid) {
    var vbResult = this.grid.ReloadBody(null, true);
    return vbResult;
  } else {
    alert("GridEx create error. please refresh page");
  }
};
/**
 * treegrid reload 메소드
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.reload = function() {
  if(this.grid) {
    var vbResult = this.grid.Reload(null,this.id,this);
    return vbResult;
  } else {
    alert("GridEx create error. please refresh page");
  }
};
/**
 * 각 속성에 따른 디폴트 속성값을 반환
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @type String|Number
 */
eXria.controls.xhtml.GridEx.prototype.getSpecificDefaultValue = function(psAttrName) {
  var vaAttrName = psAttrName.split(".");
  var vsDefaultValue = null;
  if (vaAttrName.length == 1) {
    vsDefaultValue = eXria.controls.xhtml.Default.GridEx[psAttrName];
  } else if (vaAttrName.length == 2) {
    vsDefaultValue = eXria.controls.xhtml.Default.GridEx[vaAttrName[0]][vaAttrName[1]] != null ? eXria.controls.xhtml.Default.GridEx[vaAttrName[0]][vaAttrName[1]] : vsDefaultValue;
  }

  if(vsDefaultValue === undefined) {
    return null;
  }

  return vsDefaultValue;
};

/**
 * 클래스 명을 반환합니다.
 * @return "GridEx"
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.toString = function() {
  return "GridEx";
};
/**
 * 16진수형태의 색상 값을 255,255,255 형태의 문자열 값으로 변환하는 메소드
 * @param {String} psValue 16진수형태의 color 값
 * @return 255,255,255 형태의 색상 문자열 값
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getRGBValue = function(psValue) {
  var colorHexCode = parseInt(psValue.substr(1), 16);
  var red = (colorHexCode & 0xff0000) >> 16;
  var green = (colorHexCode & 0xff00) >> 8;
  var blue = (colorHexCode & 0xff);
  return (red + "," + green + "," + blue);
};
/**
 * 문자열 값을 xml 문자열로 변환하는 메소드
 * @param {String} pValue 문자열
 * @param {Number} pnQuotMark 문자열을 감싸는 따움표 종료를 구분짓는 정수 값
 * @return xml 문자열
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getXml = function(pValue, pnQuotMark) {
  var t = typeof(pValue);
  var v = "";
  if(pnQuotMark == 1) {
    if(t=="string") v = "'"+pValue.replace(/\&/g,"&amp;").replace(/\"/g,"&quot;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;").replace(/\n/g,"&#x0A;")+"'";
    else if(t=="number") v = "'"+pValue+"'";
    else if(t=="boolean") v = "'"+(pValue?1:0)+"'";
  } else if(pnQuotMark == 2) {
    if(t=="string") v = "\""+pValue.replace(/\&/g,"&amp;").replace(/\"/g,"&quot;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;").replace(/\n/g,"&#x0A;")+"\"";
    else if(t=="number") v = "\""+pValue+"\"";
    else if(t=="boolean") v = "\""+(pValue?1:0)+"\"";
  } else {
    if(t=="string") v = pValue.replace(/\&/g,"&amp;").replace(/\"/g,"&quot;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;").replace(/\n/g,"&#x0A;");
    else if(t=="number") v = pValue;
    else if(t=="boolean") v = pValue?1:0;
  }
  return v;
};
/**
 * 문자열 값을 xml value 문자열로 변환하는 메소드
 * @param {String|Number|Boolean} pValue 문자열
 * @type String
 * @return xml value 문자열
 */
eXria.controls.xhtml.GridEx.prototype.getXmlValue = function(pValue) {
  var t = typeof(pValue);
  var v = null;
  if(t=="string") v = "\""+pValue.replace(/\&/g,"&amp;").replace(/\</g,"&lt;").replace(/"/g,"&quot;").replace(/\n/g,"&#x0A;")+"\"";
  else if(t=="number") v = "\""+pValue+"\"";
  else if(t=="boolean") v = "\""+(pValue?1:0)+"\"";
  return v;
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.stringToXml = function(psValue){
  if(typeof(psValue)!="string" || psValue.search(/[\&\"\<\>\n]/)<0) return psValue;
  return psValue.replace(/\&/g,"&amp;").replace(/\"/g,"&quot;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;").replace(/\n/g,"&#x0A;");
};

/////////////////////////////////////////////////////////////////
// Value 관련 메소드
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.valueToString = function(poValue, pnType, psFormat) {
  if(this.grid) return this.grid.ValueToString(poValue, pnType, psFormat);
  else alert("valueToString call Error");
};
/**
 * Cell 값을 문자열 형태로 반환하는 메소드
 * @param {Object} poRow row object
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.getString = function(poRow, psCol) {
  if(this.grid){
    var vsString = this.grid.GetString(poRow, psCol);
    vsString = this.convertStringExria(poRow, psCol, vsString);
    return vsString;
  }else{
    alert("getString call Error");
  }
};
/**
 * Cell 값을 반환하는 메소드
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return cell value
 * @type String|Array(String)
 */
eXria.controls.xhtml.GridEx.prototype.getValue = function(poRow, psCol) {
  if(this.grid){
    var vsValue = this.grid.GetValue(poRow, psCol);
    var vsType = this.getType(poRow, psCol);
    switch(vsType){ 
      case "Int": 
      case "Float": 
      case "Date": 
        if(!vsValue) vsValue = (vsValue == "0") ? 0 : ""; 
        if(typeof(vsValue) != "string") vsValue = vsValue - 0;
        break;
      case "Bool": 
        if(vsValue==null || vsValue==="") vsValue = ""; 
        vsValue = (vsValue) ? vsValue-0 : 0;
        break;
      case "Radio": 
      case "Enum": 
        if(typeof(vsValue)=="number") vsValue = "" + vsValue;
        break;
      default:
        vsValue = (vsValue == null) ? "" : vsValue + "";
    }
    vsValue = this.convertValueExria(poRow, psCol, vsValue);
    return vsValue;
  }else{
    alert("getValue call Error");
  }
};
//Highgarden Start 090407
/**
 * TreeGrid의 Value를 eXria에 맞는 Format으로 반환
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @param {String} psValue Value
 * @return eXria에 맞는 Format으로 변환된 TreeGrid의 Value
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.convertValueExria = function(poRow, psCol, psValue) {
  if(poRow == null || psCol == null || psCol == undefined) return psValue;
  var vsType = this.getType(poRow, psCol);
  var vsRowType = this.getRowType(poRow);
  var voColumn = null;

  if(vsRowType == this.RowType.HeadRow) voColumn = this.getFunctionColumn(poRow, null, psCol);
  else if(vsRowType == this.RowType.BodyRow) voColumn = this.getBodyColumn(null, psCol);
  else if(vsRowType == this.RowType.FootRow) voColumn = this.getFootColumn(poRow, null, psCol);
  switch(vsType){
    case "Date" :
      if(psValue !== null && psValue !== ""){
        var voDate = new Date(psValue);
        var vsYear = voDate.getUTCFullYear() + "";
        // DateMask 추가코드
        var vsMonth = (voDate.getUTCMonth() + 1) + "";
        var vsDate = voDate.getUTCDate() + "";
        var vsHour = voDate.getUTCHours() + "";
        var vsMinute = voDate.getUTCMinutes() + "";
        var vsSecond = voDate.getUTCSeconds() + "";
        if(vsMonth.length == 1) vsMonth = "0" + vsMonth;
        if(vsDate.length == 1) vsDate = "0" + vsDate;
        if(vsHour.length == 1) vsHour = "0" + vsHour;
        if(vsMinute.length == 1) vsMinute = "0" + vsMinute;
        if(vsSecond.length == 1) vsSecond = "0" + vsSecond;
        var vsRetValue = psValue;
        var vsRegFormat = null;
        var vsRegMast = null
        var vsNoFormat = null;
        var vsNoMask = null;
        //getValue 시에 format 에서 mask 형식으로 수정 13.8.9 박상찬
        if(voColumn.regMask) {
//          vsRegFormat = voColumn.regFormat;
//          vsNoFormat = vsRegFormat.replace(/[^ymdhs]/gi, "");
          vsRegMast = voColumn.regMask;
          vsNoMask = vsRegMast.replace(/[^ymdhs]/gi, "");
          if(vsNoMask.length == 14) voColumn.dateType = "DateTime";
          else if(vsNoMask.length == 8) voColumn.dateType = "Date";
          else if(vsNoMask.length == 6) voColumn.dateType = "Time";
        }
        if(voColumn.dateType == "DateTime") vsRetValue = vsYear + vsMonth + vsDate + vsHour + vsMinute + vsSecond;
        else if(voColumn.dateType == "Date") vsRetValue = vsYear + vsMonth + vsDate;
        else if(voColumn.dateType == "Time") vsRetValue = vsHour + vsMinute + vsSecond;
        return vsRetValue;
      }else{
        return psValue;
      }
      break;
    case "Enum" :
      // 허용운 추가코드
      /*
      var vaEnumKeys = null;
      vaEnumKeys = Get(poRow, psCol + "EnumKeys").split('|');// this.grid.GetEnumKeys(poRow, psCol);

      if(vaEnumKeys) vaEnumKeys = vaEnumKeys.slice(1);
      if(psValue !== "" && vaEnumKeys) psValue = vaEnumKeys[psValue];*/


      /*
      // 허용운 추가코드
      var vaEnumKeys = null;
      vaEnumKeys = Get(poRow, psCol + "EnumKeys").split('|');// this.grid.GetEnumKeys(poRow, psCol);
      vaEnumKeys = vaEnumKeys.slice(1);
      for(var i=0, il=vaEnumKeys.length; i<il; i++){
        if(vaEnumKeys[i] == psValue){
          vsRetValue = i;
          break;
        }
      }
      */

      return psValue;
      break;
    case "Radio" :
    case "CheckBox" :
      var vaRet = new Array();
      if(psValue == "") return null;
      var vaValues = voColumn.itemgroup.getItemValuesToArray();
      var vaLabels = voColumn.itemgroup.getItemLabelsToArray();

      var getMatchValue = function(pnIdx){
        return vaValues[pnIdx];
      }

      var vaTreeLabels = String(psValue).split(";");
      var vaRet = [];
      for(var i=0; i<vaTreeLabels.length; i++) {
        for(var j=0; j<vaLabels.length; j++)
          if(vaTreeLabels[i] == vaLabels[j])
            vaRet.push(vaValues[j]);
      }
      var vsRet = vaRet.join(",");
      // radio일 경우에 초기값 설정이 없는 경우와 있는 경우에 따라서 value를 가져오는 방식이 상이해서
      // 아래의 조건문 처럼 경우수를 한가지 더 넣음(실제로는 treegrid의 버그임)
      if(psValue !== null && psValue !== "" && vsRet == "") {
        if(getMatchValue(psValue) != undefined) vaRet.push(getMatchValue(psValue));
      }
      return vaRet;
      break;
    case "Bool" :
      if(psValue === 0) return "false";
      else if(psValue === 1) return "true";
    default :
      if(voColumn) {
        if(vsType == "Text" && voColumn.mask) {
          psValue = this.getOrgValueFromMask(String(psValue), voColumn.mask);
        } else if(vsType == "Text" && typeof(psValue) == "number") {
          psValue += "";
        }
      }
      return psValue;
      break;
  }

};
/**
 * TreeGrid의 String을 eXria에 맞는 Format으로 반환
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.convertStringExria = function(poRow, psCol, psString){
  if(poRow == null || psCol == null || psCol == undefined) return psString;
  var vsType = this.getType(poRow, psCol);
  var vsRowType = this.getRowType(poRow);
  var voColumn = null;
  var vsValue = this.getValue(poRow, psCol);

  if(vsRowType == this.RowType.HeadRow) voColumn = this.getFunctionColumn(poRow, null, psCol);
  else if(vsRowType == this.RowType.BodyRow) voColumn = this.getBodyColumn(null, psCol);
  else if(vsRowType == this.RowType.FootRow) voColumn = this.getFootColumn(poRow, null, psCol);
  switch (vsType) {
    case "Enum" :
      if(vsValue == "") return "";
      return psString;
      break;
    case "Radio" :
    case "CheckBox" :
      if(psString == "&nbsp") return "";
      break;
    default :
      return psString;
      break;
  }
};
/**
 * eXria의 Value를 TreeGrid에 맞는 Format으로 반환
 * @param {String} poColumn GridEx BodyColumn
 * @param {String} psValue Value
 * @return String
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.convertValueTGrid = function(poColumn, psValue, poRow, psColId) {
  if(poColumn == null) return psValue;

  switch(poColumn.type){
    case "Date" :
      var vnTime = "";
      if (psValue != "" && psValue != null) {
      // DateMask 추가코드
        var tempDate = new Date(this.addSeparator(psValue, 2, poRow, psColId));
        var ut = new Date(tempDate);
        var voDate = new Date(Date.UTC(ut.getFullYear(), ut.getMonth(), ut.getDate(), ut.getHours(), ut.getMinutes(), ut.getSeconds()));
        vnTime = voDate.getTime();
    }
      return vnTime;
      break;
    case "Bool" :
      if(psValue != null && psValue != "") {
        psValue = eval(psValue);
        return psValue;
      }
      break;
    case "Radio" :
    case "CheckBox" :
      if(psValue == null) return null; // 2009.12.01 yhkim(bug6398) 이 조건문 자체는 맨위로 가야할듯 하나 Date가 ""리턴하는 side-effect 문제로 이조건문에만 넣음 > 향후고려 필요
      var vaValues = poColumn.itemgroup.getItemValuesToArray();
      var getMatchValueIdx = function(psVal){
        for(var i=0; i<vaValues.length; i++){
          if(vaValues[i] == psVal) return i;
        }
        return false;
      }
//      if(typeof(psValue) == "string") psValue = new Array(psValue);
      if(typeof(psValue) == "string") psValue = psValue.split(",");

      vsRet = "";
      var vaAllValues = poColumn.itemgroup.getItemValuesToArray();
      var vaAllLabels = poColumn.itemgroup.getItemLabelsToArray();
      var vaSelectedValues = psValue;
      var vaSelectedLabels = [];
      for(var p=0; p< vaAllValues.length; p++) {
        for(var q=0; q<vaSelectedValues.length; q++)
        if(vaAllValues[p] == vaSelectedValues[q])
          vaSelectedLabels.push(vaAllLabels[p]);
      }
      vsRet = vaSelectedLabels.join(";");
      if(psValue !== null && psValue !== "" && vsRet == "") {
        vaSelectedLabels.push(getMatchValueIdx(psValue[psValue.length-1]));
        vsRet = vaSelectedLabels.join(";");
      }
      return vsRet;

      break;
    case "Enum" :
      // 허용운 추가코드
      var vsRetValue = "";

      var vaEnumKeys = Get(poRow, psColId + "EnumKeys").split('|');
      vaEnumKeys = vaEnumKeys.slice(1);
      for(var i=0, il=vaEnumKeys.length; i<il; i++){
        if(vaEnumKeys[i] == psValue){
          vsRetValue = i;
          break;
        }
      }
      return psValue;
      break;
    default :
      return psValue;
      break;
  }

};
//Highgarden End 090407
//HighGarden Modify 090420 Date 처리
/**
 * setString
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setString = function(poRow, psCol, psValue, pbRefresh) {
  if(this.grid){
    var vsOVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정전 value 획득

    // TreeGrid는 UTC를 기준으로 Date를 처리하기 때문에 입력 값을 UTC 기준 시간으로 변환하여 입력해야 함
    if(this.getType(poRow, psCol) == "Date")
    {
      var vnlen = psValue.length;
      if(psValue.length == 14) {
        var vsYear = psValue.substring(0, 4);
        var vsMonth = psValue.substring(4, 6);
        var vsDay = psValue.substring(6, 8);
        var vsHour = psValue.substring(8, 10);
        var vsMinute = psValue.substring(10, 12);
        var vsSecond = psValue.substring(12, 14);
        psValue = Date.UTC(vsYear,vsMonth-1,vsDay,vsHour,vsMinute,vsSecond);
      } else if(psValue.length == 8) {
        var vsYear = psValue.substring(0, 4);
        var vsMonth = psValue.substring(4, 6);
        var vsDay = psValue.substring(6, 8);
        psValue = Date.UTC(vsYear,vsMonth-1,vsDay);
      } else if(psValue.length == 6) {
        var voNow = new Date();
        var vsYear = voNow.getUTCFullYear();
        var vsMonth = voNow.getUTCMonth();
        var vsDay = voNow.getUTCDate();
        var vsHour = psValue.substring(0, 2);
        var vsMinute = psValue.substring(2, 4);
        var vsSecond = psValue.substring(4, 6);
        var voNow = new Date();
        psValue = Date.UTC(vsYear,vsMonth,vsDay,vsHour,vsMinute,vsSecond);
      }
    }
    this.grid.SetString(poRow, psCol, psValue, pbRefresh);
    var vsNVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정후 value 획득
    if(vsOVal !== vsNVal) this.enGridexAfterValueChanged(this.grid, poRow, psCol); // 두 값을 비교후 바뀌었을 경우 event 발생
  }else{
    alert("setString call Error");
  }
};
//yhkim 2009.05.08
/**
 * RightButton인 경우 (Normal또는Image) 타입에 따라 (image Path 또는 Button Text)와  Width 값을 설정한다
 * @param {Object} poRow row object
 * @param {String} psCol 현재 컬럼명
 * @param {String} psValue Image Path 또는 Button Text
 * @param {String} pnWidth 사이즈 (default:저장된 기본 설정값)
 * @param {Boolean} pbRefresh (default:true)
 */
eXria.controls.xhtml.GridEx.prototype.setRightButton = function(poRow, psCol, psValue, pnWidth, pbRefresh) {
  if(pnWidth != null)
    this.setRowAttribute(poRow, psCol, "WidthPad", String(pnWidth), 0);

  var voColumn = this.getBodyColumn(null, psCol);

  if(voColumn == null) return;
  if(voColumn.rightButton == null) return;

  if(voColumn.rightButton.type.toUpperCase() == "NORMAL") {
    this.setRowAttribute(poRow, psCol, "Button", "Button", pbRefresh);
    this.setRowAttribute(poRow, psCol, "ButtonText", psValue, pbRefresh);
  }
  else {
    if(psValue) {
    var vsBaseUrl = "";
    if(psValue.indexOf("http://") != -1) {
      psValue = psValue;
    }
    else {
      var vsBaseUrl = this.canvas.page.metadata.resourceBaseUrl;
      if(vsBaseUrl == "" || vsBaseUrl == null)
        psValue = psValue;
      else
        psValue = vsBaseUrl + psValue;
      }
    }

    this.setRowAttribute(poRow, psCol, "Button", psValue, pbRefresh);
  }
};
//yhkim 2009.05.08
/**
 * Button Type 컬럼에 Label값을 설정한다
 * @param {Object} poRow row object
 * @param {String} psCol 현재 컬럼명
 * @param {String} psValue 속성값
 * @param {Boolean} pbRefresh (default:true)
 */
eXria.controls.xhtml.GridEx.prototype.setButtonLabel = function(poRow, psCol, psValue, pbRefresh) {
  this.setRowAttribute(poRow, psCol, "Caption", psValue, pbRefresh);
};
/**
 * 내부사용 함수(Row의 특정컬럼에 추가속성을 설정한다)
 * @param {Object} poRow row object
 * @param {String} psCol 현재 컬럼명
 * @param {String} psAttr 컬럼명과 합쳐질 속성명
 * @param {String} psValue 속성값
 * @param {Boolean} pbRefresh 새로고침 여부
 * @private
 * //yhkim 2009.05.06
 */
eXria.controls.xhtml.GridEx.prototype.setRowAttribute = function(poRow, psCol, psAttr, psValue, pbRefresh) {
  var vsAttr = psCol + psAttr;

  poRow[vsAttr] = psValue;

  // default는 항상 Refresh
  if(pbRefresh == null || pbRefresh == true)
    this.refreshRow(poRow);
};
//HighGarden Modify 090420 Date 처리
/**
 * Cell value 설정
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @param {Object} poValue value
 * @param {Boolean} pbRefresh 화면 새로고침 여부
 * @param {Boolean} pbRowTypeChecked
 */
eXria.controls.xhtml.GridEx.prototype.setValue = function(poRow, psCol, poValue, pbRefresh, pbRowTypeChecked) {
  if(this.grid){
    var voColumn;

    if(!!pbRowTypeChecked){
      var vsRowType = this.getRowType(poRow);
      if(vsRowType == this.RowType.BodyRow){
        voColumn = this.getBodyColumn(null, psCol);
      }else if(vsRowType == this.RowType.HeadRow){
        voColumn = this.getFunctionColumn(poRow, null , psCol);
        voColumn.value = poValue;
      }else if(vsRowType == this.RowType.FootRow){
        voColumn = this.getFootColumn(poRow, null , psCol);
      }
    }else{
      voColumn = this.getBodyColumn(null, psCol);
    }

    var vsOVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정전 value 획득
    poValue = this.convertValueTGrid(voColumn, poValue, poRow, psCol);
    if(this.grid.FRow && this.grid.FCol) this.grid.EndEdit(this.grid.FRow,this.grid.FCol,true);
    this.grid.SetValue(poRow, psCol, poValue, pbRefresh);
    var vsNVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정후 value 획득
    if(vsOVal !== vsNVal) this.enGridexAfterValueChanged(this.grid, poRow, psCol); // 두 값을 비교후 바뀌었을 경우 event 발생
  }else{
    alert("setValue call Error");
  }
};

/**
 * Cell value 설정 (DataSet의 status를 변경하지 않고 단지 value만을 변경함)
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @param {Object} poValue value
 * @param {Boolean} pbRefresh 화면 새로고침 여부
 */
eXria.controls.xhtml.GridEx.prototype.simpleSetValue = function(poRow, psCol, poValue, pbRefresh) {
  if(this.grid){
    var voColumn = this.getBodyColumn(null, psCol);
    var vsOVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정전 value 획득
    poValue = this.convertValueTGrid(voColumn, poValue, poRow, psCol);

    this.grid.SetValue(poRow, psCol, poValue, pbRefresh);

    var vsNVal = this.getValue(poRow, psCol); // AfterValueChanged Event 를 위한 수정후 value 획득
    if(vsOVal !== vsNVal) this.enGridexAfterValueChanged(this.grid, poRow, psCol, true); // 두 값을 비교후 바뀌었을 경우 event 발생
  }else{
    alert("setValue call Error");
  }
};

/**
 * Cell type 반환 메소드
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return Cell type
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getType = function(poRow, psCol) {
  if(this.grid) return this.grid.GetType(poRow, psCol);
  else alert("getType call Error");
};
/**
 * getFormat
 * @param {Object} poRow row object
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.getFormat = function(poRow, psCol, bEdit) {
  if(this.grid) return this.grid.GetFormat(poRow, psCol, bEdit);
  else alert("getFormat call Error");
};
/**
 * Cell에 지정된 Enum 반환
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return Cell에 지정된 Enum
 * @type Array
 */
eXria.controls.xhtml.GridEx.prototype.getEnum = function(poRow, psCol) {
  if(this.grid) return Get(poRow, psCol+"Enum");
  else alert("getEnum call Error");
//  if(this.grid) return this.grid.GetEnum(poRow, psCol);
//  else alert("getEnum call Error");
};
/**
 * Enum에서 지정 value를 갖는 아이템의 인덱스 반환.
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @param {String} psValue value
 * @return Enum에서 지정 value를 갖는 아이템의 인덱스
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getEnumIndex = function(poRow, psColId, psValue) {
  if(this.grid){
    var vsRetValue = null;
    var vaEnumKeys = Get(poRow, psColId + "EnumKeys").split('|');
      vaEnumKeys = vaEnumKeys.slice(1);
      for(var i=0, il=vaEnumKeys.length; i<il; i++){
        if(vaEnumKeys[i] == psValue){
          vsRetValue = i;
          break;
        }
      }
      return vsRetValue;
  }else{alert("getEnumIndex call Error");}
};
/**
 * Cell의 편집 가능 여부를 반환하는 메소드.
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return Cell의 편집 가능 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.canEdit = function(poRow, psColId) {
  if(this.grid) return this.grid.CanEdit(poRow, psColId);
  else alert("canEdit call Error");
};
/**
 * Cell의 focusing 가능 여부를 반환하는 메소드.
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return Cell의 focusing 가능 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.canFocus = function(poRow, psColId) {
  if(this.grid) return this.grid.CanFocus(poRow, psColId);
  else alert("canFocus call Error");
};
/////////////////////////////////////////////////////////////////
//Cell 관련 메소드
/**
 * setColor
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setColor = function(poRow, psColId) {
  var voRow = this.getRowIndex(2);
  voRow[psColId+"Marked"]=true;
  this.grid.ShowRow(voRow);
  this.grid.ColorRow(voRow);
};
/**
 * 지정된 Cell에 focus를 주기 위한 메소드
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @param {Number} pnfocusPagePos 포커스될 페이지 위치
 * @param {Boolean} bShow 포커스될 페이지를 보여줄 지 여부
 * @return 포커싱 성공여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.focus = function(poRow, psCol, pnfocusPagePos , bShow) {
  if(this.grid) return this.grid.Focus(poRow, psCol, pnfocusPagePos , bShow);
  else alert("focus call Error");
};
/**
 * 지정된 Cell을 편집상태로 만들어 주기 위한 메소드
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @param {Boolean} pbNoRunEvent onGridexFocus를 발생 안 시킬지 여부
 */
eXria.controls.xhtml.GridEx.prototype.startEdit = function(poRow, psCol, pbNoRunEvent) {
  //yjcho 2009.09.17 Add
  if(this.grid) {
    this.canvas.setFocusByControl(this);
    this.noFocusEvent = pbNoRunEvent;
    this.grid.Focus(poRow, psCol);
    this.noFocusEvent = false;
    this.grid.StartEdit(poRow, psCol);
  }
};
/////////////////////////////////////////////////////////////////
//Row 관련 메소드
/**
 * 전체 행 삭제
 * DataSet과 연결
 */
eXria.controls.xhtml.GridEx.prototype.deleteAll = function() {
  this.grid.Focus(null, null);
  if(this.datasetId != null){
    var voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
    if(voDataSet){
      var vnDataCount = voDataSet.getRowCnt();
      for(; vnDataCount > 0; vnDataCount--){
        voDataSet.deleteRow(vnDataCount);
      }
    }

  } else {
    var voData = this.data.getNodesetData2();
    var vnSize = voData.getLength();
    var voInstRow = null;
    var vsStatus = null;
    for(var i = 0; i < vnSize; i++) {
      voInstRow = voData.item(i);
      vsStatus = voInstRow.getUserAttribute("status");
      if(vsStatus == null) vsStatus = "";
      if(vsStatus.indexOf("I") != -1) voInstRow.getParentNode().removeChild(voInstRow);
      else if(vsStatus.indexOf("R") == -1) voInstRow.setUserAttribute("status", "R" + vsStatus);
    }
  }
  this.refreshData(null, null, true);
};
/**
 * 전체 행 개수 리턴
 * @param {Boolean} pbGrouped 그룹핑된 row를 포함시킬 지 여부
 * @return 전체 행 개수
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getRowCnt = function(pbGrouped) {
  var vnRowCount = 0;
//  var vnHeadCount = 0;
//  var vnFootCount = 0;
//  if(this.grid.Head.childNodes) vnHeadCount = this.grid.Head.childNodes.length;
//  if(this.grid.Foot.childNodes) vnFootCount = this.grid.Foot.childNodes.length;
//  vnRowCount = this.grid.RowCount - vnHeadCount - vnFootCount;

  if(this.grid.Body.childNodes && this.grid.Body.firstChild) vnRowCount = this.grid.Body.firstChild.childNodes.length;

  // 이조건을 안타면 Group등의 비어있는root한개만 있는경우도 row갯수를 반환한다
  if(vnRowCount === 0 && this.cfg.paging != "fast") return 0;
  if(pbGrouped && this.cfg.paging != "fast") return vnRowCount;
  // 페이지가 쓰이는 경우
//  if((this.cfg.paging == "fast" || this.cfg.paging == "auto") && this.grid.PageLength) {
//    for(var r=this.grid.XB.firstChild,vnRowCount=0;r;r=r.nextSibling) {
//      for(var v=r.firstChild;v;v=v.nextSibling,vnRowCount++) {
//      }
//    }
//  }
//  else {
    var vnIndex = 0;
    var vaDataRow = new Array();
    var voXB = this.grid.XB;
    function findLeafNode(poNode){
      var voNode = poNode;
      if(voNode.childNodes.length > 0){
        for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
          findLeafNode(r);
        }
      } else {
        if(voNode && voNode.nodeName && voNode.nodeName == "I") vaDataRow.push(voNode);
      }
    };
    if(voXB != undefined) findLeafNode(voXB);
    vnRowCount = vaDataRow.length;
//  }
  return vnRowCount;
};
/**
 * DataSource의 전체 행 개수 리턴
 * @return DataSource의 전체 행 개수
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getDataRowCnt = function(){
  var vnRowCount = 0;
  var voData = null;
  if(this.datasetId != null){
    try{
      voData = this.canvas.page.model.getDataSet(this.datasetId);
      if(voData) vnRowCount = voData.getRowCnt();
    } catch(e) {
      return voRowCount;
    }
  }else{
    try {
      voData = this.data.getNodesetData2();
      if(voData != null) {
        vnRowCount = voData.getLength();
        var vnSize = vnRowCount;
        var voNode = null;
        var vsStatus = null;
        for(var i = 0; i < vnSize; i++) {
          voNode = voData.item(i);
          vsStatus = voNode.getUserAttribute("status");
          if(vsStatus.indexOf("R") != -1) vnRowCount--;
        }
      }
    } catch(e) {
      return vnRowCount;
    }
  }
  return vnRowCount;
};
/**
 * 선택된 행들의 인덱스 배열을 반환하는 메소드
 * @return 선택된 행들의 인덱스 배열
 * @type Array(Number)
 */
eXria.controls.xhtml.GridEx.prototype.getSelectedIndexes = function() {
  var vaSelIndex = new Array(), vnIndex = 0, vnSelIndex = 0;

  for(var row=this.grid.GetFirstVisible();row;row=this.grid.GetNextVisible(row)) {
    if(row.Selected) {
      vaSelIndex[vnSelIndex++] = vnIndex;
    }
    vnIndex++;
  }

  if(vnSelIndex == 0) vaSelIndex = null;
  return vaSelIndex;
};
/**
 * 그리드의 첫 번째 row 오브젝트를 반환하는 메소드
 * @return 그리드의 첫 번째 row 오브젝트
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getFirst = function() {
  if(this.grid) return this.grid.GetFirst();
  else alert("getFirst call Error");
};
/**
 * 주어진 row의 다음 row 오브젝트를 반환하는 메소드
 * @param {Object} poRow row object
 * @return 주어진 row의 다음 row 오브젝트
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getNext = function(poRow) {
  if(this.grid) return this.grid.GetNext(poRow);
  else alert("getNext call Error");
};

/**
 * 주어진 row의 다음 row 오브젝트를 반환하는 메소드
 * @param {Object} poRow row object
 * @return 주어진 row의 이전 row 오브젝트
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getPrev = function(poRow) {
  if(this.grid) return this.grid.GetPrev(poRow);
  else alert("getPrev call Error");
};

/**
 * getRows
 * @param {Number} pnSection Cols위치를 구분하기 위한 정수(0 ? left, 1 ? variable, 2 - right).
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getRows = function(pnSection) {
  if(this.grid) return this.grid.GetRows(pnSection);
  else alert("getRows call Error");
};
/**
 * getRowIndex
 * @param {Number} pnIndex row index
 * @param {Boolean} pbGrouped 그룹핑된 row를 포함한 상태에서의 인덱스인지 여부
 * @return row object
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getRowIndex = function(pnIndex, pbGrouped) {
  if(pnIndex < 0) return null;
  // 페이지가 쓰이는 경우
//  if((this.cfg.paging == "fast" || this.cfg.paging == "auto") && this.grid.PageLength) {
  var voRow = null;
  if(this.cfg.paging == "fast" && this.grid.PageLength) {
    var voPageNum = 0;
    var voIndexInPage = 0;
    var voPage = null;
    var vnIncRowCnt = 0;

    voPage = this.grid.GetPage(voPageNum++);
    var vnPageRows = 0;
    while(voPage || pnIndex > vnIncRowCnt) {
      vnPageRows = voPage ? (voPage.childNodes.length ? voPage.childNodes.length : this.grid.PageLength) : this.grid.PageLength;
      vnIncRowCnt += vnPageRows;
      if(vnIncRowCnt >= pnIndex + 1) {
        voIndexInPage = pnIndex - (vnIncRowCnt - vnPageRows);
        break;
      }
      voPage = this.grid.GetPage(voPageNum++);
    }
    if(voPage) {
      for(voRow=voPage.firstChild,num=0;voIndexInPage!=num;voRow=voRow.nextSibling,num++){
        if(voRow == null) break;
      }
    }
    return voRow;
  }

  // 페이지가 쓰이는 않는 경우
  var vaDataRow = new Array();
  var voXB = this.grid.XB;
  var findLeafNode = null;
  var vnIdx = -1;
  var vbQuit = false;
  if(pbGrouped) {
    findLeafNode = function(poNode){
      var voNode = poNode;
      if(voNode && voNode.nodeName && voNode.nodeName == "I") {
          vnIdx++;
          if(vnIdx == pnIndex) {
            voRow = voNode;
            vbQuit = true;
            return;
          }
      }
      if(voNode.childNodes.length > 0) {
        for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
          findLeafNode(r);
          if(vbQuit) return;
        }
      }
    };
  } else {
    findLeafNode = function(poNode){
      var voNode = poNode;
      if(voNode.childNodes.length > 0 && voNode["InstIdx"] == null){
        for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
          findLeafNode(r);
          if(vbQuit) return;
        }
      }else{
        if(voNode && voNode.nodeName && voNode.nodeName == "I") vnIdx++;
        if(vnIdx == pnIndex) {
          voRow = voNode;
          vbQuit = true;
          return;
        }
      }
    };
  }
  if(voXB != undefined) findLeafNode(voXB);
  return voRow;
};

/**
 * getBodyRowByIndex
 * @param {Number} pnIndex row index
 * @return row object
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getBodyRowByIndex = function(pnIndex) {
  return this.getRowIndex(pnIndex);
};

/**
 * getHeaderRowByIndex
 * @param {Number} pnIndex header row index
 * @return header row
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getHeaderRowByIndex = function(pnIndex) {
  var vnIndex = 0;
  var vaFixedRows = this.grid.GetFixedRows();
  var voRetRow = null;

  if(vaFixedRows[pnIndex]){
    var vsSection = vaFixedRows[pnIndex].Fixed;

    if(vsSection == "Head") voRetRow = vaFixedRows[pnIndex];
  }

  return voRetRow;
};
/**
 * getFooterRowByIndex
 * @param {Number} pnIndex footer row index
 * @return footer row
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getFooterRowByIndex = function(pnIndex) {
  var vnIndex = 0;
  var vaFixedRows = this.grid.GetFixedRows();
  var vaFooterRows = new Array();
  var voRetRow = null;

  for(var i=0; i<vaFixedRows.length; i++){
    var vsSection = vaFixedRows[i].Fixed;
    if(vsSection == "Foot") vaFooterRows.push(vaFixedRows[i]);
  }

  if(vaFooterRows[pnIndex]) voRetRow = vaFooterRows[pnIndex];
  return voRetRow;
};
/**
 * row 타입을 반환하는 메소드
 * @return row 타입 구분 문자열
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getRowType = function(poRow) {
  var vsAttr = poRow.Fixed;

  if(vsAttr == "Head") return this.RowType.HeadRow;
  else if(vsAttr == "Foot") return this.RowType.FootRow;
  else return this.RowType.BodyRow;

  return vsAttr;
};
/**
 * 주어진 row의 index를 반환하는 메소드
 * @param {Object} poRow row object
 * @param {Boolean} pbGrouped 그룹핑된 row를 포함한 상태에서의 인덱스를 반환할 지 여부
 * @return 주어진 row의 index
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getIndexOfRow = function(poRow, pbGrouped) {
  var vnRowIndex = null;
  if(poRow != null && poRow["ChildIdx"] != null) poRow = poRow.parentNode;
  // 페이지가 쓰이는 경우
  if(this.cfg.paging == "fast" && this.grid) {
    var voPage = this.grid.GetRowPage(poRow);
    if(voPage) {
      var vnPageNum = this.grid.GetPageNum(voPage);
      if(vnPageNum != null) {
        vnRowIndex = 0;
        var voPage = null;
        for(var i = 0; i < vnPageNum; i++) {
          voPage = this.grid.GetPage(i);
          vnRowIndex += voPage ? (voPage.childNodes.length ? voPage.childNodes.length : this.grid.PageLength) : this.grid.PageLength;
        }
        vnRowIndex += this.grid.GetPos(poRow);
        return vnRowIndex;
      }
    }
  }

  // 페이지가 쓰이지 않는 경우
  var vnIndex = 0;
  var vaDataRow = new Array();
  var voXB = this.grid.XB;
  var findLeafNode = null;
  var vbQuit = false;
  if(pbGrouped) {
    findLeafNode = function(poNode) {
      var voNode = poNode;
      if(voNode == poRow) {
        vnRowIndex = vnIndex;
        vbQuit = true;
        return;
      }else{
        if(voNode && voNode.nodeName && voNode.nodeName == "I") vnIndex++;
      }
      if(voNode.childNodes.length > 0){
        for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
          findLeafNode(r);
          if(vbQuit) return;
        }
      }
    };
  } else {
    findLeafNode = function(poNode) {
      var voNode = poNode;
      if(voNode.childNodes.length > 0 && voNode["InstIdx"] == null){
        for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
          findLeafNode(r);
          if(vbQuit) return;
        }
      }else{
        if(voNode == poRow){
          vnRowIndex = vnIndex;
          vbQuit = true;
          return;
        }else{
          //vaDataRow.push(voNode);
          vnIndex++;
        }
      }
    };
  }
  findLeafNode(voXB);
  return vnRowIndex;
};
/**
 * 주어진 row index에 해당하는 instance row index를 반환하는 메소드
 * @param {Number} poRow 그리드 row index
 * @return 주어진 row의 index에 해당하는 instance row index
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getInstanceRowIndex = function(pnIndex) {
  var vnInstIdx = null;
  if(this.datasetId == null) {
    var voRow = this.getRowIndex(pnIndex);
    var vnInstIdx = voRow["InstIdx"];
    if(vnInstIdx == null) vnInstIdx = voRow.getAttribute("InstIdx");
    vnInstIdx = parseInt(vnInstIdx);
    vnInstIdx += 1;
  } else {
    var voDst = this.dataset;
    vnInstIdx = voDst.getInstanceRowIndex(pnIndex + 1);
  }
  return vnInstIdx;
};
/**
 * 주어진 header row의 index를 반환하는 메소드
 * @param {Object} poRow header row object
 * @return header row index
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getIndexOfHeadRow = function(poRow) {
  var vaRows = this.grid.GetFixedRows();
  for(var i=0; i<vaRows.length;i++){
    if(vaRows[i] == poRow && this.getRowType(poRow) == this.RowType.HeadRow) {
      if(poRow.Kind == "Data") return i - 1;
      return i;
    }
  }
  return null;
};
/**
 * 주어진 footer row의 index를 반환하는 메소드
 * @param {Object} poRow footer row object
 * @return footer row index
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getIndexOfFootRow = function(poRow) {
  var vaFixedRows = this.grid.GetFixedRows();
  var vaFooterRows = new Array();
  var voRetRow = null;
  var vnIndex = 0;

  for(var i=0; i<vaFixedRows.length; i++){
    var vsSection = vaFixedRows[i].Fixed;
    if(vsSection == "Foot") vaFooterRows.push(vaFixedRows[i]);
  }

  for(var i=0; i<vaFooterRows.length;i++){
    if(vaFooterRows[i] == poRow && this.getRowType(poRow) == this.RowType.FootRow) return vnIndex;
    vnIndex++;
  }
  return null;
};
/**
 * 주어진 row에 매핑된 instance row index를 반환하는 메소드.
 * 반드시 XHTML 모드에서만 사용해야함.
 * @param {Object} poRow row object
 * @return 주어진 row의 instance index
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getInstIndexOfRow = function(poRow) {
  var vnInstIdx = poRow["InstIdx"];
  if(vnInstIdx == null) vnInstIdx = poRow.getAttribute("InstIdx");
  vnInstIdx = parseInt(vnInstIdx) + 1;
  return vnInstIdx;
};
/**
 * 선택된 row object들을 배열형태를 반환하는 메소드
 * @return 선택된 row object들의 배열
 * @type Array(Object)
 */
eXria.controls.xhtml.GridEx.prototype.getSelRows = function() {
  var vaSelRows = null;
  if(this.grid) {
    vaSelRows = this.grid.GetSelRows();
    if(vaSelRows.length == 0) vaSelRows = null;
    return vaSelRows;
  }
  else new Error("getSelRows call Error");
};
//yhkim 2009.05.11 multiSelect 관련
/**
 * 설정된 multiSelect 값을 반환하는 메소드
 * @return 설정된 multiSelect 값
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.getMultiSelect = function() {
  return this.cfg.multiSelect;
};
/**
 * 포커스된 row object를 반환하는 메소드
 * @return 포커스된 row object
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getFocusRow = function() {
  if(this.grid) return this.grid.FRow;
  else alert("getFocusRow call Error");
};
/**
 * 포커스된 column의 Header ID를 반환하는 메소드
 * @return Header ID
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getFocusCol = function() {
  if(this.grid) return this.grid.FCol;
  else alert("getFocusCol call Error");
};
/**
 * 포커스된 row의 인데스를 반환하는 메소드
 * @param {Boolean} pbGrouped 그룹핑된 row를 포함한 상태에서의 인덱스를 반환할 지 여부
 * @return 포커스된 row의 인덱스
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getFocusRowIndex = function(pbGrouped) {
  var vnRowIndex = null;
  if(this.grid.FRow){
    vnRowIndex = this.getIndexOfRow(this.grid.FRow, pbGrouped);
  }
  return vnRowIndex;
};
/**
 * 특정 row에 포커스를 주기 위한 메소드
 * @param {Number} pnIndex row index
 * @return 포커싱 성공 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.setFocusRowIndex = function(pnIndex, pbNoRunEvent, pbGrouped) {
  if(this.canvas.focusedControl != this)
    this.canvas.setFocusByControl(this);

  var voRowCtrl = this.getRowIndex(pnIndex, pbGrouped);
  this.noFocusEvent = pbNoRunEvent;

  if(pnIndex < 0)   // exception
    return false;

  var colID = null; // default value
  var vbResult = false;
  // yhkim 2009.04.08 : initial focus column setting
  if( this.grid.FCol == undefined){
    var sections = this.grid.GetSections();
    if(sections.length != 0){
      var nSec = sections[0];
      colID = this.grid.GetFirstCol(nSec);
      if(colID == "Panel") colID = this.grid.GetNextCol(colID);
    }
  }
  //yhkim 2009.04.08 : reset scroll (in treegrid source)
  vbResult = this.grid.Focus(voRowCtrl, colID, null, true);
  this.noFocusEvent = false;
  //this.scrollIntoView(this.getRowIndex(this.getDataRowCnt()-1));
  return vbResult;
};
/**
 * 특정 row에 포커스를 주기 위한 메소드
 * @param {Object} poRow row 객체
 * @return 포커싱 성공 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.setFocusRow= function(poRow, pbNoRunEvent) {
  if(this.canvas.focusedControl != this)
    this.canvas.setFocusByControl(this);

  this.noFocusEvent = pbNoRunEvent;

  if(poRow == null)   // exception
    return false;

  var colID = null; // default value
  var vbResult = false;
  // yhkim 2009.04.08 : initial focus column setting
  if( this.grid.FCol == undefined){
    var sections = this.grid.GetSections();
    if(sections.length != 0){
      var nSec = sections[0];
      colID = this.grid.GetFirstCol(nSec);
    }
  }
  //yhkim 2009.04.08 : reset scroll (in treegrid source)
  vbResult = this.grid.Focus(poRow, colID, null, true);
  this.noFocusEvent = false;
  //this.scrollIntoView(this.getRowIndex(this.getDataRowCnt()-1));
  return vbResult;
};
/**
 * 커서가 위치한 row를 반환하는 메소드
 * @return 커서가 위치한 row
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.getActualRow = function() {
  if(this.grid) return this.grid.ARow;
  else alert("getActualRow call Error");
};
/**
 * 주어진 row를 선택 또는 해제하기 위한 메소드
 * @param {Object} poRow row object
 * @param {Number} pnSelect : null은 하나이상의 셀이 선택되어 있으면 해당 로우를 해제하고 아니면 선택, 1은 해당 로우를 선택, 0은 해당 로우를 해제
 */
eXria.controls.xhtml.GridEx.prototype.selectRow = function(poRow, pnSelect) {
  if(this.grid) return this.grid.SelectRow(poRow, pnSelect);
  else alert("selectRow call Error");
};
/**
 * 모든 row를 선택 또는 해제하기 위한 메소드
 * @param {Object} poRow row object
 * @param {Number} pnSelect : null은 선택된 로우가 있으면 모두 해제하고 선택된 로우가 없으면 모두 선택함, 1은 모든 로우 선택, 0은 모든 로우 해제, -1은 선택된 로우는 해제하고 해제된 로우는 선택
 */
eXria.controls.xhtml.GridEx.prototype.selectAllRows = function(pnSelect) {
  if(this.grid) this.grid.SelectAllRows(pnSelect);
  else alert("selectAllRows call Error");
};
/**
 * 특정 영역의 Cell들을 선택하기 위한 메소드
 * @param {Object} poRow1 영역 시작 부분의 row object
 * @param {String} psCol1 poRow1 영역 시작 부분의 column id
 * @param {Object} poRow2 영역 끝 부분의 row object
 * @param {String} psCol2 영역 끝 부분의 column id
 * @param {Number} pnSelect 0 ? unselects range, 1 ? selectes range, 2 ? unselects range if cell row1,col1 is selected, otherwise selects the range
 * @param {Number} pnType bit array, &1 ? selects only visible rows, &2 ? ignores children of collapsed rows.
 * @return 선택 성공 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.selectRange = function(poRow1, psCol1, poRow2, psCol2, pnSelect, pnType) {
  if(this.grid) this.grid.SelectRange(poRow1, psCol1, poRow2, psCol2, pnSelect, pnType);
  else alert("selectRange call Error");
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.getRowsByValue = function(psCol, poValue) {
  for(var voCol=this.grid.GetFirstCol();voCol;voCol=this.grid.GetNextCol(voCol)) {
    if(vnIndex == pnIndex) return voCol;
    vnIndex = vnIndex + 1;
  }
};
/**
 * 한 행을 추가
 * @param {Boolean} poParent parent row object(tree구조가 아닐경우 null로 표기)
 * @param {Object} poNext (이행의 바로 이전에 새행이 추가됨, null설정시 맨 마지막에 추가)
 * @param {Boolean} pbShow 화면 표시 여부(default값은  true)
 * @return 추가된 row object
 * @type Object
 */
eXria.controls.xhtml.GridEx.prototype.addRow = function(poParent, poNext, pbShow) {
  var voRow = null;
  var vnIndex = this.getIndexOfRow(poNext);

  if(vnIndex == null) vnIndex = this.getRowCnt();
  if(pbShow == null) pbShow = true;

  if(this.datasetId != null) {
    if(!this.dataset) this.dataset = this.canvas.page.model.getDataSet(this.datasetId);
    this.dataset.insertRow(vnIndex + 1, false);
  } else if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
    if(vnIndex < this.getRowCnt()) this.data.addData(null, null, vnIndex);
    else this.data.addData();
  }
  
  this.grid.LastId = this.lastId;
  if(this.grid) voRow = this.grid.AddRow(poParent, poNext, pbShow);
  this.lastId++;
  
  //rightButton 처리
  var voCollection = this.rgtBtnList;
  var vnSize = voCollection.size();
  if(vnSize > 0)
  {
    var voColumn;
    var vsValue;
    for(var i = 0; i < vnSize; i++){
     voColumn = voCollection.get(i);
     vsValue = voColumn.itemgroup.getItemValuesToString('|');
     if(!vsValue) vsValue = voColumn.rightButton.value;
     this.setRightButton(voRow, voColumn.colId, vsValue, voColumn.width);
    }
  }

  //enum Column style 처리
  voCollection = this.enumColList;
  vnSize = voCollection.size();
  if(vnSize > 0)
  {
    var voColumn;
    for(var i = 0; i < vnSize; i++){
     voColumn = voCollection.get(i);
     this.grid.SetAttribute(voRow, voColumn.colId, "IconAlign", "Right", false);
    }
  }

  //MaxHeigth 처리
  if(this.rowMaxHeight != null) {
    voRow.MaxHeight = this.rowMaxHeight;
    voRow.MaxEditHeight = this.rowMaxHeight;
  }
  this.refreshRow(voRow);

  // yhkim 2009.05.28
  this.scrollIntoView(voRow, null);
  if(this.datasetId == null) {
    if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
      var voNodeList = this.data.getNodesetData2();
      var vnIdx = voNodeList.getLength() - 1;
      voNodeList.item(vnIdx).setUserAttribute("status", "I");
      voRow["InstIdx"] = vnIdx;
    }
  }
  return voRow;
};
//yhkim 2009.05.28
/**
 * 스크롤될 Cell위치 지정
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.scrollIntoView = function(poRow, psCol) {
  if(psCol == null){
    for(var i = 0; i < 3; i++){
      var vsColName = this.getColNames(i, 0);
      if(vsColName != "Panel"){
        psCol = vsColName;
        break;
      }
    }
  }
  if(this.cfg.paging == "fast"){
    this.grid.ScrollIntoView(poRow, psCol, this.cfg.pagePos);
  }else{
    this.grid.ScrollIntoView(poRow, psCol);
  }
};
/**
 * 한 행을 추가
 * @param {Number} pnIndex row Index
 * @param {Boolean} pbAfter 주어진 row 뒤에 행을 삽입할 지 여부
 */
eXria.controls.xhtml.GridEx.prototype.insertRow = function(pnIndex, pbAfter, poParent, pbShow) {
  var vbEmptyRow = false;
  var vaChildRows = this.childRows;
  if(this.getRowCnt() == 0) vbEmptyRow = true;

  if(pnIndex === null || pnIndex === undefined || this.rowMerged){
  pnIndex = 0;
  if(vbEmptyRow) pbAfter = true;
  else pbAfter = false;
  }

  if(this.datasetId != null) {
    if(!this.dataset) this.dataset = this.canvas.page.model.getDataSet(this.datasetId);
    if(vbEmptyRow) this.dataset.insertRow(pnIndex + 1, false);
    else this.dataset.insertRow(pnIndex + 1, pbAfter);
  } else if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
    this.data.addData();
  }


  if(this.cfg.groupMain && this.cfg.groupCols){
    if(poParent == null) poParent = this.getRowIndex(pnIndex).parentNode;
  }

  if(pbAfter) {
    voRow = this.getRowIndex(pnIndex+1);
  } else {
    voRow = this.getRowIndex(pnIndex);
  }

  var vbMove = false;

  if(this.cfg.groupMain && this.cfg.groupCols && !vaChildRows){
    if(voRow == null){
      vbMove = true;
      voRow = this.getRowIndex(pnIndex);
    }
    if(poParent == null) return;
  }
  
  this.grid.LastId = this.lastId;
  var voRetRow = null;
  if(this.grid) voRetRow = this.grid.AddRow(poParent, voRow, true);
  voRetRow.id = parseInt(this.grid.LastId);
  this.lastId++;
  
  if(vaChildRows) {
    var vnSize = vaChildRows.length;
    var voChild = null;
    for(var i = 0; i < vnSize; i++) {
      voChild = this.grid.AddRow(voRetRow, null, true, voRetRow.id + "_" + (i + 1));
      voChild["ChildIdx"] = i;
    }
  }

  if (this.cfg.groupMain && this.cfg.groupCols) {
    var vaGroupCols = this.cfg.groupCols.split(",");

    var ThisGrid = this.grid;
    var This = this;
    var vsGroupMain = this.cfg.groupMain;

    function setGroupValue(poElem){
      var vsGroupValue = ThisGrid.GetValue(poElem, vsGroupMain);
      var vsGroupCol = vaGroupCols[parseInt(poElem["Level"])];
      This.setGroupDefaultValue(voRetRow, vsGroupCol, vsGroupValue);
      if(poElem.parentNode.nodeName == "I") setGroupValue(poElem.parentNode);
    }

    if (voRetRow.parentNode != poParent || (pbAfter == true && vbMove)) {
      this.grid.MoveRow(voRetRow, poParent, null, true);
      this.grid.RenderBody();
    }
    setGroupValue(poParent);
  }

  //rightButton 처리
  var voCollection = this.rgtBtnList;
  var vnSize = voCollection.size();
  if(vnSize > 0)
  {
    var voColumn;
    var vsValue;
    for(var i = 0; i < vnSize; i++){
     voColumn = voCollection.get(i);
     vsValue = voColumn.itemgroup.getItemValuesToString('|');
     if(!vsValue) vsValue = voColumn.rightButton.value;
     this.setRightButton(voRetRow, voColumn.colId, vsValue, voColumn.width);
    }
  }

  //enum Column style 처리
  voCollection = this.enumColList;
  vnSize = voCollection.size();
  if(vnSize > 0)
  {
    var voColumn;
    for(var i = 0; i < vnSize; i++){
     voColumn = voCollection.get(i);
     this.grid.SetAttribute(voRetRow, voColumn.colId, "IconAlign", "Right", false);
    }
  }

  //MaxHeigth 처리
  if(this.rowMaxHeight != null) {
    voRetRow.MaxHeight = this.rowMaxHeight;
    voRetRow.MaxEditHeight = this.rowMaxHeight;
  }
  this.refreshRow(voRetRow);

  //yhkim 2009.05.28
  this.scrollIntoView(voRetRow, null);
  if(this.datasetId == null) {
    if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
      var voNodeList = this.data.getNodesetData2();
      var vnIdx = voNodeList.getLength() - 1;
      voNodeList.item(vnIdx).setUserAttribute("status", "I");
      voRetRow["InstIdx"] = vnIdx;
    }
  }
  return voRetRow;
};
eXria.controls.xhtml.GridEx.prototype.setGroupDefaultValue = function(poRow, psCol, psValue){
  if (this.grid) {
    this.grid.SetValue(poRow, psCol, psValue, true);
  }
  // DataSet과의 데이타 동기화
  var voDataSet, voColumn, vsDatasetCol = null;
  base = this;
  if(base.datasetId != null) {
    if(base.dataset) voDataSet = base.dataset;
    else voDataSet = base.canvas.page.model.getDataSet(base.datasetId);
    if(base.dataset) {
      voColumn = base.getBodyColumn(null, psCol);
      if(voColumn) {
        vsDatasetCol = voColumn.datasetCol;
        if(vsDatasetCol == null) {
          vsDatasetCol = voColumn.ref;
          if(vsDatasetCol != null) {
            var vaPath = vsDatasetCol.split("/");
            vsDatasetCol = vaPath[vaPath.length - 1];
          }
        }
        if(vsDatasetCol) {
          var voValue, vaEnumKeys = null;
          var vnRowIndex = base.getIndexOfRow(poRow);
          voValue = base.grid.GetValue(poRow, psCol);
          voValue = this.convertValueExria(poRow, psCol, voValue);
          if(voValue === null) voValue = "";
          var vbResult = true;
//          if(pbSimple) {
//            vbResult = base.dataset.simpleSet(vnRowIndex+1, vsDatasetCol, voValue);
//          } else {
            vbResult = base.dataset.set(vnRowIndex+1, vsDatasetCol, voValue);
//          }
          if(!vbResult) alert("data sync error");
        }
      }
    }
  }

};
/**
 * 해당 순번의 행 삭제
 * @param {Number} pnIndex 삭제될 row index
 */
eXria.controls.xhtml.GridEx.prototype.delRowByIndex = function(pnIndex) {
  var voRow = this.getRowIndex(pnIndex);
  this.delRow(voRow);
  /*
  var vnIndex = 0;
  for(var voRow=this.grid.GetFirst();voRow;voRow=this.grid.GetNext(voRow)) {
    if(vnIndex == pnIndex) this.grid.DelRow(voRow);
    vnIndex = vnIndex + 1;
    this.grid.RefreshRow(voRow);
  }
  */
};
/**
 * 해당 행 삭제
 * @param {Object} poRow 삭제될 row object
 */
eXria.controls.xhtml.GridEx.prototype.delRow = function(poRow) {
  var vnIndex = this.getIndexOfRow(poRow);

  if(this.datasetId == null) {
    if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
      var vnInstIdx = poRow["InstIdx"];
      if(vnInstIdx == null) vnInstIdx = poRow.getAttribute("InstIdx");
      vnInstIdx = parseInt(vnInstIdx);
      var voInstRow = this.data.getNodesetData2(vnInstIdx).node;
      var vsStatus = voInstRow.getUserAttribute("status");
      if(vsStatus == null) vsStatus = "";
      if(vsStatus.indexOf("I") != -1) voInstRow.getParentNode().removeChild(voInstRow);
      else if(vsStatus.indexOf("R") == -1) voInstRow.setUserAttribute("status", "R" + vsStatus);
    }
  } else {
    this.dataset.deleteRow(vnIndex + 1);
  }
  if(this.grid) this.grid.DelRow(poRow);
  else alert("delRow call Error");
  if(this.getRowCnt() == 0) {
    this.grid.LastId = "";
    this.grid.Focus(null, null);
  }
};
/**
 * 행에 대한 삭제를 marking
 * @param {Object} poRow row object
 * @param {Number} pnType type =  1 ? delete + confirm dialog, 2 ? delete, 3 ? undelete (delete는 child row까지 모두 삭제, undelete는 해당 로우만 삭제)
 */
eXria.controls.xhtml.GridEx.prototype.markDelRow = function(poRow, pnType) {

  if(pnType == null)
    return false;

  if(this.grid) {
    if(this.grid.DeleteRow(poRow, pnType) == false) {
      alert("cannot Mark Delete");
      return;
    }
  }
  else alert("deleteRow call Error");
};
/**
 * 해당 순번의 행에 대한 삭제를 marking
 * @param {Number} pnType [1 : delete + confirm dialog, 2 : delete, 3 : undelete (delete는 child row까지 모두 삭제, undelete는 해당 로우만 삭제)]
 */
eXria.controls.xhtml.GridEx.prototype.markDelRowByIndex = function(pnIndex, pnType) {
  var voRow = this.getRowIndex(pnIndex);
  this.markDelRow(voRow, pnType);

  /*
  var vnIndex = 0;
  for(var voRow=this.grid.GetFirst();voRow;voRow=this.grid.GetNext(voRow)) {
    if(vnIndex == pnIndex) this.grid.DeleteRow(voRow, pnType);
    vnIndex = vnIndex + 1;
    this.grid.RefreshRow(voRow);
  }
  */
};
/////////////////////////////////////////////////////////////////
// Column 관련 메소드
/**
 * addCol
 * @param {String} psColId column id
 * @param {Number} pnSec section of columns (0 ? left, 1 ? variable, 2 ? right)
 * @param {Number} pnPos column position in its section
 * @param {Number} pnWidth column width or null for automatic computing
 * @param {Boolean} pbShow column displayed in table
 * @param {String} psType column type
 * @param {String} psCaption caption
 * @param {String} psFormula column formula
 * @param {String} psEnum enum string
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addCol = function(psColId, pnSec, pnPos, pnWidth, pbShow, psType, psCaption, psFormula, psEnum) {
  if(this.grid) return this.grid.AddCol(psColId, pnSec, pnPos, pnWidth, pbShow, psType, psCaption, psFormula, psEnum);
  else alert("addCol call Error");
};
/**
 * 헤드 컬럼을 구함
 * @param {String} psHeadColId header column id
 * @return 칼럼에 설정된 Ref
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getHeadColumn = function(psHeadColId) {
  if(this.headColMap.get(psHeadColId)) return this.headColMap.get(psHeadColId);

  var voCols = new Array();
  var voHeader, voRow, vsRef = null;

  voHeader = this.header;
  voCols[0] = voHeader.cols["left"];
  voCols[1] = voHeader.cols["center"];
  voCols[2] = voHeader.cols["right"];

  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
      for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
        if(voColumn.id == psHeadColId) {
          return voColumn;
        }
      }
    }
  }
  return null;
};
/**
 * 헤드 컬럼을 제거
 * @param {String} psHeadColId header column id
 * @return 제거된 헤드 컬럼 객체
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.removeHeadColumn = function(psHeadColId) {
  var voCols = new Array();
  var voHeader, voRow, vsRef = null;

  voHeader = this.header;
  voCols[0] = voHeader.cols["left"];
  voCols[1] = voHeader.cols["center"];
  voCols[2] = voHeader.cols["right"];

  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
      for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
        if(voColumn.id == psHeadColId) {
          voColumn = voRow.columns.splice(j, 1);
          this.headColMap.remove(psHeadColId);
          return voColumn[0];
        }
      }
    }
  }
  return null;
};
/**
 * 주어진 Body Column을 반환하는 메소드.
 * @param {String} psColId column id(null)
 * @param {String} psHeadColId header column id
 * @return body Column
 * @type eXria.controls.xhtml.GridEx.BodyColumn
 */
eXria.controls.xhtml.GridEx.prototype.getBodyColumn = function(psColId, psHeadColId) {
  if(psColId && this.bodyColMap.get(psColId)) return this.bodyColMap.get(psColId);
  if(psHeadColId && this.bodyColHMap.get(psHeadColId)) return this.bodyColHMap.get(psHeadColId);

  var voBody = this.body;
  var voCols = new Array(3);
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  for(var i=0; i<voBody.cols.length; i++) {
    if(voCols[i]) {
      for(var j=0; j<voCols[i].rows.length; j++) {
        voColsRow = voCols[i].rows[j];
        for(var k=0; k<voColsRow.columns.length; k++) {
          voColumn = voColsRow.columns[k];
          if(voColumn.id == psColId) return voColumn;
          if(psColId == null && voColumn.colId == psHeadColId) return voColumn;
        }
      }
    }
  }
  return null;
/*
  var vnIndex = 0;
  if(!pnSection) pnSection = 1;
  for(var voCol=this.grid.GetFirstCol();voCol;voCol=this.grid.GetNextCol(voCol)) {
    if(vnIndex == pnIndex) return voCol;
    vnIndex = vnIndex + 1;
  }
*/
};
/**
 * Body Column을 제거해주는 메소드.
 * @param {String} psColId column id(null)
 * @param {String} psHeadColId header column id
 * @return 제거된 body Column 객체
 * @type eXria.controls.xhtml.GridEx.BodyColumn
 */
eXria.controls.xhtml.GridEx.prototype.removeBodyColumn = function(psColId, psHeadColId) {
  var voBody = this.body;
  var voCols = new Array(3);
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  for(var i=0; i<voBody.cols.length; i++) {
    if(voCols[i]) {
      for(var j=0; j<voCols[i].rows.length; j++) {
        voColsRow = voCols[i].rows[j];
        for(var k=0; k<voColsRow.columns.length; k++) {
          voColumn = voColsRow.columns[k];
          if(psColId && voColumn.id == psColId) {
            voColumn = voColsRow.columns.splice(k, 1);
            this.bodyColMap.remove(psColId);
            this.bodyColHMap.remove(voColumn.colId);
            return voColumn[0];
          }
          if(psColId == null && voColumn.colId == psHeadColId) {
            voColumn = voColsRow.columns.splice(k, 1);
            this.bodyColMap.remove(voColumn.id);
            this.bodyColHMap.remove(psHeadColId);
            return voColumn[0];
          }
        }
      }
    }
  }
  return null;
};
/**
 * 주어진 Function Column 을 반환하는 메소드.
 * @param {object} poRow header row object
 * @param {String} psColId Function column id
 * @param {String} psHeadColId header column id
 * @return Function Column
 * @type eXria.controls.xhtml.GridEx.FunctionColumn
 */
eXria.controls.xhtml.GridEx.prototype.getFunctionColumn = function(poRow, psColId, psHeadColId) {
  if(psColId && this.functionColMap.get(psColId)) return this.functionColMap.get(psColId);

  var vnIndex = this.getIndexOfHeadRow(poRow);
  var voCols = new Array();
  var voColumn = null;
  voCols[0] = this.header.cols["left"];
  voCols[1] = this.header.cols["center"];
  voCols[2] = this.header.cols["right"];

  for ( var i = 0; i < 3; i++) {
    if (voCols[i]) {
      var vaFunRows = new Array();
      for ( var j = 0; voCols[i].rows.length > j; j++) {
        var voRow = voCols[i].rows[j];
        voColumn = voRow.columns[0];
        if(voColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn
      || voColumn instanceof eXria.controls.xhtml.GridEx.HeadColumn){
          vaFunRows.push(voRow);
        }
      }
      var voFunRow = vaFunRows[vnIndex];
      for(var j=0; j<voFunRow.columns.length; j++){
        var voColumn = voFunRow.columns[j];
        if(voColumn.id == psColId) return voColumn;
        if(psColId == null && voColumn.colId == psHeadColId) return voColumn;
      }
    }
  }

  return null;
};
/**
 * Function Column을 제거해주는 메소드.
 * @param {object} poRow header row object
 * @param {String} psColId Function column id
 * @param {String} psHeadColId header column id
 * @return Function Column
 * @type eXria.controls.xhtml.GridEx.FunctionColumn
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.removeFunctionColumn = function(poRow, psColId, psHeadColId) {
  var vnIndex = this.getIndexOfHeadRow(poRow);
  var voCols = new Array();
  var voColumn = null;
  var voRow = null;
  voCols[0] = this.header.cols["left"];
  voCols[1] = this.header.cols["center"];
  voCols[2] = this.header.cols["right"];

  for ( var i = 0; i < 3; i++) {
    if (voCols[i]) {
      var vnFunRowIdx = -1;
      var vnSize = voCols[i].rows.length;
      for ( var j = 0; vnSize > j; j++) {
        voRow = voCols[i].rows[j];
        voColumn = voRow.columns[0];
        if(voColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn
      || voColumn instanceof eXria.controls.xhtml.GridEx.HeadColumn){
          vnFunRowIdx++;
          if(vnFunRowIdx == vnIndex) break;
        }
      }
      vnSize = voRow.columns.length;
      for(var j=0; j < vnSize; j++){
        var voColumn = voRow.columns[j];
        if(voColumn.id == psColId) {
          voColumn = voRow.columns.splice(j, 1);
          this.functionColMap.remove(voColumn[0].id);
          return voColumn[0];
        }
        if(psColId == null && voColumn.colId == psHeadColId) {
          voColumn = voRow.columns.splice(j, 1);
          return voColumn[0];
        }
      }
    }
  }

  return null;
};
/**
 * 주어진 footer Column 을 반환하는 메소드.
 * @param {object} poRow footer row object
 * @param {String} psColId footer column id
 * @param {String} psHeadColId header column id
 * @return footer Column
 * @type eXria.controls.xhtml.GridEx.FootColumn
 */
eXria.controls.xhtml.GridEx.prototype.getFootColumn = function(poRow, psColId, psHeadColId) {
  if(psColId && this.footColMap.get(psColId)) return this.footColMap.get(psColId);

  var voFooter = this.footer;
  var vnIndex = this.getIndexOfFootRow(poRow);
  var voFootRow = voFooter.rows[vnIndex];

  for(var vsColsSec in voFootRow.cols){
    var voCols = voFootRow.cols[vsColsSec];
    for(var i=0; i<voCols.columns.length; i++){
      var voColumn = voCols.columns[i];
      if(voColumn.id == psColId) return voColumn;
      if(psColId == null && voColumn.colId == psHeadColId) return voColumn;
    }
  }

  return null;
};
/**
 * Footer Column을 제거해주는 메소드.
 * @param {object} poRow footer row object
 * @param {String} psColId footer column id
 * @param {String} psHeadColId header column id
 * @return footer Column
 * @type eXria.controls.xhtml.GridEx.FootColumn
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.removeFootColumn = function(poRow, psColId, psHeadColId) {
  if(psColId && this.footColMap.get(psColId)) return this.footColMap.get(psColId);

  var voFooter = this.footer;
  var vnIndex = this.getIndexOfFootRow(poRow);
  var voFootRow = voFooter.rows[vnIndex];

  for(var vsColsSec in voFootRow.cols){
    var voCols = voFootRow.cols[vsColsSec];
    for(var i=0; i<voCols.columns.length; i++){
      var voColumn = voCols.columns[i];
      if(voColumn.id == psColId) {
        voColumn = voRow.columns.splice(i, 1);
        this.footColMap.remove(voColumn[0].id);
        return voColumn[0];
      }
      if(psColId == null && voColumn.colId == psHeadColId) {
        voColumn = voRow.columns.splice(i, 1);
        return voColumn[0];
      }
    }
  }

  return null;
};
/**
 * header column id에 해당하는 칼럼 이름(ID)를 구함
 * @param {String} psHeadColId header column id
 * @return header column id에 해당하는 칼럼 이름(ID)
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getBodyColid = function(psHeadColId) {
  var voBody = this.body;
  var voCols = new Array(3);
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  for(var i=0; i<voBody.cols.length; i++) {
    if(voCols[i]) {
      for(var j=0; j<voCols[i].rows.length; j++) {
        voColsRow = voCols[i].rows[j];
        for(var k=0; k<voColsRow.columns.length; k++) {
          voColumn = voColsRow.columns[k];
          if(voColumn.colId == psHeadColId) return voColumn.id;
        }
      }
    }
  }
  return null;
};
/**
 * 인덱스에 해당하는 칼럼 이름(ID)를 구함
 * @param {Number} pnSection
 * @param {Number} pnSection section of columns (0 ? left, 1 ? variable, 2 ? right)
 * @return 칼럼 이름(ID)
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getColNames = function(pnSection, pnIndex) {
  return this.grid.ColNames[pnSection][pnIndex];
};
/**
 * 인덱스에 해당하는 칼럼 ID를 구함
 * @param {Number} pnSection
 * @param {Number} pnSection section of columns (0 ? left, 1 ? variable, 2 ? right)
 * @return 칼럼 이름(ID)
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getColId = function(pnSection, pnIndex) {
  return this.grid.ColNames[pnSection][pnIndex];
};
/**
 * 칼럼에 설정된 Ref를 구함
 * @param {String} psHeadColId header column id
 * @return 칼럼에 설정된 Ref
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getColRef = function(psHeadColId) {
  var voCols = new Array();
  var voBody, voRow, vsRef = null;

  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
      for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
        if(voColumn.colId == psHeadColId) {
          if(this.datasetId != null) {
            vsRef = voColumn.datasetCol;
            if(vsRef)
              return vsRef;
          }
          else {
            vsRef = voColumn.ref;
            if(vsRef) {
              vaPath = vsRef.split("/");
              vsRef = vaPath[vaPath.length - 1];
              return vsRef;
            }
          }
        }
      }
    }
  }
};
/**
 * 칼럼에 설정된 Ref 및 dataset정렬타입을 구함
 * @param {String} psHeadColId header column id
 * @return 칼럼에 설정된 Ref
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getColRefAndTextFlag = function(psHeadColId) {
  var voCols = new Array();
  var voBody, voRow, vsRef = null;
  var vnTextFlag = null;;

  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];
  if(psHeadColId == this.cfg.idColumn) psHeadColId = "id";
  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
      for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
        vnTextFlag = 1;
        if(voColumn.type == "Int" || voColumn.type == "Float") vnTextFlag = 0;
        if(voColumn.colId == psHeadColId) {
          if(this.datasetId != null) {
            vsRef = voColumn.datasetCol;
            if(vsRef) return [vsRef, vnTextFlag];
            else return [voColumn.colId, vnTextFlag];
          }
          else {
            vsRef = voColumn.ref;
            if(vsRef) {
              vaPath = vsRef.split("/");
              vsRef = vaPath[vaPath.length - 1];
              return [vsRef, vnTextFlag];
            }
          }
        }
      }
    }
  }
};
/**
 * 주어진 칼럼의 다음 칼럼 id를 구한다.
 * @param {String} psCol column id
 * @return 주어진 칼럼의 다음 칼럼 id
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getNextCol = function(psCol) {
  if(this.grid) return this.grid.GetNextCol(psCol);
  else alert("getNextCol call Error");
};
/**
 * 주어진 칼럼의 이전 칼럼 id를 구한다.
 * @param {String} psCol column id
 * @return 주어진 칼럼의 다음 칼럼 id
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getPrevCol = function(psCol) {
  if(this.grid) return this.grid.GetPrevCol(psCol);
  else alert("getPrevCol call Error");
};
/**
 * 맨처음 칼럼 id를 구한다. (Section이 주어지면 주어진 Section에서 null 이면 전체에서)
 * @param {Number} pnSection section of columns (0 ? left, 1 ? variable, 2 ? right)
 * @return 맨처음 칼럼 id
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getFirstCol = function(pnSection) {
  if(this.grid) return this.grid.GetFirstCol(pnSection);
  else alert("getFirstCol call Error");
};
/**
 * 마지막 칼럼 id를 구한다. (Section이 주어지면 주어진 Section에서 null 이면 전체에서)
 * @param {Number} pnSection section of columns (0 ? left, 1 ? variable, 2 ? right)
 * @return 마지막 칼럼 id
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getLastCol = function(pnSection) {
  if(this.grid) return this.grid.GetLastCol(pnSection);
  else alert("getLastCol call Error");
};
/////////////////////////////////////////////////////////////////
// Html 관련 메소드
/**
 * 주어진 row를 새로고침 하는 메소드
 * @param {Object} poRow row object
 */
eXria.controls.xhtml.GridEx.prototype.refreshRow = function(poRow) {
  if(this.grid) this.grid.RefreshRow(poRow);
  else alert("refreshRow call Error");
};
/**
 * 주어진 Cell을 새로고침 하는 메소드
 * @param {Object} poRow row object
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.refreshCell = function(poRow, psColId) {
  if(this.grid) this.grid.RefreshCell(poRow, psColId);
  else alert("refreshCell call Error");
};
/**
 * Cell의 HTML element를 반환하는 메소드
 * @param {Object} poRow row object
 * @param {String} psCol column id
 * @param {Number} pnType type==0 ? returns object of whole cell (main tag TD)
 * type==1 ? returns inner tag &lt;TD&gt; containing &lt;DIV&gt; with text (for MainCol and button) or inner tag &lt;DIV class="width..."&gt;
 * type==2 ? returns tag &lt;IMG&gt; or &lt;BUTTON&gt; for cell with button or null
 * @return Cell의 HTML element
 * @type HTMLElement
 */
eXria.controls.xhtml.GridEx.prototype.getCell = function(poRow, psCol, pnType) {
  if(this.grid) return this.grid.GetCell(poRow, psCol, pnType);
  else alert("getCell call Error");
};
/////////////////////////////////////////////////////////////////
//Page 관련 메소드
/**
 * 포커스된 페이지 위치를 반환하는 메소드
 * @param {Object} poRow row object
 * @return 포커스된 row의 page 위치
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getFocusPagePos = function(poRow) {
  if(this.grid) return this.grid.GetPagePos(poRow);
  else alert("getFocusPagePos call Error");
};

/**
 * 해당 row가 속한 페이지의 위치를 반환하는 메소드
 * @param {Object} poRow row object
 * @return row가 속한 page의 인덱스
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getPageNum = function(poRow) {
  if(this.grid) return this.grid.GetPageNum(poRow);
  else alert("getPageNum call Error");
};

/**
 * 전체 페이지 갯수를 반환하는 메소드
 * @return 전체 페이지 갯수
 * @type Number
 */
eXria.controls.xhtml.GridEx.prototype.getPageTotalNum = function(){
  if(this.grid) {
    var voTotalNum = 0;
    for(var r=this.grid.XB.firstChild;r;r=r.nextSibling) {
      if(r!=null) voTotalNum++;
      else break;
    }
    return voTotalNum;
  } else {
    alert("getPageTotalNum call Error");
  }
};

/////////////////////////////////////////////////////////////////
//Sort 관련 메소드
/**
 * 소트 실행
 * @param {Number} pnSortCount 화면 클릭에 의한 sort 여부를 구분 짓기 위한 정수
 * @param {Array(String)} paSortCols sort 컬럼 id 저장 배열
 * @param {Array} paSortTypes sort type
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.sort = function(pnSortCount, paSortCols, paSortTypes) {
  if(pnSortCount > 0) this.sortUser = true;
  this.sortColsUser = paSortCols;
  this.sortTyepsUser = paSortTypes;

//  if(this.cfg.idColumn != null) {
//    this.refresh(null, true, true, true);
//  } else {
    if(this.getRowCnt() > 0)  this.refreshData(null, null, true, true);
//  }
};
/**
 * 매개변수로 주어진 칼럼에 의해 GridEx를 sorting 한다.
 * @param {Array(String)} paSortCols sort 컬럼 id 저장 배열
 * @param {Array} paSortTypes sort type
 * @param {Boolean} bNosort 1이면 SortCols, SortTypes, sort icons을 변경하되 sorting을 수행하지 않는다. 0이면 sorting 까지 수행한다.
 */
eXria.controls.xhtml.GridEx.prototype.changeSort = function(paSortCols, paSortTypes, bNosort) {
  var cols = ""
  if(typeof(paSortTypes)=="object") {
    for(var i=0;i<paSortTypes.length;i++) if(paSortTypes[i]) paSortCols[i] = "-"+paSortCols[i];
    for(var i=0;i<paSortCols.length;i++) {
      if(cols == "") cols = cols + paSortCols[i];
      else cols = cols + "," + paSortCols[i];
    }
  }

  if(this.grid) this.grid.ChangeSort(cols, bNosort);
  else new Error("grid is null");
};

/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 속성값
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  this.setAttr(psAttrName, psAttrValue);
  var voCtrl = this.getCtrl(poDocument);

  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  case "className" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "left" :
  case "top" :
       this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    break;
  case "width" :
    var vnOldWidth = this.innerWidth;
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.refresh();
    break;
  case "height" :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
    break;
  case "borderWidth" :
  case "borderLeftWidth" :
  case "borderRightWidth" :
  case "borderTopWidth" :
  case "borderBottomWidth" :
    this.refresh(poDocument);
    break;
  case "multiSelect" :
    this.cfg.multiSelect = psAttrValue;
    break;
  default :
    this.setAttrCtrl(psAttrName, psAttrValue, voCtrl);
    this.setAttrCtrl(psAttrName, psAttrValue, this.ctrl);
    break;
  }
};
/**
 * 그리드 헤더 생성.
 * @return 그리드헤더
 * @type eXria.controls.xhtml.GridEx.Header
 */
eXria.controls.xhtml.GridEx.prototype.createHeader = function() {
  var voHeader = new eXria.controls.xhtml.GridEx.Header(this);
  return voHeader;
};
/**
 * 그리드 바디 생성.
 * @return 그리드바디
 * @type eXria.controls.xhtml.GridEx.Body
 */
eXria.controls.xhtml.GridEx.prototype.createBody = function() {
  var voBody = new eXria.controls.xhtml.GridEx.Body(this);
  return voBody;

};
/**
 * 그리드 footer 생성.
 * @return 그리드 footer
 * @type eXria.controls.xhtml.GridEx.Footer
 */
eXria.controls.xhtml.GridEx.prototype.createFooter = function() {
  var voFooter = new eXria.controls.xhtml.GridEx.Footer(this);
  return voFooter;
};
/**
 * 그리드에 헤더 추가.
 * @param {eXria.controls.xhtml.GridEx.Header} poHeader 그리드헤더
 */
eXria.controls.xhtml.GridEx.prototype.addHeader = function(poHeader) {
//  poHeader.create();
  this.header = poHeader;
};
/**
 * 그리드에 바디 추가.
 * @param {eXria.controls.xhtml.GridEx.Body} poBody 그리드바디
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addBody = function(poBody) {
//  poBody.create();
  this.body = poBody;
};

/**
 * 그리드에 functionRow 추가.
 * @param {eXria.controls.xhtml.GridEx.FunctionRow} poFunctionRow 그리드 functionRow
 */
eXria.controls.xhtml.GridEx.prototype.addFunctionRow = function(poFunctionRow){
//  this.functionRow = poFunctionRow;
};

/**
 * 그리드에 footer 추가.
 * @param {eXria.controls.xhtml.GridEx.Footer} poFooter 그리드 footer
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addFooter = function(poFooter) {
  this.footer = poFooter;
};
/**
 * 주어진 row의 HTML element를 반환하는 메소드
 * @param {Object} poRow row object
 * @return 주어진 row의 HTML element
 * @type HTMLElement
 */
eXria.controls.xhtml.GridEx.prototype.getRow = function(poRow) {
  //(0 ? left, 1 ? variable, 2 - right)
  if(this.grid) return this.grid.GetRow(poRow, 1);
  else alert("getRow call Error");
};
/**
 * Row의 Color 설정
 * @param {String} psColor Color
 * @param {Object} poRow row object
 */
eXria.controls.xhtml.GridEx.prototype.setRowColor = function(psColor, poRow) {
  var vsColor = null;
  if(psColor.substring(0, 1) != "#"){
    vsColor = eXria.controls.xhtml.Util.getColor(psColor);
  }else{
    vsColor = psColor;
  }
  this.saveRowColor(poRow, psColor); // Color 저장

  var vnIdx = this.getIndexOfRow(poRow);
  var vsRGB = this.getRGBValue(vsColor);
  var vnVal = (vsRGB+"").split(",");
  //vnVal = (vnVal[0]<<16)+(vnVal[1]<<8)+(vnVal[2]-0);

  poRow["Color"] = vnVal;
  this.refreshRow(poRow);
};
/**
 * Row의 Index로 Row Color 설정
 * @param {String} psColor Color
 * @param {Number} pnIndex Row의 Index
 */
eXria.controls.xhtml.GridEx.prototype.setRowIndexColor = function(psColor, pnIndex/*, ...*/) {
  var vaArgv = arguments;
  var vnSize = vaArgv.length;
  for(var i=1; i<vnSize; i++){
    var voRow = this.getRowIndex(vaArgv[i]);
    this.setRowColor(psColor, voRow);
  }
};
/**
 * Cell의 Color 설정
 * @param {String} psColor Color
 * @param {Object} poRow row object
 * @param {String} psCol HeadColumn의 ID
 */
eXria.controls.xhtml.GridEx.prototype.setCellColor = function(psColor, poRow, psCol){
  var vsColor = null;
  if(psColor.substring(0, 1) != "#"){
    vsColor = eXria.controls.xhtml.Util.getColor(psColor);
  }else{
    vsColor = psColor;
  }
  this.saveCellColor(poRow, psCol, psColor);

  var vsRGB = this.getRGBValue(vsColor);
  var vnVal = (vsRGB+"").split(",");
  //vnVal = (vnVal[0]<<16)+(vnVal[1]<<8)+(vnVal[2]-0);
  var vsAttrName = psCol + "Color";
  poRow[vsAttrName] = vnVal;
  this.refreshRow(poRow); // TreeGrid RefreshRow에서 호출되는  GetRowHTML에서 Cell의 컬러를 설정
};
/**
 * Body Column들의 Color 설정
 * @param {String} psColor Color
 * @param {String} psCol HeadColumn의 ID
 */
eXria.controls.xhtml.GridEx.prototype.setBodyColumnColor = function(psColor, psCol){
  var vnLoop = this.getRowCnt();
  for(var i=0; i<vnLoop; i++){
    var voRow = this.getRowIndex(i);
    this.setCellColor(psColor, voRow, psCol);
  }
};
/**
 * Row의 Color 획득
 * @param {Object} poRow row object
 * @return Row의 Color 값
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getRowColor = function(poRow){
  //5.0에서 6.0 으로 변경 되면서 GetColor메소드가 제거 되었음

  if(!!this.grid && !!poRow){
  if(!!poRow.Color){
    var vsRGBArr = poRow.Color;
    return eXria.controls.xhtml.Util.getRGBToHex(Number(vsRGBArr[0]),Number(vsRGBArr[1]),Number(vsRGBArr[2]));
  }
  return poRow.Color;
  //if(this.grid) return this.grid.GetColor(poRow);
  }
  else alert("getRowColor call Error");
};

/**
 * Column의 Color 획득
 * @param {Object} poRow row object
 * @param {String} psCol HeadColumn의 ID
 * @return Column의 Color 값
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getCellColor = function(poRow, psCol){


  if(this.grid) return this.grid.GetColor(poRow, psCol);
  else alert("getColumnColor call Error");
};

/**
 * NodeSet value를 문자열 형태로 반환하는 메소드
 * @param {String} psCol 현재 컬럼명
 * @param {String} psValue xPath의 특정 컬럼
 * @param {String} psPath xPath로 지정된 곳
 * @param {String} psDelimeter 기본 컬럼에 설정된 Delimeter
 * @return NodeSet value 문자열
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.getNodeSetString = function(psInstance, psValue, psPath, psDelimeter){
  var voData = new eXria.controls.DataRefNodeset(this);
  var vsDelimeter = psDelimeter;

  if(vsDelimeter == null)
    vsDelimeter = "|";

  var vsInstanceID = psInstance;

  voData.setNodesetRef(vsInstanceID, psPath);
  var vsValueNode = "";
  var voCollectionNode = voData.getNodesetData2();

  if(voCollectionNode) {
    var vnLoop = voCollectionNode.getLength();
    var voMapNode = null;
    var voItem = null;
    var vsNodeVal = null;
    for(var i = 0; i < vnLoop; i++) {
      voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
      vsNodeVal = voMapNode.get(psValue);
      vsValueNode += vsDelimeter + (vsNodeVal ? vsNodeVal : "");
    }
  }
  return vsValueNode;
};
/**
 * GridEx에 연결된 Dataset을 Excel파일로 export한다.
 * @param {String} psPath export할 Excel 화일의 경로명
 * @param {Number} pnStartIdx export할 시작 Index
 * @param {Number} pnEndIdx export할 마지막 Index
 * @param {String} cell안에 데이터의 세로 정렬 [ex. "top", "middle", "bottom"]
 * @return Export의 성공여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.exportExcel = function(psPath, pnStartIdx, pnEndIdx, psVarticalAlign){
  if(psVarticalAlign == null) psVarticalAlign = "middle";
  if(!this.dataset) return false;
//  this.dataset.rebuild(false);
  var voModel = this.canvas.page.model;
  var voFSO = voModel.getFileSystemObject();
  var vsId = this.id;
  var vsFileName = this.userAttr;
  if(vsFileName == null || vsFileName == "") vsFileName = vsId;

  function checkFilePath(pbOver){
    if(!psPath || pbOver === false) psPath = voFSO.showFilePicker("Export Excel File", vsFileName + ".xls", "excel (*.xls)|*.xls|", 4);
    if(psPath != null && psPath != "" && voFSO.fileExists(psPath)){
      if(!window.confirm("The file '" + psPath + "' already exists.\nDo you want to replace the existing file?")) return checkFilePath(false);
    }
    return psPath;
  }

  psPath = checkFilePath();
  if(!psPath) return false;
  try{
  var vsConnId = this.datasetId + "conn";
    var conn = voModel.plugin.getConnection(vsConnId, voModel.plugin.ETBDATASETSOURCE, this.datasetId, voModel.plugin.ETBEXCELFILESOURCE, "", psPath);
    var comm = conn.getCommand(vsConnId);
    comm.changeTarget(voModel.plugin.ETBEXCELFILESOURCE,"",psPath);

  var vnVarticalAlign = comm.EXCEL_VERTICALALIGN_MIDDLE;
  psVarticalAlign = psVarticalAlign.toLowerCase();
  if (psVarticalAlign == "top")    vnVarticalAlign = comm.EXCEL_VERTICALALIGN_TOP;
  else if (psVarticalAlign == "bottom")vnVarticalAlign = comm.EXCEL_VERTICALALIGN_BOTTOM;
  comm.setVerticalAlign(vnVarticalAlign);

    if(pnStartIdx) comm.setMinRow(pnStartIdx);
    if(pnEndIdx) comm.setMaxRow(pnEndIdx);

    comm.executeQuery(comm.ETBDATAREPLACE | comm.ETBFIELDNAMENEW| comm.ETBFIRSTROWFIELD_TGT);
    conn.close();
  }catch(e){
    return false;
  }
  return true;
};
/**
 * @param {String} export 할 column id, 여러개일 경우 쉼표로 구분. [ex. "colId1,colId2,colId3"]
 * @param {Boolean} pbHeader Header 유무, false가 넘어올 경우에만 Header를 출력하지 않음
 * @param {String} psPath export할 Excel 화일의 경로명
 * @param {Number} pnStartIdx export할 시작 Index
 * @param {Number} pnEndIdx export할 마지막 Index
 * @param {String} cell안에 데이터의 세로 정렬 [ex. "top", "middle", "bottom"]
 * @type Boolean
 * @return Export 성공 유무
 * @author Choe, Hyeon jong.
 */
eXria.controls.xhtml.GridEx.prototype.exportExcelSelectedCols = function(psColIds, pbHeader, psPath, pnStartIdx, pnEndIdx, psVarticalAlign){
  return this.exportExcelMatchHeader(pbHeader, psPath, pnStartIdx, pnEndIdx, psColIds, null, psVarticalAlign);
};
/**
 * Grid의 헤더명을 Export될 Excel의 컬럼명으로 하여 GridEx에 연결된 Dataset을 Excel파일로 export 한다.
 * @param {Boolean} pbHeader Header 유무, false가 넘어올 경우에만 Header를 출력하지 않음
 * @param {String} psPath export할 Excel 화일의 경로명
 * @param {Number} pnStartIdx export할 시작 Index
 * @param {Number} pnEndIdx export할 마지막 Index
 * @param {String} export 할 column id, 여러개일 경우 쉼표로 구분. [ex. "colId1,colId2,colId3"]
 * @param {String} cell안에 데이터의 세로 정렬 [ex. "top", "middle", "bottom"]
 * @type Boolean
 * @return Export 성공 유무
 * @author Choe, Hyeon jong.
 */
eXria.controls.xhtml.GridEx.prototype.exportExcelMatchHeader = function(pbHeader, psPath, pnStartIdx, pnEndIdx, psColIds, pbVisibleOnly, psVarticalAlign){
  if(pbVisibleOnly == null) pbVisibleOnly = true;
  if(psVarticalAlign == null) psVarticalAlign = "middle";
  if(!this.dataset) {
    alert("dataset is null");
    return false;
  }


  // 파일 선택창에서 저장할 파일경로 및 파일명을 지정 부분
  var voModel = this.canvas.page.model;
  var voPlugin = voModel.plugin;
  var voFSO = voModel.getFileSystemObject();
  var vsId = this.id;
  var vsFileName = this.userAttr;
  if(vsFileName == null || vsFileName == "") vsFileName = vsId;

  var voUserAttr = null;
  if(this.userAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);
  }
  if(voUserAttr && !!voUserAttr.excelFileName) {
    vsFileName = voUserAttr.excelFileName;
  }

  psPath = voFSO.showFilePicker("Export Excel File", vsFileName + ".xls", "excel (*.xls)|*.xls|", 4, psPath);
  if(!psPath) return false;

  // export 처리
  try {
    var vsConnId = (new Date().getTime()) + this.datasetId + "conn";
    var conn = voPlugin.getConnection(vsConnId, voPlugin.ETBDATASETSOURCE, this.datasetId, voPlugin.ETBEXCELFILESOURCE, "", psPath);
    var comm = conn.getCommand(vsConnId);

    comm.changeTarget(voPlugin.ETBEXCELFILESOURCE,"",psPath);

  var vnVarticalAlign = comm.EXCEL_VERTICALALIGN_MIDDLE;
  psVarticalAlign = psVarticalAlign.toLowerCase();
  if (psVarticalAlign == "top")    vnVarticalAlign = comm.EXCEL_VERTICALALIGN_TOP;
  else if (psVarticalAlign == "bottom")vnVarticalAlign = comm.EXCEL_VERTICALALIGN_BOTTOM;
  comm.setVerticalAlign(vnVarticalAlign);

    var vaColIds = new Array();
    var vaHeadColIds = this.getHeadColumnList();

    if(psColIds) vaColIds = psColIds.split(",");
    else {
      var voColumn = null;
      for(var vnIndex = 0; vnIndex < vaHeadColIds.length; vnIndex++) {
        voColumn = this.getBodyColumn(null, vaHeadColIds[vnIndex]);
        if(voColumn.visible == false && pbVisibleOnly) continue;
//        vaColIds.push(this.getColRef(vaHeadColIds[vnIndex]));
        if(voColumn.datasetCol) vaColIds.push(voColumn.datasetCol);
      }
    }

    var vaHeadColIds = this.getHeadColumnList();
    var vaTmpColRef = [];
    var vsColRef = null;
    var voBodyCol = null;
    var voReg = null;
    var voMap = null;
    var vaValue = null, vaLabel = null;

    var voFuncReplaceColId = function(psColRef) {
      var vsOriColRef = psColRef;
      psColRef = "__" + psColRef;
      var vnSize = vaColIds.length;

      for(var k = 0; k < vaColIds.length; k++) {
        if(vaColIds[k] == vsOriColRef) {
          vaColIds[k] = psColRef;
          break;
        }
      }

      return psColRef;
    };

    // Enum type일 경우 value가 아닌 label로 출력하기 위한 부분
    var vbSkip = false;
    for(var i = 0, vnLen = vaHeadColIds.length ; i < vnLen ; i++) {
      voBodyCol = this.getBodyColumn(null, vaHeadColIds[i]);
      if(pbVisibleOnly && voBodyCol.visible == false) vbSkip = true;
      else vbSkip = false;
      if(psColIds == null && vbSkip) { continue; }
//      vsColRef = this.getColRef(vaHeadColIds[i]);
      vsColRef = voBodyCol.datasetCol;
      if(vsColRef == null) continue;
      switch(voBodyCol.type) {
        case "Enum" :
          voMap = {};
          vaValue = voBodyCol.itemgroup.getItemValuesToArray();
          vaLabel = voBodyCol.itemgroup.getItemLabelsToArray();
          var vnSize = vaValue.length;
          for(var j = 0; j < vnSize; j++) {
            voMap[vaValue[j]] = vaLabel[j];
          }
          this.addLabelColumn(vsColRef, vaTmpColRef, voMap);
          vsColRef = voFuncReplaceColId(vsColRef);
          break;
        case "Date" :
          this.addDateFormatColumn(vsColRef, vaTmpColRef, voBodyCol);
          vsColRef = voFuncReplaceColId(vsColRef);
          break;
        case "Text" :
        case "Lines" :
          if(!!voBodyCol.regFormat) {
            this.addTextFormatColumn(vsColRef, vaTmpColRef, voBodyCol);
            vsColRef = voFuncReplaceColId(vsColRef);
          }
          break;
      }
      // 헤더를 화면에 보이는 텍스트로 설정
      comm.setFieldMatch(vsColRef, this.getTitleText(vaHeadColIds[i]));
    }

    vsColIds = vaColIds.join(",");
    comm.setColSeq(vsColIds);
    if(pnStartIdx) comm.setMinRow(pnStartIdx);
    if(pnEndIdx) comm.setMaxRow(pnEndIdx);

    // 헤더 출력인 경우의 처리
    var vnExecConst = comm.ETBFIELDNAMENEW | comm.ETBDATAREPLACE;
    if(pbHeader != false) {
      vnExecConst = vnExecConst | comm.ETBFIRSTROWFIELD_TGT;
    }

    comm.executeQuery(vnExecConst);
    comm.setColSeq("");
    conn.close();
    var voDst = this.dataset;
    var vnSize = vaTmpColRef.length;
    var vsTmpCol = null;
    for(var i = 0; i < vnSize; i++) {
      vsTmpCol = vaTmpColRef[i];
      voDst.removeColumn(vsTmpCol);
    }
  }catch(e){
    var voDst = this.dataset;
    var vnSize = vaTmpColRef.length;
    var vsTmpCol = null;
    for(var i = 0; i < vnSize; i++) {
      vsTmpCol = vaTmpColRef[i];
      voDst.removeColumn(vsTmpCol);
    }
    alert(e.description);
    return false;
  }
  return true;
};
/**
 * Enum 등의 List타입 컬럼의 cell값을 excel export시 화면에 보여지는 값으로 내보내기 위해 사용
 * @param {String} psColRef dataset 필드명
 * @param {Array(String)} paTmpColRef 임시적으로 추가되는 Label컬럼 명세를 저장하기 위한 배열
 * @param {Object} poMap dataset 필드에 매핑되는 label값을 얻어오기 위한 Map 객체
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addLabelColumn = function(psColRef, paTmpColRef, poMap) {
  var voDst = this.dataset;
  var vsTmpColRef = "__" + psColRef;
  paTmpColRef.push(vsTmpColRef);
  voDst.addColumn(-1, vsTmpColRef);

  var vnSize = voDst.getRowCnt();
  var vsValue = null;
  var vsLabel = null;
  for(var i = 1; i <= vnSize; i++) {
    vsValue = voDst.get(i, psColRef);
    vsLabel = poMap[vsValue];
    if(vsLabel == null || vsLabel == "&nbsp") vsLabel = "";
    voDst.simpleSet(i, vsTmpColRef, vsLabel);
  }
};
/**
 * Date 타입 컬럼의 cell값을 excel export시 화면에 보여지는 값으로 내보내기 위해 사용
 * @param {String} psColRef dataset 필드명
 * @param {Array(String)} paTmpColRef 임시적으로 추가되는 Label컬럼 명세를 저장하기 위한 배열
 * @param {eXria.controls.xhtml.GridEx.BodyColumn} poBodyCol DateFormat 정보를 저장하고 있는 BodyColumn 객체
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addDateFormatColumn = function(psColRef, paTmpColRef, poBodyCol) {
  var voDst = this.dataset;
  var vsTmpColRef = "__" + psColRef;
  paTmpColRef.push(vsTmpColRef);
  voDst.addColumn(-1, vsTmpColRef);

  var vnSize = voDst.getRowCnt();
  var vsValue = null;
  var vsLabel = null;
  for(var i = 1; i <= vnSize; i++) {
    vsValue = voDst.get(i, psColRef);
    vsValue = this.convertValueTGrid(poBodyCol, vsValue, null, poBodyCol.colId);
    vsLabel = TGP.GetString(vsValue, "date", poBodyCol.regFormat);
    if(vsLabel == null || vsLabel == "&nbsp") vsLabel = "";
    voDst.simpleSet(i, vsTmpColRef, vsLabel);
  }
};
/**
 * Text나 Lines타입 컬럼의 cell값을 excel export시 화면에 보여지는 값으로 내보내기 위해 사용
 * @param {String} psColRef dataset 필드명
 * @param {Array(String)} paTmpColRef 임시적으로 추가되는 Label컬럼 명세를 저장하기 위한 배열
 * @param {eXria.controls.xhtml.GridEx.BodyColumn} poBodyCol format 정보를 저장하고 있는 BodyColumn 객체
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addTextFormatColumn = function(psColRef, paTmpColRef, poBodyCol) {
  var voDst = this.dataset;
  var vsTmpColRef = "__" + psColRef;
  paTmpColRef.push(vsTmpColRef);
  voDst.addColumn(-1, vsTmpColRef);

  var vnSize = voDst.getRowCnt();
  var vsValue = null;
  var vsLabel = null;
  for(var i = 1; i <= vnSize; i++) {
    vsValue = voDst.get(i, psColRef);
    vsLabel = TGP.GetString(vsValue, "string", poBodyCol.regFormat);
    if(vsLabel == null || vsLabel == "&nbsp") vsLabel = "";
    voDst.simpleSet(i, vsTmpColRef, vsLabel);
  }
};
//yhkim 2009.04.22
/**
 * enum list를 설정한다
 * @param {Object} poRow 현재 row
 * @param {String} psCol 현재 column
 * @param {String} psEnum 설정하려는 enum값
 * @param {String} psEnumKeys 설정하려는 enumkey값
 * @param {String} psValue 인덱스설정
 */
eXria.controls.xhtml.GridEx.prototype.setEnumList = function(poRow, psCol, psEnum, psEnumKeys, psValue){
  var vsColumnEnum = psCol + "Enum";
  var vsColumnEnumKey = psCol + "EnumKeys";
  poRow[vsColumnEnum] = psEnum;
  poRow[vsColumnEnumKey] = psEnumKeys;
  this.setValue(poRow, psCol, psValue, true);
};
/**
 * select list를 설정한다
 * @param {Object} poRow 현재 row
 * @param {String} psCol 현재 column
 * @param {String} psSelect 설정하려는 selectString 값
 * @param {String} psDefault 설정하려는 인덱스 설정, Default index는 0
 * @param {String} psDefault 설정하려는 Select의 index를 찾기위한 Delimeter, 기본값은 "|"
 * @ignore
 */
/*
eXria.controls.xhtml.GridEx.prototype.setSelectList = function(poRow, psCol, psSelect, piDefaultIndex, psDelimeter){
  var vsColumnSelect = psCol + "Defaults";
  if(poRow.setAttribute) poRow.setAttribute(vsColumnSelect, psSelect);
  else poRow[vsColumnSelect] = psSelect;

  var vsDelimeter = psDelimeter;
  if(vsDelimeter == null)
    vsDelimeter = "|";

  var vsArray = null;
  if(piDefaultIndex > 0){
    vsArray = psSelect.split('|', piDefaultIndex+2);
    if(vsArray.length > 1)
      psDefault = vsArray[piDefaultIndex+1];
  }

  this.setValue(poRow, psCol, psDefault);
  this.refreshCell(poRow,psCol);
};
*/
/**
 * 정해진 문자형 마스크 포맷으로 값을 변환.
 * @param {String} psValue 컨트롤 disabled설정
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.toStringFormatValue = function(psValue, psFormat){
  if(psValue == "") return "";
  var vsMaskPrompt = String.fromCharCode(255);
  var vsFormat = psFormat.replace(/[x#*]/gi,vsMaskPrompt);
  var vsReg = new RegExp('['+vsMaskPrompt+']','gi');
  var vsValue = psValue.replace(vsReg,"0");
  var vsRegValue = vsFormat;
  var vsRegFormat = new RegExp('['+vsMaskPrompt+']','i');
  for(var i=0;i < vsValue.length;i++) {
    vsRegValue = vsRegValue.replace(vsRegFormat, vsValue.charAt(i));
  }
  vsRegValue = vsRegValue.replace(/[x#*]/gi, vsMaskPrompt);
  return vsRegValue;
};
/**
 * 마스크 프롬프트를 공백문자롤 치환하는 메소드
 * @param {String} psValue 컨트롤 disabled설정
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.maskPromptToBlank = function(psValue){
  var vsMaskPrompt = String.fromCharCode(255);
  var vsReg = new RegExp('['+vsMaskPrompt+']','gi');
  psValue = psValue.replace(vsReg, "");
  return psValue;
};
/**
 * 주어진 data형 value에 따라 column type을 설정하기 위한 메소드.
 * @param {String} psColId column id
 * @param {String} psValue value
 * @private;
 */
eXria.controls.xhtml.GridEx.prototype.setDateValueType = function(psColId, psValue){
  var voColumn = this.getBodyColumn(null, psColId);
  psValue = String(psValue);
  psValue = psValue.replace(/\D/g, "");
  if(psValue.length == 14){ // datetime
    voColumn.dateType = "DateTime";
  }else if(psValue.length == 8){ // date
    voColumn.dateType = "Date";
  }else if(psValue.length == 6){ // time
    voColumn.dateType = "Time";
  }
};
/**
 * 주어진 column에 해당하는 format으로 value를 변환시켜 반환하는 메소드.
 * @param {String} psValue value
 * @param {String} psColId column id
 * @return 주어진 column에 해당하는 format으로 value를 변환시킨 값
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getFormattedValue = function(psValue, psColId){
  var voColumn = this.getBodyColumn(null, psColId);
  if(voColumn.formatMask){
    psValue = voColumn.formatMask.toStringFormatValue(psValue, voColumn.format, psColId);
    psValue = voColumn.formatMask.maskPromptToBlank(psValue, psColId);
  }
  return psValue;
};
/**
 * 값을 지정된 Mask에 맞게 변환하여 반환
 * @param {String} psData Data
 * @param {String} psColId Column Id
 * @return 값을 지정된 Mask에 맞게 변환한 문자열
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getMaskedValue = function(poInput, poRow, psColId){
  var voColumn = this.getBodyColumn(null, psColId);

  if(voColumn.formatMask){
    return voColumn.formatMask.getMaskedValue(poInput, poRow, psColId);
  }
  return poInput.value;
};
/**
 * Mask가 적용된 Value를 Mask를 없앤 후 반환
 * @param {String} psData Data
 * @param {String} psColId Column Id
 * @return value에서 Mask가 제거된 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getUnMaskedValue = function(psData, psColId){
  var voColumn = this.getBodyColumn(null, psColId);
  if(voColumn.formatMask){
   psData = voColumn.formatMask.getUnMaskedValue(psData, psColId);
  }
  return psData;
};
/**
 * 현재 텍스트가 전체 select 되어있는지 여부를 확인
 * @param {HTMLEvent} e 윈도우 이벤트
 * @param {HTMLInput} poInput html inputbox
 * @param {String} psColId column id
 */
eXria.controls.xhtml.GridEx.prototype.checkSelect = function(e, poInput, psColId){
  var voColumn = this.getBodyColumn(null, psColId);

  if(voColumn.formatMask){
    voColumn.formatMask.checkSelect(e, poInput, psColId);
  }
};
/**
 * 입력키에 유효성을 체크하고 마스크 타입에 맞게 문자열 변환 메소드.
 * @param {HTMLEvent} e 윈도우이벤트
 * @param {HTMLInput} poInput html inputbox
 * @param {String} psColId column id
 * @return 작업수행의 성공 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.checkKey = function(e, poInput, psColId){
  var voColumn = this.getBodyColumn(null, psColId);

  if(voColumn.formatMask){
    return voColumn.formatMask.checkKey(e, poInput, psColId);
  }
};
/**
 * KeyDown value 설정
 * @param {String} psValue value
 * @param {Object} poRow row object
 * @param {String} psColId
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setKeyDownValue = function(psValue, poRow, psColId){
  var voColumn = this.getBodyColumn(null, psColId);

  if(voColumn.formatMask){
    voColumn.formatMask.setKeyDownValue(psValue, poRow, psColId);
  }
};
/**
 * 값을 yyyymmdd형태의 문자열 값으로 반환.
 * @param psData 값
 * @param psColId Column Id
 * @return yyyymmdd형태의 문자열 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getDateString = function(psData, psColId){
  var voDate = this.getDate(psData, psColId);
  var vaStrBuf = [];
  vaStrBuf.push(voDate.getFullYear());
  var vnMonth = voDate.getMonth() + 1;
  if(vnMonth < 10) vnMonth = "0" + vnMonth;
  vaStrBuf.push(vnMonth);
  var vnDate = voDate.getDate();
  if(vnDate < 10) vnDate = "0" + vnDate;
  vaStrBuf.push(vnDate);

  return vaStrBuf.join("");
};
/**
 * 값을 Date형태로 반환.
 * @param psData 값
 * @param psColId Column Id
 * @return Date형으로 변환된 컨트롤 설정 값
 * @type Date
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getDate = function(psData, psColId){
  var voColumn = this.getBodyColumn(null, psColId);
  var voDate = new Date();
  var vsValue = psData;
  var vsMask = voColumn.mask;
  var vsFormat = vsMask.replace(/[^YMD]/gi,"");
  vsValue = vsValue.replace(/[^0-9]/gi,"");
  var vnIndex = vsValue.length;
  //year
  var temp = vsFormat.indexOf("YYYY",0);
  var vnYear = vsValue.substring(temp,temp+4);
  if(vnYear.length == 4) voDate.setFullYear(vnYear);
  //month
  var temp = vsFormat.indexOf("MM",0);
  var vnMonth = vsValue.substring(temp,temp+2);
  if(vnMonth.length == 2) voDate.setMonth(vnMonth-1);
  //date
  var temp = vsFormat.indexOf("DD",0);
  var vnDate = vsValue.substring(temp,temp+2);
  if(vnDate.length == 2) voDate.setDate(vnDate);

  return voDate;
};
/**
 * addSeparator
 * @param {String} psValue value
 * @param {Number} pnType 데이타형 value의 format을 구분 짓기 위한 정수 값.
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @return Separator가 추가된 value 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.addSeparator = function(psValue, pnType, poRow, psColId){
  if(!pnType) pnType = 1;
  var vsDateSep = "-";
  if(pnType == 2) vsDateSep = "/";
  psValue = String(psValue);

  var voColumn = this.getBodyColumn(null, psColId);

  function addDateSeparator(psDate){
    return psDate.substring(0, 4) + vsDateSep + psDate.substring(4, 6) + vsDateSep + psDate.substring(6, 8);
  }
  function addTimeSeparator(psTime){
    return psTime.substring(0, 2) + ":" + psTime.substring(2, 4) + ":" + psTime.substring(4, 6);
  }
  var vnlen = psValue.length;
  if(psValue.length == 14){ // datetime
    if(voColumn) {
      if(voColumn.dateType == null) {
        voColumn.dateType = "DateTime";
        voColumn.maxLength = 14;
      }
    }
    var vsDate = psValue.substring(0, 8);
    var vsTime = psValue.substring(8, 14);
    vsDate = addDateSeparator(vsDate);
    vsTime = addTimeSeparator(vsTime);
    psValue = vsDate + " " + vsTime;
  }else if(psValue.length == 8){ // date
    if(voColumn) {
      if(voColumn.dateType == null) {
        voColumn.dateType = "Date";
        voColumn.maxLength = 8;
      }
    }
    psValue = addDateSeparator(psValue);
  }else if(psValue.length == 6){ // time
    if(voColumn) {
      if(voColumn.dateType == null) {
        voColumn.dateType = "Time";
        voColumn.maxLength = 6;
      }
    }
    psValue = addTimeSeparator(psValue);
  }
  return psValue;
};
/**
 * Title의 Text를 획득
 * @param {String} psCol headColumn의 ID
 * @return Title의 Text
 * @type String
 */
eXria.controls.xhtml.GridEx.prototype.getTitleText = function(psCol){
  var voCols = [],
      voHeader = this.header,
      i,j,k,voRow, vnLength, vnLength2,
      voArray=[], voColumn, vsTitle;

  voCols[0] = voHeader.cols["left"];
  voCols[1] = voHeader.cols["center"];
  voCols[2] = voHeader.cols["right"];

  pastureLoop:
  for(var i = 0; i < 3; i++) {
    if(voCols[i]) {
      vnLength = voCols[i].rows.length;
      for(var j=0; j < vnLength; j++){
        if(voHeader.mainRow != j) continue;
        voRow = voCols[i].rows[j];
        for ( var k = 0; voRow.columns.length > k; k++) {
          voColumn = voRow.columns[k];
          if(voColumn.id == psCol) {
            vsTitle = voColumn.value;
            break pastureLoop;
          }
        }
      }
    }
  }

  return vsTitle;

  /*
  var vsTitle = null;
  if(this.grid.XHeader.getAttribute) vsTitle = this.grid.XHeader.getAttribute(psCol);
  else vsTitle = this.grid.XHeader[psCol];
  return vsTitle;
  */

};
/**
 * Title의 Text를 설정
 * @param {String} psCol headColumn의 ID
 * @param {String} psValue 설정될 Text
 */
eXria.controls.xhtml.GridEx.prototype.setTitleText = function(psCol, psValue, poRow){
  var voCols = [],
  voHeader = this.header,
  i,j,k,voRow, voTRow, vnLength, vnLength2,
  voArray=[], voColumn;

  voCols[0] = voHeader.cols["left"];
  voCols[1] = voHeader.cols["center"];
  voCols[2] = voHeader.cols["right"];
  
  pastureLoop:
  for(var i = 0; i < 3; i++) {
    if(voCols[i]) {
      vnLength = voCols[i].rows.length;
      for(var j=0; j < vnLength; j++){
        if(voHeader.mainRow != j) continue;
        voRow = voCols[i].rows[j];
        for ( var k = 0; voRow.columns.length > k; k++) {
          voColumn = voRow.columns[k];
          if(voColumn.id == psCol) {
            voColumn.value = psValue;
            if(poRow) {
             this.grid.SetValue(poRow, psCol, psValue, true); 
            } else {
              voTRow = this.getHeaderRowByIndex(j);
              this.grid.SetValue(voTRow, psCol, psValue, true); 
            }
            break pastureLoop;
          }
        }
      }
    }
  }
};
/**
 * Column을 숨김
 * @param {String} psCol 적용시킬 headColumn의 ID
 */
eXria.controls.xhtml.GridEx.prototype.hideColumn = function(psCol){
  this.hideColMap.put(psCol, "");
  this.grid.HideCol(psCol);
};
/**
 * Column을 보임
 * @param {String} psCol 적용시킬 headColumn의 ID
 */
eXria.controls.xhtml.GridEx.prototype.showColumn = function(psCol){
  this.hideColMap.remove(psCol);
  this.grid.ShowCol(psCol);
};
/**
 * Row를 숨김
 * @param {Object} poRow 적용시킬 Row
 */
eXria.controls.xhtml.GridEx.prototype.hideRow = function(poRow){
  this.grid.HideRow(poRow);
};
/**
 * Row를 보임
 * @param {Object} poRow 적용시킬 Row
 */
eXria.controls.xhtml.GridEx.prototype.showRow = function(poRow){
  this.grid.ShowRow(poRow);
};
/**
 * CanEdit를 설정
 * @param {Object} poRow 설정될 Row
 * @param {String} psCol 설정될 Column의 headColumn의 ID, null일경우 Row에 설정
 * @param {Boolean} pbEdit 설정될 값
 */
eXria.controls.xhtml.GridEx.prototype.setCanEdit = function(poRow, psCol, pbEdit){
  var vsAttrName = null;
  if(psCol) vsAttrName = psCol + "CanEdit";
  else vsAttrName = "CanEdit";

  if(poRow) {
    poRow[vsAttrName] = pbEdit;
    var voBodyCol = this.getBodyColumn(null, psCol);

    //2010.09.02 voBodyCol이 null이 될경우
    //에 대한 처리 코드 추가
    if((!!voBodyCol) && voBodyCol.type == "Date") {
      if (!pbEdit) {
        poRow["Button"] = "None";
      } else if(voBodyCol.calendarEnable) {
        poRow["Button"] = "Date";
      }
    }
    this.refreshRow(poRow);
  }
};
/**
 * CanFocus를 설정
 * @param {Object} poRow 설정될 Row
 * @param {String} psCol 설정될 Column의 headColumn의 ID, null일경우 Row에 설정
 * @param {Boolean} pbFocus 설정될 값
 */
eXria.controls.xhtml.GridEx.prototype.setCanFocus = function(poRow, psCol, pbFocus){
  var vsAttrName = null;
  if(psCol) vsAttrName = psCol + "CanFocus";
  else vsAttrName = "CanFocus";

  poRow[vsAttrName] = pbFocus;

  this.refreshRow(poRow);
};
/**
 * CanDrag를 설정
 * @param {Object} poRow 설정될 Row
 * @param {String} psCol 설정될 Column의 headColumn의 ID, null일경우 Row에 설정
 * @param {Boolean} pbDrag 설정될 값
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setCanDrag = function(poRow, pbDrag){
  poRow["CanDrag"] = pbDrag;

  this.refreshRow(poRow);
};
/**
 * 주어진 row object가 자식 row를 가지고 있는지 여부를 알려주는 메소드
 * @param {Object} poRow row object
 * @return 주어진 row object가 자식 row를 가지고 있는지 여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.hasChildren = function(poRow){
  if(this.grid.HasChildren(poRow)) return true;
  else return false;
};
/**
 * 새로운 창으로 GridEx를 프린트
 * @return 프린트의 성공여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.print = function(){
  return this.grid.ActionPrint();
};
/**
 * Cell의 InnerStyle을 적용
 * @return 스타일 적용여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.setCellInnerStyle = function(poRow, psCol, psStyleAttr, psStyleValue){
  var voCtrl = this.grid.GetCell(poRow, psCol);
  if(voCtrl == null) return false;
  if(voCtrl.style == null) return false;
  var voStyle = voCtrl.style;
  voStyle[psStyleAttr] = psStyleValue;
  return true;
};
/**
 * Cell의 OuterStyle을 적용
 * @return 스타일 적용여부
 * @type Boolean
 */
eXria.controls.xhtml.GridEx.prototype.setCellOuterStyle = function(poRow, psCol, psStyleAttr, psStyleValue){
  var voCtrl = this.grid.GetCell(poRow, psCol);
  if(voCtrl){
    var voStyle = voCtrl.style;
    voStyle[psStyleAttr] = psStyleValue;
    return true;
  }
  return false;
};

/**
 * HeadColumn의 ID 리스트를 얻어오기
 * pnSection : 0(LeftCols), 1(Cols), 2(RightCols), null(all)
 * @return HeadColumn의 ID리스트
 * @type Array(String)
 */
eXria.controls.xhtml.GridEx.prototype.getHeadColumnList = function(pnSection) {

  var voCols = new Array();
  var voColumn = null;

  if(pnSection == 0)
    voCols[0] = this.body.cols["left"];
  else if(pnSection == 1)
    voCols[0] = this.body.cols["center"];
  else if(pnSection == 2) {
    voCols[0] = this.body.cols["right"];
  }
  else if(pnSection == null) {
    voCols[0] = this.body.cols["left"];
    voCols[1] = this.body.cols["center"];
    voCols[2] = this.body.cols["right"];
  }
  else
    return voCols;

  var vsCols = new Array();

  for(var i=0; i<voCols.length; i++) {
    if(voCols[i]) {
      for(var j=0; j<voCols[i].rows.length; j++) {
        voColsRow = voCols[i].rows[j];
        for(var k=0; k<voColsRow.columns.length; k++) {
            voColumn = voColsRow.columns[k];
            vsCols.push(voColumn.colId);
        }
      }
    }
  }
  return vsCols;
};

/**
 * @class Concreate xhtml GridEx.Header<br>
 * GridEx 컨트롤의 헤더부분 구성정보 담당 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx} poParent 상위 그리드 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.Header 객체
 * @type eXria.controls.xhtml.GridEx.Header
 * @constructor
 */
eXria.controls.xhtml.GridEx.Header = function(poParent) {
  /**
   * 상위 객체 지정.
   * @type eXria.controls.xhtml.GridEx
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent;
  /**
   * left, center, right 컬럼그룹 저장 배열.
   * @type Array
   */
  this.cols = new Array(3);
  /**
   * 헤더의 컬럼 타이틀을 구성하는 메인 row index.
   * @type Number
   */
  this.mainRow = null;
  /**
   * 헤더의 표시 여부
   * @type Boolean
   */
  this.visible = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 배경색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 텍스트 가로 정렬 방식.(left | center | right)
   * @type String
   */
  this.textAlign = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 텍스트 밑줄 적용 방식.(underline | overline | line-through | blink)
   * @type String
   */
  this.textDecoration = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 폰트 패밀리.
   * @type String
   */
  this.fontFamily = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 폰트 사이즈.
   * @type Number
   */
  this.fontSize = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 폰트 스타일.
   * @type String
   */
  this.fontStyle = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 폰트 두께.
   * @type Number
   */
  this.fontWeight = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 보더 색상.
   * @type Number
   */
  this.borderColor = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 보더 스타일.
   * @type String
   */
  this.borderStyle = null;
  /**
   * 헤더 컬럼 셀의 공통적으로 적용될 보더 두께.
   * @type Number
   */
  this.borderWidth = null;
  /**
   * 스타일의 속성의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {};
};

/**
 * 컬럼그룹 생성.
 * @return 컬럼그룹
 * @type eXria.controls.xhtml.Columns
 */
eXria.controls.xhtml.GridEx.Header.prototype.createCols = function() {
  return new eXria.controls.xhtml.GridEx.Cols(this);
};
/**
 * 컬럼그룹 추가.
 * @param {eXria.controls.xhtml.GridEx.Columns} poCols 추가될 컬럼 그룹
 * @param {String} psType 컬럼 위치 정보('left' | 'center' | 'right')
 */
eXria.controls.xhtml.GridEx.Header.prototype.addCols = function(poCols, psType) {
  poCols.type = psType;
  if(psType == "left") this.cols[psType] = poCols;
  else if(psType == null || psType == "center") this.cols[psType] = poCols;
  else if(psType == "right") this.cols[psType] = poCols;
};


/**
 * @class Concreate xhtml GridEx.Body.<br>
 * Grid 컨트롤의 컨텐츠 구성정보 당담 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx} poParent 상위 그리드 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.Body 객체
 * @type eXria.controls.xhtml.GridEx.Body
 * @constructor
 */
eXria.controls.xhtml.GridEx.Body = function(poParent) {
  /**
   * 상위 객체 지정.
   * @type eXria.controls.xhtml.GridEx
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent;
  /**
   * left, center, right 컬럼그룹 저장 배열.
   * @type Array
   */
  this.cols = new Array(3);
  /**
   * 스타일 속성의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * height.
   * @type Number
   */
  this.height = null;
};
/**
 * 컬럼그룹 생성.
 * @return 컬럼그룹
 * @type eXria.controls.xhtml.Columns
 */
eXria.controls.xhtml.GridEx.Body.prototype.createCols = function() {
  return new eXria.controls.xhtml.GridEx.Cols(this);
};
/**
 * 컬럼그룹 추가.
 * @param {eXria.controls.xhtml.GridEx.Columns} 추가될 컬럼 그룹
 * @param {String} psType 컬럼 위치 정보('left' | 'center' | 'right')
 */
eXria.controls.xhtml.GridEx.Body.prototype.addCols = function(poCols, psType) {
  poCols.type = psType;
  if(psType == "left") this.cols[psType] = poCols;
  else if(psType == null || psType == "center") this.cols[psType] = poCols;
  else if(psType == "right") this.cols[psType] = poCols;
};


/**
 * @class Concreate xhtml GridEx.FunctionRow.<br>
 * Grid 컨트롤의 컨텐츠 구성정보 당담 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx} poParent 상위 그리드 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.FunctionRow 객체
 * @type eXria.controls.xhtml.GridEx.FunctionRow
 * @constructor
 */
eXria.controls.xhtml.GridEx.FunctionRow = function(poParent) {
  /**
   * 상위 객체 지정.
   * @type eXria.controls.xhtml.GridEx
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent;
  /**
   * 스타일 속성의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * height.
   * @type Number
   */
  this.height = null;
  /**
   * row object들을 저장하는 배열.
   * @type Array(Object)
   */
  this.rows = new Array();
};


/**
 * @class Concreate xhtml GridEx.Footer.<br>
 * Grid 컨트롤의 footer 컨텐츠 구성정보 당담 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx} poParent 상위 그리드 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.Footer 객체
 * @type eXria.controls.xhtml.GridEx.Footer
 * @constructor
 */
eXria.controls.xhtml.GridEx.Footer = function(poParent) {
  /**
   * 상위 객체 지정.
   * @type eXria.controls.xhtml.GridEx
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent;
  /**
   * 스타일 속성의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * height.
   * @type Number
   */
  this.height = null;
  /**
   * row object들을 저장하는 배열.
   * @type Array(Object)
   */
  this.rows = new Array();
};
/**
 * row object 생성 메소드
 * @return 새로 생성된 row object
 * @type eXria.controls.xhtml.GridEx.FootRow
 */
eXria.controls.xhtml.GridEx.Footer.prototype.createRow = function(){
  return new eXria.controls.xhtml.GridEx.FootRow(this);
};
/**
 * rows에 row object를 추가하기 위한 메소드
 * @param {Object} poRow row object
 */
eXria.controls.xhtml.GridEx.Footer.prototype.addRow = function(poRow){
  this.rows.push(poRow);
};


/**
 * @class Concreate xhtml Columns.<br>
 * 컬럼그룹 구성을 구성하기 위한 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridHeader|eXria.controls.xhtml.GridBody} poParent 상위 객체
 * @return 새로운 eXria.controls.xhtml.Columns 객체
 * @type eXria.controls.xhtml.Columns
 * @constructor
 */
eXria.controls.xhtml.GridEx.Cols = function(poParent) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 컬럼구룹 타입('left' | 'center' | 'right').
   * @type String
   */
  this.type = null;
  /**
   * 스크롤 바 표시 여부.
   * @type Boolean
   */
  this.noscroll = true;
  /**
   * 행 저장 배열.
   * @type Array
   */
  this.rows = new Array();
};
/**
 * ColumnsRow 생성 메소드.
 * @return 새로운 ColumnsRow 객체
 * @type eXria.controls.xhtml.GridEx.ColumnsRow
 */
eXria.controls.xhtml.GridEx.Cols.prototype.createColsRow = function() {
  var voColsRow = new eXria.controls.xhtml.GridEx.ColsRow(this);
  return voColsRow;
};
/**
 * ColumnsRow 추가 메소드.
 * @param {eXria.controls.xhtml.GridEx.ColumnsRow} poColsRow 추가할 ColumnsRow객체
 */
eXria.controls.xhtml.GridEx.Cols.prototype.addColsRow = function(poColsRow) {
  this.rows.push(poColsRow);
};


/**
 * @class Concreate xhtml FootCols.<br>
 * 컬럼그룹 구성을 구성하기 위한 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridHeader|eXria.controls.xhtml.FootRow} poParent 상위 객체
 * @return 새로운 eXria.controls.xhtml.FootCols 객체
 * @type eXria.controls.xhtml.FootCols
 * @constructor
 */
eXria.controls.xhtml.GridEx.FootCols = function(poParent) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 컬럼구룹 타입('left' | 'center' | 'right').
   * @type String
   */
  this.type = null;
  /**
   * 스크롤 바 표시 여부.
   * @type Boolean
   */
  this.noscroll = true;
  /**
   * 컬럼 저장 배열. // FootRow용
   * @type Array
   */
  this.columns = new Array();
};
/**
 * 새로운 풋 컬럼을 생성하여 반환
 * @param {String} psId 컬럼식별자
 * @param {String} psType 테이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 풋 컬럼 객체
 * @type eXria.controls.xhtml.FootColumn
 */
eXria.controls.xhtml.GridEx.FootCols.prototype.createFootColumn = function(psId, psHeadColId, psType, psInstanceid, psRef) {
  var voColumn = new eXria.controls.xhtml.GridEx.FootColumn(this, psId, psHeadColId, psType, psInstanceid, psRef);
  return voColumn;
};
/**
 * 컬럼 추가
 * @param {eXria.controls.xhtml.FootColumn} poColumn 추가될 컬럼
 */
eXria.controls.xhtml.GridEx.FootCols.prototype.addColumn = function(poColumn) {
  this.columns.push(poColumn);
  var vcGrx = this.control;
  vcGrx.footColMap.put(poColumn.id, poColumn);
};

/**
 * @class Concreate xhtml GridEx.ColumnsRow.<br>
 * 컬럼그룹 Row를 구성하기 위한 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx.Columns} poParent 상위 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.ColumnsRow 객체
 * @type eXria.controls.xhtml.GridEx.ColumnsRow
 * @constructor
 */
eXria.controls.xhtml.GridEx.ColsRow = function(poParent) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 객체 식별자
   * @type String
   */
  this.id = null;
  /**
   * 컬럼 저장 배열.
   * @type Array
   */
  this.columns = new Array();

  this.height = null;
};
/**
 * 새로운 헤드 컬럼을 생성하여 반환.
 * @param {String} psId 컬럼식별자
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 헤드 컬럼
 * @type eXria.controls.xhtml.GridEx.HeadColumn
 */
eXria.controls.xhtml.GridEx.ColsRow.prototype.createHeadColumn = function(psId, psInstanceid, psRef) {
  var voColumn = new eXria.controls.xhtml.GridEx.HeadColumn(this.parent, psId, psInstanceid, psRef);
  return voColumn;
};
/**
 * 새로운 바디 컬럼을 생성하여 반환
 * @param {String} psId 컬럼식별자
 * @param {String} psType 테이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 바디 컬럼
 * @type eXria.controls.xhtml.GridEx.BodyColumn
 */
eXria.controls.xhtml.GridEx.ColsRow.prototype.createBodyColumn = function(psId, psHeadColId, psType, psInstanceid, psRef) {
  var voColumn = new eXria.controls.xhtml.GridEx.BodyColumn(this, psId, psHeadColId, psType, psInstanceid, psRef);
  return voColumn;
};
//yhkim 2009.05.19 head 컬럼
/**
 * 새로운 Fuction Column을 생성하여 반환하는 메소드
 * @param {String} psId 새로운 Fuction Column의 id
 * @param {String} psInstanceid 참조 instance id
 * @param {String} psRef 참조 ref 정보
 */
eXria.controls.xhtml.GridEx.ColsRow.prototype.createFunctionColumn = function(
    psId, psInstanceid, psRef) {
  var voColumn = new eXria.controls.xhtml.GridEx.FunctionColumn(this.parent,
      psId, psInstanceid, psRef);
  return voColumn;
};
/**
 * 컬럼 추가
 * @param {eXria.controls.xhtml.GridEx.HeadColumn|eXria.controls.xhtml.GridEx.BodyColumn} poColumn 추가될 컬럼
 */
eXria.controls.xhtml.GridEx.ColsRow.prototype.addColumn = function(poColumn) {
  this.columns.push(poColumn);
  var vcGrx = this.control;
  if(poColumn.ganttId) {
    vcGrx.cfg.ganttIdColumn = poColumn.ganttId;
    vcGrx.cfg.idColumn = poColumn.ganttId;
  }
  if(poColumn instanceof eXria.controls.xhtml.GridEx.HeadColumn) {
    vcGrx.headColMap.put(poColumn.id, poColumn);
  } else if(poColumn instanceof eXria.controls.xhtml.GridEx.BodyColumn) {
    vcGrx.bodyColMap.put(poColumn.id, poColumn);
    vcGrx.bodyColHMap.put(poColumn.colId, poColumn);
    if(poColumn.userAttr) {
      if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(poColumn.userAttr)) poColumn.userAttrObj = eval(poColumn.userAttr);
    }
  } else if(poColumn instanceof eXria.controls.xhtml.GridEx.FunctionColumn) {
    vcGrx.functionColMap.put(poColumn.id, poColumn);
  }
};

/**
 * @class Concreate xhtml GridEx.FootRow.<br>
 * FootRow를 구성하기 위한 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx.Columns} poParent 상위 객체
 * @return 새로운 eXria.controls.xhtml.GridEx.FootRow 객체
 * @type eXria.controls.xhtml.GridEx.FootRow
 * @constructor
 */
eXria.controls.xhtml.GridEx.FootRow = function(poParent) {
  /**
   * 상위 객체 지정.
   * @private
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 객체 식별자
   * @type String
   */
  this.id = null;
  /**
   * left, center, right 컬럼그룹 저장 배열.
   * @type Array
   */
  this.cols = new Array(3);
  /**
   * 스타일 속성의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * height.
   * @type Number
   */
  this.height = null;
};
/**
 * 새로운 컬럼그룹 생성.
 * @return 새로운 컬럼그룹
 * @type eXria.controls.xhtml.Columns
 */
eXria.controls.xhtml.GridEx.FootRow.prototype.createCols = function() {
  return new eXria.controls.xhtml.GridEx.FootCols(this);
};
/**
 * 컬럼그룹 추가.
 * @param {eXria.controls.xhtml.GridEx.Columns} poCols 추가될 컬럼 그룹
 * @param {String} psType 컬럼 위치 정보('left' | 'center' | 'right')
 */
eXria.controls.xhtml.GridEx.FootRow.prototype.addCols = function(poCols, psType) {
  poCols.type = psType;
  if(psType == "left") this.cols[psType] = poCols;
  else if(psType == null || psType == "center") this.cols[psType] = poCols;
  else if(psType == "right") this.cols[psType] = poCols;
};


/**
 * @class Concreate xhtml HeadColumn.<br>
 * GridHeader에 추가될 컬럼을 구성하기 위한 클래스.
 * @version 1.0
 * @param {eXria.controls.xhtml.ColumnsRow} poParent 상위 객체
 * @param {String} psId 해당 컬럼과 매핑되고 해드컬럼의 ID
 * @param {String} psType 데이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Intance Path
 * @return 새로운 eXria.controls.xhtml.GridEx.HeadColumn 객체
 * @type eXria.controls.xhtml.GridEx.HeadColumn
 * @constructor
 */
eXria.controls.xhtml.GridEx.HeadColumn = function(poParent, psId, psInstanceId, psRef) {
  /**
   * 상위 객체 지정
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 컬럼 식별자.
   * @type String
   */
  this.id = psId;
  /**
   * instanceId
   * @type String
   */
  this.instanceId = psInstanceId;
  /**
   * ref
   * @type String
   */
  this.ref = psRef;
  /**
   * 인스턴스 데이타 접근 객체.
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this.control);
  /**
   * datasetCol
   * @type String
   */
  this.datasetCol = null;
  /**
   * 컬럼 표시 문자열.
   * @type String
   */
  this.value = null;
  /**
   * 컬럼 셀의 배경색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 컬럼 셀의 폰트색상.
   * @type String
   */
  this.color = null;
  /**
   * 컬럼의 적용될 CSS Class
   * @type String
   */
  this.className = null;
  /**
   * 컬럼의 마우스 오버 시에 적용될 CSS Class
   * @type String
   */
  this.hoverClassName = null;
  /**
   * 텍스트 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 컬럼 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * @ignore
   */
  this.field = null;
  /**
   * rowSpan.
   * @type Number
   */
  this.rowspan = null;
  /**
   * colSpan.
   * @type Number
   */
  this.colspan = null;
  /**
   * dojo type object.
   * It will be created when ColumnsRow's addColumn method called.
   * @type Object
   * @ignore
   */
  this.cell = null;
  /**
   * 컬럼을 보여줄지 여부.
   * @type Boolean
   */
  this.visible = null;
  /**
   * 첫번째 헤더 라인의 날짜 영역 (들어올수 있는 값은 ganttUnits와 동일)
   * @type String
   */
  this.ganttHeader1 = null;
  /**
   * 두번째 헤더 라인의 날짜 영역 (들어올수 있는 값은 ganttUnits와 동일)
   * @type String
   */
  this.ganttHeader2 = null;
  /**
   * 세번째 헤더 라인의 날짜 영역 (들어올수 있는 값은 ganttUnits와 동일)
   * @type String
   */
  this.ganttHeader3 = null;
  /**
   * 네번째 헤더 라인의 날짜 영역 (들어올수 있는 값은 ganttUnits와 동일)
   * @type String
   */
  this.ganttHeader4 = null;
  /**
   * 다섯번째 헤더 라인의 날짜 영역 (들어올수 있는 값은 ganttUnits와 동일)
   * @type String
   */
  this.ganttHeader5 = null;
  /**
   * 첫번째 헤더 라인의 날짜 표시 format
   * @type String
   */
  this.ganttFormat1 = null;
  /**
   * 두번째 헤더 라인의 날짜 표시 format
   * @type String
   */
  this.ganttFormat2 = null;
  /**
   * 세번째 헤더 라인의 날짜 표시 format
   * @type String
   */
  this.ganttFormat3 = null;
  /**
   * 네번째 헤더 라인의 날짜 표시 format
   * @type String
   */
  this.ganttFormat4 = null;
  /**
   * 다섯번째 헤더 라인의 날짜 표시 format
   * @type String
   */
  this.ganttFormat5 = null;
};


/**
 * @class Concreate xhtml GridEx.BodyColumn.<br>
 * Body에 추가될 컬럼을 구성하기 위한 클래스.
 * @author 김경태
 * @version 1.0
 * @param {eXria.controls.xhtml.ColsRow} poParent 상위 객체
 * @param {String} psId ID
 * @param {String} psHeadColId 헤드 컬럼 ID.
 * @param {String} psType 데이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 eXria.controls.xhtml.GridEx.BodyColumn 객체
 * @type eXria.controls.xhtml.GridEx.BodyColumn
 * @constructor
 */
eXria.controls.xhtml.GridEx.BodyColumn = function(poParent, psId, psHeadColId, psType, psInstanceId, psRef) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * id.
   * @type String
   */
  this.id = psId;
  /**
   * 헤드 컬럼 id.
   * @type Number
   */
  this.colId = psHeadColId;
  /**
   * itemgroup 오브젝트
   * @type eXria.controls.xhtml.GridEx.itemgroup
   */
  this.itemgroup = new eXria.controls.xhtml.GridEx.itemgroup();
  /**
   * instanceId
   * @type String
   */
  this.instanceId = psInstanceId;
  /**
   * ref
   * @type String
   */
  this.ref = psRef;
  /**
   * 인스턴스 데이타 접근 객체.
   * @type eXria.controls.DataRefNode
   */
  this.data = null;
  /**
   * 컬럼을 보여줄지 여부.
   * @type Boolean
   */
  this.visible = null;
  /**
   * 컬럼 데이타 타입.
   * @type String
   */
  this.type = psType || "Text";
  /**
   * 컬럼의 에디트 가능 여부
   *  uneditable - 0, 컬럼의 css 가 disable 처리 되며 수정 되지않음
   *  editable   - 1, 컬럼 수정가능
   *  preview    - 2, 컬럼의 css 가 disable 처리 도지 않으며 수정 되지 않음
   * @type Int
   */
  this.canEdit = null;
  /**
   * 컬럼의 소트 가능 여부.
   * @type Boolean
   */
  this.canSort = null;
  /**
   * 컬럼 데이타 타입별로 보여지는 형태를 지정
   * @type String
   */
  this.format = null;
  /**
   * @type String
   */
  this.regFormat = null;
  /**
   * 문자열 표현 마스크.
   * @type String
   */
  this.mask = null;
  /**
   * @type String
   */
  this.regMask = null;
  /**
   * 마스크 프롬프트 문자.
   * @type String
   */
  this.maskPrompt = "_";
  /**
   * 입력 가능한 문자열의 최대 길이.
   * @type Number
   */
  this.maxLength = null;
  /**
   * 입력 가능한 문자열의 최소 길이.(Body)
   * @type Number
   */
  this.minLength = null;
  /**
   * itemSeparator
   * @type String
   * @private
   */
  this.itemSeparator = "|";
  /**
   * 컬럼 셀의 배경색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 컬럼 셀의 폰트색상.
   * @type String
   */
  this.color = null;
  /**
   * 컬럼의 안쪽에 적용될 CSS Class
   * @type String
   */
  this.className = null;
  /**
   * 컬럼의 바깥쪽에 적용될 CSS Class
   * @type String
   */
  this.outerClassName = null;
  /**
   * 텍스트 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 인스턴스 데이타 접근 라벨 태그명.
   * @type String
   */
  this.labelTagName = psId + "_name";
  /**
   * 인스턴스 데이타 접근 value 태그명.
   * @type String
   */
  this.valueTagName = psId + "_value";
  /**
   * 셀 편집 형태가 select일 경우 select의 value 배열값
   * @type Array
   */
  this.values = null;
  /**
   * 오른쪽 버튼
   * @type eXria.controls.xhtml.GridEx.rightButton
   */
  this.rightButton = null;
  /**
   * 데이타 연산식
   * @type String
   */
  this.formula = null;
  /**
   * Group Formula
   * @type String
   */
  this.groupFormula = null;
  /**
   * Group FormulaFormat
   * @type String
   */
  this.groupFormat = null;
  /**
   * imageItem 속성을 저장하기 위한 오브젝트.
   * imageItem 속성 항목 :<br>
   * width {String} width에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * left {String} left에 대한 참조 값<br>
   * top {String} top에 대한 참조 값<br>
   * href {String} href에 대한 참조 값<br>
   * target {String} target에 대한 참조 값<br>
   * @type Object
   */
  this.imageItem = {
    width : null,           // width에 대한 ref를 의미
    height : null,          // height에 대한 ref를 의미
    left : null,            // left에 대한 ref를 의미
    top : null,             // top에 대한 ref를 의미
    href : null,            // href에 대한 ref를 의미
    target : null           // target에 대한 ref를 의미
  };
  /**
   * buttonItem 속성을 저장하기 위한 오브젝트.
   * buttonItem 속성 항목 :<br>
   * icon {String} icon에 대한 참조 값<br>
   * iconChecked {String} iconChecked에 대한 참조 값<br>
   * tooltip {String} tooltip에 대한 참조 값<br>
   * tooltipChecked {String} tooltipChecked에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * action {String} action에 대한 참조 값<br>
   * @type Object
   */
  this.buttonItem = {
    icon : null,            // icon에 대한 ref를 의미
    iconChecked : null,     // iconChecked에 대한 ref를 의미
    tooltip : null,         // icon에 대한 ref를 의미
    tooltipChecked : null,  // icon에 대한 ref를 의미
    width : null,           // icon에 대한 ref를 의미
    height : null,          // icon에 대한 ref를 의미
    action : null           // icon에 대한 ref를 의미
  };
  /**
   * Radio/CheckBox Type 시 Item들의 정렬
   * @type String
   */
  this.displayMode = null; // multilines(def) || horizontal || vertical
  /**
   * Radio/CheckBox Type 시 Label의 정렬
   * @type String
   */
  this.labelPos = null; // right(def) || left
  /**
   * calendar 아이콘의 활성화 여부.
   * @type Boolean
   */
  this.calendarEnable = true;
  /**
   * 스타일의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {
    backgroundColor : null,
    color : null,
    textAlign : null,
    readOnly : null,
    fontFamily : null,
    fontSize : null,
    fontStyle : null,
    fontWeight : null,
    borderColor : null,
    borderStyle : null,
    borderWidth : null
  };
  /**
   * date type 구분 문자열 상수 값
   * @type String
   */
  this.dateType = "Date"; // DateTime || Date || Time

  this.enumType = null;

  /**
   * 사용자 정의 nullable 속성(Body Column)
   * @type Boolean
   */
  this.nullable = true;
  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;

  /**
   * 컬럼 타입이 Text
   * @member eXria.controls.xhtml.GridEx.BodyColumn
   * @type ?
   * @author tomato at 10. 3. 15 오후 1:29
   */
  this.imeMode = null;

  /**
   * Gantt chart에서 사용하게 되는 idColumn (Task를 나타내는 유일한 id 값들을 갖는 칼럼의 헤더 id)
   * 기존에 지정된 idColumn이 있다면 무시되고 여기서 지정된 column이 idColumn으로 동작함
   * @type String
   */
  this.ganttId = null;
  /**
   * Gantt chart에서 main bar의 시작 날짜의 값을 갖는 칼럼의 헤더 id를 지정
   * @type String
   */
  this.ganttStart = null;
  /**
   * Gantt chart에서 main bar의 종료 날짜의 값을 갖는 칼럼의 헤더 id를 지정
   * 이 값이 비어있으면 main bar 대신에 milestone이 표시됨
   * @type String
   */
  this.ganttEnd = null;
  /**
   * task의 완료율을 지정하는 값을 갖는 칼럼의 헤더 id
   * @type String
   */
  this.ganttComplete = null;
  /**
   * main bar 또는 milestone 위에 마우스가 위치할 때 표시할 tooltip의 내용을 갖는 칼럼의 헤더 id
   * @type String
   */
  this.ganttTooltipText = null;
  /**
   * 의존하는 task(다음으로 오는 task)의 id 값(세미콜른으로 구분하여 여러 개의 값이 올수 있음)을 갖는 칼럼의 헤더 id
   * @type String
   */
  this.ganttDependencies = null;
  /**
   * ganttDependencies에서 지정된 task별로 의존 형태를 나타내는 값을 갖는 칼럼의 헤더 id
   * 이때 해당 칼럼에서 지정 가능한 값은 SF(start->start), SF(start->end) FS(end->start), FF(end -> end)의 네가지 이며
   * FS가 디폴트이고 하나의 task에 여러 개의 연결 정보가 존재시 세미콜른으로 구분하여 지정
   * @type String
   */
  this.ganttDependencyTypes = null;
  /**
   * Gantt Chart를 표시할때 기본이 되는 날짜(시간) 단위
   * ‘m’ - minutes,’m5’ ? 5 minutes, ’m10’ ? 10 minutes, ’m15’ ? quarters of hour, ’m30’ halves of hour,
   * ’h’ - hours, ’h2’ ? 2 hours, ’h3’ ? 3 hours, ’h6’ ? quarters of day, ’h8’ ? thirds of day, ’h12’ - halves of day,
   * ’d’ - days, ’w’ ? weeks (starting by Sunday), ’w1’ ? weeks (starting by Monday),
   * ’M’ - months, ’M3’ ? quarters of year, ’M6’ ? halves of year, ’y’ ? years
   * @type String
   */
  this.ganttUnits = null;
  /**
   * 영역의 맨처음과 맨나중에 남는 영역을 짜를때의 단위
   * 지정될 수 있는 값은 ganttUnits와 같음
   * @type String
   */
  this.ganttTrimUnits = null;
  /**
   * 사용자에 의해 Main bars 와 milestones 이 created, deleted and modified 될 수 있음
   * @type String
   */
  this.ganttEditMain = null;
   /**
   * 사용자에 의해 Dependency lines 이 created and deleted 될 수 있음
   * @type String
   */
  this.ganttEditDependency = null;
  /**
   * 사용자에 의해 Resources 가 assigned or entered 될 수 있음
   * @type String
   */
  this.ganttEditResources = null;
  /**
   * 백그라운드로 표시가 되는 Date Range로 특정 구간이 반복된다는 것을 나타내기 위해 사용
   * @type String
   */
  this.ganttBackground = null;
  /**
   * 백그라운드가 반복되는 interval로 가능한 값은 ganttUnits의 값과 같음(생략되면 ganttUnits에 설정된 값과 같음)
   * @type String
   */
  this.ganttBackgroundRepeat = null;
  /**
   * 메인 바 또는 마일스톤에 표시될 문자열을 가지고 있는 칼럼의 헤더 id
   * @type String
   */
  this.ganttResources = null;
  /**
   * ganttUnits 로 지정된 기본 unit 하나의 넓이(픽셀)
   * @type String
   */
  this.ganttUnitWidth = null;
  /**
   * gantt의 스타일을 css로 지정
   * GanttG, GanttAqua, GanttBlack, GanttBlue, GanttFuchsia, GanttGray, GanttGreen, GanttLime,
   * GanttMaroon, GanttNavy, GanttOlive, GanttOrange, GanttPurple, GanttRed, GanttSilver, GanttTeal, GanttWhite,
   * GanttYellow 중에 하나를 지정
   * @type String
   */
  this.ganttClass = null;
}
/**
 * 오른쪽 버튼을 생성하여 반환
 * @param {String} psType 테이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 오른쪽 버튼
 * @type eXria.controls.xhtml.GridEx.rightButton
 */
eXria.controls.xhtml.GridEx.BodyColumn.prototype.createRightButton = function(psType, psInstanceId, psRef) {
  var voRightButton = new eXria.controls.xhtml.GridEx.rightButton(this, psType, psInstanceId, psRef);
  return voRightButton;
};
/**
 * 주어진 오른쪽 버튼 오브젝트를 컬럼에 추가하는 메소드
 * @param {eXria.controls.xhtml.GridEx.rightButton} poRightButton 오른쪽 버튼 오브젝트
 */
eXria.controls.xhtml.GridEx.BodyColumn.prototype.addRightButton = function(poRightButton) {
  this.rightButton = poRightButton;
};
/**
 * Body칼럼의 nodeset을 설정하는 메소드
 * @param {String} psNodesetInstanceId Page에서 Unique한 InstanceId
 * @param {String} psNodesetPath 해당 Instance에서의 XPath
 */
eXria.controls.xhtml.GridEx.BodyColumn.prototype.setNodesetRef = function(psNodesetInstanceId, psNodesetPath) {
  if(this.itemgroup && this.itemgroup.data) this.itemgroup.data.setNodesetRef(psNodesetInstanceId, psNodesetPath);
};
/**
 * 사용자 정의 속성 추가
 * @param {String} psUserAttr 사용자 정의 속성 문자열 값
 */
eXria.controls.xhtml.GridEx.BodyColumn.prototype.setUserAttr = function(psUserAttr) {
  this.userAttr = psUserAttr;
  if(psUserAttr) {
    if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(psUserAttr)) this.userAttrObj = eval(psUserAttr);
  }
};
/**
 * @class Concreate xhtml GridEx.FootColumn.<br>
 * Footer에 추가될 컬럼을 구성하기 위한 클래스.
 * @author 김경태
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx.ColsRow} poParent 상위 객체
 * @param {String} psId ID
 * @param {String} psHeadColId 헤드 컬럼 ID.
 * @param {String} psType 데이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 eXria.controls.xhtml.GridEx.FootColumn 객체
 * @type eXria.controls.xhtml.GridEx.FootColumn
 * @constructor
 */
eXria.controls.xhtml.GridEx.FootColumn = function(poParent, psId, psHeadColId, psType, psInstanceId, psRef) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * id.
   * @type String
   */
  this.id = psId;
  /**
   * 헤드 컬럼 id.
   * @type Number
   */
  this.colId = psHeadColId;
  /**
   * itemgroup 오브젝트
   * @type eXria.controls.xhtml.GridEx.itemgroup
   */
  this.itemgroup = new eXria.controls.xhtml.GridEx.itemgroup();
  /**
   * instanceId
   * @type String
   */
  this.instanceId = psInstanceId;
  /**
   * 인스턴스 데이타 참조 xpath 경로
   * @type String
   */
  this.ref = psRef;
  /**
   * 인스턴스 데이타 접근 객체.
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this.control);
  /**
   * 컬럼을 보여줄지 여부.
   * @type Boolean
   */
  this.visible = null;
  /**
   * 컬럼 데이타 타입.
   * @type String
   */
  this.type = psType || "Text";
  /**
   * 컬럼의 에디트 가능 여부
   * @type Boolean
   */
  this.canEdit = null;
  /**
   * 컬럼의 소트 가능 여부.
   * @type Boolean
   */
  this.canSort = null;
  /**
   * 컬럼 데이타 타입별로 보여지는 형태를 지정
   * @type String
   */
  this.format = null;
  /**
   * @type String
   */
  this.regFormat = null;
  /**
   * 문자열 표현 마스크.
   * @type String
   */
  this.mask = null;
  /**
   * @type String
   */
  this.regMask = null;
  /**
   * 마스크 프롬프트 문자.
   * @type String
   */
  this.maskPrompt = "_";
  /**
   * cursor 위치
   * @type Number
   * @private
   */
  this.cursorPosition = -1;
  /**
   * 컬럼에 적용된 FormatMask 객체 참조
   * @type String
   */
  this.formatMask = null;
  /**
   * date type 구분 문자열 상수 값
   * @type String
   */
  this.dateType = "DateTime"; // DateTime || Date || Time
  /**
   * 입력 가능한 문자열의 최대 길이.
   * @type Number
   */
  this.maxLength = null;
  /**
   * 입력 가능한 문자열의 최소 길이.(Foot)
   * @type Number
   */
  this.minLength = null;
  /**
   * itemSeparator
   * @type String
   * @private
   */
  this.itemSeparator = "|";
  /**
   * 컬럼 셀의 배경색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 컬럼 셀의 폰트색상.
   * @type String
   */
  this.color = null;
  /**
   * 컬럼의 안쪽에 적용될 CSS Class
   * @type String
   */
  this.className = null;
  /**
   * 컬럼의 바깥쪽에 적용될 CSS Class
   * @type String
   */
  this.outerClassName = null;
  /**
   * 텍스트 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 인스턴스 데이타 접근 라벨 태그명.
   * @type String
   */
  this.labelTagName = psId + "_name";
  /**
   * 인스턴스 데이타 접근 value 태그명.
   * @type String
   */
  this.valueTagName = psId + "_value";
  /**
   * 셀 편집 형태가 select일 경우 select의 value 배열값
   * @type Array
   */
  this.values = null;
  /**
   * 오른쪽 버튼
   */
  this.rightButton = null;
  /**
   * 데이타 연산식
   */
  this.formula = null;
  /**
   * imageItem 속성을 저장하기 위한 오브젝트.
   * imageItem 속성 항목 :<br>
   * width {String} width에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * left {String} left에 대한 참조 값<br>
   * top {String} top에 대한 참조 값<br>
   * href {String} href에 대한 참조 값<br>
   * target {String} target에 대한 참조 값<br>
   */
  this.imageItem = {
    width : null,           // width에 대한 ref를 의미
    height : null,          // height에 대한 ref를 의미
    left : null,            // left에 대한 ref를 의미
    top : null,             // top에 대한 ref를 의미
    href : null,            // href에 대한 ref를 의미
    target : null           // target에 대한 ref를 의미
  };
  /**
   * buttonItem 속성을 저장하기 위한 오브젝트.
   * buttonItem 속성 항목 :<br>
   * icon {String} icon에 대한 참조 값<br>
   * iconChecked {String} iconChecked에 대한 참조 값<br>
   * tooltip {String} tooltip에 대한 참조 값<br>
   * tooltipChecked {String} tooltipChecked에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * action {String} action에 대한 참조 값<br>
   */
  this.buttonItem = {
    icon : null,            // icon에 대한 ref를 의미
    iconChecked : null,     // iconChecked에 대한 ref를 의미
    tooltip : null,         // icon에 대한 ref를 의미
    tooltipChecked : null,  // icon에 대한 ref를 의미
    width : null,           // icon에 대한 ref를 의미
    height : null,          // icon에 대한 ref를 의미
    action : null           // icon에 대한 ref를 의미
  };
  /**
   * Radio/CheckBox Type 시 Item들의 정렬
   * @type String
   */
  this.displayMode = null; // multilines(def) || horizontal || vertical
  /**
   * Radio/CheckBox Type 시 Label의 정렬
   * @type String
   */
  this.labelPos = null; // right(def) || left
  /**
   * calendar 아이콘의 활성화 여부.
   * @type Boolean
   */
  this.calendarEnable = true;
  /**
   * 스타일의 디폴트 값 저장 Object
   * @type Object
   * @private
   */
  this.df = {
    backgroundColor : null,
    color : null,
    textAlign : null,
    readOnly : null,
    fontFamily : null,
    fontSize : null,
    fontStyle : null,
    fontWeight : null,
    borderColor : null,
    borderStyle : null,
    borderWidth : null
  };

  this.enumType = null;

  /**
   * 사용자 정의 nullable 속성(Foot Column)
   * @type Boolean
   */
  this.nullable = true;
  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;

  /**
   * 컬럼 타입이 Text
   * @member eXria.controls.xhtml.GridEx.FootColumn
   * @type ?
   * @author tomato at 10. 3. 15 오후 1:29
   */
  this.imeMode = null;
};
/**
 * 오른쪽 버튼을 생성하여 반환
 * @param {String} psType 데이터 타입
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 오른쪽 버튼
 * @type eXria.controls.xhtml.GridEx.rightButton
 */
eXria.controls.xhtml.GridEx.FootColumn.prototype.createRightButton = function(psType, psInstanceId, psRef) {
  var voRightButton = new eXria.controls.xhtml.GridEx.rightButton(this, psType, psInstanceId, psRef);
  return voRightButton;
};
/**
 * 주어진 오른쪽 버튼 오브젝트를 컬럼에 추가하는 메소드
 * @param {eXria.controls.xhtml.GridEx.rightButton} poRightButton 오른쪽 버튼 오브젝트
 */
eXria.controls.xhtml.GridEx.FootColumn.prototype.addRightButton = function(poRightButton) {
  this.rightButton = poRightButton;
};


/**
 * @class GridEx.rightButton<br>
 * rightButton 클래스.
 * @author 김경태
 * @version 1.0
 * @param {eXria.controls.xhtml.GridEx.BodyColumn} poParent 상위 BodyColumn 객체
 * @param {String} psType 버튼 type
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 eXria.controls.xhtml.GridEx.rightButton 객체
 * @type eXria.controls.xhtml.GridEx.rightButton
 * @constructor
 */
eXria.controls.xhtml.GridEx.rightButton = function(poParent, psType, psInstanceId, psRef) {
  /**
   * 상위 객체 지정.
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 오른쪽 버튼의 형태
   * 일반적인 버튼 : Normal, 이미지 : Image
   */
  this.type = psType;
  /**
   * instanceId
   * @type String
   */
  this.instanceId = psInstanceId;
  /**
   * 인스턴스 데이타 참조 xpath 경로
   * @type String
   */
  this.ref = psRef;
  /**
   * 버튼 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * 버튼 value.
   * @type String
   */
  this.value = null;
  /**
   * 버튼 enableMode
   * @type String
   */
  this.enableMode = null;
};


/**
 * @class GridEx.itemgroup<br>
 * itemgroup 클래스.
 * BodyColumn에 두개 이상의 데이타를 표시해야 되는 경우(Enum, Select 등) 사용됨
 * @author 김경태
 * @version 1.0
 * @return 새로운 eXria.controls.xhtml.GridEx.itemgroup 객체
 * @type eXria.controls.xhtml.GridEx.itemgroup
 * @constructor
 */
eXria.controls.xhtml.GridEx.itemgroup = function() {
  /**
   * 아이템 label 태그 명
   * @type String
   */
  this.labelTagName = null;
  /**
   * 아이템 value 태그 명
   * @type Number
   */
  this.valueTagName = null;
  /**
   * 데이타 접근 정보 저장 오브젝트.
   * @type eXria.controls.DataRefNodeset
   */
  this.data = new eXria.controls.DataRefNodeset();
  /**
   * 인스턴스로 부터 가져올 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.itemset = new eXria.data.ArrayMap();
  /**
   * 앞쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.frontItems = new eXria.data.ArrayMap();
  /**
   * 뒤쪽에 위치할 아이템 리스트.
   * @type eXria.data.ArrayMap
   */
  this.backItems = new eXria.data.ArrayMap();
};
/**
 * itemset에 아이템 추가 메소드.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.addToItemset = function() {
  this.itemset.clear();
  var voData = this.data;
  var vsInstanceId = voData.nodesetInstanceId;
  var vsRef = voData.nodesetInstancePath;

  if(vsInstanceId == null || vsRef == null) return;
  var voCollectionNode = voData.getNodesetData2();
  var vsLabelTagName = this.labelTagName;
  var vsValueTagName = this.valueTagName;
  if(voCollectionNode) {
    var vnLoop = voCollectionNode.getLength();
    var voMapNode = null;
    var vsLabelNode = null;
    var vsValueNode = null;
    var voItem = null;
    for(var i = 0; i < vnLoop; i++) {
      voMapNode = new eXria.data.xhtml.MapNode(voCollectionNode.item(i));
      if(vsLabelTagName) vsLabelNode = voMapNode.get(vsLabelTagName);
      else vsLabelNode = i;
      vsValueNode = voMapNode.get(vsValueTagName);
      if(vsLabelNode == null) vsLabelNode = "";
      if(vsValueNode == null) vsValueNode = "";
    voItem = this.itemset.put(vsValueNode, vsLabelNode);
    }
  }
};
/**
 * frontItems혹은 backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psType 아이템 타입
 * @param {String} psName 아이템 라벨 명
 * @param {String} poValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.addItem = function(psType, psOption, psValue, pnIndex, poDocument) {
  if(psType == "front") voItems = this.frontItems;
  else voItems = this.backItems;

  if(pnIndex == null) {
      if(psValue == null) psValue = psOption;
      voItems.put(psValue, psOption);
  } else {
    var voNewItems = new eXria.data.ArrayMap();
    var vnIndex = 0;
    var voIterator = voItems.getKeyCollection().iterator();
    var vsKey = null;
    while(voIterator.hasNext()) {
      if(vnIndex == pnIndex){
        if(psValue == null) psValue = psOption;
        voItems.put(psValue, psOption);
      }
      vsKey = voIterator.next();
      voNewItems.put(vsKey, voItems.get(vsKey));
      vnIndex++;
    }
    if(psType == "front") this.frontItems = voNewItems;
    else this.backItems = voNewItems;
  }
};
/**
 * frontItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psOption 아이템 라벨 명
 * @param {String} psValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.addItemFront = function(psOption, psValue, pnIndex, poDocument) {
  this.addItem("front", psOption, psValue, pnIndex, poDocument);
};
/**
 * backItems에 아이템을 추가하기 위한 메소드.
 * @param {String} psOption 아이템 라벨 명
 * @param {String} psValue 아이템 설정 값
 * @param {Number} pnIndex 전체 리스트에서의 인덱스
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.addItemBack = function(psOption, psValue, pnIndex, poDocument) {
  this.addItem("back", psOption, psValue, pnIndex, poDocument);
};
/**
 * 리스트 아이템 제거.
 * @param {String} psName 아이템 라벨 명
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.removeItem = function(psName, poDocument) {
  this.frontItems.remove(psName);
  this.itemset.remove(psName);
  this.backItems.remove(psName);
};
/**
 * 모든 리스트 아이템 제거.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document. 생략가능.
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.removeAll = function(poDocument) {
  this.frontItems.clear();
  this.itemset.clear();
  this.backItems.clear();
};
/**
 * item label들을 문자열 배열에 담아 반환하는 메소드
 * @return item label들을 담은 문자열 배열
 * @type Array(String)
 * @private
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.getItemLabelsToArray = function() {
  var vaLabels = new Array();

  var vnIndex = 0;
  var vsKey = null;

  var voItems = this.frontItems;
  var voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsKey = voIterator.next();
    var vsTemp  = vsKey.search(/\S/gi);
    if(vsTemp === -1) vsKey = "&nbsp";
    vaLabels[vnIndex] = vsKey;
    vnIndex++;
  }

  voItems = this.itemset;
  voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsKey = voIterator.next();
    var vsTemp  = vsKey.search(/\S/gi);
    if(vsTemp === -1) vsKey = "&nbsp";
    vaLabels[vnIndex] = vsKey;
    vnIndex++;
  }

  voItems = this.backItems;
  voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsKey = voIterator.next();
    var vsTemp  = vsKey.search(/\S/gi);
    if(vsTemp === -1) vsKey = "&nbsp";
    vaLabels[vnIndex] = vsKey;
    vnIndex++;
  }

  return vaLabels;
};
/**
 * item value들을 문자열 배열에 담아 반환하는 메소드
 * @return item value들을 담은 문자열 배열
 * @type Array(String)
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.getItemValuesToArray = function() {
  var vaValues = new Array();

  var voItems = this.frontItems;
  var voIterator = voItems.getKeyCollection().iterator();
  var vsKey = null;
  var vsValue = null;
  var vnIndex = 0;
  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vaValues[vnIndex] = vsValue;
    vnIndex++;
  }

  voItems = this.itemset;
  voIterator = voItems.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vaValues[vnIndex] = vsValue;
    vnIndex++;
  }

  voItems = this.backItems;
  voIterator = voItems.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vaValues[vnIndex] = vsValue;
    vnIndex++;
  }

  return vaValues;
};
/**
 * item label들을 sparator를 이용하여 하나의 문자열로 반환하는 메소드
 * @return 한 문자열로 표현된 item들의 label 값
 * @type String
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.getItemLabelsToString = function(psSeparator) {
  var vsLabels = '', vsLabel = '';
  var vbSeparator = false;
  if(psSeparator) vbSeparator = true;

  var voItems = this.frontItems;
  var voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsLabel = voIterator.next();
    vsLabel += "";
    vsLabel = vsLabel.replace(/\'/g, "&apos;")
    var vsTemp  = vsLabel.search(/\S/gi);
    if(vsTemp === -1) vsLabel = "&nbsp";
    if(vbSeparator) vsLabels = vsLabels + psSeparator + vsLabel;
    else vsLabels = vsLabels + vsLabel;
  }

  voItems = this.itemset;
  voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsLabel = voIterator.next();
    vsLabel += "";
    vsLabel = vsLabel.replace(/\'/g, "&apos;")
    var vsTemp  = vsLabel.search(/\S/gi);
    if(vsTemp === -1) vsLabel = "&nbsp";
    if(vbSeparator) vsLabels = vsLabels + psSeparator + vsLabel;
    else vsLabels = vsLabels + vsLabel;
  }

  voItems = this.backItems;
  voIterator = voItems.getValueCollection().iterator();
  while(voIterator.hasNext()) {
    vsLabel = voIterator.next();
    vsLabel += "";
    vsLabel = vsLabel.replace(/\'/g, "&apos;")
    var vsTemp  = vsLabel.search(/\S/gi);
    if(vsTemp === -1) vsLabel = "&nbsp";
    if(vbSeparator) vsLabels = vsLabels + psSeparator + vsLabel;
    else vsLabels = vsLabels + vsLabel;
  }

  return vsLabels;
};
/**
 * item value들을 sparator를 이용하여 하나의 문자열로 반환하는 메소드
 * @return 한 문자열로 표현된 item들의 value 값
 * @type String
 */
eXria.controls.xhtml.GridEx.itemgroup.prototype.getItemValuesToString = function(psSeparator) {
  var vsValues = '', vsValue = '';
  var vbSeparator = false;
  if(psSeparator) vbSeparator = true;

  var voItems = this.frontItems;
  var voIterator = voItems.getKeyCollection().iterator();

  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vsValue += "";
    vsValue = vsValue.replace(/\'/g, "&apos;");
    if(vbSeparator) vsValues = vsValues + psSeparator + vsValue;
    else vsValues = vsValues + vsValue;
  }

  voItems = this.itemset;
  voIterator = voItems.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vsValue += "";
    vsValue = vsValue.replace(/\'/g, "&apos;");
    if(vbSeparator) vsValues = vsValues + psSeparator + vsValue;
    else vsValues = vsValues + vsValue;
  }

  voItems = this.backItems;
  voIterator = voItems.getKeyCollection().iterator();
  while(voIterator.hasNext()) {
    vsValue = voIterator.next();
    vsValue += "";
    vsValue = vsValue.replace(/\'/g, "&apos;");
    if(vbSeparator) vsValues = vsValues + psSeparator + vsValue;
    else vsValues = vsValues + vsValue;
  }

  return vsValues;
};

//yhkim 2009.05.18 Paging Data 관련
/**
 * 그리드의 paging 구조 정의 문자열을 반환하는 메소드
 * @param {Number} rowPos page 위치 정보
 * @return 그리드의 paging 구조 정의 문자열
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getPagingData = function(rowPos) {
  if (this.cfg.paging != "fast")
    return;
  // 렌더링 할 페이지 카운트
  if(this.pageCountWithFastMode === 0) this.pageCountWithFastMode++;

  this.cfg.pagePos = rowPos;
  var vnId = this.cfg.pageLength * rowPos;
  var vnPos = 0;
  var voPage = null;
  for(var i = 0; i < rowPos; i++) {
    voPage = this.grid.GetPage(i);
    vnPos += voPage ? (voPage.childNodes.length ? voPage.childNodes.length : this.grid.PageLength) : this.grid.PageLength;
  }

  var vsXml = "";
  if (this.datasetId == null) {
    if (this.data.nodesetInstanceId == null || this.data.nodesetInstancePath == null)
      return;
    var voCollectionNode = null;
    if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
      voCollectionNode = this.data.getNodesetStr();
      if(voCollectionNode) {
        voCollectionNode = eval(voCollectionNode);
      }
    } else {
      voCollectionNode = this.data.getNodesetData();
    }
    // instance는 0부터
    vsXml = this.makeRowData(voCollectionNode, vnPos, vnPos + this.cfg.pageLength, vnId);
  } else {
    var voDataSet = null;
    if(this.dataset)
      voDataSet = this.dataset;
    else
      voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
    // dataset은 1부터
    vsXml = this.makeRowData(voDataSet, vnPos + 1, vnPos + this.cfg.pageLength, vnId + 1);
  }

  var vsReturn = '<Grid><Body><B Pos=' + '"' + rowPos + '"' + '>';
  vsReturn = vsReturn + vsXml;
  vsReturn = vsReturn + '</B></Body></Grid>';
  if(this.grid.RowCount < 1) this.grid.RowCount = 1;
  return vsReturn;
};
//yhkim 2009.05.18 Paging Data
/**
 * makeRowData
 * @param {eXria.data.xhtml.CollectionNode | eXria.data.DataSetCmd} poCollectionNode data collection node or dataset
 * @param {Number} pnFirst 읽어 올 시작 page 위치
 * @param {Number} pnLoop 읽어 올 row count
 * @param {Number} pnId 그리드 row 객체에 부여될 id 시작 번호
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.makeRowData = function(poCollectionNode, pnFirst, pnLoop, pnId) {
  if(poCollectionNode) {
    var vnDataCount;
    if(this.datasetId) {
      vnDataCount = poCollectionNode.getRowCnt();
    } else if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
      vnDataCount = poCollectionNode.length;
    } else {
      vnDataCount = poCollectionNode.size();
    }
    if(pnFirst > vnDataCount) return "";
    if(pnLoop > vnDataCount) pnLoop = vnDataCount;
  } else {
     return "";
  }
  var voFuncDataSize;
  var voAddStatusMap = {};
  var voUptStatusMap = {};
  var voDelStatusMap = {};
  var vaStatus, vsStatus, vnSize, voDst;
  
  this.funcRef = function(poColumn) {
    return poColumn.ref;
  };
  this.funcRowId = function(poMapNode, pnId) {
    return pnId + 1;
  };
  this.funcGet = function(poMapNode, psRef) {
    return poMapNode[psRef]
  };
  this.funcRefVal = function(psRef, poMapNode, pnIdx, psInstId) {
    return this.getRefValueFromMap(psRef, poMapNode);
  };
  
  if(this.datasetId) {
    pnLoop += 1;
    voDst = poCollectionNode;
    vaStatus = voDst.getStatusIndex(eXria.data.CrudType.ADDEDFLAG);
    vaStatus = vaStatus.split(",");
    vnSize = vaStatus.length;
    for(var i = 0; i < vnSize; i++) {
      vsStatus = vaStatus[i];
      if(vsStatus != "") {
        voAddStatusMap[vsStatus] = "";
      }
    }
    vaStatus = voDst.getStatusIndex(eXria.data.CrudType.MODIFIEDFLAG);
    vaStatus = vaStatus.split(",");
    vnSize = vaStatus.length;
    for(var i = 0; i < vnSize; i++) {
      vsStatus = vaStatus[i];
      if(vsStatus != "") {
        voUptStatusMap[vsStatus] = "";
      }
    }
    vaStatus = voDst.getStatusIndex(eXria.data.CrudType.DELETEDFLAG);
    vaStatus = vaStatus.split(",");
    vnSize = vaStatus.length;
    for(var i = 0; i < vnSize; i++) {
      vsStatus = vaStatus[i];
      if(vsStatus != "") {
        voDelStatusMap[vsStatus] = "";
      }
    }
    
    poCollectionNode = eval(voDst.dataSet.getRowDataStrContainFrontIndex(pnFirst, pnLoop));
    this.funcMapNode = function(poCollectionNode, pnIdx) {
      return poCollectionNode[pnIdx - pnFirst];
    };
    this.funcStatus = function(poMapNode, pnIdx) {
      var vsStatus = "";
      if(voAddStatusMap[pnIdx] != null) vsStatus += "I";
      else if(voUptStatusMap[pnIdx] != null) vsStatus += "U";
      else if(voDelStatusMap[pnIdx] != null) vsStatus += "D";
      return vsStatus;
    };
    this.funcRef = function(poColumn) {
      return poColumn.datasetCol;
    };
    this.funcRowId = function(poMapNode, pnId) {
      return poMapNode["@frontIndex"];
    };
    
  } else if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    this.funcMapNode = function(poCollectionNode, pnIdx) {
      return poCollectionNode[pnIdx];
    };
    this.funcStatus = function(poMapNode, pnIdx) {
      return this.data.getNodesetData2(pnIdx).node.getUserAttribute("status");
    };
    
  } else {
    this.funcMapNode = function(poCollectionNode, pnIdx) {
      return new eXria.data.xhtml.MapNode(poCollectionNode.get(pnIdx));
    };
    this.funcStatus = function(poMapNode, pnIdx) {
      return poMapNode.node.getUserAttribute("status");
    };
    this.funcGet = function(poMapNode, psRef) {
      return poMapNode.get(psRef);
    };
    this.funcRefVal = function(psRef, poMapNode, pnIdx, psInstId) {
      return this.getRefValue(psRef, poMapNode, pnIdx, psInstId);
    };
    
  }
  if(pnId == null) pnId = pnFirst;
  var voMapNode = null;
  var voBody, voRow, voColumn, voValue = null;
  var vsBody = "", vsRow;
  var vsRef, vaPath, vsRButtonRef, vsRButtonValue = "";
  var voCols = new Array();
  
  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  var vsDsColId;
  var voCfg = this.cfg;
  
  this.setColsRowSpan(pnFirst, pnLoop, poCollectionNode);
  var voMergeRowColsMap = this.mergeRowColsMap;
  var vaChildRows = this.childRows;
  var vnSize;

  for( var i = pnFirst, ii = pnId; i < pnLoop; i++, ii++) {
    vsRow = this.getTRowStr(i, ii, poCollectionNode, voCols, voCfg, voMergeRowColsMap);
    if(vaChildRows) {
      vnSize = vaChildRows.length;
      vsRow += ">";
      for(var j = 0; j < vnSize; j++) {
        vsRow += this.getTRowStr(i, ii, poCollectionNode, voCols, voCfg, voMergeRowColsMap, vaChildRows[j], j) + "/>";
      }
      vsRow += "</I>";
    } else if(vsRow != ""){
      vsRow +=  "/>";
    } else {
      ii--;
    }

    vsBody = vsBody + vsRow;
  }
  this.rowCount = pnLoop;
  return vsBody;
};
/**
 * 데이타 로딩 시점에서 데이타 메타 정보를 응용단에서 편집 가능하도록 하는 이벤트 발생 메소드
 * @param {Number} pnRowIdx row 인덱스
 * @param {String} psRow 해당 row 메타 데이타
 * @param {Array(Object)|eXria.data.ArrayCollection} paRowData 전체 row 데이타
 * @return 응용단에서 편집된 row 메타 데이타
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setRowMetaExtAttrs = function(pnRowIdx, psRow, paRowData) {
  var vsVal = psRow;
  var voPage = this.canvas.page;
  if(voPage.onGridexSetRowMetaExtAttrs) vsVal = voPage.onGridexSetRowMetaExtAttrs(this, pnRowIdx, psRow, paRowData);
  if(vsVal == null) vsVal = psRow;
  return vsVal;
};

/**
 * MarkDelRow가 된 로우와 Dataset  Sync
 * @param {Object} poRow markdel상태가 변한 row
 * @param {Boolean} pbDel 
 */
eXria.controls.xhtml.GridEx.prototype.SetMarkDelStatus = function(poRow, pbDel) {
  if(this.datasetId) {
    if(!this.dataset) this.dataset = this.canvas.page.model.getDataSet(this.datasetId);
    if(this.dataset == null) return;

    var vnIdx = this.getIndexOfRow(poRow)

    if(pbDel == true) {
        if(poRow["Added"] == "1") this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.UNCHANGEDFLAG);
        else this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.DELETEDFLAG);
    } else {
      if(poRow["Added"] == "1") {
        if(poRow["Changed"] == "1") this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.ADDEDFLAG);
        else this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.EMPTYEDFLAG);
      } else if(poRow["Changed"] == "1") {
        this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.MODIFIEDFLAG);
      } else {
        this.dataset.setStatus(vnIdx + 1, eXria.data.CrudType.UNCHANGEDFLAG);
      }
    }
//    if(pbDel == true )
//      this.dataset.setStatus(vnIndex + 1, this.dataset.dataSet.ETBDELETEDFLAG);
//    else
//      this.dataset.setStatus(vnIndex + 1, this.dataset.dataSet.ETBUNCHANGEDFLAG);
  } else if(!!this.data.nodesetInstanceId && !!this.data.nodesetInstancePath) {
    var vnInstIdx = poRow["InstIdx"];
    if(vnInstIdx == null) vnInstIdx = poRow.getAttribute("InstIdx");
    vnInstIdx = parseInt(vnInstIdx);
    var voInstRow = this.data.getNodesetData2(vnInstIdx).node;
    var vsStatus = null;
    if(pbDel) {
      vsStatus = voInstRow.getUserAttribute("status");
      if(vsStatus == null) vsStatus = "";
      if(vsStatus.indexOf("D") == -1) voInstRow.setUserAttribute("status", "D" + vsStatus);
    } else {
      vsStatus = voInstRow.getUserAttribute("status");
      if(vsStatus != null) {
        voInstRow.setUserAttribute("status", vsStatus.replace("D", ""));
      }
    }
  }
};

/**
 * NodeSet Ref 이외의 경로가 참조 가능한 ref(image 등)에 대하여 value 값을 구해 리턴
 * @param {String} psRef XPath
 * @param {eXria.data.xhtml.MapNode || DataSet} poNodeSet NodeSet 형태의 값들을 가지고 있는 객체
 * @param {Number} pnIndex
 * @param {String} psInstanceId instance의 Id로 현재는 사용 안함
 * @return 해당 instance의 ref에 있는 value
 * @type {String}
 */
eXria.controls.xhtml.GridEx.prototype.getRefValue = function(psRef, poNodeSet, pnIndex, psInstanceId) {
  var voValue = "";
  if(!psInstanceId) psInstanceId = this.data.nodesetInstanceId;
  if(psRef) {
    if(psRef.indexOf("/") == 0) {                     // XPath가 절대경로로 지정된 경우
      this.data.setRef(psInstanceId, psRef);
      voValue = this.data.getNodeData().getValue();
    } else if(poNodeSet) {                            // XPath가 상대경로로 지정된 경우
      vaPath = psRef.split("/");
      if(this.dataset) voValue = poNodeSet[vaPath];
      else voValue = poNodeSet.get(vaPath[vaPath.length - 1]);
    }
    if(!voValue) voValue = "";
  }
  return voValue;
};
/**
 * NodeSet Ref 이외의 경로가 참조 가능한 ref(image 등)에 대하여 value 값을 구해 리턴
 * @param {String} psRef XPath
 * @param {Object} poRowData row 데이타 저장 맵 객체
 * @return 해당 row 데이타의 ref에 있는 value
 * @type {String}
 */
eXria.controls.xhtml.GridEx.prototype.getRefValueFromMap = function(psRef, poRowData) {
  if(psRef == null || poRowData == null) return null;
  var voValue = "";
  if(psRef.indexOf("/") == 0) {
    var voData = this.data;
    voData.setRef(voData.nodesetInstanceId, psRef);
    voValue = voData.getNodeData().getValue();
  } else {
    var vaPath = psRef.split("/");
    voValue = poRowData[vaPath[vaPath.length - 1]];
  }
  if(!voValue) voValue = "";
  return voValue;
};
//yhkim 2009.05.19 head 컬럼
/**
 * @class Fuction Column 클래스
 * @param {eXria.controls.xhtml.GridEx.BodyColumn} poParent 상위 객체
 * @param {String} psId ID
 * @param {String} psInstanceId Instance ID
 * @param {String} psRef Instance Path
 * @return 새로운 eXria.controls.xhtml.GridEx.FunctionColumn 객체
 * @type eXria.controls.xhtml.GridEx.FunctionColumn
 * @constructor
 */
eXria.controls.xhtml.GridEx.FunctionColumn = function(poParent, psId, psInstanceId, psRef) {
  /**
   * 상위 객체 지정
   * @type eXria.controls.xhtml.GridEx.Body|eXria.controls.xhtml.GridEx.Header
   */
  this.parent = poParent;
  /**
   * 자신이 속한 GridEx 컨트롤 참조
   *
   * @type eXria.controls.xhtml.GridEx
   */
  this.control = poParent.control;
  /**
   * 헤드 컬럼 식별자.
   * @type String
   */
  this.colId = null;
  /**
   * 컬럼 식별자
   */
  this.id = psId;
  /**
   * instanceId
   * @type String
   */
  this.instanceId = psInstanceId;
  /**
   * ref
   * @type String
   */
  this.ref = psRef;
  /**
   * 인스턴스 데이타 접근 객체.
   *
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this.control);
  /**
   * datasetCol
   * @type String
   */
  this.datasetCol = null;
  /**
   * 컬럼 표시 문자열.
   * @type String
   */
  this.value = null;
  /**
   * 입력 가능한 문자열의 최대 길이.
   * @type Number
   */
  this.maxLength = null;
  /**
   * 입력 가능한 문자열의 최소 길이.(Function)
   * @type Number
   */
  this.minLength = null;
  /**
   * 컬럼 셀의 배경색상.
   * @type String
   */
  this.backgroundColor = null;
  /**
   * 컬럼 셀의 폰트색상.
   * @type String
   */
  this.color = null;
  /**
   * 컬럼의 안쪽에 적용될 CSS Class
   * @type String
   */
  this.className = null;
  /**
   * 컬럼의 바깥쪽에 적용될 CSS Class
   * @type String
   */
  this.outerClassName = null;
  /**
   * 텍스트 정렬 방식.
   * @type String
   */
  this.textAlign = null;
  /**
   * 컬럼 가로 길이.
   * @type Number
   */
  this.width = null;
  /**
   * @ignore
   */
  this.field = null;
  /**
   * rowSpan.
   * @type Number
   */
  this.rowspan = null;
  /**
   * colSpan.
   * @type Number
   */
  this.colspan = null;
  /**
   * dojo type object. It will be created when ColumnsRow's addColumn method
   * called.
   * @type Object
   * @ignore
   */
  this.cell = null;
  /**
   * 컬럼을 보여줄지 여부.
   * @type Boolean
   */
  this.visible = null;
  // yhkim 2009.05.19 head 컬럼
  /**
   * 드래그 가능 여부.
   * @type Boolean
   * @private
   */
  this.canDrag = null;
  /**
   * 편집 가능 여부.
   * @type Boolean
   */
  this.canEdit = null;
  /**
   * 포커싱 가능 여부.
   * @type Boolean
   */
  this.canFocus = null;
  /**
   * 데이타 연산식
   * @type String
   */
  this.formula = null;
  /**
   * 컬럼 타입 구분 문자열
   * @type String
   */
  this.type = "Text";
  /**
   * item separator
   * @type String
   * @private
   */
  this.itemSeparator = "|";
  /**
   * itemgroup 객체 참조 변수
   * @type eXria.controls.xhtml.GridEx.itemgroup
   */
  this.itemgroup = new eXria.controls.xhtml.GridEx.itemgroup();
  /**
   * rightButton 객체 참조 변수
   * @type eXria.controls.xhtml.GridEx.rightButton
   */
  this.rightButton = null;
  /**
   * imageItem 속성을 저장하기 위한 오브젝트.
   * imageItem 속성 항목 :<br>
   * width {String} width에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * left {String} left에 대한 참조 값<br>
   * top {String} top에 대한 참조 값<br>
   * href {String} href에 대한 참조 값<br>
   * target {String} target에 대한 참조 값<br>
   */
  this.imageItem = {
    width : null,           // width에 대한 ref를 의미
    height : null,          // height에 대한 ref를 의미
    left : null,            // left에 대한 ref를 의미
    top : null,             // top에 대한 ref를 의미
    href : null,            // href에 대한 ref를 의미
    target : null           // target에 대한 ref를 의미
  };
  /**
   * buttonItem 속성을 저장하기 위한 오브젝트.
   * buttonItem 속성 항목 :<br>
   * icon {String} icon에 대한 참조 값<br>
   * iconChecked {String} iconChecked에 대한 참조 값<br>
   * tooltip {String} tooltip에 대한 참조 값<br>
   * tooltipChecked {String} tooltipChecked에 대한 참조 값<br>
   * height {String} height에 대한 참조 값<br>
   * action {String} action에 대한 참조 값<br>
   */
  this.buttonItem = {
    icon : null,            // icon에 대한 ref를 의미
    iconChecked : null,     // iconChecked에 대한 ref를 의미
    tooltip : null,         // icon에 대한 ref를 의미
    tooltipChecked : null,  // icon에 대한 ref를 의미
    width : null,           // icon에 대한 ref를 의미
    height : null,          // icon에 대한 ref를 의미
    action : null           // icon에 대한 ref를 의미
  };

  this.calendarEnable = true;

  this.enumType = null;

  /**
   * 사용자 정의 nullable 속성(Function Column)
   * @type Boolean
   */
  this.nullable = true;
  /**
   * 사용자정의 Max Byte 길이
   * @type Number
   */
  this.maxByteLenth = null;
  /**
   * 사용자정의 Min Byte 길이
   * @type Number
   */
  this.minByteLenth = null;

  /**
   * 컬럼 타입이 Text
   * @member eXria.controls.xhtml.GridEx.FunctionColumn
   * @type ?
   * @author tomato at 10. 3. 15 오후 1:29
   */
  this.imeMode = null;
};
/**
 * 새로운 rightButton을 생성하여 반환하는 메소드
 * @param {String} psType 버튼 타입 구분 문자열
 * @param {String} psInstanceid 참조 instance id
 * @param {String} psRef 참조 instance path 정보
 * @return 새로운 rightButton 객체
 * @type eXria.controls.xhtml.GridEx.FunctionColumn.prototype.createRightButton
 */
eXria.controls.xhtml.GridEx.FunctionColumn.prototype.createRightButton = function(psType, psInstanceId, psRef) {
  var voRightButton = new eXria.controls.xhtml.GridEx.rightButton(this, psType, psInstanceId, psRef);
  return voRightButton;
};
/**
 * 주어진 오른쪽 버튼 오브젝트를 컬럼에 추가하는 메소드
 * @param {eXria.controls.xhtml.GridEx.rightButton} poRightButton 오른쪽 버튼 오브젝트
 */
eXria.controls.xhtml.GridEx.FunctionColumn.prototype.addRightButton = function(poRightButton) {
  this.rightButton = poRightButton;
};


/**
 * @class FormatMask 오브젝트 생성 클래스
 * @param {Object} poColumn 부모 컬럼 객체
 * @param {eXria.controls.xhtml.GridEx} poGrid GridEx 객체
 * @return eXria.controls.xhtml.GridEx.FormatMask 객체
 * @type eXria.controls.xhtml.GridEx.FormatMask
 * @constructor
 */
eXria.controls.xhtml.GridEx.FormatMask = function(poColumn, poGrid){
  /**
   * GridEx 객체 참조 변수
   * @type eXria.controls.xhtml.GridEx
   */
  this.grid = poGrid;
  /**
   * 컬럼 객체 참조 변수
   * @type Object
   */
  this.column = poColumn;
  /**
   * format 문자열 참조 변수
   * @type String
   */
  this.format = poColumn.format;
  /**
   * @type String
   */
  this.regFormat = poColumn.regFormat;
  /**
   * mask 문자열 참조 변수
   * @type String
   */
  this.mask = poColumn.mask;
  /**
   * @type String
   */
  this.regMask = poColumn.regMask;
  /**
   * maskPrompt 문자열 참조 변수
   * @type String
   */
  this.maskPrompt = poColumn.maskPrompt;
  /**
   * 텍스트가 전체 select 되었는지 여부
   * @type Boolean
   */
  this.vbSelectAll = false;
  /**
   * mask character 설정 값을 참조하기 위한 Object
   * @type Object
   */
  this.stringMaskChar = {
    "9" : "0-9",
    "0" : "0-9",
    "#" : "0-9",
    "*" : "0-9a-zA-Z",
    "x" : "0-9a-zA-Z",
    "X" : "0-9a-zA-Z",
    "a" : "0-9a-zA-Z",
    "A" : "0-9a-zA-Z",
    "w" : "a-zA-Z",
    "W" : "a-zA-Z",
    "!" : "0-9a-zA-Z",
    "^" : "0-9a-zA-Z"
  };
  /**
   * 숫자형 mask character 설정 값을 참조하기 위한 Object
   * @type Object
   */
  this.numberMaskChar = {
    "9" : "0-9",
    "0" : "0-9",
    "#" : "0-9",
    "." : "."
  };
  /**
   * date형 character 설정 값을 참조하기 위한 Object
   * @type Object
   */
  this.dateMaskChar = {
    "Y" : "0-9",
    "y" : "0-9",
    "M" : "0-9",
    "D" : "0-9",
    "d" : "0-9",
    "H" : "0-9",
    "h" : "0-9",
    "m" : "0-9",
    "s" : "0-9"
  };
  /**
   * 이벤트 키값 상수 정의 오브젝트.
   * @type Object
   */
  this.constKey = {
    SHIFT: 16,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    TAB: 9,
    BACKSPACE: 8,
    DEL: 46,
    HAN_ENG: 21,
    UP : 38,
    DOWN : 40
  };
  /**
   * YYMMDD의 정규식 표현.
   * @type RegExp
   * @private
   */
  this.regDateMask = /[yMdHhms]/g;
  /**
   * 숫자가 아닌 정규식 표현.
   * @type RegExp
   * @private
   */
  this.noDigits = /[^\d]/gi;
  /**
   * 커서 위치 저장 변수
   * @type Number
   * @private
   */
  this.cursorPosition = -1;
};
/**
 * TreeGrid의 Format, Mask 관련 속성의 문자열 반환
 * @param {Object} psFormat Format
 * @return String
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.createFormatAndMask = function(poColumn){
  var vsFormat = poColumn.regFormat;
  var vsMask = poColumn.regMask;
  var vsType = poColumn.type;
  var vsEditFormat = "", vsEditMask = "", vsResultMask = "", vsRet = "";
  if(!vsFormat && vsMask) vsFormat = vsMask;
  if(!vsFormat && vsType=="Date") vsFormat = "yyyy-MM-dd";
  if(!vsMask && vsType=="Date") vsMask = "yyyyMMdd";
  switch(vsType){
    case "Int" :
    case "Float" :
      if(vsMask){
        if(vsMask.lastIndexOf(".")) vsMask = vsMask.replace(vsMask.charAt(vsMask.lastIndexOf(".")-1), "0");
        vsEditMask = "^[0-9]*\\.*[0-9]*$";
        vsResultMask = "^[0-9]*\\.*[0-9]*$";
      }
      break;
    case "Text" :
    case "Lines" :
      if(vsMask){
        var vsMaskReg = "";
        var voMaskChar = this.stringMaskChar;
        for(var vsMaskChar in this.stringMaskChar){
          if(/\W/.test(vsMaskChar)) vsMaskChar = "\\" + vsMaskChar;
          vsMaskReg += vsMaskChar;
        }
        var vrMaskReg = new RegExp("[^" + vsMaskReg + "]", "g");

        var vsNoFormat = vsMask.replace(vrMaskReg, "");

        vsEditMask = "^";

        //문자가 일치하는 마지막 index를 리턴
        var getLastIndex = function(pnIndex){
          if(pnIndex > vsNoFormat.length) return vsNoFormat.length;
          if(vsNoFormat.charAt(pnIndex) == vsNoFormat.charAt(pnIndex + 1)) pnIndex = getLastIndex(pnIndex + 1);
          return pnIndex;
        }

        //editmask 생성
        var getEditMask = function(pnIndex){
          if(!pnIndex) pnIndex = 0;
          var vnStartIdx = pnIndex;
          var vnLastIdx = getLastIndex(pnIndex);
          var vnCnt = vnLastIdx + 1 - vnStartIdx;

          vsEditMask = vsEditMask + "[" + voMaskChar[vsNoFormat.charAt(pnIndex)] + "]{" + 0 + "," + vnCnt + "}";
          if(vsNoFormat.charAt(vnLastIdx + 1)) vsEditMask = getEditMask(vnLastIdx + 1);
          return vsEditMask;
        }

        //resultmask 생성
        var getResultMask = function(pnIndex){
          if(!pnIndex) pnIndex = 0;
          var vnStartIdx = pnIndex;
          var vnLastIdx = getLastIndex(pnIndex);
          var vnCnt = vnLastIdx + 1 - vnStartIdx;

          vsResultMask = vsResultMask + "[" + voMaskChar[vsNoFormat.charAt(pnIndex)] + "]{" + vnCnt + "}";
          if(vsNoFormat.charAt(vnLastIdx + 1)) vsResultMask = getResultMask(vnLastIdx + 1);
          return vsResultMask;
        }

        vsEditMask = getEditMask() + "$";
        vsResultMask = getResultMask() + "$";
      }
      break;
    case "Date" :
      vsFormat = this.convertDateFormat(vsFormat);
      if(vsMask){
        vsMask = this.convertDateFormat(vsMask);
        var vsNoFormat = vsMask.replace(/[^ymdhs]/gi, "");
        vsEditMask = "^";
        vsEditMask = vsEditMask + "[0-9]{0," + vsNoFormat.length + "}$";
        vsResultMask = vsResultMask + "[0-9]{" + vsNoFormat.length + "}$";
//        if(vsMask.length <= 8 && /ss/.test(vsMask)) poColumn.dateType = "Time";
//        else if(vsMask.length < 14) poColumn.dateType = "Date";
//        else poColumn.dateType = "DateTime";
      }
      break;
    case "Radio" :
    case "CheckBox" :
      var pnFormat = 1;
      if(poColumn.displayMode){
        if(poColumn.displayMode == "horizontal") pnFormat -= 1;
        else if(poColumn.displayMode == "vertical") pnFormat += 1;
      }
      if(poColumn.labelPos == "left") pnFormat += 4;
      if(poColumn.type == "CheckBox") pnFormat = pnFormat + 8 + 16 + 32;

      vsFormat = "|" + pnFormat + "|||||";
      return vsFormat;
      break;
  }
  var vsRet = "";
  var vsId = poColumn.colId;
  if(vsId == poColumn.control.cfg.idColumn) vsId = "id";
  if(vsFormat) vsRet = vsRet + " " + vsId + "Format='" + vsFormat + "'";
//  if(vsMask) vsRet = vsRet + " " + vsId + "EditFormat='" + vsMask + "' " + vsId + "EditMask='" + vsEditMask + "' " + vsId + "ResultMask='" + vsResultMask + "'";
  if(vsMask) vsRet = vsRet + " " + vsId + "EditFormat='" + vsMask + "' ";
  return  vsRet;
};
/**
 * 주어진 format 문자열을 내부적으로 사용될 표준 format 문자열로 변환하는 메소드
 * @param {String} psFormat format 문자열
 * @return 내부적으로 사용될 표준 format 문자열로 변환된 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.convertDateFormat = function(psFormat){
  // DateMask 추가코드
  /*
  psFormat = psFormat.toUpperCase();
  psFormat = psFormat.split("Y").join("y");
  psFormat = psFormat.split("D").join("d");
  if(psFormat.search("HH24") != -1) psFormat = psFormat.split("HH24").join("HH");
  else if(psFormat.search("HH12") != -1) psFormat = psFormat.split("HH12").join("hh");
  else if(psFormat.search("HH") != -1) psFormat = psFormat.split("HH").join("hh");

  psFormat = psFormat.split("MI").join("mm");
  psFormat = psFormat.split("SS").join("ss");
  */
  return psFormat;
};
/**
 * 정해진 문자형 마스크 포맷으로 값을 변환.
 * @param {String} psValue 컨트롤 disabled설정
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.toStringFormatValue = function(psValue, psFormat, psColId){
//  if(psValue == "") return "";
  var voColumn = this.column;

  var vsMaskReg = "";
  var vsMaskPrompt = String.fromCharCode(255);
  for(var vsMaskChar in this.stringMaskChar){
    if(/\W/.test(vsMaskChar)) vsMaskChar = "\\" + vsMaskChar;
    vsMaskReg += vsMaskChar;
  }
  var vrMaskReg = new RegExp("[" + vsMaskReg + "]", "g");
  var vrPrompt = new RegExp("["+vsMaskPrompt+"]", "i");
  var vsFormat = psFormat.replace(vrMaskReg, vsMaskPrompt);
  var vnValIdx = 0;
  for(var i=0; i<vsFormat.length; i++){
    if(vrPrompt.test(vsFormat.charAt(i))){
      var vsFormatChar = psFormat.charAt(i);
      var vsValueChar = psValue.charAt(vnValIdx);
      switch(vsFormatChar){
        case "0" :
          break;
        case "9" :
        case "#" :
        case "*" :
        case "x" :
        case "X" :
          break;
        case "a" :
        case "w" :
        case "^" :
          vsValueChar = vsValueChar.toLowerCase();
          break;
        case "A" :
        case "W" :
        case "!" :
          vsValueChar = vsValueChar.toUpperCase();
          break;
      }
      if(vsValueChar != "") vsFormat = vsFormat.replace(vsFormat.charAt(i), vsValueChar);
      vnValIdx++;
    }
  }
  vrPrompt = new RegExp("["+vsMaskPrompt+"]", "gi");
  if(voColumn) vsFormat = vsFormat.replace(vrPrompt, voColumn.maskPrompt);
  else vsFormat = vsFormat.replace(vrPrompt, "");
  return vsFormat;
};
/**
 * 주어진 값에 정규식 표현을 적용하여 반환하는 메소드
 * @param {String} psValue value
 * @param {String} psMask 정규식 문자 포함 마스크
 * @return 정규식 표현을 적용한 value 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.toMaskedChar = function(psValue, psMask){
  switch(psMask){
    case "0" :
      break;
    case "9" :
    case "#" :
    case "*" :
    case "x" :
    case "X" :
      break;
    case "a" :
    case "w" :
    case "^" :
      psValue = psValue.toLowerCase();
      break;
    case "A" :
    case "W" :
    case "!" :
      psValue = psValue.toUpperCase();
      break;
  }
  return psValue;
};
/**
 * 마스크 프롬프트를 공백문자롤 치환하는 함수
 * @param {String} psValue 컨트롤 disabled설정
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.maskPromptToBlank = function(psValue, psColId){
  if(!psColId) return psValue;
  var voColumn = this.column;
  var vsMaskPrompt = voColumn.maskPrompt;
  var vsReg = new RegExp('['+vsMaskPrompt+']','gi');
  psValue = psValue.replace(vsReg, "");
  return psValue;
};
/**
 * 값을 지정된 Mask에 맞게 변환하여 반환
 * @param {String} psData Data
 * @param {String} psColId Column Id
 * @return String
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.getMaskedValue = function(poInput, poRow, psColId){
  var voColumn = this.column;
  var vsData = this.grid.getValue(poRow, psColId);
  var voEditMaskObj = this.editMaskObj = new eXria.controls.xhtml.EditMask();
  voEditMaskObj.df.mask = voColumn.mask;
  if(!voColumn.mask) return poInput.value;
  voEditMaskObj.df.maskPrompt = voColumn.maskPrompt;
  voEditMaskObj.subElement.input = poInput;
  voEditMaskObj.document = this.document;
  if(voEditMaskObj.cursorPosition < 0) voEditMaskObj.cursorPosition = 0;

  switch(voColumn.type) {
    case "Int":
    case "Float":
      vsData = String(vsData);
      vsData = this.setNumber(vsData);
      break;
    case "Date":
//      vsData = this.toDateFormatValue(vsData);
      vsData = poInput.value;
      if(vsData == "") vsData = this.toDateFormatValue(vsData);
      break;
    case "Text":
    case "Lines":
      vsData = this.setGeneric(vsData, psColId);
      break;
  }
  if(vsData == null) vsData = "&nbsp;"
  return vsData;
}
/**
 * 정해진 날짜형 마스크 포맷으로 값을 변환.
 * @param {String} psValue 컨트롤 disabled설정
 * @return 날짜형 마스크 포맷 적용 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.toDateFormatValue = function(psValue){
  psValue = psValue.replace(/[^\d]/g, "");
  var vsMask = this.convertDateFormat(this.column.mask);
  var vsPrompt = this.column.maskPrompt;
  var vsFormat = vsMask.replace(this.regDateMask,vsPrompt);
  // 개체의 값 얻어오기
  var vsReg = new RegExp('['+vsPrompt+']','gi');
  //var vsValue = psValue.replace(vsReg,"a");
  var vsRegValue = vsFormat;
  var vsRegFormat = new RegExp('['+vsPrompt+']','i');
  for(var i=0;i < psValue.length;i++) {
    vsRegValue = vsRegValue.replace(vsRegFormat, psValue.charAt(i));
  }
  vsRegValue = vsRegValue.replace(/[YMDhms]/g,vsPrompt);
  return vsRegValue;
};
/**
 * 숫자형 마스크 포맷으로 값을 변환.
 * @param {String} psValue 입력값
 * @return 숫자형 마스크 포맷 적용 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.setNumber = function(psValue) {
  var vsValue = this.getUnMaskedValue(psValue);
  var vsMask = this.column.mask;
  vsValue = NumberToString(psValue, vsMask);
  return vsValue;
};
/**
 * 문자형 마스크 포맷으로 값을 변환.
 * @param {String} psValue 입력값
 * @return 문자형 마스크 포맷 적용 값
 * @type String
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.setGeneric = function (psValue, psColId){
  var voColumn = this.column;
  var vsValue = this.getUnMaskedValue(psValue, psColId);
  vsValue = this.toStringFormatValue(vsValue, voColumn.mask, psColId);
  var vnPos = vsValue.indexOf(voColumn.maskPrompt);
  this.cursorPosition = vnPos;
  return vsValue;
};
/**
 * setKeyDownValue
 * @param {String} psValue 입력값
 * @param {Object} poRow row object
 * @param {String} psColId column id
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.setKeyDownValue = function(psValue, poRow, psColId){
  this.tempValue = psValue;
}
/**
 * 입력키에 유효성을 체크하고 마스크 타입에 맞게 문자열 변환 메소드.
 * @param {HTMLEvent} e 윈도우이벤트
 * @return 작업수행의 성공 여부
 * @type Boolean
 * @ignore
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.checkKey = function(e, poInput, psColId){
  var voColumn = this.column;
  var vnKeyCode = e.keyCode;
  var vsValue = poInput.value;
  var vnPos = this.cursorPosition = this.getCursorPosition(poInput);
  if(vnKeyCode == 229 && e.type != "keyup") { // 한글 입력 상태에서 마우스 클릭시 keyup 이벤트가 발생하여 이를 제외하여 체크
    alert("한글 입력은 허용이 되지 않습니다.");
  } else if(vnKeyCode == 229 && e.type == "keyup") {
    return;
  }

  var voConstKey = this.constKey;
  switch(vnKeyCode) {
    case voConstKey["ENTER"] :
    case voConstKey["TAB"] :
    case voConstKey["SHIFT"] :
    case voConstKey["LEFT"] :
    case voConstKey["RIGHT"] :
    case voConstKey["UP"] :
    case voConstKey["DOWN"] :
      return true;
  }
  var voStringMaskChar = this.stringMaskChar;
  var voNumberMaskChar = this.numberMaskChar;
  var voDateMaskChar = this.dateMaskChar;

  var voMaskCharSet = null;
  var vsType = voColumn.type;
  if(vsType == "Text" || vsType == "Lines") voMaskCharSet = voStringMaskChar;
  else if(vsType == "Int" || vsType == "Float") voMaskCharSet = voNumberMaskChar;
  else if(vsType == "Date") voMaskCharSet = voDateMaskChar;

  var vsMaskReg = "";
  for(var vsMaskChar in voMaskCharSet){
    if(/\W/.test(vsMaskChar)) vsMaskChar = "\\" + vsMaskChar;
    vsMaskReg += vsMaskChar;
  }
  var vrMaskReg = new RegExp("[" + vsMaskReg + "]", "g");
  var vsColMask = voColumn.mask;
  if(voColumn.type == "Date") voColumn.mask = this.convertDateFormat(voColumn.mask);
  var vsMask = voColumn.mask.replace(vrMaskReg, voColumn.maskPrompt);
  var vsTempValue = this.tempValue;

  function checkPosChar(pnPos){
    var vsMChar = voColumn.mask.charAt(pnPos-1);
    for(var vsMaskChar in voMaskCharSet){
      if(voMaskCharSet[vsMChar]) return voMaskCharSet[vsMChar];
    }
    return false;
  }

  function getValuePosition(pos, pnType){
    if(pos < 0 || pos > voColumn.mask.length) return pos;
    var retPos = pos;
    if(checkPosChar(pos)){
    }else{
      if(pnType == 0) pos--;
      else if(pnType == 1) pos++;
      retPos = getValuePosition(pos, pnType);
    }
    return retPos;
  }

  function setInputChar(pnPos, psChar){
    var vaTempValue = vsTempValue.split("");
    vaTempValue[pnPos-1] = psChar;
    return vaTempValue.join("");
  }
  function deleteInputChar(pnPos1, pnPos2){
    var vaTempValue = vsTempValue.split("");
    if(voColumn.type == "Text" || voColumn.type == "Lines") vaTempValue[pnPos1] = vsMask.charAt(pnPos1);
    if(voColumn.type == "Int" || voColumn.type == "Float") vaTempValue[pnPos1] = "";
    return vaTempValue.join("");
  }
  function returnInputValue(){
    return vsTempValue;
  }

  function checkInputCharValidation(pnPos, psChar){
    var vbRet = new RegExp("[" + voMaskCharSet[voColumn.mask.charAt(pnPos)] + "]").test(psChar);
    return vbRet;
  }

  vnKeyCode = this.matchNumberPad(vnKeyCode);
  var vsKeyCharacter = String.fromCharCode(vnKeyCode);
  switch(voColumn.type){
    case "Text" :
    case "Lines" :
    case "Date" :
      if(this.vbSelectAll){
        vnPos = vsMask.indexOf(voColumn.maskPrompt);
        if(new RegExp("[" + voMaskCharSet[voColumn.mask.charAt(vnPos)] + "]", "g").test(vsValue)){
          vsKeyCharacter = vsValue.charAt(vnTempPos-1);
          vsValue = this.toMaskedChar(vsKeyCharacter, voColumn.mask.charAt(vnPos));
          vsValue = vsMask.replace(voColumn.maskPrompt, vsValue);
        }else{
          vsValue = vsMask;
        }
        vnPos = vsValue.indexOf(voColumn.maskPrompt);
      }else if(vnKeyCode == 8 || vnKeyCode == 46){
        var vnTempPos = getValuePosition(vnPos, 0);
        vsValue = deleteInputChar(vnPos, vnTempPos);
      }else{
        var vnTempPos = getValuePosition(vnPos, 1);
        vsKeyCharacter = vsValue.charAt(vnTempPos-1);

        if(checkInputCharValidation(vnTempPos-1, vsKeyCharacter)){
          vsKeyCharacter = this.toMaskedChar(vsKeyCharacter, voColumn.mask.charAt(vnTempPos-1));
          vsValue = setInputChar(vnTempPos, vsKeyCharacter);

          // 2009.07.01 다음키가  key값 또는 maskPrompt도 아닌경우( - << 와 같은 캐릭터 일경우)
          // TODO: -- 두개일경우를 고려하여 for루프가 필요할수 있다
          if(vsValue.charAt(vnTempPos)) {
            var vsNextKey = vsValue.charAt(vnTempPos);
            if(voColumn.maskPrompt != vsNextKey) {
              if(checkInputCharValidation(vnTempPos, vsNextKey) == false)
                vnTempPos++;
            }
          }

          vnPos = vnTempPos;
        }else{
          vsValue = returnInputValue();
          vnPos--;
        }
      }
      break;
    case "Int" :
    case "Float" :
      if(vnKeyCode == 8 || vnKeyCode == 46){
        var vnTempPos = getValuePosition(vnPos, 0);
        vsValue = deleteInputChar(vnPos, vnTempPos);
        vsValue = vsValue.replace(/[^0-9\.]/gi, "");
        vsValue = NumberToString(vsValue, voColumn.mask);
        vnPos++;
      }else{
        vsValue = vsValue.replace(/[^0-9\.]/gi, "");
        var vnTempPos = getValuePosition(vnPos, 1);
        if(vnKeyCode == 190) vsKeyCharacter = ".";
        if(checkInputCharValidation(vnTempPos-1, vsKeyCharacter)){
          vsKeyCharacter = this.toMaskedChar(vsKeyCharacter, voColumn.mask.charAt(vnTempPos));
          vsValue = setInputChar(vnTempPos, vsKeyCharacter);
          var vnTempLen = vsValue.length;
          if(vsKeyCharacter != "."){
            vsValue = vsValue.replace(/[^0-9\.]/gi, "");
            vsValue = NumberToString(vsValue, voColumn.mask);
          }
          vnPos = vnTempPos;
          if(vnTempLen != vsValue.length) vnPos++;
        }else{
          vsValue = returnInputValue();
          vnPos--;
        }
      }
      break;
  }
  poInput.value = vsValue;
  if(vnPos >= 0) this.setCursorPosition(vnPos, poInput);
};
/**
 * 날짜 validiate 검사.
 * @param (String) psValue 컨트롤 disabled설정
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.checkDate = function(psValue){
  var voDf = this.df;
  psValue = psValue.replace(this.noDigits, "");
  var vsFormat = this.column.mask;
  vsFormat = vsFormat.replace(/[^YyMDdhms]/g, "");

  var vnYearPos = vsFormat.search(/yyyy/i);
  var vnMonthPos = vsFormat.search(/mm/i);
  var vnDatePos = vsFormat.search(/dd/i);
  var vnYear = psValue.substr(vnYearPos, 4);
  if(vnYear != "") vnYear = parseInt(vnYear);
  var vnMonth = psValue.substr(vnMonthPos, 2);
  if(vnMonth.length == 1) vnMonth += "0";
  if(vnMonth != "") vnMonth = parseInt(vnMonth) - 1;
  var vnDate = psValue.substr(vnDatePos, 2);
  if(vnDate.length == 1) vnDate += "0";
  if(vnDate != "") vnDate = parseInt(vnDate);

  var voDate = new Date();
  if(vnYear == "" || vnYear == 0) vnYear = voDate.getFullYear();
  if(vnMonth == "" || vnMonth == -1) vnMonth = voDate.getMonth();
  if(vnDate == "" || vnDate == 0) vnDate = voDate.getDate();

  voDate.setFullYear(vnYear);
  voDate.setMonth(vnMonth);
  voDate.setDate(vnDate);

  if( voDate.getFullYear() != vnYear
      || voDate.getMonth() != vnMonth
      || voDate.getDate() != vnDate) {
    return false;
  }
  return true;
};
/**
 * 사용자가 정의한 마스크를 제외하고 삭제
 * @param poEvent
 * @return 삭제하고 난 후의 값
 * @type Array(String)
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.chkBackSpace = function(poEvent, psColId, poInput){
  var voColumn = this.column;
  var voDf = this.df;
  var vnKeyCode = poEvent.keyCode;
  var vnPos = this.getCursorPosition(poInput);
  var vsValue = null;
  var vnCutPos = 0;
  var vsMaskReg = "";
  var vsMaskPrompt = String.fromCharCode(255);
  for(var vsMaskChar in this.stringMaskChar){
    if(/\W/.test(vsMaskChar)) vsMaskChar = "\\" + vsMaskChar;
    vsMaskReg += vsMaskChar;
  }
  var voStringReg = new RegExp("[^" + vsMaskReg + "]","g");
  var voDateReg = new RegExp("[^YMDhms]","g");
  var voReg = null;
  var voRegI = null;
  var voValues = new Array;
  voColumn.vbSelectAll = false; // temp code
  if(voColumn.vbSelectAll) return "";
  if(voColumn.type == "Text" || voColumn.type == "Lines") {
    voReg = voStringReg;
    voRegI = new RegExp("[" + vsMaskReg + "]","g");
  }
  else if(voColumn.type == "Date") {
    voReg = voDateReg;
    voRegI = /[YMDhms]/g;
  }
  vsValue = poInput.value;
  if(vnKeyCode == 8){
    var vsVal1 = vsValue.substring(0, vnPos);
    var vsVal2 = vsValue.substring(vnPos, vsValue.length);
    vsValue = vsVal1 + voColumn.maskPrompt + vsVal2;
    vnPos++;
  }else if(vnKeyCode == 46){
    var vsVal1 = vsValue.substring(0, vnPos);
    var vsVal2 = vsValue.substring(vnPos, vsValue.length);
    vsValue = vsVal1 + voColumn.maskPrompt + vsVal2;
  }
  voValues[0] = vsValue;
  voValues[1] = vnPos;

  return voValues;
};
/**
 * inputbox에서의 커서 위치 설정
 * @param {Number} pnPos 커서 위치 값
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.setCursorPosition = function(pnPos, poInput) {
  if(poInput.selectionEnd) {
    poInput.selectionStart = pnPos;
    poInput.selectionEnd = pnPos;
  } else if (poInput.createTextRange) {
    var voRange = poInput.createTextRange();
    voRange.collapse(true);
    voRange.moveEnd('character', pnPos);
    voRange.moveStart('character', pnPos);
    voRange.select();
  }
};
/**
 * 현재에서의 커서 위치 반환
 * @return 커서의 위치
 * @type Number
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.getCursorPosition = function(poInput) {
  var voDocument = this.grid.document;
  var vnCursorPosition = -1;
  if(poInput == null) return vnCursorPosition;
  if (poInput.selectionEnd) {
    vnCursorPosition = poInput.selectionEnd;
  } else if(voDocument.selection && voDocument.selection.createRange) {
    var voRange = voDocument.selection.createRange().duplicate();
    voRange.moveStart('textedit', -1);
    vnCursorPosition = voRange.text.length;
  }
  return vnCursorPosition;
};
/**
 * 넘버패드의 keycode를 기본 숫자 keycode로 변환
 * @param (Number)
 * @return 변환된 keyCOde
 * @type Number
 * @private
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.matchNumberPad = function(vnKeyCode){
  if(vnKeyCode > 95 && vnKeyCode < 106) return vnKeyCode -= 48;
  else if(vnKeyCode == 110) return 190;
  else return vnKeyCode;
}
/**
 * 현재 텍스트가 전체 select 되어있는지 여부를 확인
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.checkSelect = function(e, poInput, psColId){
  var voDocument = this.grid.document;
  var voCanvas = this.grid.canvas;
  var vnTextLen = poInput.value.length;
  this.vbSelectAll = false;
  if(voCanvas.page.metadata.browser.ie){
    var voTextRange = voDocument.selection.createRange();
    var vnLen = voTextRange.text.length;
    if(vnLen == vnTextLen) this.vbSelectAll = true;
  }else{
    if(poInput.selectionEnd - poInput.selectionStart == vnTextLen) this.vbSelectAll = true;
  }
};
/**
 * Mask가 적용된 Value를 Mask를 없앤 후 반환
 * @param {String} psData Data
 * @param {String} psColId Column Id
 * @return String
 * @type String
 * @private
 */
eXria.controls.xhtml.GridEx.FormatMask.prototype.getUnMaskedValue = function(psData, psColId){
  var voColumn = this.column;
  var vsMask = voColumn.mask;
  var vsNotMask = "";
  var vsMaskReg = null;

  if(!vsMask) return psData;
  if(voColumn.type == "Text" || voColumn.type == "Lines"){
    vsNotMask = eXria.util.StringUtil.trim((voColumn.mask.replace(/[#*x]/gi,"")));
    if(vsNotMask.length != 0){
      if(vsNotMask.match(/\W/g)){
        var vaMatch = String(vsNotMask.match(/\W/g)).split(",");
        for(var i=0; i<vaMatch.length; i++) vaMatch[i] = "\\" + vaMatch[i];
        vsNotMask = vaMatch.join("");
      }
      vsNotMask = "[" + vsNotMask + "]";
      vsMaskReg = new RegExp(vsNotMask,'gi');
    }
  }
  var vsData = eXria.controls.xhtml.Util.parseLang(psData);
  var vsFormat = voColumn.mask.replace(this.regDateMask, voColumn.maskPrompt);
  // 개체의 값 얻어오기
  var vsReg = new RegExp('['+voColumn.maskPrompt+']','gi');
  //var vsValue = psValue.replace(vsReg,"a");
  var vsRegValue = vsFormat;
  var vsRegFormat = new RegExp('['+voColumn.maskPrompt+']','gi');
  switch(voColumn.type){
    case "Text":
    case "Lines":
      psData = String(psData);
      psData = psData.replace(vsMaskReg, "");
      psData = psData.replace(vsRegFormat, "");
      vsData = psData;
      break;
    case "Int":
    case "Float":
      psData = String(psData);
      vsData = Number(psData.replace(/[^0-9\.\-\+]/gi, ""));
      break;
    case "Date":
      vsFormat = vsMask.replace(this.regDateMask, voColumn.maskPrompt);
      vsData = this.toDateFormatValue(vsData);
      var vsNotMask = voColumn.mask.replace(/[ymdhs]/gi, "");
      vsNotMask = vsNotMask.split(" ").join("");
      if(vsNotMask.length != 0){
        if(vsNotMask.match(/\W/g)){
          var vaMatch = String(vsNotMask.match(/\W/g)).split(",");
          for(var i=0; i<vaMatch.length; i++) vaMatch[i] = "\\" + vaMatch[i];
          vsNotMask = vaMatch.join("");
        }
        vsNotMask = "[" + vsNotMask + "]";
        vsMaskReg = new RegExp(vsNotMask,'gi');
      }
      vsData = vsData.replace(vsMaskReg, "");

      vsData = vsData.replace(new RegExp("[\\" + voColumn.maskPrompt + "]", "gi"), "");
      vsData = vsData.split(" ").join("");
      break;
  }
  return vsData;
};


/**
 * @class GridEx의 Color정보 저장 객체 정의 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx.ColorData 객체
 * @type eXria.controls.xhtml.GridEx.ColorData
 * @constructor
 * @private
 */
eXria.controls.xhtml.GridEx.ColorData = function() {
  /**
   * row 식별자 저장 배열
   * @type Arryay
   * @private
   */
  this.primaryKeys = new Array();
  /**
   * header row color 정보 저장 배열
   * @type Array
   * @private
   */
  this.headColorData = new Array();
  /**
   * body row color 정보 저장 배열
   * @type Array
   * @private
   */
  this.bodyColorData = new Array();
  /**
   * footer row color 정보 저장 배열
   * @type Array
   * @private
   */
  this.footColorData = new Array();
  /**
   * header row color 정보를 반환하는 메소드
   * @return header row color 정보
   * @type Array
   * @private
   */
  this.getHeaderRowData = function(psColId){
    for(var i=0,il=this.headColorData.length; i<il; i++){
      if(this.headColorData[i].columnId == psColId) return this.headColorData[i];
    }
    return null;
  };
  /**
   * footer row color 정보를 반환하는 메소드
   * @return footer row color 정보
   * @type Array
   * @private
   */
  this.getFooterRowData = function(psColId){
    for(var i=0,il=this.footColorData.length; i<il; i++){
      if(this.footColorData[i].columnId == psColId) return this.footColorData[i];
    }
    return null;
  }
};

/**
 * @class GridEx row의 Color정보 저장 객체 정의 클래스
 * @return 새로운 eXria.controls.xhtml.GridEx.ColorData.RowData 객체
 * @type eXria.controls.xhtml.GridEx.ColorData.RowData
 * @constructor
 * @private
 */
eXria.controls.xhtml.GridEx.ColorData.RowData = function(){
  /**
   * column 식별자 저장 ArrayMap 객체
   * @type Array
   * @private
   */
  this.primaryKeyValues = new eXria.data.ArrayMap();
  /**
   * row color 값 참조 변수
   * @type String
   * @private
   */
  this.rowColor = null;
  /**
   * 컬럼 색상 정보 ArrayMap 객체
   * @type Array
   * @private
   */
  this.columnsColor = new eXria.data.ArrayMap();
  /**
   * 컬럼 id 참조 변수
   * @type Array
   * @private
   */
  this.columnId = null;
};

/**
 * @class GridEx Page(Fast) 옵션일 경우 Select 처리 위한 함수
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setPageSelection = function() {
   // paging 관련 추가코드 (rowcount갯수가 변함)
//  var vnCount = this.getRowCnt();
//  for(var i = 0; i < vnCount; i++) {
//   var voRow = this.getRowIndex(i);
//    if(voRow) {
//      if(this.pageSelectAllChecked == true) {
//        if(voRow.Selected == null || voRow.Selected == false) {
//          this.selectRow(voRow);
//        }
//      }
//      else if(this.pageSelectAllChecked == false) {
//        if(voRow.Selected == true) {
//          this.selectRow(voRow);
//        }
//      }
//    }
//  }
//
//  // 마지막에 안보이는 사례 보임
//  var voRow = this.grid.GetLastVisible(null, null);
//  if(voRow) {
//    if(this.pageSelectAllChecked == true) {
//      if(voRow.Selected == null || voRow.Selected == false) {
//        this.selectRow(voRow);
//      }
//    }
//    else if(this.pageSelectAllChecked == false) {
//      if(voRow.Selected == true) {
//        this.selectRow(voRow);
//      }
//    }
//  }
   var vaRow = this.getPagingRows();
   var vnSize = vaRow.length;
   var voRow = null;
   for(var i = 0; i < vnSize; i++) {
     voRow = vaRow[i];
     if(this.pageSelectAllChecked == true) {
       if(voRow.Selected == null || voRow.Selected == false) {
         this.selectRow(voRow);
       }
     } else if(this.pageSelectAllChecked == false) {
       if(voRow.Selected == true) {
         this.selectRow(voRow);
       }
     }
   }
};

/**
 * @member eXria.controls.xhtml.GridEx
 * @type void
 * @author yhkim at 10. 1. 5 오전 11:29
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setColumnDiffWidth = function(pnOldWidth, pnAttrValue) {
  var voCols = new Array();
  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  var nColLen = 0;
  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
    for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
    if(voColumn.visible !== false)
        nColLen++;
    }
    }
  }
  var nDiff = pnAttrValue - pnOldWidth;
  nDiff = nDiff / nColLen;

  for(var i=0; i<3; i++) {
    if(voCols[i]) {
      voRow = voCols[i].rows[0];
      for(var j=0; j<voRow.columns.length; j++) {
        voColumn = voRow.columns[j];
    if(voColumn.visible !== false)
          voColumn.width = voColumn.width + nDiff;
      }
    }
  }
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
};

/**
 * @member eXria.controls.xhtml.GridEx
 * @type void
 * @author yhkim at 10. 1. 12 오후 19:07
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getOrgValueFromMask = function(psData, psMask) {
  if(psData == null || psData == "") return psData;
  if(psMask == null || psMask == "") return psData;
  var voRegMap = {"x": "[A-Za-z0-9]", "X": "[A-Za-z0-9]", "#": "[0-9]", "*": ".", "S" : "[a-zA-Z0-9\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]"};
  psMask = psMask.replace(/[^#Xx*S]/g, "");
  var vsRegValue = "";
  var vnIndex = 0;
  var vnSize = psMask.length;
  var vsMaskChar = null;
  var vsChar = null;
  var vnValLen = psData.length;
  var vsRegStr = null;
  for(var i=0; i < vnSize; i++) {
    vsMaskChar = psMask.charAt(i);    // xx:
    vsChar = psData.charAt(vnIndex++);  // 123
    vsRegStr = voRegMap[vsMaskChar];  //
    if(vsRegStr && (new RegExp(vsRegStr)).test(vsChar)) vsRegValue += vsChar;
  else i--;
    if(vnIndex >= vnValLen) break;
  }

  return vsRegValue;
};

/**
 * treegrid소스내에서 동적으로 locale정보를 얻기위해 제공해주는 함수(gridEx에서는 사용안됨)
 * @member eXria.controls.xhtml.GridEx
 * @type void
 * @author yhkim at 10. 1. 282 오후 19:07
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getLocale = function() {
  var vsLocale = "kor";
  if(this.locale == null) {
    if(this.canvas.page.metadata.useMultilingual != null && this.canvas.page.metadata.language != null) {
      if(this.canvas.page.metadata.useMultilingual == true) {
        var vsDefaultLocale = this.canvas.page.metadata.eXriaLocale.toUpperCase();
        if(vsDefaultLocale == "KO_KR") vsLocale = "kor";
        else if(vsDefaultLocale == "JA_JP") vsLocale = "jpn";
        else if(vsDefaultLocale.search(/ZH/) != -1) vsLocale = "chn";
        else vsLocale = "eng";
      }
      else {
        if(this.canvas.page.metadata.language.toUpperCase() == "KO") vsLocale = "kor";
        else vsLocale = "eng";
      }
    }
  }
  else vsLocale = this.locale;
  return vsLocale;
};

/**
 * Re-calculates grid after given cell changes
 * @member eXria.controls.xhtml.GridEx
 * @type void
 * @author tomato at 10. 2. 24 오후 3:06
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.recalculate = function(poRow, psCol, pbShow) {
  this.grid.Recalculate(poRow, psCol, pbShow);
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.clearDataSetRowKeyValue = function(psKeyName) {
  var voDataSet = null;
  if (this.dataset) voDataSet = this.dataset;
    else {
    if(this.datasetId)
      voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
  }
  if(voDataSet) {
    if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE)
      voDataSet.setRowsAttr(psKeyName, null);
//    else if(this.canvas.page.metadata.modelType == eXria.form.ModelType.PLUGIN) {
    else {
      var vnRowCnt = voDataSet.getRowCnt();
      for(var i = 0; i < vnRowCnt; i++) {
        // plugin 한번에 날리는 로직을 구현해준다고 함
        voDataSet.setRowAttr(i+1, psKeyName, "");
      }
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.setDataSetRowKeyValue = function(psKeyName, psValue) {
   if(psValue == null) psValue = "";
   var voDataSet = null;
  if (this.dataset) voDataSet = this.dataset;
    else {
    if(this.datasetId)
      voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
  }

  if(voDataSet === null) return;

  if(voDataSet) {
    var vaIndexes = [];
    if(psKeyName === "focus__RowIndex") {
      if(this.focusRow !== null)
        vaIndexes.push(this.getIndexOfRow(this.focusRow));
    }
    else if(psKeyName === "selected__RowIndex") {
          if(this.selectedIndexes !== null)
        vaIndexes = this.selectedIndexes;
    }

    for(var j = 0; j < vaIndexes.length; j++) {
      voDataSet.setRowAttr(vaIndexes[j]+1, psKeyName, psValue);
    }
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.runWithDataSetColumnType = function(psType) {
  var voDataSet = null;
  if (this.dataset) voDataSet = this.dataset;
  else {
    if(this.datasetId)
      voDataSet = this.canvas.page.model.getDataSet(this.datasetId);
  }

  if(voDataSet === null) return;

  var voRow = null;
  var vsValue = null;

  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE) {
    var vaList = null;
    vaList = voDataSet.getRowsAttr(psType);
    if(vaList == null || !(vaList instanceof Array)) vaList = [];
    for(var i = 0; i < vaList.length; i++) {
    var vnIndex = vaList[i].get(0);
    vsValue = voDataSet.getRowAttr(vnIndex, psType);
    voRow = this.getRowIndex(vnIndex-1);
    }
  }
//  else if(this.canvas.page.metadata.modelType == eXria.form.ModelType.PLUGIN) {
  else {
    var vnDSCnt = voDataSet.getRowCnt();
    for(var i = 1; i < vnDSCnt+1; i++) {
      vsValue = voDataSet.getRowAttr(i, psType);
      if(!!vsValue) {
        voRow = this.getRowIndex(i-1);
        break;
      }
    }
  }

  if(voRow) {
    if(vsValue) {
      if("focus__RowIndex" === psType) {
        if(vsValue == "") vsValue = null;
        this.grid.Focus(voRow, vsValue, null, true);
      }
      if("selected__RowIndex" === psType) {
        if(voRow.Selected != true)
          this.grid.SelectRow(voRow);
      }
    }
    else {
      if("selected__RowIndex" === psType && voRow.Selected === true)
        this.grid.SelectRow(voRow);
    }
  }
};

/**
 *
 * @member eXria.controls.xhtml.GridEx
 * @type ?
 * @author tomato at 10. 3. 9 오후 1:22
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.Initialize = function() {
  this.pageSelectAllChecked = null;
};

/**
 * @member eXria.controls.xhtml.GridEx
 * @author tomato at 10. 3. 11 오전 9:40
 * @ignore
 */
eXria.controls.xhtml.GridEx.prototype.getIMEInfo = function(poRow, psCol) {
  var voCol = null;
  if(voCol == null) voCol = this.getBodyColumn(null, psCol);
  if(voCol == null) voCol = this.getFunctionColumn(poRow, null , psCol);
  if(voCol == null) voCol = this.getFootColumn(poRow, null , psCol);
  if(voCol && voCol.imeMode) return voCol.imeMode;
};

/**
 * 그리드 컬럼 정보 반환
 * @member eXria.controls.xhtml.GridEx
 * @type ?
 * @author tomato at 10. 4. 8 오후 4:20
 */
eXria.controls.xhtml.GridEx.prototype.getColumnObj = function(psCol) {
  var voColumn = null;
  var voCols = new Array();
  voBody = this.body;
  voCols[0] = voBody.cols["left"];
  voCols[1] = voBody.cols["center"];
  voCols[2] = voBody.cols["right"];

  var voArray = new Array();
  for(var i = 0; i < voCols.length; i++)
    if(voCols[i] && voCols[i].rows)
      voArray = voArray.concat(voCols[i].rows[0].columns);

  for(var j=0; j < voArray.length; j++) {
    voColumn = voArray[j];
    if(voColumn.colId == psCol) {
      break;
    }
  }
  return voColumn;
};

/**
 * instance 또는 dataset의 컬럼 name 으로 그리드 rowIndex 의 value값 가져오기
 * @member eXria.controls.xhtml.GridEx
 * @type ?
 * @author tomato at 10. 4. 8 오후 4:20
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.getValueByIndex = function(pnRow, psCol) {
  var value = null;

  if(this.dataset)
    return this.dataset.get(pnRow, psCol);
  else {
    var voColumn = this.getColumnObj(psCol);
    if(voColumn == null) return;
    var poCollectionNode = this.data.getNodesetData();
    if(poCollectionNode == null) return;
    var voMapMode = new eXria.data.xhtml.MapNode(poCollectionNode.get(pnRow));
    value = voMapMode.get(voColumn.ref);
    return value;
  }
};

/**
 * instance 또는 dataset의 row의 String값 가져오기
 * @member eXria.controls.xhtml.GridEx
 * @type ?
 * @author tomato at 10. 4. 8 오후 4:20
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.getStringByIndex = function(pnRow, psCol) {
  var vsValue = this.getValueByIndex(pnRow, psCol);
  var voColumn = this.getColumnObj(psCol);
  if(voColumn == null) return;
  // Treegrid값 형태로 변환
  switch(voColumn.type){
    case "Date" :
      var vnTime = "";
      if (vsValue != "" && vsValue != null) {
        var tempDate = new Date(this.addSeparator(vsValue, 2, null, psCol));
        var ut = new Date(tempDate);
        var voDate = new Date(Date.UTC(ut.getFullYear(), ut.getMonth(), ut.getDate(), ut.getHours(), ut.getMinutes(), ut.getSeconds()));
        vnTime = voDate.getTime();
      }
      vsValue = vnTime;
      break;
    case "Bool" :
      if(vsValue != null && vsValue != "") vsValue = eval(vsValue);
      break;
    case "Radio" :
    case "CheckBox" :
      if(vsValue == null) return null; // 2009.12.01 yhkim(bug6398) 이 조건문 자체는 맨위로 가야할듯 하나 Date가 ""리턴하는 side-effect 문제로 이조건문에만 넣음 > 향후고려 필요
      var vaValues = voColumn.itemgroup.getItemValuesToArray();
      var getMatchValueIdx = function(psVal) {
        for(var i=0; i<vaValues.length; i++) {
          if(vaValues[i] == psVal) return i;
        }
        return false;
      }
      if(typeof(vsValue) == "string") vsValue = vsValue.split(",");
      if(voColumn.type == "CheckBox") {
        var vaAllValues = voColumn.itemgroup.getItemValuesToArray();
        var vaAllLabels = voColumn.itemgroup.getItemLabelsToArray();
        var vaSelectedValues = vsValue;
        var vaSelectedLabels = [];
        for(var p=0; p< vaAllValues.length; p++) {
          for(var q=0; q<vaSelectedValues.length; q++)
          if(vaAllValues[p] == vaSelectedValues[q])
            vaSelectedLabels.push(vaAllLabels[p]);
        }
        vsValue = vaSelectedLabels.join(";");
      }else {
        vsValue = getMatchValueIdx(vsValue[vsValue.length-1]);
      }
      break;
    case "Enum" :
      var vsValues = voColumn.itemgroup.getItemValuesToString(voColumn.itemSeparator);
      var vsLabels = voColumn.itemgroup.getItemLabelsToString(voColumn.itemSeparator);

      var vaEnumKeys = vsValues.split('|');
      var vaEnum = vsLabels.split('|');
      for(var i=0, il=vaEnumKeys.length; i<il; i++){
        if(vaEnumKeys[i] == vsValue){
          vsRetValue = i;
          break;
        }
      }
      vsValue = vaEnum[i];
    default :
      break;
  }
  // Tree그리드 변환 형태 따름
  return this.grid.GetStringExt(voColumn.type, voColumn.regFormat, vsValue);

};

/**
 * GridEx의 칼럼과 이벤트 정보를 다른 GridEx에서 가져와 확장한다.
 * @param {Object} eXria.controls.xhtml.GridEx
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.extendCols = function(poGrid) {
  var voTrgDst = this.dataset;
  var voTrgHColsRow = this.header.cols["center"].rows[0];
  var voTrgBColsRow = this.body.cols["center"].rows[0];
  var voCol = null;

  var voSrcDst = poGrid.dataset;
  var voSrcHColsRow = poGrid.header.cols["center"].rows[0];
  var vaSrcHColumns = voSrcHColsRow.columns;
  var voSrcHCol = null;
  var voSrcBCol = null;
  var vnSize = vaSrcHColumns.length;
  for(var i = 0; i < vnSize; i++) {
    voSrcHCol = vaSrcHColumns[i];
    voSrcBCol = poGrid.getBodyColumn(null, voSrcHCol.id)

    voCol = voTrgHColsRow.createHeadColumn(voSrcHCol.id, null, null);
    voCol.colspan = voSrcHCol.colspan;
    voCol.value = voSrcHCol.value;
    voCol.className = voSrcHCol.className;
    voCol.hoverClassName = voSrcHCol.hoverClassName;
    voTrgHColsRow.addColumn(voCol);

    voCol = voTrgBColsRow.createBodyColumn(voSrcBCol.id, voSrcHCol.id, voSrcBCol.type, voSrcBCol.instanceId, voSrcBCol.ref);
    voCol.width = voSrcBCol.width;
    voCol.datasetCol = voSrcBCol.datasetCol;

    voCol.className = voSrcBCol.className;
    voCol.hoverClassName = voSrcBCol.hoverClassName;
    voCol.enumType = voSrcBCol.enumType;
    voCol.formula = voSrcBCol.formula;
    voCol.itemSeparator = voSrcBCol.itemSeparator;

    voCol.minLength = voSrcBCol.minLength;
    voCol.maxLength = voSrcBCol.maxLength;
    voCol.minByteLength = voSrcBCol.minByteLength;
    voCol.maxByteLength = voSrcBCol.maxByteLength;
    voCol.nullable = voSrcBCol.nullable;
    voCol.inputMode = voSrcBCol.inputMode;

    voCol.groupFormula = voSrcBCol.groupFormula;
    voCol.groupFormat = voSrcBCol.groupFormat;
    voCol.groupClassName = voSrcBCol.groupClassName;

    if(voCol.type == "Int" || voCol.type == "Float" || voCol.type == "Date" || voCol.type == "Text") {
      voCol.format = voSrcBCol.format;
      voCol.mask = voSrcBCol.mask;
      voCol.regMask = voSrcBCol.regMask;
      voCol.regFormat = voSrcBCol.regFormat;
    }

    if(voSrcBCol.rightButton) {
        var voRightButton = voCol.createRightButton(voSrcBCol.rightButton.type, voSrcBCol.instanceId, voSrcBCol.ref);
        voRightButton.width = voSrcBCol.rightButton.width;
        voRightButton.value = voSrcBCol.rightButton.value;
        voRightButton.enableMode = voSrcBCol.rightButton.enableMode;
        voCol.addRightButton(voRightButton);
    }

    voCol.canEdit = voSrcBCol.canEdit;
    voCol.canFocus = voSrcBCol.canFocus;
    voCol.canSort = voSrcBCol.canSort;
    voCol.visible = voSrcBCol.visible;

    var voItemGroup = null;
    switch(voCol.type) {
      case "CheckBox" :
      case "Radio" :
        voCol.displayMode = voSrcBCol.displayMode;
      case "Enum" :
        var voData = voSrcBCol.itemgroup.data;
        voItemGroup = voCol.itemgroup;
        if(voData.nodesetInstanceId && voData.nodesetInstancePath) {
          voItemGroup = voCol.itemgroup;
          voItemGroup.data.setNodesetRef(voData.nodesetInstanceId, voData.nodesetInstancePath);
          voItemGroup.labelTagName = voSrcBCol.itemgroup.labelTagName;
          voItemGroup.valueTagName = voSrcBCol.itemgroup.valueTagName;
        }

        var voItems = voSrcBCol.itemgroup.frontItems;
        var vnItemCnt = voItems.size();
        var voItemKeys = voItems.getKeyCollection();
        var voItemValues = voItems.getValueCollection();
        var vsItemKey = null;
        var vsItemValue = null;
        for(var j = 0; j < vnItemCnt; j++) {
          vsItemKey = voItemKeys.get(j);
          vsItemValue = voItemValues.get(j);
          voItemGroup.addItemFront(vsItemValue, vsItemKey);
        }
        voItems = voSrcBCol.itemgroup.backItems;
        vnItemCnt = voItems.size();
        voItemKeys = voItems.getKeyCollection();
        voItemValues = voItems.getValueCollection();
        for(var j = 0; j < vnItemCnt; j++) {
          vsItemKey = voItemKeys.get(j);
          vsItemValue = voItemValues.get(j);
          voItemGroup.addItemBack(vsItemValue, vsItemKey);
        }
        break;
      case "Button" :
        voCol.buttonItem.width = voSrcBCol.buttonItem.width;
        voCol.buttonItem.height = voSrcBCol.buttonItem.height;
        voCol.buttonItem.icon = voSrcBCol.buttonItem.icon;
        voCol.buttonItem.iconChecked = voSrcBCol.buttonItem.iconChecked;
        voCol.buttonItem.tooltip = voSrcBCol.buttonItem.tooltip;
        voCol.buttonItem.tooltipChecked = voSrcBCol.buttonItem.tooltipChecked;
        break;
      case "Image" :
        voCol.imageItem.width = voSrcBCol.imageItem.width;
        voCol.imageItem.height = voSrcBCol.imageItem.height;
        voCol.imageItem.left = voSrcBCol.imageItem.left;
        voCol.imageItem.top = voSrcBCol.imageItem.top;
        voCol.imageItem.href = voSrcBCol.imageItem.href;
        voCol.imageItem.target = voSrcBCol.imageItem.target;
        break;
    }

    voTrgBColsRow.addColumn(voCol);
    voTrgDst.addColumn(-1, voCol.datasetCol);
  }

  var vaTableName = voSrcDst.getCRUDTableNames().split(",");
  var vnTblCnt = vaTableName.length;
  var vsTableNm = null;
  var vnColCnt = null;
  var vaColName = null;
  var vsColNm = null;
  var vaCol = null;
  var vsPrefix = null;
  for(var i = 0; i < vnTblCnt; i++) {
    vsTableNm = vaTableName[i];
    if(vsTableNm == "") {
      break;
    }
    vsPrefix = voSrcDst.getPrefix(vsTableNm);
    voTrgDst.addCRUDTable(vsTableNm);
    voTrgDst.setPrefix(vsTableNm, vsPrefix);
    vaColName = voSrcDst.getPrimaryKeys(vsTableNm).split(",");
    vnColCnt = vaColName.length;
    for(var j = 0; j < vnColCnt; j++) {
      vsColNm = vaColName[j];
      if(vsColNm == "") break;
      vaCol = vsColNm.split(":");
      vsColNm = voTrgDst.addPrimaryKey(vsTableNm, vaCol[0], vaCol[1]);
    }

    vaColName = voSrcDst.getUpdateCols(vsTableNm).split(",");
    vnColCnt = vaColName.length;
    for(var j = 0; j < vnColCnt; j++) {
      vsColNm = vaColName[j];
      if(vsColNm == "") break;
      vaCol = vsColNm.split(":");
      vsColNm = voTrgDst.addUpdateColumn(vsTableNm, vaCol[0], vaCol[1]);
    }
  }
  this.orgEventList = {};
  for(var attr in poGrid) {
    if(attr.indexOf("onGridex") == 0) {
      var vsPageFunc = poGrid[attr].toString();
      if(this[attr] == null) {
        var vnStIdx = vsPageFunc.indexOf(".") + 1;
        var vnEdIdx = vsPageFunc.lastIndexOf("(");
        vsPageFunc = vsPageFunc.substring(vnStIdx, vnEdIdx);

        var vsFunc = poGrid.canvas.page[vsPageFunc].toString();
        var vnStIdx = vsFunc.indexOf("{") + 1;
        var vnEdIdx = vsFunc.lastIndexOf("}");
        vsFunc = vsFunc.substring(vnStIdx, vnEdIdx);
        eval("this.canvas.page[vsTrgFuncSource] = function(e) {" + vsFunc + "};");
        eval("this[attr] = this.canvas.page[vsTrgFuncSource];");
        this.orgEventList[attr] = null;
      } else {
        var vsTrgFuncSource = this[attr].toString();
        var vnStIdx = vsTrgFuncSource.indexOf(".") + 1;
        var vnEdIdx = vsTrgFuncSource.lastIndexOf("(");
        vsTrgFuncSource = vsTrgFuncSource.substring(vnStIdx, vnEdIdx);

        var vsTrgPageFunc = this.canvas.page[vsTrgFuncSource].toString();
        var vnStIdx = vsTrgPageFunc.indexOf("{") + 1;
        var vnEdIdx = vsTrgPageFunc.lastIndexOf("}");
        var vsTrgFunc = vsTrgPageFunc.substring(vnStIdx, vnEdIdx);

        var vnStIdx = vsPageFunc.indexOf(".") + 1;
        var vnEdIdx = vsPageFunc.lastIndexOf("(");
        vsPageFunc = vsPageFunc.substring(vnStIdx, vnEdIdx);

        var vsFunc = poGrid.canvas.page[vsPageFunc].toString();
        var vnStIdx = vsFunc.indexOf("{") + 1;
        var vnEdIdx = vsFunc.lastIndexOf("}");
        vsFunc = vsFunc.substring(vnStIdx, vnEdIdx);
        this.orgEventList[attr] = "this.canvas.page[\"" + vsTrgFuncSource + "\"] = function(e) {" + vsTrgFunc + "};";
        eval("this.canvas.page[vsTrgFuncSource] = function(e) {" + vsTrgFunc + vsFunc + "};");
      }
    }
  }

  this.refresh();
};

/**
 * GridEx에 대한 확장 이전의 상태를 저장한다.
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.extendInit = function() {
  this.extendTableMap = {};
  this.extendHeadColMap = {};
  this.extendRestoreObj = {};
  var voDst = this.dataset;
  var vaCol = this.getHeadColumnList(1);
  var vsCol = null;
  var vnSize = vaCol.length;
  for(var j = 0; j < vnSize; j++) {
    vsCol = vaCol[j];
    this.extendHeadColMap[vsCol] = "";
  }

  var vaTbl = voDst.getCRUDTableNames().split(",");
  vnSize = vaTbl.length;
  var vsTbl = null;
  for(var j = 0; j < vnSize; j++) {
    vsTbl = vaTbl[j];
    if(vsTbl == "") break;
    this.extendTableMap[vsTbl] = "";
  }
};

/**
 * GridEx의 상태를 초기 extendInit 시점으로 되돌린다.
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.extendReset = function() {
  var voDst = this.dataset;
  var vaCol = this.getHeadColumnList(1);
  var vsCol = null;
  var voCol = null;
  var vnSize = vaCol.length;
  for(var j = 0; j < vnSize; j++) {
    vsCol = vaCol[j];
    if(this.extendHeadColMap[vsCol] == null) {
      this.removeHeadColumn(vsCol);
      voCol = this.removeBodyColumn(null, vsCol);
      voDst.removeColumn(voCol.datasetCol);
    }
  }

  var vaTbl = voDst.getCRUDTableNames().split(",");
  vnSize = vaTbl.length;
  var vsTbl = null;
  for(var j = 0; j < vnSize; j++) {
    vsTbl = vaTbl[j];
    if(this.extendTableMap[vsTbl] == null) {
      voDst.removeCRUDTable(vsTbl);
    }
  }
  var voOrgEventList = this.orgEventList;
  for(var vsAttr in voOrgEventList) {
    if(voOrgEventList[vsAttr] == null) {
      this[vsAttr] = null;
    } else {
      eval(voOrgEventList[vsAttr]);
    }
  }
  this.refresh();
};

/**
 * 일반적으로 그리드와 연결된 데이타셋의 CUD내역을 submission객체를 통해 서버로 전달할 때 기본 테이블의 내용과 확장 테이블에 내용이 같이 보내지게됨.
 * 기본테이블의 CUD내역만을 submission을 통해 서버로 전달할 경우 setDstReqMode(true)를 호출 후 submission send를 호출하면됨.
 * 다시 기본테이블과 확장테이블의 CUD내역을 모두 보내고자 할 경우에는 setDstReqMode(false)를 호출하여 setDstReqMode(true) 상태를 해지시킴.
 * @param {Boolean} pbStandard true이면 원래 가지고 있던 영역에 대한 것만 보내는 모드로 변경하고 이 모드를 해제하는 경우에만 false로 지정
 * @public
 */
eXria.controls.xhtml.GridEx.prototype.extendSetReqMode = function(pbStandard) {
  var voDst = this.dataset;
  var voRestore = null;
  var vsTbl = null;
  var voObj = null;
  var vaCols = null;
  var vnSize = null;
  if(pbStandard == true) {
    voRestore = this.extendRestoreObj;
    var vaTbl = voDst.getCRUDTableNames();
    vaTbl = vaTbl.replace(/\,$/, "");
    vaTbl = vaTbl.split(",");
    vnSize = vaTbl.length;
    for(var i = 0; i < vnSize; i++) {
      vsTbl = vaTbl[i];
      if(this.extendTableMap[vsTbl] == null) {
        voObj = {};
        voObj.prefix = voDst.getPrefix(vsTbl);
        vaCols = voDst.getPrimaryKeys(vsTbl);
        vaCols = vaCols.replace(/\,$/, "");
        if(vaCols == "") vaCols = [];
        else vaCols = vaCols.split(",");
        voObj.primaryKeys = vaCols;

        vaCols = voDst.getUpdateCols(vsTbl);
        vaCols = vaCols.replace(/\,$/, "");
        if(vaCols == "") vaCols = [];
        else vaCols = vaCols.split(",");
        voObj.updateCols = vaCols;

        voRestore[vsTbl] = voObj;
        voDst.removeCRUDTable(vsTbl);
      }
    }
  } else {
    if(this.extendRestoreObj == null) return;
    voRestore = this.extendRestoreObj;
    for(vsTbl in voRestore) {
      voObj = voRestore[vsTbl];
      voDst.addCRUDTable(vsTbl);
      voDst.setPrefix(vsTbl, voObj.prefix);
      var vaPrimaryKeys = voObj.primaryKeys;
      vnSize = vaPrimaryKeys.length;
      for(var i = 0; i < vnSize; i++) {
        vaCols = vaPrimaryKeys[i].split(":");
        voDst.addPrimaryKey(vsTbl, vaCols[0], vaCols[1]);
      }
      var vaUpdateCols = voObj.updateCols;
      vnSize = vaUpdateCols.length;
      for(var i = 0; i < vnSize; i++) {
        vaCols = vaUpdateCols[i].split(":");
        voDst.addUpdateColumn(vsTbl, vaCols[0], vaCols[1]);
      }
    }
    delete this.extendRestoreObj;
  }
};
/**
 * Gantt chart 뷰 영역을 오늘 일자 기준으로 이동시켜주는 메소드.
 * @param {String} psIcon 오늘 일자 기준선 표시에 사용되는 이미지 경로(디폴트 값 : null)
 *
 */
eXria.controls.xhtml.GridEx.prototype.moveToToday = function(psIcon) {
  var vbRefresh = false;
  if(psIcon) {
    if(this.userAttr == null) this.userAttr = {};
//    if(this.userAttr.todayIcon == null) {
//      vbRefresh = true;
//    }
    this.userAttr.todayIcon = psIcon;
    vbRefresh = true;
  }

  if(vbRefresh) {
    this.refresh(null, true);
  } else {
    var voRow = this.getRowIndex(0);
    var vnLeftOffset = 0;
    var voCols = this.body.cols["left"];
    var vsGanttCol = null;
    if(voCols) {
      var voColumns = voCols.rows[0].columns;
      var vnSize = voColumns.length;
      var voColumn = null;
      for(var i = 0; i < vnSize; i++) {
        voColumn = voColumns[i];
        if(voColumn.visible != false) vnLeftOffset += voColumn.width;
      }
    }
    var vnLeftOffset2 = 0;
    voCols = this.body.cols["center"];
    if(voCols) {
      var voColumns = voCols.rows[0].columns;
      var vnSize = voColumns.length;
      var voColumn = null;
      for(var i = 0; i < vnSize; i++) {
        voColumn = voColumns[i];
        if(voColumn.type == "Gantt") {
          vsGanttCol = voColumn.colId;
          break;
        }
        if(voColumn.visible != false) vnLeftOffset2 += voColumns[i].width;
      }
    }
    var vnWidth = this.width;
    var vnScrollAreaHalfWidth = (vnWidth - vnLeftOffset) / 2;
    var voGanttCell = this.grid.GetCell(voRow, vsGanttCol);
    if(voGanttCell) {
      vaDiv = voGanttCell.getElementsByTagName("DIV");
      if(vaDiv.length == 0) {
        return;
      }
      var vnX = parseInt(vaDiv[vaDiv.length - 1].style.marginLeft) + vnLeftOffset2;
      this.grid.SetScrollLeft(vnX - vnScrollAreaHalfWidth);
    }
  }
};

/**
 * paging된 grid row 객체들을 배열에 담아 반환하는 메소드
 * @return paging된 row 저장 배열
 * @type Array(Object)
 */
eXria.controls.xhtml.GridEx.prototype.getPagingRows = function() {
  if(this.cfg.paging != "fast") return null;

  var vaDataRow = [];
  var vnIndex = 0;
  var vaDataRow = new Array();
  var voXB = this.grid.XB;
  function findLeafNode(poNode){
    var voNode = poNode;
    if(voNode.childNodes.length > 0){
      for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
        findLeafNode(r);
      }
    } else {
      if(voNode && voNode.nodeName && voNode.nodeName == "I") vaDataRow.push(voNode);
    }
  };
  if(voXB != undefined) findLeafNode(voXB);
  else return null;
  return vaDataRow;
};

/**
 * 현재 그리드 데이터의 정렬된 상태를 기준으로 instance row 데이타를 배열에 담아 반환하는 메소드
 * @return instance row가 그리드 row의 정렬 상태에 따라 순서대로 저장되는 배열
 * @type Array(eXria.data.xhtml.Node);
 */
eXria.controls.xhtml.GridEx.prototype.getSortedInstRows = function() {
  if(this.cfg.paging == "fast") return null;

  var vaDataRow = [];
  var vnIndex = 0;
  var voXB = this.grid.XB;
  function findLeafNode(poNode){
    var voNode = poNode;
    if(voNode.childNodes.length > 0){
      for(var r=poNode.firstChild,num=0;r;r=r.nextSibling,num++){
        findLeafNode(r);
      }
    } else {
      if(voNode && voNode.nodeName && voNode.nodeName == "I") vaDataRow.push(parseInt(voNode["InstIdx"]));
    }
  };
  if(voXB != undefined) findLeafNode(voXB);
  else return null;
  var voNodeList = this.data.getNodesetData2();
  var vnSize = vaDataRow.length;
  for(var i = 0; i < vnSize; i++) {
    vaDataRow[i] = voNodeList.item(vaDataRow[i]);
  }
  return vaDataRow;
};
/**
 * 사용자 이벤트 핸들러에 전달될 이벤트 객체 하위 속성 초기화 메소드
 * @member eXria.controls.xhtml.GridEx
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.resetEvent = function() {
    var voEvent = this.event;
    voEvent.object = null;
    voEvent.type = null;
    voEvent.row = null;
    voEvent.beforeRow = null;
    voEvent.colId = null;
    voEvent.beforeColId = null;
    voEvent.pagePos  = null;
    voEvent.x = null;
    voEvent.y = null;
    voEvent.key = null;
    voEvent.value = null;
    voEvent.e = null;
    voEvent.startcol = null;
    voEvent.pastedtext = null;
    voEvent.copiedRows = null;
};
/**
 * 데이타 세로 셀 병합 수행 메소드
 * @param {Number} pnFirst 셀 병합 시작 행 인덱스 번호
 * @param {pnLoop} pnLoop 셀 병합 종료 행 인덱스 번호(셀 병합에 포함되지 않음)
 * @param {eXria.data.xhtml.CollectionNode} poCollectionNode data collection node
 * @member eXria.controls.xhtml.GridEx
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setColsRowSpan = function(pnFirst, pnLoop, poCollectionNode) {
  this.mergeRowColsMap = {};
  this.rowMerged = false;
  var vaMergeRowCols = this.mergeRowCols;
  if(vaMergeRowCols && vaMergeRowCols.length > 0) {
    var voMergeRowColsMap = this.mergeRowColsMap;
    var vnSize = vaMergeRowCols.length;
    for(var i = 0; i < vnSize; i++) {
      voMergeRowColsMap[vaMergeRowCols[i]] = {};
    }
    this.setColRowSpan(pnFirst, pnLoop, poCollectionNode, vaMergeRowCols, 0);
  }
};
/**
 * 컬럼별 데이타 세로 셀 병합 수행 메소드.
 * 다중 컬럼 셀 병합을 위해 내부적으로 다음 컬럼을 대상으로 메소드 재귀호출.
 * @param {Number} pnFirst 셀 병합 시작 행 인덱스 번호
 * @param {pnLoop} pnLoop 셀 병합 종료 행 인덱스 번호(셀 병합에 포함되지 않음)
 * @param {eXria.data.xhtml.CollectionNode} poCollectionNode data collection node
 * @param {Array(String)} paMergeRowCols 셀 병합 컴럼 명세 저장 배열
 * @param {Array(String)} paMergeRowCols 셀 병합 수행 컬럼의 셀 병합 컬럼 명세 배열 내의 인덱스
 * @member eXria.controls.xhtml.GridEx
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.setColRowSpan = function(pnFirst, pnLoop, poCollectionNode, paMergeRowCols, pnColIdx) {
  var voMergeRowColsMap = this.mergeRowColsMap;
  var voColumn = this.getBodyColumn(null, paMergeRowCols[pnColIdx]);
  var voMergeRowColIdxMap = voMergeRowColsMap[voColumn.colId];
  var voValue, voPrevVal, vnRowSpan, j;
    
  for( var i = pnFirst; i < pnLoop; i++) {
    voMapNode = this.funcMapNode(poCollectionNode, i);
    voMergeRowColIdxMap = voMergeRowColsMap[voColumn.colId]
    vsRef = voColumn.ref;
    if (vsRef) {
      vaPath = vsRef.split("/");
      vsRef = vaPath[vaPath.length - 1];
    }
    if (vsRef != null)  voValue = this.funcGet(voMapNode, vsRef);
    voPrevVal = voMergeRowColIdxMap[(i - 1) + "_val"];
    voMergeRowColIdxMap[i + "_val"] = voValue;
    if(i != pnFirst && voPrevVal != voValue) {
      j = i - 1;
      vnRowSpan = 1;
      while(j > pnFirst) {
        if(voMergeRowColIdxMap[j + "_val"] == voMergeRowColIdxMap[(j - 1) + "_val"]) {
          vnRowSpan++;
          voMergeRowColIdxMap[j + ""] = 0;
          this.rowMerged = true;
        }
        j--;
      }
      voMergeRowColIdxMap[j + ""] = this.mergeRowCols ? vnRowSpan + 0.5 : vnRowSpan ;
      if(pnColIdx < paMergeRowCols.length - 1) this.setColRowSpan(j, j + vnRowSpan, poCollectionNode, paMergeRowCols, pnColIdx + 1);
      pnFirst = j + vnRowSpan;
    }
    if(i == pnLoop - 1) {
      j = i;
      vnRowSpan = 1;
      while(j > pnFirst) {
        if(voMergeRowColIdxMap[j + "_val"] == voMergeRowColIdxMap[(j - 1) + "_val"]) {
          vnRowSpan++;
          voMergeRowColIdxMap[j + ""] = 0;
          this.rowMerged = true;
        }
        j--;
      }
      voMergeRowColIdxMap[j + ""] = this.mergeRowCols ? vnRowSpan + 0.5 : vnRowSpan;
      if(pnColIdx < paMergeRowCols.length - 1) this.setColRowSpan(j, j + vnRowSpan, poCollectionNode, paMergeRowCols, pnColIdx + 1);
    }
  }
};
/**
 * 트리그리드 데이타 행 생성 메소드
 * @param {Number} pnIdx 데이타 리스트 내에 데이타 인덱스 번호
 * @param {Number} pnId id 컬럼에 설정될 순번
 * @param {eXria.data.xhtml.CollectionNode} poCollectionNode 생성하고자 하는 문자열의 데이타 행을 포함하는 데이타 리스트
 * @param {eXria.controls.xhtml.Columns} poCols 헤더 컬럼 추출을 위한 컬럼 그룹 객체
 * @param {eXria.controls.xhtml.GridEx.Cfg} poCfg 그리드 Cfg 참조 객체
 * @param {Object} poMergeRowColsMap row merge를 수행할 컬럼 명세 저장 json 객체
 * @param {Object} poChildRef Child Data Row의 컬럼별 data ref 저장 json 객체
 * @param {Number} pnChildIdx Child Data Rows 내에서의 row 인덱스
 * @member eXria.controls.xhtml.GridEx
 * @private
 */
eXria.controls.xhtml.GridEx.prototype.getTRowStr = function(pnIdx, pnId, poCollectionNode, poCols, poCfg, poMergeRowColsMap, poChildRef, pnChildIdx) {
    var vsRow = "<I";
    var vsBg = null;
    var voDataSet = this.dataset;
    var voDataSetHeader = (voDataSet) ? voDataSet.getHeader() : null; 
    var vsTmpColRef = null;
    if(this.oddRowBg || this.evenRowBg) {
      if(pnIdx % 2 == 1) vsBg = this.evenRowBg;
      else vsBg = this.oddRowBg;
      if(vsBg) vsRow += "  Color=\"" + vsBg + "\"";
    }
    if(!poChildRef)  vsRow += " InstIdx='" + pnIdx + "'";
    else vsRow += " ChildIdx='" + pnChildIdx + "'";
    var voMapNode = this.funcMapNode(poCollectionNode, pnIdx);
    var vsStatus = this.funcStatus(voMapNode, pnIdx);
    var voRow, voValue, voColumn, vsColumn, vsRef, vsSpan, vaPath, voMergeRowColIdxMap, vsExtAttrs;
    if(vsStatus == null) vsStatus = "";
    vsRow += " InstStatus='" + vsStatus + "'";
    if(vsStatus.indexOf("R") != -1) return "";
    if(poCfg.editing != null) vsRow = vsRow + " CanEdit='" + poCfg.editing + "'";
    if(vsStatus.indexOf("I") != -1) vsRow += " Added='1'";
    if(vsStatus.indexOf("U") != -1) vsRow += " Changed='1'";
    if(vsStatus.indexOf("D") != -1) vsRow += " Deleted='1'";
    for ( var i = 0; i < 3; i++) {
      if (poCols[i]) {
        if (poCols[i].rows.length > 0) {
          voRow = poCols[i].rows[0];
          if (i == 1) {
            if (voRow.id != null) vsRow = vsRow + " id='" + voRow.id + "'";
          }
          for ( var k = 0; k < voRow.columns.length; k++) {
            voColumn = voRow.columns[k];
            voMergeRowColIdxMap = poMergeRowColsMap[voColumn.colId]
            if(voColumn.colId == "id") { // id 칼럼에 대한 처리
              if(poCfg.ganttIdColumn) {  // id 칼럼이 Gantt에서 지정된 칼럼일 경우
                vsRef = this.funcRef(voColumn);
                if (vsRef != null) voValue = this.funcGet(voMapNode, vsRef);
                voValue = this.getXml(voValue, 2);
                vsRow = vsRow + " id=" + voValue;
              } else { // id 칼럼이 일반적인 형태로 지정된 경우
                if(poChildRef) vsRow = vsRow + " id='" + poCfg.idPrefix + this.funcRowId(voMapNode, pnId) + poCfg.idPostfix + "_" + (pnChildIdx + 1) + "'";
                else vsRow = vsRow + " id='" + poCfg.idPrefix + this.funcRowId(voMapNode, pnId) + poCfg.idPostfix + "'";
                
                if(!!voDataSet && poCfg.paging === "none" && !vsStatus){
                  vsTmpColRef = "__id" + poCfg.idPrefix + poCfg.idPostfix;
                  if(!voDataSetHeader.contains(vsTmpColRef)) voDataSet.appendColumn(vsTmpColRef);
                  voDataSet.simpleSet(pnIdx, vsTmpColRef, this.funcRowId(voMapNode, pnId));
                  voColumn.datasetCol = vsTmpColRef;
                }
              }
            } else {
              vsRef =  this.funcRef(voColumn);
              if(poChildRef) {
                vsRef = poChildRef[voColumn.colId];
              }
              if (vsRef) {
                vsRef = vsRef.split(",");
                vsSpan = vsRef[1];
                vaPath = vsRef[0].split("/");
                vsRef = vaPath[vaPath.length - 1];
              }
              if (vsRef != null)  voValue = this.funcGet(voMapNode, vsRef);

              if (voValue != null && voValue != "") {
                switch (voColumn.type) {
                case "Enum":
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  vsColumn = vsColumn + " " + voColumn.colId + "IconAlign='Right'";
                  break;
                case "Bool":
                case "Number":
                case "Int":
                case "Float":
                  voValue = eval(voValue);
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  break;
                case "CheckBox":
                case "Radio":
                  voValue = this.convertValueTGrid(voColumn, voValue);
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  break;
                case "Select":
                  if (voColumn.selectionDataType == "Numeric") voValue = eval(voValue);
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  break;
                case "Pass":
                case "Text":
                case "Lines":
                case "Html":
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  break;
                // DateMask 추가코드
                case "Date":
                  voValue = this.addSeparator(voValue, 2, null, voColumn.colId)
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "=" + voValue;
                  break;
                case "Button":
                  voValue = this.getXml(voValue, 2);
                  vsColumn = " " + voColumn.colId + "Caption=" + voValue;
                  vsRef = voColumn.buttonItem.width;
                  if (vsRef) {
                    if (isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                    vsColumn = vsColumn + " " + voColumn.colId + "Width=" + voValue;
                  } else {
                    var vnButtonWidth = voColumn.width;
                    if(vnButtonWidth > 2) vnButtonWidth = vnButtonWidth - 2;
                    voValue = this.getXml(vnButtonWidth, 2);
                    vsColumn = vsColumn + " " + voColumn.colId + "Width=" + voValue;
                  }
                  vsRef = voColumn.buttonItem.height;
                  if (vsRef) {
                    if (isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                    vsColumn = vsColumn + " " + voColumn.colId + "Height=" + voValue;
                  }
                  vsRef = voColumn.buttonItem.icon;
                  if (vsRef) {
                    if (isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                    vsColumn = vsColumn + " " + voColumn.colId + "Icon=" + voValue;
                  }
                  vsRef = voColumn.buttonItem.iconChecked;
                  if (vsRef) {
                    if (isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                    vsColumn = vsColumn + " " + voColumn.colId + "IconChecked=" + voValue;
                  }
                  vsRef = voColumn.buttonItem.tooltip;
                  if (vsRef) {
                    if(isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                      vsColumn = vsColumn + " " + voColumn.colId + "ToolTip=" + voValue;
                  }
                  vsRef = voColumn.buttonItem.tooltipChecked;
                  if (vsRef) {
                    if(isNaN(vsRef)) {
                      vaPath = vsRef.split("/");
                      vsRef = vaPath[vaPath.length - 1];
                      voValue = this.funcGet(voMapNode, vsRef);
                      voValue = this.getXml(voValue, 2);
                    } else {
                      voValue = this.getXml(vsRef, 2);
                    }
                    if (!voValue) voValue = "";
                    vsColumn = vsColumn + " " + voColumn.colId + "ToolTipChecked=" + voValue;
                  }
                  break;
                case "Image":
                  voHrefValue = this.getRefValue(voColumn.imageItem.href, voMapNode, pnIdx);
                  voTargetValue = this.getRefValue(voColumn.imageItem.target, voMapNode, pnIdx);
                  voWidthValue = this.getRefValue(voColumn.imageItem.width, voMapNode, pnIdx);
                  //voHeightValue = this.getRefValue(voColumn.imageItem.height, voMapNode, pnIdx);
                  if(voColumn.imageItem.height == "" || voColumn.imageItem.height === null) {
                    if(this.body.cols && this.body.cols["center"] && this.body.cols["center"].rows)
                      voHeightValue = this.body.cols["center"].rows[0].height;
                  }
                  else
                    voHeightValue = this.getRefValue(voColumn.imageItem.height, voMapNode, pnIdx);

                  voLeftValue = this.getRefValue(voColumn.imageItem.left, voMapNode, pnIdx);
                  voTopValue = this.getRefValue(voColumn.imageItem.top, voMapNode, pnIdx);
                  if(voValue != null) {
                    var vaStrBuf = [];
                    vaStrBuf.push(" ");
                    vaStrBuf.push(voColumn.colId);
                    vaStrBuf.push("=\"|");
                    vaStrBuf.push(voHrefValue);
                    vaStrBuf.push("|");
                    vaStrBuf.push(voWidthValue);
                    vaStrBuf.push("|");
                    vaStrBuf.push(voHeightValue);
                    vaStrBuf.push("|");
                    vaStrBuf.push(voLeftValue);
                    vaStrBuf.push("|");
                    vaStrBuf.push(voTopValue);
                    vaStrBuf.push("|");
                    vaStrBuf.push(voTargetValue);
                    vaStrBuf.push("\"");
                    vsColumn = vaStrBuf.join("");
                  }
                  break;
                }
                voValue = null;
              } else {
                vsColumn = " " + voColumn.colId + "=\"\"";
                if(voColumn.type == "Gantt" && voColumn.ganttFlags && i == pnIdx) {
                  vsColumn += " " + voColumn.colId + "GanttFlags='" + voColumn.ganttFlags + "'";
                  vsColumn += " " + voColumn.colId + "GanttFlagTexts='" + voColumn.ganttFlagTexts + "'";
                  vsColumn += " " + voColumn.colId + "GanttFlagIcons='" + voColumn.ganttFlagIcons + "'";
                } else if(voColumn.type == "Enum") {
                  vsColumn = vsColumn + " " + voColumn.colId + "IconAlign='Right'";
                }
              }

              if(voColumn.rightButton) {
                var vsRButtonType = voColumn.rightButton.type;
                if(voColumn.rightButton.ref) {  // ref가 있는 경우 그 경로에 해당하는 값으로 설정
                  if(this.canvas.page.metadata.modelType == eXria.form.ModelType.JRE && i == 0) {
                    var vaDataList = this.data.getNodesetStr(voColumn.rightButton.instanceId, voColumn.rightButton.ref);
                    if(vaDataList) vaDataList = eval(vaDataList);
                    voColumn.rightButton.dataList = vaDataList;
                  }
                  vsRButtonValue = this.funcRefVal(voColumn.rightButton.ref, voMapNode, pnIdx, voColumn.rightButton.instanceId);
                  if(vsRButtonType == "Image") {
                    if(vsRButtonValue) vsColumn = vsColumn + " " + voColumn.colId + "Button='" + vsRButtonValue + "'";
                  } else if(vsRButtonType == "Normal") {
                    if(vsRButtonValue) vsColumn = vsColumn + " " + voColumn.colId + "Button='Button' " + voColumn.colId + "ButtonText='" + vsRButtonValue + "'";
                  }
                } else {                        // ref가 없는 경우 value 값으로 설정
                  if(vsRButtonType == "Image") {
                    vsRButtonValue = eXria.controls.xhtml.Util.getImagePath(voColumn.rightButton.value, this.window);
                    if(vsRButtonValue) vsColumn = vsColumn + " " + voColumn.colId + "Button='" + vsRButtonValue + "'";
                  } else if(vsRButtonType == "Normal") {
                    vsRButtonValue = voColumn.rightButton.value;
                    if(vsRButtonValue) vsColumn = vsColumn + " " + voColumn.colId + "Button='Button' " + voColumn.colId + "ButtonText='" + vsRButtonValue + "'";
                  }
                }
              }
              if(voMergeRowColIdxMap && voMergeRowColIdxMap[pnIdx] > 1) {
                vsColumn = vsColumn + " " + voColumn.colId + "RowSpan=\"" + voMergeRowColIdxMap[pnIdx] + "\"";
              }
              if(!!vsSpan) vsColumn = vsColumn + " " + voColumn.colId + "Span=\"" + vsSpan + "\"";
              vsRow = vsRow + vsColumn;
            }
          }
        }
      }
    }
    if (voRow.height != null) {
      vsRow = vsRow + " Height='" + voRow.height + "'";
      if(this.rowMaxHeight == null) this.rowMaxHeight = voRow.height;
    }
    if(this.rowMaxHeight != null) {
      vsRow = vsRow + " MaxHeight='" + this.rowMaxHeight + "'";
      vsRow = vsRow + " MaxEditHeight='" + this.rowMaxHeight + "'";
    }
    var vnRowIdx = pnIdx;
    if(this.datasetId != null) vnRowIdx--;
    if(!!this.showTooltip) {
      var vaShowTooltip = this.showTooltip;
      for(var z=0, vnRowCnt = vaShowTooltip.length; z < vnRowCnt; z++){
        vsDsColId = vaShowTooltip[z]['dsColId'];
        vsRow = vsRow + " " + vaShowTooltip[z]['colId'] + "ShowHint='0' " + vaShowTooltip[z]['colId'] + "Tip='" + this.funcGet(this.funcMapNode(poCollectionNode, vnRowIdx), vsDsColId).simpleReplace('\n','<br/>') + "'";
      }
    }
    if(this.datasetId && this.makeRowColorData(pnIdx) != null) vsRow = vsRow + this.makeRowColorData(pnIdx);
    //로우별 스타일 정보 반영
    vsExtAttrs = this.setRowMetaExtAttrs(vnRowIdx, vsRow, poCollectionNode);
    
    return vsExtAttrs;
};
/**
 * @fileoverview
 * Concreate xhtml HtmlEditor(XHTML HtmlEditor 컨트롤)
 * @author
 */

/**
 * @class 에디터 컨트롤을 생성하는 class입니다.<br />
 * XHTML TextArea Control.
 * @version 2.0
 * @param {String} psId 컨트롤 식별자
 * @param {Number} pnLeft 컨트롤 좌상단 점의 x좌표
 * @param {Number} pnTop 컨트롤 좌상단 점의 y좌표
 * @param {Number} pnWidth 컨트롤의 가로 길이
 * @param {Number} pnHeight 컨트롤의 세로 길이
 * @return 새로운 eXria.controls.xhtml.HtmlEditor 객체
 * @type eXria.controls.xhtml.HtmlEditor
 * @constructor
 * @base eXria.controls.xhtml.UIControl
 */
eXria.controls.xhtml.HtmlEditor = function(psId,pnLeft, pnTop, pnWidth, pnHeight) {

  pnLeft = pnLeft == null ? 20 : pnLeft;
  pnTop = pnTop == null ? 20 : pnTop;
  pnWidth = pnWidth == null ? 100 : pnWidth;
  pnHeight = pnHeight == null ? 100 : pnHeight;

  eXria.controls.xhtml.UIControl.call(this, psId, pnLeft, pnTop, pnWidth, pnHeight);
  /**
   * Data 연동 객체(싱글 노드 연동).
   * @type eXria.controls.DataRefNode
   */
  this.data = new eXria.controls.DataRefNode(this);
  /////////////////////////////////////////////////////////////////////////////
  ////속성
  /**
   * 컨트롤의 설정된 값.
   * @type String
   */
  this.value = null;
  /**
   * 보더를 제외한 컨트롤의 가로길이.
   * @type Number
   * @private
   */
  this.innerWidth = this.width;
  /**
   * 보더를 제외한 컨트롤의 세로길이.
   * @type Number
   * @private
   */
  this.innerHeight = this.height;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 패딩 값.
   * @type Number
   */
  this.padding = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 좌측 패딩 값.
   * @type Number
   */
  this.paddingLeft = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 우측 패딩 값.
   * @type Number
   */
  this.paddingRight = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 상단 패딩 값.
   * @type Number
   */
  this.paddingTop = null;
  /**
   * 컨트롤에 표시될 텍스트에 적용될 하단 패딩 값.
   * @type Number
   */
  this.paddingBottom = null;
  /**
   * 컨트롤의 css속성값 혹은 디폴트 속성값을 저장하기 위한 오브젝트
   * @type Object
   * @private
   */
  this.df = {};
  /**
   * 컨트롤의 하위 HTMLElement 요소들
   * @private
   */
  this.subElement = {};
  /**
   * 텍스트 오버플로우
   */
  this.inputOverFlow = false;
  /**
   * 에디터 객체
   * @type Object
   * @private
   */
  this.editorInstance = null;
  /**
   * 에디터 객체
   * @type Boolean
   * @private
   */
  this.readOnly = null;

  /**
    TODO 속성중에 editor 속성은 전부 private 으로 만듬
  **/
};

eXria.controls.xhtml.Util.createInheritance(eXria.controls.xhtml.UIControl, eXria.controls.xhtml.HtmlEditor);

/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.createCtrl = function(poDocument){
  var voCtrl = poDocument.createElement("div");
  voCtrl["id"] = this.id;
  if(this.canvas.page.metadata.browser.ie > 0) voCtrl["hideFocus"] = true;
  this.document = poDocument;
  this.ctrl = voCtrl;
  return voCtrl;
};

/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setTemplate = function(poCtrl, poDocument){
  this.template = [];
  var vaTemplate = this.template;
  var vsClass = this.getCSSClass(this, 1);
  vaTemplate.push("<textarea id='" + this.id + "_CKEDITORTextArea' ");
//  vaTemplate.push("<textarea id='" + this.id + "_CKEDITORTextArea' class='" + vsClass + "' ");
  vaTemplate.push("@attStrBuf");
  vaTemplate.push(" style=\"");
  vaTemplate.push("@cssStrBuf");
  vaTemplate.push("\">");
  vaTemplate.push("</textarea>")
};
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.refreshTemplate = null;
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setSpecificDefaults = function(poCtrl, poDocument) {
  var voUserAttr = null;
  this.setStyleCurrentBorderValue(this);
  this.innerWidth = this.width - this.borderLeftWidth - this.borderRightWidth;
  if(this.innerWidth < 0) this.innerWidth = 0;
  this.innerHeight = this.height - this.borderTopWidth - this.borderBottomWidth;
  if(this.innerHeight < 0) this.innerHeight = 0;
//  this.value = this.getAttrValue("value",this.value);

  this.skin  = this.getAttrValue("skin",this.skin);
  this.toolbarSet  = this.getAttrValue("toolbarSet",this.toolbarSet);
  this.formatListSet  = this.getAttrValue("formatListSet",this.formatListSet);
  this.fontListSet  = this.getAttrValue("fontListSet",this.fontListSet);
  this.fontSizeStyle  = this.getAttrValue("fontSizeStyle",this.fontSizeStyle);
  this.language  = this.getAttrValue("language",this.language);
  this.enterMode  = this.getAttrValue("enterMode",this.enterMode);
  this.shiftEnterMode  = this.getAttrValue("shiftEnterMode",this.shiftEnterMode);
  this.styleTagMode  = this.getAttrValue("styleTagMode",this.styleTagMode);
  this.readOnly = this.getAttrValue("readOnly",this.readOnly);

  if(null === this.readOnly){
    if(this.userAttr) {
      if(/^\s*\(\s*\{(.|\n)*\}\s*\)\s*$/.test(this.userAttr)) voUserAttr = eval(this.userAttr);

      this.readOnly = voUserAttr.readOnly;
    }
  }
  if(voUserAttr) {
    this.userAttrObj = voUserAttr;
  }
};
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setSpecificAttrs = function(poCtrl, poDocument) {
  var voDf = this.df;
  var vaCssStrBuf = null;
  var vaAttStrBuf = null;
  var vaTemplate = this.template;
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var vfcSetAttStrBuf = this.setAttStrBuf;

  poCtrl["tabIndex"] = this.tabIndex;
  poCtrl["tooltip"] = this.tooltip;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;margin:0px;padding:0px;");
  if(this.visible == false) vaCssStrBuf.push("display:none;");
  else vaCssStrBuf.push("display:block;");
  vfcSetCssStrBuf(vaCssStrBuf, "z-index", this.zIndex);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "border-style", this.borderStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "border-color", this.borderColor);
  vfcSetCssStrBuf(vaCssStrBuf, "left", this.left, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "top", this.top, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "width", this.innerWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", this.innerHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-left-width", this.borderLeftWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-right-width", this.borderRightWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-top-width", this.borderTopWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "border-bottom-width", this.borderBottomWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "overflow", "hidden");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  poCtrl.style.cssText = vaCssStrBuf.join("");

  vaAttStrBuf = [];

  var vnWidth = this.innerWidth - this.paddingLeft - this.paddingRight;
  if(vnWidth < 0) vnWidth = 0;

  var vnHeight = this.innerHeight - this.paddingTop - this.paddingBottom;
  if(vnHeight < 0) vnHeight = 0;

  vaCssStrBuf = [];
  vaCssStrBuf.push("position:absolute;padding:0px;border-style:none;top:0px;left:0px;");//overflow:hidden;");
  vfcSetCssStrBuf(vaCssStrBuf, "width", vnWidth, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "height", vnHeight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", "transparent");
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);
  vaTemplate[3] = vaCssStrBuf.join("");

  poCtrl.innerHTML = vaTemplate.join("");

  vaCssStrBuf = null;
  vaAttStrBuf = null;
  vaTemplate = null;
  this.template = null;

  //////////////////////////////////////////////////////////////////////////////////////
  // 에디터 관련 처리 Start
  //////////////////////////////////////////////////////////////////////////////////////

  //1.에디터 속성값 불러오기
  var voOuterControl = poCtrl;
  var voEditorConfig = this.getEditorConfig();
  var voReadOnly = this.readOnly;

  //2.에디터 높이지정
  voEditorConfig.height = vnHeight + this.setEditorHeight(voEditorConfig);

  //readOnly 여부 결정
  CKEDITOR.on("instanceReady", function (ev) {
      var bodyelement = ev.editor.document.$.body;
      if(!!voReadOnly) bodyelement.setAttribute("contentEditable", false);
      else bodyelement.setAttribute("contentEditable", true);
  });

  //3.에디터 로딩
  var voEditor = CKEDITOR.replace( this.id+'_CKEDITORTextArea', voEditorConfig);
  this.editorInstance = voEditor;

  //4.에디터 Value 지정
  if(!!this.value)
    this.editorInstance.setData( this.value );

  //5.에디터 textStyle 지정
  this.setEditorContentsStyle(voOuterControl);

  //6.에디터 이벤트 핸들러 지정
  this.setEditorEventHandler();


  //////////////////////////////////////////////////////////////////////////////////////
  // 에디터 관련 처리 End
  //////////////////////////////////////////////////////////////////////////////////////

}


/**
 * HTMLEditor readOnly 여부 적용
 * @param {String} psText 설정 값.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.HtmlEditor.prototype.setReadOnly = function(pbReadOnly){
  var voCtrl = this.ctrl;
  var voDocument = this.document;
  this.readOnly = pbReadOnly;//(!!pbReadOnly)? true : false;

  var voEditor = this.editorInstance;
  if (voEditor) {
      //voEditor.destroy();
      CKEDITOR.remove(voEditor);
  }

  while( voCtrl.hasChildNodes() ) { voCtrl.removeChild( voCtrl.lastChild ); }

  this.setTemplate(voCtrl, voDocument);
  this.setSpecificDefaults(voCtrl, voDocument);
  this.setSpecificAttrs(voCtrl, voDocument);

}

/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setEditorHeight = function(poEditorConfig){
  var vsToolBarCase =  (!!this.toolbarSet) ? this.toolbarSet : 'default' ;
  var vsSkinCase = (!!this.skin) ? this.skin : 'default'
  var vnHeight = 0;

  //TODO - 높이를 하드 코딩 했기때문에 브라우저에 따라서
  //문제가 될 소지가 있음...수정해야함
  if(vsSkinCase === "default"){
    switch(vsToolBarCase){
      case 'default' : vnHeight = -137; break;
      case 'eXriaBasic' : vnHeight = -137;; break;
      case 'basic' :  vnHeight = -75; break;
      case 'all' :  vnHeight = -200; break;
      default : break;
    }
  }else if(vsSkinCase === "office2003"){
    switch(vsToolBarCase){
      case 'default' : vnHeight = -137 + 28; break;
      case 'eXriaBasic' : vnHeight = -137 + 28; break;
      case 'basic' :  vnHeight = -75 + 18-3; break;
      case 'all' :  vnHeight = -200 + 38-5; break;
      default : break;
    }
  }else if(vsSkinCase === "v2"){
    switch(vsToolBarCase){
      case 'default' : vnHeight = -137 + 28; break;
      case 'eXriaBasic' : vnHeight = -137 + 28; break;
      case 'basic' :  vnHeight = -75 + 18; break;
      case 'all' :  vnHeight = -200 + 38; break;
      default : break;
    }
  }

  return vnHeight;
}

/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setEditorContentsStyle = function(poCtrl){
  var vaCssStrBuf = [];
  var vfcSetCssStrBuf = this.setCssStrBuf;
  var voEditorId = this;
  vfcSetCssStrBuf(vaCssStrBuf, "font-family", this.fontFamily);
  vfcSetCssStrBuf(vaCssStrBuf, "font-size", this.fontSize, "pt");
  vfcSetCssStrBuf(vaCssStrBuf, "font-style", this.fontStyle);
  vfcSetCssStrBuf(vaCssStrBuf, "font-weight", this.fontWeight);
  vfcSetCssStrBuf(vaCssStrBuf, "color", this.color);
  vfcSetCssStrBuf(vaCssStrBuf, "background-color", this.backgroundColor);
  vfcSetCssStrBuf(vaCssStrBuf, "text-align", this.textAlign);
  vfcSetCssStrBuf(vaCssStrBuf, "text-decoration", this.textDecoration);
  vfcSetCssStrBuf(vaCssStrBuf, "padding", this.padding, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-left", this.paddingLeft, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-right", this.paddingRight, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-top", this.paddingTop, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "padding-bottom", this.paddingBottom, "px");
  vfcSetCssStrBuf(vaCssStrBuf, "cursor", this.cursor);

  //에디터가 준비 되면 CSS 와 inlineStyle 적용
  this.editorInstance.on('instanceReady', function(ev){

    //eXria_CRE_Configuration.css 를 iframe 에 복사
    var voOriginCssElement = document.getElementsByTagName("link")[0];
    var voIframeContentDocument = document.getElementById("cke_contents_"+voEditorId.id+"_CKEDITORTextArea")
                                 .childNodes[0].contentWindow.document;
    var voIframeContentHead = voIframeContentDocument.getElementsByTagName("head")[0];
    var voTargetCssElement = voIframeContentDocument.createElement('link');

    voTargetCssElement.type = 'text/css';
    voTargetCssElement.rel = 'stylesheet';
    voTargetCssElement.href = voOriginCssElement.href;
    voTargetCssElement.media = 'screen';
    voIframeContentHead.appendChild(voTargetCssElement);

    //inlineStyle 지정
    voIframeContentDocument.getElementsByTagName("body")[0]
    .style.cssText = vaCssStrBuf.join("");

  });

  //에디터가 focus / blur  될경우 스타일 지정
  var vsCssTextBackup = poCtrl.style.cssText;
  if(!!this.focusDisplay){
    this.editorInstance.on('focus', function(){
      voEditorId.setFocusStyle(true);
    });
    this.editorInstance.on('blur', function(){
      //poCtrl.style.cssText = vsCssTextBackup;
      voEditorId.setFocusStyle(false);
    });
  }
}

/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.setEditorEventHandler = function(){
  if(!!this.onblur)
    this.editorInstance.on('blur', this.onblur);

  if(!!this.onfocus)
    this.editorInstance.on('focus', this.onfocus);

  if(!!this.onkeydown)
    this.editorInstance.on('key', this.onkeydown);

  if(!!this.onready)
    this.editorInstance.on('instanceReady', this.onready);
}


/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.getEditorConfig = function(){
  var voEditorConfig = {};
  //에디터 리사이즈 지정
  voEditorConfig.resize_enabled = false;

  //에디터 스킨 지정
  if(!!this.skin){
    switch(this.skin){
      case "default" : break;
      default : voEditorConfig.skin = this.skin; break;
    }
  }

  //에디터 툴바 지정
  if(!!this.toolbarSet){
    switch(this.toolbarSet){
      case 'default' : break;
      case 'eXriaBasic' : break;

      case 'basic' :
          voEditorConfig.toolbar = 'Basic';
        break;

      case 'all' :
          voEditorConfig.toolbar = 'Full';
        break;

      default : break;
    }
  }

  //에디터 포맷 리스트 지정
  if(!!this.formatListSet){
    switch(this.formatListSet){
      case 'title' :
        voEditorConfig.format_tags = 'h1;h2;h3;h4;h5;h6';
        break;
    }
  }

  //에티터 폰트 포맷 리스트 지정
  if(!!this.fontListSet){
    switch(this.fontListSet){
      case 'kor' :
        voEditorConfig.font_names =   '굴림' + ';'+ '굴림체' + ';'+
                                      '돋움' + ';'+ '돋움체' + ';'+
                                      '맑은 고딕' + ';'+ '바탕' + ';'+
                                      '바탕체' + ';'+ '궁서' + ';'+
                                      '궁서체' + ';'+ '새굴림' + ';'+
                                      '으뜸체' + ';'+ '휴먼둥근헤드라인' + ';'+
                                      '휴먼아미체' + ';'+ '휴먼옛체' + ';'+
                                      '휴먼매직체';
        break;
      case 'eng' :
        voEditorConfig.font_names =   'Arial/Arial, Helvetica, sans-serif;' +
                                      'Comic Sans MS/Comic Sans MS, cursive;' +
                                      'Courier New/Courier New, Courier, monospace;' +
                                      'Georgia/Georgia, serif;' +
                                      'Lucida Sans Unicode/Lucida Sans Unicode, Lucida Grande, sans-serif;' +
                                      'Tahoma/Tahoma, Geneva, sans-serif;' +
                                      'Times New Roman/Times New Roman, Times, serif;' +
                                      'Trebuchet MS/Trebuchet MS, Helvetica, sans-serif;' +
                                      'Verdana/Verdana, Geneva, sans-serif;'
        break;
    }
  }

  //에디터 폰트 사이즈 리스트 지정
  if(!!this.fontSizeStyle){
     switch(this.fontSizeStyle){
       case 'css' :
        voEditorConfig.fontSize_sizes = '12 Pixels/12px;Big/2.3em;30 Percent More/130%;Bigger/larger;Very Small/x-small';
        break;
     }
  }

  //에디터 언어 포맷 지정
  if(!!this.language){
    switch(this.language){
      case 'kor' :
        voEditorConfig.language = 'ko';
        break;
      case 'eng' :
        voEditorConfig.language = 'en';
        break;
      case 'jpn' :
        voEditorConfig.language = 'ja';
        break;
      case 'chn' :
        voEditorConfig.language = 'zh';
        break;
      default :
        var vsLanguage = eXria.controls.xhtml.Util.getDefaultLocale();
        switch(vsLanguage){
          case 'kor' : voEditorConfig.language = 'ko'; break;
          case 'eng' : voEditorConfig.language = 'en'; break;
          case 'jpn' : voEditorConfig.language = 'ja'; break;
          case 'chn' : voEditorConfig.language = 'zh'; break;
        }
    }
  }

  //에디터 엔터키 속성 지정
  if(!!this.enterMode){
      switch(this.enterMode){
        case 'P': voEditorConfig.enterMode = 1; break;
        case 'BR': voEditorConfig.enterMode = 2; break;
        case 'DIV': voEditorConfig.enterMode = 3; break;
      }
  }

  //에디터 쉬프트 엔터키 속성 지정
  if(!!this.shiftEnterMode){
    switch(this.shiftEnterMode){
        case 'P': voEditorConfig.enterMode = 1; break;
        case 'BR': voEditorConfig.enterMode = 2; break;
        case 'DIV': voEditorConfig.enterMode = 3; break;
    }
  }

  //에디터 TextArea Font 스타일 지정
  if(!!this.styleTagMode){
    switch(this.styleTagMode){
      case 'block'  :
       voEditorConfig.stylesSet = [
        { name : 'Blue Title'   , element : 'h3', styles : { 'color' : 'Blue' } },
        { name : 'Red Title'    , element : 'h3', styles : { 'color' : 'Red' } },
        { name : 'Yellow Title' , element : 'h3', styles : { 'color' : 'Yellow' } },
        { name : 'Green Title' , element : 'h3', styles : { 'color' : 'Green' } }
       ];
       break;
      case 'inline' :
       voEditorConfig.stylesSet = [
        { name : 'Marker: Yellow' , element : 'span', styles : { 'background-color' : 'Yellow' } },
        { name : 'Marker: Green'  , element : 'span', styles : { 'background-color' : 'Lime' } },
        { name : 'Big'        , element : 'big' },
        { name : 'Small'      , element : 'small' },
        { name : 'Typewriter'   , element : 'tt' },
        { name : 'Computer Code'  , element : 'code' },
        { name : 'Keyboard Phrase'  , element : 'kbd' },
        { name : 'Sample Text'    , element : 'samp' },
        { name : 'Variable'     , element : 'var' },
        { name : 'Deleted Text'   , element : 'del' },
        { name : 'Inserted Text'  , element : 'ins' },
        { name : 'Cited Work'   , element : 'cite' },
        { name : 'Inline Quotation' , element : 'q' },
        { name : 'Language: RTL'  , element : 'span', attributes : { 'dir' : 'rtl' } },
        { name : 'Language: LTR'  , element : 'span', attributes : { 'dir' : 'ltr' } }
       ];
       break;
    }
  }

  //에디터 bodyClass 적용
  voEditorConfig.bodyClass = this.getCSSClass(this, 1);

  return voEditorConfig;
}


/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.refreshSpecificAttrs = function(poCtrl, poDocument) {}

/**
 * applyAttrRebuild
 * @param {String} psAttrName 속성명
 * @param {String} psAttrValue 지정된 속성값
 * @param {HTMLElement} poDocument 실체화 컨트롤이 위치한 Document
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.applyAttrRebuild = function(psAttrName, psAttrValue, poDocument) {
  var voCtrl = this.ctrl;
  var voBtn = this.subElement.button;
  var voSpan = this.subElement.span;
  var voDf = this.df;

  this.setAttr(psAttrName, psAttrValue);
  var vaAttrName = psAttrName.split(".");
  var voObj = this;
  for(var i = 0; i < vaAttrName.length - 1; i++) {
    voObj = voObj[vaAttrName[i]];
  }

  switch(psAttrName) {
  case "disabled" :
    this.setDisable(voCtrl, psAttrValue);
    break;
  default :
    this.refresh(poDocument);
    break;
  }
};

/**
 * 컨트롤에 설정된 값을 반환합니다.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @return 컨트롤의 할당된 값
 * @type String
 */
eXria.controls.xhtml.HtmlEditor.prototype.getValue = function(poDocument) {
  this.value = this.editorInstance.getData();
  return this.value;
};

/**
 * 컨트롤에 지정된 값을 설정합니다.
 * @param {String} psText 설정 값.
 * @param {HTMLDiv} poCtrl 실체화 컨트롤.
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 */
eXria.controls.xhtml.HtmlEditor.prototype.setValue = function(psText, poCtrl, poDocument) {
  this.value = psText;
  this.data.setData(this.value);
  this.editorInstance.setData( this.value );
};

/**
 * 컨트롤의 포커스가 위치한 영역에 값을 추가 합니다.
 * @param {String} psText 설정 값.
 */
eXria.controls.xhtml.HtmlEditor.prototype.insertHtml = function(psText, poCtrl, poDocument) {
  this.editorInstance.insertHtml( psText );
  this.value = this.getValue();
  this.data.setData(this.value);
};


/**
 * loadData
 * @param {HTMLDocument} poDocument 실체화 컨트롤이 위치한 Document
 * @private
 */
eXria.controls.xhtml.HtmlEditor.prototype.loadData = function(poDocument) {
  this.onchangeInitValue = undefined;
  if(this.data.instanceId == null) {
    this.onchangeInitValue = this.value ? this.value : "";
    return;
  }
  var voCtrl = this.ctrl;
  var vsRefData = this.data.getData();
  this.setValue(vsRefData, voCtrl, poDocument);
};
/**
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.reloadData = function(poCtrl, poDocument) {
  this.loadData(poDocument);
};

/**
 * 각 속성에 따른 디폴트 값을 반환합니다.
 * @param {String} psAttrName 속성명
 * @return 디폴트 속성값
 * @ignore
 */
eXria.controls.xhtml.HtmlEditor.prototype.getSpecificDefaultValue = function(psAttrName){
  var vsDefaultValue = eXria.controls.xhtml.Default.HtmlEditor[psAttrName];
  if( vsDefaultValue === undefined) {
    //alert(psAttrName + " - Defaul 속성 리스트가 아닙니다.");
    return null;
  }
  return vsDefaultValue;
};

/**
 * 클래스 명을 반환합니다.
 * @return "HtmlEditor"
 * @type String
 */
eXria.controls.xhtml.HtmlEditor.prototype.toString = function() {
  return "HtmlEditor";
};
var deployJava={
  htmlDoc:null,
  debug:null,
  firefoxJavaVersion:null,
  myInterval:null,
  preInstallJREList:null,
  returnPage:null,
  brand:null,
  locale:null,
  installType:null,
  EAInstallEnabled:false,
  EarlyAccessURL:null,
  getJavaURL:'http://jdl.sun.com/webapps/getjava/BrowserRedirect?host=java.com',
  appleRedirectPage:'http://www.apple.com/support/downloads/',
  oldMimeType:'application/npruntime-scriptable-plugin;DeploymentToolkit',
  mimeType:'application/java-deployment-toolkit',
  launchButtonPNG:'http://java.sun.com/products/jfc/tsc/articles/swing2d/webstart.png',
  browserName:null,
  browserName2:null,
  getJREs:function(){
  var list=new Array();
  if(deployJava.isPluginInstalled()){
    var plugin=deployJava.getPlugin();
    var VMs=plugin.jvms;
    for(var i=0;i<VMs.getLength();i++){
      list[i]=VMs.get(i).version;
    }
  }else{
    var browser=deployJava.getBrowser();
    if(browser=='MSIE'){
      if(deployJava.testUsingActiveX('1.7.0')){
        list[0]='1.7.0';
      }else if(deployJava.testUsingActiveX('1.6.0')){
        list[0]='1.6.0';
      }else if(deployJava.testUsingActiveX('1.5.0')){
        list[0]='1.5.0';
      }else if(deployJava.testUsingActiveX('1.4.2')){
        list[0]='1.4.2';
      }else if(deployJava.testForMSVM()){
        list[0]='1.1';
      }
    }else if(browser=='Netscape Family'){
      deployJava.getJPIVersionUsingMimeType();
      if(deployJava.firefoxJavaVersion!=null){
        list[0]=deployJava.firefoxJavaVersion;
      }else if(deployJava.testUsingMimeTypes('1.7')){
        list[0]='1.7.0';
      }else if(deployJava.testUsingMimeTypes('1.6')){
        list[0]='1.6.0';
      }else if(deployJava.testUsingMimeTypes('1.5')){
        list[0]='1.5.0';
      }else if(deployJava.testUsingMimeTypes('1.4.2')){
        list[0]='1.4.2';
      }else if(deployJava.browserName2=='Safari'){
        if(deployJava.testUsingPluginsArray('1.7.0')){
          list[0]='1.7.0';
        }else if(deployJava.testUsingPluginsArray('1.6')){
          list[0]='1.6.0';
        }else if(deployJava.testUsingPluginsArray('1.5')){
          list[0]='1.5.0';
        }else if(deployJava.testUsingPluginsArray('1.4.2')){
          list[0]='1.4.2';
        }
      }
    }
  }
  if(deployJava.debug){
    for(var i=0;i<list.length;++i){
      alert('We claim to have detected Java SE '+list[i]);
    }
  }
  return list;
},
installJRE:function(requestVersion){
  var ret=false;
  if(deployJava.isPluginInstalled()){
    if(deployJava.versionCheck(requestVersion) == false && !!window.isInstallJREOffline) {
      return deployJava.installJREOffline();
    }
    if(deployJava.getPlugin().installJRE(requestVersion)){
      deployJava.refresh();
      if(deployJava.returnPage!=null){
        deployJava.htmlDoc.location=deployJava.returnPage;
      }
      return true;
    }else{
      return false;
    }
  }else{
    if(!!window.isInstallJREOffline) {
      return deployJava.installJREOffline();
    } else {
      return deployJava.installLatestJRE();
    }
  }
},
installLatestJRE:function(){
  if(deployJava.isPluginInstalled()){
    if(deployJava.getPlugin().installLatestJRE()){
      deployJava.refresh();
      if(deployJava.returnPage!=null){
        deployJava.htmlDoc.location=deployJava.returnPage;
      }
      return true;
    }else{
      return false;
    }
  }else{
    var browser=deployJava.getBrowser();
    var platform=navigator.platform.toLowerCase();
    if((deployJava.EAInstallEnabled=='true')&&(platform.indexOf('win')!=-1)&&(deployJava.EarlyAccessURL!=null)){
      deployJava.preInstallJREList=deployJava.getJREs();
      if(deployJava.returnPage!=null){
        deployJava.myInterval=setInterval("deployJava.poll()",3000);
      }
      location.href=deployJava.EarlyAccessURL;
      return false;
    }else{
      if(browser=='MSIE'){
        return deployJava.IEInstall();
      }else if((browser=='Netscape Family')&&(platform.indexOf('win32')!=-1)){
        return deployJava.FFInstall();
      }else{
        location.href=deployJava.getJavaURL+
        ((deployJava.returnPage!=null)?('&returnPage='+deployJava.returnPage):'')+
        ((deployJava.locale!=null)?('&locale='+deployJava.locale):'')+
        ((deployJava.brand!=null)?('&brand='+deployJava.brand):'');
      }
      return false;
    }
  }
},
installJREOffline:function(){
  deployJava.getJavaURL = jreOfflineDLPage;
  var browser=deployJava.getBrowser();
  var platform=navigator.platform.toLowerCase();
  if((deployJava.EAInstallEnabled=='true')&&(platform.indexOf('win')!=-1)&&(deployJava.EarlyAccessURL!=null)){
    deployJava.preInstallJREList=deployJava.getJREs();
    if(deployJava.returnPage!=null){
      deployJava.myInterval=setInterval("deployJava.poll()",3000);
    }
    location.href=deployJava.EarlyAccessURL;
    return false;
  }else{
    if(browser=='MSIE'){
      return deployJava.IEInstall();
    }else if((browser=='Netscape Family')&&(platform.indexOf('win32')!=-1)){
      return deployJava.FFInstall();
    }else{
      location.href =
      (deployJava.getJavaURL.indexOf("/")==0? deployJava.metadata.resourceBaseUrl+deployJava.getJavaURL.substring(1):deployJava.getJavaURL)+
      ((deployJava.returnPage!=null)?('&returnPage='+deployJava.returnPage):'')+
      ((deployJava.locale!=null)?('&locale='+deployJava.locale):'')+
      ((deployJava.brand!=null)?('&brand='+deployJava.brand):'');
    }
    return false;
  }
},
runApplet:function(attributes,parameters,minimumVersion){
  if(minimumVersion=='undefined'||minimumVersion==null){
    minimumVersion='1.1';
  }
  var regex="^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
  var matchData=minimumVersion.match(regex);
  if(deployJava.returnPage==null){
    deployJava.returnPage=deployJava.htmlDoc.location;
  }
  if(matchData!=null){
    var browser=deployJava.getBrowser();
    if((browser!='?')&&('Safari'!=deployJava.browserName2)){
      if(deployJava.versionCheck(minimumVersion+'+')){
        deployJava.writeAppletTag(attributes,parameters);
      }else if(deployJava.installJRE(minimumVersion+'+')){
        deployJava.refresh();
        location.href=deployJava.htmlDoc.location;
        deployJava.writeAppletTag(attributes,parameters);
      }
    }else{
      deployJava.writeAppletTag(attributes,parameters);
    }
  }else{
    if(deployJava.debug){
      alert('Invalid minimumVersion argument to runApplet():'+minimumVersion);
    }
  }
},
writeAppletTag:function(attributes,parameters){
  var s='<'+'applet ';
  var codeAttribute=false;
  for(var attribute in attributes){
    s+=(' '+attribute+'="'+attributes[attribute]+'"');
    if(attribute=='code'){
      codeAttribute=true;
    }
  }
  if(!codeAttribute){
    s+=(' code="dummy"');
  }
  s+='>';
  deployJava.htmlDoc.write(s);
  if(parameters!='undefined'&&parameters!=null){
    var codebaseParam=false;
    for(var parameter in parameters){
      if(parameter=='codebase_lookup'){
        codebaseParam=true;
      }
      s='<param name="'+parameter+'" value="'+
      parameters[parameter]+'">';
      deployJava.htmlDoc.write(s);
    }
    if(!codebaseParam){
      deployJava.htmlDoc.write('<param name="codebase_lookup" value="false">');
    }
  }
  deployJava.htmlDoc.write('<'+'/'+'applet'+'>');
},
versionCheck:function(versionPattern){
  var index=0;
  var regex="^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?(\\*|\\+)?$";
  var matchData=versionPattern.match(regex);
  if(matchData!=null){
    var familyMatch=true;
    var patternArray=new Array();
    for(var i=1;i<matchData.length;++i){
      if((typeof matchData[i]=='string')&&(matchData[i]!='')){
        patternArray[index]=matchData[i];
        index++;
      }
    }
    if(patternArray[patternArray.length-1]=='+'){
      familyMatch=false;
      patternArray.length--;
    }else{
      if(patternArray[patternArray.length-1]=='*'){
        patternArray.length--;
      }
    }
    var list=deployJava.getJREs();
    for(var i=0;i<list.length;++i){
      if(deployJava.compareVersionToPattern(list[i],patternArray,familyMatch)){
        return true;
      }
    }
    return false;
  }else{
    alert('Invalid versionPattern passed to versionCheck: '+versionPattern);
    return false;
  }},
  isWebStartInstalled:function(minimumVersion){
    var browser=deployJava.getBrowser();
    if((browser=='?')||('Safari'==deployJava.browserName2)){
      return true;
    }
    if(minimumVersion=='undefined'||minimumVersion==null){
      minimumVersion='1.4.2';
    }
    var retval=false;
    var regex="^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
    var matchData=minimumVersion.match(regex);
    if(matchData!=null){
      retval=deployJava.versionCheck(minimumVersion+'+');
    }else{
      if(deployJava.debug){
        alert('Invalid minimumVersion argument to isWebStartInstalled(): '+minimumVersion);
      }
      retval=deployJava.versionCheck('1.4.2+');
    }
    return retval;
  },
  getJPIVersionUsingMimeType:function(){
    for(var i=0;i<navigator.mimeTypes.length;++i){
      var s=navigator.mimeTypes[i].type;
      var m=s.match(/^application\/x-java-applet;jpi-version=(.*)$/);
      if(m!=null){
        deployJava.firefoxJavaVersion=m[1];
        break;
      }
    }
  },
  launchWebStartApplication:function(jnlp){
    var uaString=navigator.userAgent.toLowerCase();
    deployJava.getJPIVersionUsingMimeType();
    if(uaString.indexOf("windows",0)!=-1){
      if(deployJava.isWebStartInstalled('1.6.0_18')==false){
        if(deployJava.isPluginInstalled()){
          if(deployJava.installLatestJRE()==false){
            alert("Java install failed: cannot use launchWebStartApplication function");
            return;
          }
        }else{
          alert("Please visit java.com to install Java and try again after");
          return;
        }
      }
    }else{
      if(deployJava.firefoxJavaVersion==null){
        alert("Please visit java.com to install Java and try again after");
        return;
      }
      if(deployJava.firefoxJavaVersion<"1.6.0_18"){
        alert("Please visit java.com to install Java and try again after");
        return;
      }
    }
    var jnlpDocbase=null;
    if(deployJava.htmlDoc.documentURI){
      jnlpDocbase=deployJava.htmlDoc.documentURI;
    }
    if(jnlpDocbase==null){
      jnlpDocbase=deployJava.htmlDoc.URL;
    }
    var browser=deployJava.getBrowser();
    if(browser=='MSIE'){
      deployJava.htmlDoc.write('<'+'object classid="clsid:8AD9C840-044E-11D1-B3E9-00805F499D93" '+'width="0" height="0">'+'<'+'PARAM name="launchjnlp" value="'+jnlp+'"'+'>'+'<'+'PARAM name="docbase" value="'+jnlpDocbase+'"'+'>'+'<'+'/'+'object'+'>');
    }else if(browser=='Netscape Family'){
      deployJava.htmlDoc.write('<'+'embed type="application/x-java-applet;jpi-version='+deployJava.firefoxJavaVersion+'" '+'width="0" height="0" '+'launchjnlp="'+jnlp+'"'+'docbase="'+jnlpDocbase+'"'+' />');
    }
    deployJava.htmlDoc.location=jnlpDocbase;
  },
  createWebStartLaunchButtonEx:function(jnlp,minimumVersion){
    if(deployJava.returnPage==null){
      deployJava.returnPage=jnlp;
    }
    var url='javascript:deployJava.launchWebStartApplication(\''+jnlp+'\');';
    deployJava.htmlDoc.write('<'+'a href="'+url+'" onMouseOver="window.status=\'\';'+'return true;"><'+'img '+'src="'+deployJava.launchButtonPNG+'" '+'border="0" /><'+'/'+'a'+'>');
  },
  createWebStartLaunchButton:function(jnlp,minimumVersion){
    if(deployJava.returnPage==null){
      deployJava.returnPage=jnlp;
    }
    var url='javascript:'+'if (!deployJava.isWebStartInstalled(&quot;'+minimumVersion+'&quot;)) {'+'if (deployJava.installLatestJRE()) {'+'if (deployJava.launch(&quot;'+jnlp+'&quot;)) {}'+'}'+'} else {'+'if (deployJava.launch(&quot;'+jnlp+'&quot;)) {}'+'}';
    deployJava.htmlDoc.write('<'+'a href="'+url+'" onMouseOver="window.status=\'\';'+'return true;"><'+'img '+'src="'+deployJava.launchButtonPNG+'" '+'border="0" /><'+'/'+'a'+'>');
  },
  launch:function(jnlp){
    if(deployJava.isPluginInstalled()){
      return deployJava.getPlugin().launch(jnlp);
    }else{
      deployJava.htmlDoc.location=jnlp;
      return true;
    }
  },
  isPluginInstalled:function(){
    var plugin=deployJava.getPlugin();
    if(plugin&&plugin.jvms){
      return true;
    }else{
      return false;
    }
  },
  isAutoUpdateEnabled:function(){
    if(deployJava.isPluginInstalled()){
      return deployJava.getPlugin().isAutoUpdateEnabled();
    }
    return false;
  },
  setAutoUpdateEnabled:function(){
    if(deployJava.isPluginInstalled()){
      return deployJava.getPlugin().setAutoUpdateEnabled();
    }
    return false;
  },
  setInstallerType:function(type){
    deployJava.installType=type;
    if(deployJava.isPluginInstalled()){
      return deployJava.getPlugin().setInstallerType(type);
    }
    return false;
  },
  setAdditionalPackages:function(packageList){
    if(deployJava.isPluginInstalled()){
      return deployJava.getPlugin().setAdditionalPackages(packageList);
    }
    return false;
  },
  setEarlyAccess:function(enabled){
    deployJava.EAInstallEnabled=enabled;
  },
  isPlugin2:function(){
    if(deployJava.isPluginInstalled()){
      if(deployJava.versionCheck('1.6.0_10+')){
        try{
          return deployJava.getPlugin().isPlugin2();
        }catch(err){
        }
      }
    }
    return false;
  },
  allowPlugin:function(){
    deployJava.getBrowser();
    var ret=('Chrome'!=deployJava.browserName2&&'Safari'!=deployJava.browserName2&&'Opera'!=deployJava.browserName2);
    return ret;
  },
  getPlugin:function(){
    deployJava.refresh();
    var ret=null;
    if(deployJava.allowPlugin()){
      ret=deployJava.htmlDoc.getElementById('deployJavaPlugin');
    }
    return ret;
  },
  compareVersionToPattern:function(version,patternArray,familyMatch){
    var regex="^(\\d+)(?:\\.(\\d+)(?:\\.(\\d+)(?:_(\\d+))?)?)?$";
    var matchData=version.match(regex);
    if(matchData!=null){
      var index=0;
      var result=new Array();
      for(var i=1;i<matchData.length;++i){
        if((typeof matchData[i]=='string')&&(matchData[i]!='')){
          result[index]=matchData[i];
          index++;
        }
      }
      var l=Math.min(result.length,patternArray.length);
      if(familyMatch){
        for(var i=0;i<l;++i){
          if(result[i]!=patternArray[i])return false;
        }
        return true;
      }else{
        for(var i=0;i<l;++i){
          if(result[i]<patternArray[i]){
            return false;
          }else if(result[i]>patternArray[i]){
            return true;
          }
        }
        return true;
      }
    }else{
      return false;
    }
  },
  getBrowser:function(){
    if(deployJava.browserName==null){
      var browser=navigator.userAgent.toLowerCase();
      if(deployJava.debug){
        alert('userAgent -> '+browser);
      }
      if(browser.indexOf('msie')!=-1){
        deployJava.browserName='MSIE';
        deployJava.browserName2='MSIE';
      }else if(browser.indexOf('firefox')!=-1){
        deployJava.browserName='Netscape Family';
        deployJava.browserName2='Firefox';
      }else if(browser.indexOf('chrome')!=-1){
        deployJava.browserName='Netscape Family';
        deployJava.browserName2='Chrome';
      }else if(browser.indexOf('safari')!=-1){
        deployJava.browserName='Netscape Family';
        deployJava.browserName2='Safari';
      }else if(browser.indexOf('mozilla')!=-1){
        deployJava.browserName='Netscape Family';
        deployJava.browserName2='Other';
      }else if(browser.indexOf('opera')!=-1){
        deployJava.browserName='Netscape Family';
        deployJava.browserName2='Opera';
      }else{
        deployJava.browserName='?';
        deployJava.browserName2='unknown';
      }
      if(deployJava.debug){
        alert('Detected browser name:'+deployJava.browserName+', '+deployJava.browserName2);
      }
    }
    return deployJava.browserName;
  },
  testUsingActiveX:function(version){
    var objectName='JavaWebStart.isInstalled.'+version+'.0';
    if(!ActiveXObject){
      if(deployJava.debug){
        alert('Browser claims to be IE, but no ActiveXObject object?');
      }
      return false;
    }
    try{
      return(new ActiveXObject(objectName)!=null);
    }catch(exception){
      return false;
    }
  },
  testForMSVM:function(){
    var clsid='{08B0E5C0-4FCB-11CF-AAA5-00401C608500}';
  if(typeof oClientCaps!='undefined'){
    var v=oClientCaps.getComponentVersion(clsid,"ComponentID");
    if((v=='')||(v=='5,0,5000,0')){
      return false;
    }else{
      return true;
    }
  }else{
    return false;
  }
},
testUsingMimeTypes:function(version){
  if(!navigator.mimeTypes){
    if(deployJava.debug){
      alert('Browser claims to be Netscape family, but no mimeTypes[] array?');
    }
    return false;
  }
  for(var i=0;i<navigator.mimeTypes.length;++i){
    s=navigator.mimeTypes[i].type;
    var m=s.match(/^application\/x-java-applet\x3Bversion=(1\.8|1\.7|1\.6|1\.5|1\.4\.2)$/);
    if(m!=null){
      if(deployJava.compareVersions(m[1],version)){
        return true;
      }
    }
  }
  return false;
},
testUsingPluginsArray:function(version){
  if((!navigator.plugins)||(!navigator.plugins.length)){
    return false;
  }
  var platform=navigator.platform.toLowerCase();
  for(var i=0;i<navigator.plugins.length;++i){
    s=navigator.plugins[i].description;
    if(s.search(/^Java Switchable Plug-in (Cocoa)/)!=-1){
      if(deployJava.compareVersions("1.5.0",version)){
        return true;
      }
    }else if(s.search(/^Java/)!=-1){
      if(platform.indexOf('win')!=-1){
        if(deployJava.compareVersions("1.5.0",version)||deployJava.compareVersions("1.6.0",version)){
          return true;
        }
      }
    }
  }
  if(deployJava.compareVersions("1.5.0",version)){
    return true;
  }
  return false;
},
IEInstall:function(){
  location.href=(deployJava.getJavaURL.indexOf("/")==0?deployJava.metadata.resourceBaseUrl+deployJava.getJavaURL.substring(1):deployJava.getJavaURL)+((deployJava.returnPage!=null)?('&returnPage='+deployJava.returnPage):'')+((deployJava.locale!=null)?('&locale='+deployJava.locale):'')+((deployJava.brand!=null)?('&brand='+deployJava.brand):'')+((deployJava.installType!=null)?('&type='+deployJava.installType):'');
  return false;
},
done:function(name,result){
},
FFInstall:function(){
  location.href=(deployJava.getJavaURL.indexOf("/")==0?deployJava.metadata.resourceBaseUrl+deployJava.getJavaURL.substring(1):deployJava.getJavaURL)+((deployJava.returnPage!=null)?('&returnPage='+deployJava.returnPage):'')+((deployJava.locale!=null)?('&locale='+deployJava.locale):'')+((deployJava.brand!=null)?('&brand='+deployJava.brand):'')+((deployJava.installType!=null)?('&type='+deployJava.installType):'');
  return false;
},
compareVersions:function(installed,required){
  var a=installed.split('.');
  var b=required.split('.');
  for(var i=0;i<a.length;++i){
    a[i]=Number(a[i]);
  }
  for(var i=0;i<b.length;++i){
    b[i]=Number(b[i]);
  }
  if(a.length==2){
    a[2]=0;
  }
  if(a[0]>b[0])return true;
  if(a[0]<b[0])return false;
  if(a[1]>b[1])return true;
  if(a[1]<b[1])return false;
  if(a[2]>b[2])return true;
  if(a[2]<b[2])return false;
  return true;
},
enableAlerts:function(){
  deployJava.browserName=null;
  deployJava.debug=true;
},
poll:function(){
  deployJava.refresh();
  var postInstallJREList=deployJava.getJREs();
  if((deployJava.preInstallJREList.length==0)&&(postInstallJREList.length!=0)){
    clearInterval(deployJava.myInterval);
    if(deployJava.returnPage!=null){
      location.href=deployJava.returnPage;
    };
  }
  if((deployJava.preInstallJREList.length!=0)&&(postInstallJREList.length!=0)&&(deployJava.preInstallJREList[0]!=postInstallJREList[0])){
    clearInterval(deployJava.myInterval);
    if(deployJava.returnPage!=null){
      location.href=deployJava.returnPage;
    }
  }
},
writePluginTag:function(){
  var browser=deployJava.getBrowser();
  if(browser=='MSIE'){
    deployJava.htmlDoc.write('<'+'object classid="clsid:CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA" '+'id="deployJavaPlugin" width="0" height="0">'+'<'+'/'+'object'+'>');
  }else if(browser=='Netscape Family'&&deployJava.allowPlugin()){
    deployJava.writeEmbedTag();
  }
},
refresh:function(){
  navigator.plugins.refresh(false);
  var browser=deployJava.getBrowser();
  if(browser=='Netscape Family'&&deployJava.allowPlugin()){
    var plugin=deployJava.htmlDoc.getElementById('deployJavaPlugin');
    if(plugin==null){
      deployJava.writeEmbedTag();
    }
  }
},
writeEmbedTag:function(){
  var written=false;
  if(navigator.mimeTypes!=null){
    for(var i=0;i<navigator.mimeTypes.length;i++){
      if(navigator.mimeTypes[i].type==deployJava.mimeType){
        if(navigator.mimeTypes[i].enabledPlugin){
          deployJava.htmlDoc.write('<'+'embed id="deployJavaPlugin" type="'+deployJava.mimeType+'" hidden="true" />');
          written=true;
        }
      }
    }
    if(!written){
      for(var i=0;i<navigator.mimeTypes.length;i++){
        if(navigator.mimeTypes[i].type==deployJava.oldMimeType){
          if(navigator.mimeTypes[i].enabledPlugin){
            deployJava.htmlDoc.write('<'+'embed id="deployJavaPlugin" type="'+deployJava.oldMimeType+'" hidden="true" />');
          }
        }
      }
    }
  }
},
do_initialize:function(){
  deployJava.writePluginTag();
  if(deployJava.locale==null){
    var loc=null;
    if(loc==null)try{
      loc=navigator.userLanguage;
    }catch(err){
    }
    if(loc==null)try{
      loc=navigator.systemLanguage;
    }catch(err){
    }
    if(loc==null)try{
      loc=navigator.language;
    }catch(err){
    }
    if(loc!=null){
      loc.replace("-","_")
      deployJava.locale=loc;
    }
  }
}
};
